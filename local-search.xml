<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>路径规划算法</title>
    <link href="/2022/05/04/Self-Driving/PathPlan/"/>
    <url>/2022/05/04/Self-Driving/PathPlan/</url>
    
    <content type="html"><![CDATA[<h1 id="自动驾驶汽车定位-感知-规划-决策-控制概述">1.自动驾驶汽车定位-感知-规划-决策-控制概述</h1><h3 id="定位">定位</h3><ul><li>定位，即通过GPS、惯导、激光雷达等传感器，获取车辆的位置和航向信息。</li><li><strong>绝对定位</strong>是指通过GPS实现，采用双天线，通过卫星获得车辆在地球上的绝对位置和航向信息。</li><li><strong>相对定位</strong>是指根据车辆的初始位姿，通过惯导、里程计等传感器获得加速度信息，将其对时间进行积分，即可得到相对初始位姿的当前位姿信息。</li></ul><h3 id="感知">感知</h3><ul><li>环境感知，即通过<strong>摄像头、激光雷达、毫米波雷达、超声波雷达</strong>等队中传感器，感知周围环境信息和车辆状态信息。</li><li>环境信息包括：道路、方向、曲率、坡度、交通标志，信号灯；车辆状态信息包括：车辆前进的速度、加速度、转向角度、车身位置及姿态。</li><li>多种传感器虽然可以获得丰富、细致的环境信息，但如何对多种传感器的信息进行<strong>融合统一处理</strong></li></ul><h3 id="规划">规划</h3><ul><li>规划是对未来时域、空域的车辆一系列动作的计划。从涉及的时空大小全局（宏观）路径规划和局部（微观）路径规划。</li><li><strong>全局路径规划</strong>指在已知全局地图的情况下，从车辆当前位置规划出一条到目的地的全局路径。</li><li><strong>局部路径规划</strong>指根据环境感知的信息在环道、转弯、躲避障碍物等情况下，实时规划出一条安全、平顺、舒适的行驶路径。</li></ul><h3 id="决策控制">决策控制</h3><ul><li>决策控制，包括决策和控制两部分</li><li>决策，在整个无人驾驶系统中，扮演<strong>驾驶员大脑</strong>的角色，根据定位、感知、路径规划的信息，决定无人车的形式策略。包括：选取哪条车道、是否换道、是否跟车行驶、是否绕道、是否停车等。</li><li>控制，主要包括<strong>转向、驱动、制动</strong>三方面的控制，执行规划决策模块下发的期望速度和期望转向角度，也包括转向灯、喇叭、门窗等的控制。</li></ul><h1id="全局路径规划算法dijkstra算法">2.全局路径规划算法——Dijkstra算法</h1><h2 id="算法简介">算法简介</h2><p>迪杰斯特拉算法(Dijkstra)是由荷兰计算机科学家狄克斯特拉于1959年提出的，因此又叫狄克斯特拉算法。是从一个节点遍历其余各节点的最短路径算法，解决的是有权图中最短路径问题</p><h2 id="算法思想">算法思想</h2><ul><li>设<spanclass="math inline">\(G=(V,E)\)</span>是一个带权有向图，把图中节点集合V分成两组，<font color='green'>第一组为已求出最短路径的集合</font>,(用S表示，初始时S中只有一个源点，以后每求得一条最短路径，就将该节点加入到集合S中，直到全部节点都加入到S中，算法结束)</li><li><font color='green'>第二组为区域未确定最短路径的节点集合</font>（用U表示），按最短路径长度的递增次序依次把第二组的节点加入S中。在加入的过程中，总保持从源点v到S中各节点的最短路径长度不大于从源点v到U中任何节点的最短路径长度。</li><li>此外，每个节点对应一个距离，S中的节点的距离就是从v到此节点的最短距离路径长度，U中的节点的距离，是从v到此节点只包括S中的节点为中间节点的当前最短路径长度。</li></ul><p><img src="/img/PathPlaning/Dijkstra.png" /></p><h2 id="算法精讲">算法精讲</h2><ul><li>初始时，S只包含起点s；U包含除s外的其他节点，且U中节点的距离为”起点s到该节点的距离“[例如，U中节点v的距离为(s,v)的长度，然后s和v不相邻，则v的距离为<spanclass="math inline">\(\infty\)</span>].</li><li>从U中选出”距离最短的节点k“，并将节点k加入到S中；同时，从U中移除节点k。</li><li>更新U中各节点到起点s的距离。之所以更新U中节点的距离，是因为上一步确定了k是求出最短路径的节点，从而可以利用k来更新其他节点的距离；例如，<spanclass="math inline">\((s,v)\)</span>的距离可能大于<spanclass="math inline">\((s,k)+(k,v)\)</span>的距离。</li><li>重复步骤(2)和(3)，直到遍历完所有节点。</li></ul><p><img src="/img/PathPlaning/Dijkstra1.png" /></p><p><strong>选取节点<span class="math inline">\(D\)</span>，<spanclass="math inline">\(S=\{D(0)\}\)</span> <spanclass="math inline">\(U=\{A(\infty),B(\infty),{\color{Red}C(3)},E(4),F(\infty),G(\infty)\}\)</span></strong></p><p><img src="/img/PathPlaning/Dijkstra2.png" /></p><p><strong>选取节点<span class="math inline">\(C\)</span>，<spanclass="math inline">\(S=\{D(0),C(3)\}\)</span>，<spanclass="math inline">\(\{A(\infty),B(13),{\color{Red}E(4)},F(9),G(\infty)\}\)</span>.</strong></p><p><img src="/img/PathPlaning/Dijkstra3.png" /></p><p><strong>选取节点<span class="math inline">\(E\)</span>，<spanclass="math inline">\(S=\{D(0),C(3),E(4)\}\)</span>，<spanclass="math inline">\(U=\{A(\infty),B(13),{\color{Red}F(6)},G(12)\}\)</span>.</strong></p><p><img src="/img/PathPlaning/Dijkstra4.png" /></p><p><strong>选取节点<span class="math inline">\(F\)</span>，<spanclass="math inline">\(S=\{D(0),C(3),E(4),F(6)\}\)</span>，<spanclass="math inline">\(U=\{A(2),B(13),{\color{Red}G(12)}\}\)</span>.</strong></p><p><img src="/img/PathPlaning/Dijkstra5.png" /></p><p><spanclass="math inline">\(S=\{D(0),C(3),E(4),F(6),G(12)\}\)</span>，<spanclass="math inline">\(U=\{A(22),{\color{Red}B(13)}\}\)</span>.</p><p><img src="/img/PathPlaning/Dijkstra6.png" /></p><p><spanclass="math inline">\(S=\{D(0),C(3),E(4),F(6),G(12),B(13)\}\)</span>，<spanclass="math inline">\(U=\{\color{Red}A(22)\}\)</span>.</p><p><img src="/img/PathPlaning/Dijkstra7.png" /></p><p><spanclass="math inline">\(S=\{D(0),C(3),E(4),F(6),G(12),B(13),A(22)\}\)</span>，<spanclass="math inline">\(U=\varnothing\)</span>.</p><p><img src="/img/PathPlaning/Dijkstra8.png" /></p><p><span class="math inline">\(D\rightarrow A\)</span>的最优路径为<spanclass="math inline">\(D\rightarrow E \rightarrow F \rightarrowA\)</span></p><p>最短距离为22</p><h2 id="matlab实现">Matlab实现</h2><figure class="highlight matlab"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></div></td><td class="code"><pre><code class="hljs matlab">clc<br>clear<br>close all<br><span class="hljs-comment">%% 图定义</span><br><span class="hljs-comment">% 根据节点的邻近节点表及字母点-数字节点对应表，构造节点元胞数组</span><br>nodes_dist = cell(<span class="hljs-number">0</span>);<br>nodes_dist(<span class="hljs-number">1</span>,:) = &#123;<span class="hljs-number">1</span>, [<span class="hljs-number">2</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>], [<span class="hljs-number">12</span>, <span class="hljs-number">16</span>, <span class="hljs-number">14</span>]&#125;;<br>nodes_dist(<span class="hljs-number">2</span>,:) = &#123;<span class="hljs-number">2</span>, [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>], [<span class="hljs-number">12</span>, <span class="hljs-number">10</span>, <span class="hljs-number">7</span>]&#125;;<br>nodes_dist(<span class="hljs-number">3</span>,:) = &#123;<span class="hljs-number">3</span>, [<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>], [<span class="hljs-number">10</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]&#125;;<br>nodes_dist(<span class="hljs-number">4</span>,:) = &#123;<span class="hljs-number">4</span>, [<span class="hljs-number">3</span>, <span class="hljs-number">5</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]&#125;;<br>nodes_dist(<span class="hljs-number">5</span>,:) = &#123;<span class="hljs-number">5</span>, [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>], [<span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">8</span>]&#125;;<br>nodes_dist(<span class="hljs-number">6</span>,:) = &#123;<span class="hljs-number">6</span>, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>], [<span class="hljs-number">16</span>, <span class="hljs-number">7</span>, <span class="hljs-number">6</span>, <span class="hljs-number">2</span>, <span class="hljs-number">9</span>]&#125;;<br>nodes_dist(<span class="hljs-number">7</span>,:) = &#123;<span class="hljs-number">7</span>, [<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>], [<span class="hljs-number">14</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>]&#125;;<br><br><span class="hljs-comment">%% 算法初始化</span><br><span class="hljs-comment">% S/U的第一列表示节点编号</span><br><span class="hljs-comment">% 对于S,第二列表示从源节点到本节点已求得的最小距离，不再变更；</span><br><span class="hljs-comment">% 对于U,第二列表示从源节点到本节点暂时求得的最小距离，可能会变更</span><br>S = [<span class="hljs-number">4</span>, <span class="hljs-number">0</span>];<br>U(:,<span class="hljs-number">1</span>) = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>];<br>U(:,<span class="hljs-number">2</span>) = [<span class="hljs-built_in">inf</span>, <span class="hljs-built_in">inf</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-built_in">inf</span>, <span class="hljs-built_in">inf</span>]&#125;;<br><br><span class="hljs-comment">% 最优路径及暂时的最优路径的初始化</span><br>path_opt = cell(<span class="hljs-number">7</span>, <span class="hljs-number">2</span>);<br>path_opt(<span class="hljs-number">4</span>,:) = &#123;<span class="hljs-number">4</span>, <span class="hljs-number">4</span>&#125;;<br><br>path_temp = cell(<span class="hljs-number">7</span>, <span class="hljs-number">2</span>);<br>path_temp(<span class="hljs-number">3</span>,:) = &#123;<span class="hljs-number">3</span>, [<span class="hljs-number">4</span>, <span class="hljs-number">3</span>]&#125;;<br>path_temp(<span class="hljs-number">4</span>,:) = &#123;<span class="hljs-number">4</span>, <span class="hljs-number">4</span>&#125;;<br>path_temp(<span class="hljs-number">5</span>,:) = &#123;<span class="hljs-number">5</span>, [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>]&#125;;<br><br><span class="hljs-comment">%% 循环遍历所有节点</span><br><span class="hljs-keyword">while</span> ~<span class="hljs-built_in">isempty</span>(U)<br>[dist_min, idx] = <span class="hljs-built_in">min</span>(U(:,<span class="hljs-number">2</span>));<br>node_min = U(idx, <span class="hljs-number">1</span>);<br>S(<span class="hljs-keyword">end</span>+<span class="hljs-number">1</span>,:) = [node_min, dist_min];<br>U(idx,:) = [];<br><br><span class="hljs-comment">% 将最小的距离值的节点添加到到最优路径集合</span><br>path_opt(node_min,:) = path_temp(node_min,:);<br><br><span class="hljs-comment">%% 依次遍历最小距离节点的邻节点，判断是否在U集合中更新邻节点的距离值</span><br><span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span> = <span class="hljs-number">1</span>:<span class="hljs-built_in">length</span>(nodes_dist&#123;node_min, <span class="hljs-number">2</span>&#125;)<br><span class="hljs-built_in">i</span> = <span class="hljs-number">1</span>;<br><span class="hljs-comment">% 需要判断的节点</span><br>node_temp = nodes_dist&#123;node_min, <span class="hljs-number">2</span>&#125;(<span class="hljs-built_in">i</span>);<br><br><span class="hljs-comment">% 找出U集合中节点node_temp的索引值</span><br>idx_temp = <span class="hljs-built_in">find</span>(node_temp == U(:,<span class="hljs-number">1</span>));<br><br><span class="hljs-comment">% 判断是否更新</span><br><span class="hljs-keyword">if</span> ~<span class="hljs-built_in">isempty</span>(idx_temp)<br><span class="hljs-keyword">if</span> dist_min + node_dist&#123;node_min, <span class="hljs-number">3</span>&#125;(<span class="hljs-built_in">i</span>) &lt; U(idx_temp, <span class="hljs-number">2</span>)<br>U(idx_temp, <span class="hljs-number">2</span>) = dist_min + nodes_dist&#123;node_min, <span class="hljs-number">3</span>&#125;(<span class="hljs-built_in">i</span>)<br><br><span class="hljs-comment">% 更新暂时最优路径</span><br>path_temp&#123;node_temp, <span class="hljs-number">1</span>&#125; = node_temp;<br>            path_temp&#123;node_temp, <span class="hljs-number">2</span>&#125; = [path_opt&#123;node_min, <span class="hljs-number">2</span>&#125;, node_temp];<br>            <span class="hljs-keyword">end</span>        <br></code></pre></td></tr></table></figure><h2 id="python实现">Python实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 图定义</span><br><span class="hljs-comment"># 根据节点的邻近节点表-数字对应表，构造图</span><br>nodes_dist = <span class="hljs-built_in">dict</span>()<br>nodes_dist[<span class="hljs-number">1</span>] = &#123;<span class="hljs-number">2</span>: <span class="hljs-number">12</span>, <span class="hljs-number">6</span>: <span class="hljs-number">16</span>, <span class="hljs-number">7</span>: <span class="hljs-number">14</span>&#125;<br>nodes_dist[<span class="hljs-number">2</span>] = &#123;<span class="hljs-number">1</span>: <span class="hljs-number">12</span>, <span class="hljs-number">3</span>: <span class="hljs-number">10</span>, <span class="hljs-number">6</span>: <span class="hljs-number">7</span>&#125;<br>nodes_dist[<span class="hljs-number">3</span>] = &#123;<span class="hljs-number">2</span>: <span class="hljs-number">10</span>, <span class="hljs-number">4</span>: <span class="hljs-number">3</span>, <span class="hljs-number">5</span>: <span class="hljs-number">5</span>, <span class="hljs-number">6</span>: <span class="hljs-number">6</span>&#125;<br>nodes_dist[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">3</span>: <span class="hljs-number">3</span>, <span class="hljs-number">5</span>: <span class="hljs-number">4</span>&#125;<br>nodes_dist[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">3</span>: <span class="hljs-number">5</span>, <span class="hljs-number">4</span>: <span class="hljs-number">4</span>, <span class="hljs-number">6</span>: <span class="hljs-number">2</span>, <span class="hljs-number">7</span>: <span class="hljs-number">8</span>&#125;<br>nodes_dist[<span class="hljs-number">6</span>] = &#123;<span class="hljs-number">1</span>: <span class="hljs-number">16</span>, <span class="hljs-number">2</span>: <span class="hljs-number">7</span>, <span class="hljs-number">3</span>: <span class="hljs-number">6</span>, <span class="hljs-number">5</span>: <span class="hljs-number">2</span>, <span class="hljs-number">7</span>: <span class="hljs-number">9</span>&#125;<br>nodes_dist[<span class="hljs-number">7</span>] = &#123;<span class="hljs-number">1</span>: <span class="hljs-number">14</span>, <span class="hljs-number">5</span>: <span class="hljs-number">8</span>, <span class="hljs-number">6</span>: <span class="hljs-number">9</span>&#125;<br><br><span class="hljs-comment"># S 集合</span><br>S = <span class="hljs-built_in">dict</span>()<br><br><span class="hljs-comment"># U 集合</span><br>U = <span class="hljs-built_in">dict</span>()<br>U[<span class="hljs-number">1</span>] = <span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;inf&#x27;</span>)<br>U[<span class="hljs-number">2</span>] = <span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;inf&#x27;</span>)<br>U[<span class="hljs-number">3</span>] = <span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;inf&#x27;</span>)<br>U[<span class="hljs-number">4</span>] = <span class="hljs-number">0</span><br>U[<span class="hljs-number">5</span>] = <span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;inf&#x27;</span>)<br>U[<span class="hljs-number">6</span>] = <span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;inf&#x27;</span>)<br>U[<span class="hljs-number">7</span>] = <span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;inf&#x27;</span>)<br><br><span class="hljs-comment"># 当前最优路径</span><br>keys = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">8</span>)]<br>path_temp = <span class="hljs-built_in">dict</span>([(k, []) <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> keys])<br><br><br><span class="hljs-comment"># 最终最优路径</span><br>path_opt = <span class="hljs-built_in">dict</span>([(k, []) <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> keys])<br><br><span class="hljs-comment"># 循环遍历U集合，直到所有节点被确定，并移出集合</span><br><span class="hljs-keyword">while</span> U:<br>    <span class="hljs-comment"># 寻找U集合中的最小值，及其对应的节点</span><br>    dist_min = <span class="hljs-built_in">min</span>(U.values())<br>    node_min = <span class="hljs-built_in">min</span>(U, key=U.get)<br>    <span class="hljs-comment"># 将最小值节点移出U集合，移入S集合</span><br>    S[node_min] = dist_min<br>    <span class="hljs-keyword">del</span> U[node_min]<br><br>    <span class="hljs-comment"># 确定该最小值节点的最终最优路径</span><br>    path_opt[node_min] += path_temp[node_min]<br>    path_opt[node_min].append(node_min)<br><br>    <span class="hljs-comment"># 围绕该最小值节点，循环遍历其相邻节点</span><br>    <span class="hljs-keyword">for</span> node_temp <span class="hljs-keyword">in</span> nodes_dist[node_min].keys():<br>        <span class="hljs-comment"># 判断该相邻节点是否在集合U中，即该节点是否已经被确定。若已确定，则不做考虑</span><br>        <span class="hljs-keyword">if</span> node_temp <span class="hljs-keyword">in</span> <span class="hljs-built_in">list</span>(U.keys()):<br>            <span class="hljs-comment"># 判断该路径是否比原有路径短</span><br>            <span class="hljs-keyword">if</span> (dist_min + nodes_dist[node_min][node_temp]) &lt; U[node_temp]:<br>                <span class="hljs-comment"># 更新最短距离</span><br>                U[node_temp] = dist_min + nodes_dist[node_min][node_temp]<br>                <span class="hljs-comment"># 该最短距离所对应的新路径</span><br>                path_temp[node_temp] = path_opt[node_min]<br><br><span class="hljs-built_in">print</span>(S, U)<br><span class="hljs-built_in">print</span>(path_opt)<br></code></pre></td></tr></table></figure><h1 id="全局路径规划算法蚁群算法">3.全局路径规划算法——蚁群算法</h1><h2 id="算法简介-1">算法简介</h2><p>蚁群算法是一种智能算法，它是由一群无智能或有微智能的个体(Agent)通过相互协作表现出智能行为，从而为求解复杂问题提供了一个新的可能性。</p><ul><li>蚁群算法(Ant Colony Algorithm, ACA)于1992年首次提出，该算法模拟了自然界中<font color='green'>蚂蚁的觅食行为</font>.</li><li>蚂蚁在寻找食物源时，会在其经过的路径上释放一种信息素，并能够感知其他蚂蚁释放的信息素，信息素<font color='green'>浓度的大小表征路径的远近</font>，信息素浓度越高，表示对应的路径距离越短。</li><li>通常，蚂蚁会以较大的概率优先选择信息素浓度较大路径，并释放一定量的信息素，以增强该条路径上的信息素浓度，这样，会形成正反馈。最终，蚂蚁能够找到一条从巢穴到食物源的最佳路径，即距离最短。</li></ul><h3 id="tsp问题描述">TSP问题描述</h3><p>蚁群算法最早用来解决TSP问题，并且表现出很大的优越性，因为它有分布式特性、鲁棒性强并且容易与其他算法结合，但是同时也存在收敛速度慢，容易陷入局部最优等缺点。</p><p>TSP问题(Travel SalespersonProblem，即旅行商问题或者称为中国邮递员问题)，是一种NP-hard问题，此类问题用一般的算法很难得到最优解的，所以一般需要借助一些启发式算法求解，例如遗传算法(GA)，蚁群算法(ACO)，微粒群算法(PSO)等。</p><blockquote><p>TSP问题（旅行商问题）是指旅行家旅行n个城市，要求<strong>各个城市经历且仅经历一次</strong>然后回到出发城市，并要求所走路程最短。</p></blockquote><p>一个TSP问题可以表达为：求解遍历图<spanclass="math inline">\(G=(V,E,C)\)</span>，所有的节点一次并且回到起始节点，使得连接这些节点的路径成本最低。</p><h2 id="算法思想-1">算法思想</h2><ul><li>用蚂蚁的行走路径并表示待优化问题的可行解，整个蚂蚁群的所有路径构成待优化问题的解空间。</li><li>路径较短的，蚂蚁会释放较多的信息素，随着时间的推进，<font color='green'>较短的路径上积累的信息素浓度逐渐增高</font>，选择该路径的蚂蚁个数也愈来愈多。</li><li>最终，整个蚂蚁会在正反馈的作用下集中到最佳的路径上，此时对应的便是待优化问题的最优解。</li></ul><p><img src="/img/PathPlaning/ACA.jpg" /></p><h2 id="算法精讲-1">算法精讲</h2><h3 id="原理">原理</h3><p>假如蚁群中所有蚂蚁的数量为<spanclass="math inline">\(m\)</span>，所有城市之间的信息素用矩阵<spanclass="math inline">\(pheromone\)</span>表示，最短路径为<spanclass="math inline">\(bestLength\)</span></p><p>，最佳路径为<spanclass="math inline">\(bestTour\)</span>。每只蚂蚁都有自己的内存，内存中用一个禁忌表(Tabu)来存储蚂蚁已经访问过的城市，表示以后的搜索将不能访问这些城市；还有用另外一个允许访问的城市表(Allowed)来存储它还可以访问的城市；另外还用矩阵(Delta)来储存它在一个循环（或者迭代）中经过的路径释放的信息素；还有另外一些数据，例如一些控制参数<spanclass="math inline">\((\alpha,\beta,\rho,Q)\)</span>，该蚂蚁行走完全程的总成本或距离(tourLength)，等等。假定算法总共运行MAX_GEN次，运行时间为t.</p><p>蚁群算法计算过程如下：</p><ol type="1"><li><p>初始化</p></li><li><p>为每只蚂蚁选择下一个节点。</p></li><li><p>更新信息素矩阵</p></li><li><p>检查终止条件</p></li></ol><blockquote><p>如果达到最大迭代数MAX_GEN，算法终止，转到第(5)步；否则，重新初始化所有蚂蚁的Delta矩阵所有元素初始化为0，Tabu表清空，Allowed表加入所有城市节点。随机选择它们的起始位置（也可以人为指定）。在Tabu表中加入起始节点，Allowed表中删除该起始节点，重复执行(2),(3),(4)步。</p></blockquote><ol start="5" type="1"><li>输出最优值</li></ol><hr /><p>不失一般性，设整个蚂蚁群体中蚂蚁的数量为<spanclass="math inline">\(m\)</span>，城市的数量为<spanclass="math inline">\(n\)</span>，城市<spanclass="math inline">\(i\)</span>与城市<spanclass="math inline">\(j\)</span>之间的相互距离为<spanclass="math inline">\(d_{ij}(i,j=1,2,...,n)\)</span>，<spanclass="math inline">\(t\)</span>时刻城市<spanclass="math inline">\(i\)</span>与城市<spanclass="math inline">\(j\)</span>连接路径上的信息素浓度为<spanclass="math inline">\(\tau_{ij}(t)\)</span>。初始时刻，各个城市间连接路径上的信息素浓度相同，不妨设为<spanclass="math inline">\(\tau_{ij}(0)=\tau_0\)</span>。</p><p>蚂蚁<spanclass="math inline">\(k(k=1,2,...,m)\)</span>根据各个城市间连接路径上的信息素浓度决定其下一个访问的城市，设<spanclass="math inline">\(P^k_{ij}(t)\)</span>表示<spanclass="math inline">\(t\)</span>时刻蚂蚁<spanclass="math inline">\(k\)</span>从城市<spanclass="math inline">\(i\)</span>转移到城市<spanclass="math inline">\(j\)</span>的概率，其计算公式如下：</p><p>​ <spanclass="math display">\[P^K_{ij}=\begin{cases}\dfrac{[\tau_{ij}(t)]^\alpha\cdot [\eta_{ij}(t)]^\beta}{\sum\limits_{S \inallow_k}[\tau_{is}(t)]^\alpha\cdot [\eta_{is}(t)]^\beta},&amp;S \inallow_k \\ 0, &amp;S \notin allow_k\end{cases}\]</span></p><p>其中，<spanclass="math inline">\(\eta_{ij}(t)\)</span>为启发函数，<spanclass="math inline">\(\eta_{ij}(t)=\frac{1}{d_{ij}}\)</span>，表示蚂蚁从城市<spanclass="math inline">\(i\)</span>转移到城市<spanclass="math inline">\(j\)</span>的期望程度，<spanclass="math inline">\(allow_k(k=1,2,...,m)\)</span>蚂蚁<spanclass="math inline">\(k\)</span>待访问城市的集合。开始时，<spanclass="math inline">\(allow_k\)</span>中有<spanclass="math inline">\((n-1)\)</span>个元素，即包括除了蚂蚁<spanclass="math inline">\(k\)</span>出发城市的其他所有城市，随着时间的推进，<spanclass="math inline">\(allow_k\)</span>中的元素不断减少，直至为空，即表示所有的城市均访问完毕。<spanclass="math inline">\(\alpha\)</span>为信息素重要程度因子，其值越大，表示信息素的浓度在转移中起的作用越大；<spanclass="math inline">\(\beta\)</span>为启发函数重要程度因子，其值越大，表示启发函数转移中的作用越大，即蚂蚁会以较大的概率转移到距离短的城市。</p><p>在蚂蚁释放信息素的同时，各个城市间连接路径上的信息素逐渐消失，设参数<spanclass="math inline">\(\rho(0&lt;\rho&lt;1)\)</span>表示信息挥发程度。因此，当所有蚂蚁完成一次循环后，各个城市间连接路径上的信息素浓度需要进行实时更新，具体公式如下：</p><p>​ <span class="math display">\[\begin{cases}\tau_{ij}(t+1) =(1-\rho)*\tau_{ij}(t)+\Delta\tau_{ij} \\\Delta\tau_{ij}=\sum\limits_{k=1}^m \Delta\tau^k_{ij}, &amp;0&lt;\rho&lt;1\end{cases}\]</span></p><p>其中，<spanclass="math inline">\(\Delta\tau^k_{ij}\)</span>表示第<spanclass="math inline">\(k\)</span>只蚂蚁在城市<spanclass="math inline">\(i\)</span>与城市<spanclass="math inline">\(j\)</span>连接路径上释放的信息素浓度，<spanclass="math inline">\(\Delta\tau_{ij}\)</span>表示所有蚂蚁在城市<spanclass="math inline">\(i\)</span>与城市<spanclass="math inline">\(j\)</span>连接路径上释放的信息素浓度之和。</p><p>ant cycle system 模型中，<spanclass="math inline">\(\Delta\tau^k_{ij}\)</span>的计算公式如下：</p><p>​ <span class="math display">\[\Delta\tau^k_{ij}=\begin{cases}Q/L_k,&amp; 第k只蚂蚁从城市i访问城市j \\ 0, &amp; 其它\end{cases}\]</span></p><table><colgroup><col style="width: 9%" /><col style="width: 33%" /><col style="width: 56%" /></colgroup><thead><tr class="header"><th></th><th style="text-align: center;">定义</th><th style="text-align: center;">参数影响分析</th></tr></thead><tbody><tr class="odd"><td><span class="math inline">\(\alpha\)</span></td><td style="text-align: center;">信息启发式因子</td><td style="text-align: center;"><spanclass="math inline">\(\alpha\)</span>值越大，蚂蚁选择之前走过的路径可能性就越大，搜索路径的随机性减弱，<spanclass="math inline">\(\alpha\)</span>越小，蚁群搜索范围就会减少，容易陷入局部最优</td></tr><tr class="even"><td><span class="math inline">\(\beta\)</span></td><td style="text-align: center;">期望启发式因子</td><td style="text-align: center;"><spanclass="math inline">\(\beta\)</span>值越大，蚁群越容易选择局部较短路径，这时算法的收敛速度是加快了，但是随机性却不高，容易得到局部最优解</td></tr><tr class="odd"><td><span class="math inline">\(m\)</span></td><td style="text-align: center;">蚁群数量</td><td style="text-align: center;"><spanclass="math inline">\(m\)</span>数目越多，得到的最优解就越精确，但是会产生不少重复解，随着算法接近最优解的收敛，信息正反馈作用降低，大量的重复工作，消耗了资源，增加了时间复杂度</td></tr><tr class="even"><td><span class="math inline">\(\rho\)</span></td><td style="text-align: center;">信息挥发因子，<spanclass="math inline">\(1-\rho\)</span>表示残留因子</td><td style="text-align: center;"><spanclass="math inline">\(\rho\)</span>过小时，在各路径上残留的信息素过多，导致无效的路径继续被搜索，影响到算法的收敛速率；<spanclass="math inline">\(\rho\)</span>过大，无效的路径虽然可以被排除搜索，但是不能保证有效的路径也会被搜索，影响到最优值的搜索。</td></tr></tbody></table><p>蚁群算法中主要参数的理想选择如下：</p><table><thead><tr class="header"><th style="text-align: center;">参数</th><th style="text-align: center;">取值范围</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><spanclass="math inline">\(\alpha\)</span></td><td style="text-align: center;"><spanclass="math inline">\([0,5]\)</span></td></tr><tr class="even"><td style="text-align: center;"><spanclass="math inline">\(\beta\)</span></td><td style="text-align: center;"><spanclass="math inline">\([0,5]\)</span></td></tr><tr class="odd"><td style="text-align: center;"><spanclass="math inline">\(Q\)</span></td><td style="text-align: center;"><span class="math inline">\([10,10000]\)</span></td></tr><tr class="even"><td style="text-align: center;"><spanclass="math inline">\(\rho\)</span></td><td style="text-align: center;"><spanclass="math inline">\([0.1,0.99]\)</span></td></tr></tbody></table><hr /><p><strong>流程图</strong>：</p><p><img src="/img/PathPlaning/aca.png" /></p><h2 id="文献">文献</h2><h3 id="蚁群算法中参数-αβ-ρ设置的研究-以-tsp-问题为例">1.蚁群算法中参数α、β 、ρ设置的研究 ———以 TSP 问题为例</h3><p>蚁群算法在TSP问题应用中取得了良好的效果，但也存在一些不足：</p><ul><li>如果参数<span class="math inline">\(\alpha 、\beta、\rho\)</span>设置不当，导致求解速度很慢且所得的解质量特别差；</li><li>基本蚁群算法计算量大，求解所需要的时间较长；</li><li>基本蚁群算法中理论上要求所有的蚂蚁选择同一路线，该线路即为所求的最优线路；但在实际计算中，在给定一定循环次数的条件下很难实现这种情况。</li><li>另一方面，在其他实际应用中，如图像处理中寻求最优模板问题，并不要求所有的蚂蚁都能找到最优的模板，而只需要一只找到即可。</li></ul><p><span class="math inline">\((t+n)\)</span>时刻在<spanclass="math inline">\(ij\)</span>路径上的信息素浓度为：</p><p>​ <spanclass="math display">\[\tau_{ij}(t+n)=(1-\rho)\tau_{ij}(t)+\Delta\tau_{ij}(t+n)\]</span></p><p><span class="math inline">\(\Delta\tau_{ij}\)</span>表示蚂蚁<spanclass="math inline">\(k\)</span>在时间段<spanclass="math inline">\(t\)</span>到<spanclass="math inline">\((t+n)\)</span>的过程中，在<spanclass="math inline">\(i\)</span>到<spanclass="math inline">\(j\)</span>的路径上留下的残留信息浓度。根据信息素更新策略的不同，有3种不同的蚁群算法模型：</p><ol type="1"><li><p>ant-quantity模型</p><p><spanclass="math display">\[\Delta\tau_{ij}(t,t+1)=\begin{cases}\dfrac{Q_1}{d_{ij}}，&amp;如果蚂蚁k经过ij \\ 0， &amp;如果蚂蚁k不经过ij\end{cases}\]</span></p><p>式中，<spanclass="math inline">\(Q_1\)</span>是常量，信息素的增量与<spanclass="math inline">\(ij\)</span>之间的距离有关。</p></li><li><p>ant-density模型</p><p><spanclass="math display">\[\Delta\tau_(t,t+1)=\begin{cases}Q_2，&amp;如果蚂蚁k经过ij\\ 0，&amp; 如果蚂蚁k不经过ij \end{cases}\]</span></p><p>式中，<spanclass="math inline">\(Q_2\)</span>是常量，则信息素增加一个固定值，与<spanclass="math inline">\(ij\)</span>之间的距离无关</p></li><li><p>ant-cycle模型</p><p><spanclass="math display">\[\Delta\tau_{ij}(t,t+1)=\begin{cases}Q_3/L^k，&amp;如果蚂蚁k在巡回中经过ij\\ 0，&amp;如果蚂蚁k在巡回中不经过ij \end{cases}\]</span></p><p>式中，<span class="math inline">\(Q_3\)</span>是常量；<spanclass="math inline">\(L^k\)</span>表示第<spanclass="math inline">\(k\)</span>只蚂蚁的循环路线，即如果蚂蚁经过<spanclass="math inline">\(ij\)</span>，则信息素增量为一个常量除以蚂蚁<spanclass="math inline">\(k\)</span>的巡回路线长。这里，信息素增量只与蚂蚁的巡回路线和<spanclass="math inline">\(Q_3\)</span>有关系，而和具体的<spanclass="math inline">\(d_{ij}\)</span>无关。</p></li></ol><h2 id="代码实现">代码实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> random<br><span class="hljs-keyword">import</span> copy<br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">import</span> math<br><span class="hljs-keyword">import</span> tkinter<br><span class="hljs-keyword">import</span> threading<br><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> reduce<br><br><span class="hljs-comment"># 参数</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">Alpha:信息启发因子，值越大，则蚂蚁选择之前走过的路径可能性就越大，值越小，则蚁群搜索范围就会减少，容易陷入局部最优</span><br><span class="hljs-string">Beta:值越大，蚁群就越容易选择局部最短路径，这时算法收敛速度加快，但是随机性不高，容易得到局部的相对最优</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br>(Alpha, Beta, Rho, Q) = (<span class="hljs-number">1.0</span>, <span class="hljs-number">2.0</span>, <span class="hljs-number">0.5</span>, <span class="hljs-number">100.0</span>)<br><span class="hljs-comment"># 城市数，蚁群</span><br>(city_num, ant_num) = (<span class="hljs-number">50</span>, <span class="hljs-number">50</span>)<br>distance_x = [<br>    <span class="hljs-number">178</span>,<span class="hljs-number">272</span>,<span class="hljs-number">176</span>,<span class="hljs-number">171</span>,<span class="hljs-number">650</span>,<span class="hljs-number">499</span>,<span class="hljs-number">267</span>,<span class="hljs-number">703</span>,<span class="hljs-number">408</span>,<span class="hljs-number">437</span>,<span class="hljs-number">491</span>,<span class="hljs-number">74</span>,<span class="hljs-number">532</span>,<br>    <span class="hljs-number">416</span>,<span class="hljs-number">626</span>,<span class="hljs-number">42</span>,<span class="hljs-number">271</span>,<span class="hljs-number">359</span>,<span class="hljs-number">163</span>,<span class="hljs-number">508</span>,<span class="hljs-number">229</span>,<span class="hljs-number">576</span>,<span class="hljs-number">147</span>,<span class="hljs-number">560</span>,<span class="hljs-number">35</span>,<span class="hljs-number">714</span>,<br>    <span class="hljs-number">757</span>,<span class="hljs-number">517</span>,<span class="hljs-number">64</span>,<span class="hljs-number">314</span>,<span class="hljs-number">675</span>,<span class="hljs-number">690</span>,<span class="hljs-number">391</span>,<span class="hljs-number">628</span>,<span class="hljs-number">87</span>,<span class="hljs-number">240</span>,<span class="hljs-number">705</span>,<span class="hljs-number">699</span>,<span class="hljs-number">258</span>,<br>    <span class="hljs-number">428</span>,<span class="hljs-number">614</span>,<span class="hljs-number">36</span>,<span class="hljs-number">360</span>,<span class="hljs-number">482</span>,<span class="hljs-number">666</span>,<span class="hljs-number">597</span>,<span class="hljs-number">209</span>,<span class="hljs-number">201</span>,<span class="hljs-number">492</span>,<span class="hljs-number">294</span>]<br>distance_y = [<br>    <span class="hljs-number">170</span>,<span class="hljs-number">395</span>,<span class="hljs-number">198</span>,<span class="hljs-number">151</span>,<span class="hljs-number">242</span>,<span class="hljs-number">556</span>,<span class="hljs-number">57</span>,<span class="hljs-number">401</span>,<span class="hljs-number">305</span>,<span class="hljs-number">421</span>,<span class="hljs-number">267</span>,<span class="hljs-number">105</span>,<span class="hljs-number">525</span>,<br>    <span class="hljs-number">381</span>,<span class="hljs-number">244</span>,<span class="hljs-number">330</span>,<span class="hljs-number">395</span>,<span class="hljs-number">169</span>,<span class="hljs-number">141</span>,<span class="hljs-number">380</span>,<span class="hljs-number">153</span>,<span class="hljs-number">442</span>,<span class="hljs-number">528</span>,<span class="hljs-number">329</span>,<span class="hljs-number">232</span>,<span class="hljs-number">48</span>,<br>    <span class="hljs-number">498</span>,<span class="hljs-number">265</span>,<span class="hljs-number">343</span>,<span class="hljs-number">120</span>,<span class="hljs-number">165</span>,<span class="hljs-number">50</span>,<span class="hljs-number">433</span>,<span class="hljs-number">63</span>,<span class="hljs-number">491</span>,<span class="hljs-number">275</span>,<span class="hljs-number">348</span>,<span class="hljs-number">222</span>,<span class="hljs-number">288</span>,<br>    <span class="hljs-number">490</span>,<span class="hljs-number">213</span>,<span class="hljs-number">524</span>,<span class="hljs-number">244</span>,<span class="hljs-number">114</span>,<span class="hljs-number">104</span>,<span class="hljs-number">552</span>,<span class="hljs-number">70</span>,<span class="hljs-number">425</span>,<span class="hljs-number">227</span>,<span class="hljs-number">331</span>]<br><br><span class="hljs-comment"># 城市距离和信息素</span><br>distance_graph = [[<span class="hljs-number">0.0</span> <span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(city_num)] <span class="hljs-keyword">for</span> raw <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(city_num)]<br>pheromone_graph = [[<span class="hljs-number">1.0</span> <span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(city_num)] <span class="hljs-keyword">for</span> raw <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(city_num)]<br><br><br><span class="hljs-comment">#----------蚂蚁-----------</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Ant</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span>  <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, ID</span>):<br>        self.ID = ID                    <span class="hljs-comment"># ID</span><br>        self.__clean_data()             <span class="hljs-comment"># 随机初始化出生点</span><br></code></pre></td></tr></table></figure><h1id="全局路径规划算法动态规划算法">4.全局路径规划算法——动态规划算法</h1><h2 id="算法简介-2">算法简介</h2><ul><li>动态规划是运筹学的一个分支，是求解<strong>多阶段决策过程</strong>最优化问题的数学方法。</li><li>各个阶段决策的选取不是任意确定的，它依赖于<strong>当前面临的状态</strong>，又<strong>影响以后的发展</strong>。当各个阶段的决策确定以后，就组成一个<strong>决策序列</strong>，因而也就决定了整个过程的一条活动路线，这样的一个前后关联具有链状结构的多阶段过程就称为多阶段决策问题。</li><li>动态规划在车辆工程技术领域有着广泛的应用，如“<strong>两档变速器的最优换挡规律</strong>”、“<strong>混合动力汽车最优能量管理策略</strong>”、“<strong>栅格地图最优路径搜索</strong>”等。</li></ul><p>动态规划算法是通过拆分问题，定义问题状态和状态之间的关系，使得问题能够以递推（或者说分治）的方式去解决。动态规划算法的基本思想与分治法类似，也是将待求解问题分解为若干子问题（阶段），按顺序求解子阶段，前一子问题的解，为后一子问题的求解提供了有用的信息。在求解任一子问题时，列出各种可能的局部解，最后一个子问题就是初始问题的解。</p><h2 id="算法思想-2">算法思想</h2><ul><li>美国数学家Bellman等人在20世纪50年代初提出了著名的最优化原理，把多阶段决策问题转化为<strong>一系列单阶段最优化</strong>问题。</li><li>对最佳路径（最佳决策过程）所经过的各个阶段，其中每各阶段起始点到全过程终点的路径，必定是该阶段起始点到全过程终点的一切可能路径中的最佳路径（最优决策），这就是Bellman提出的著名的最优化原理。</li><li>简言之，<strong>一个最优决策的子决策必然是最优的</strong>。</li></ul><p><img src="/img/PathPlaning/多阶段决策过程示意图.png" /></p><h2 id="算法精讲-2">算法精讲</h2><ul><li>逆向寻优，正向求解</li><li>DP算法本质由三层循环构成</li><li>第一层遍历每一个阶段；</li><li>第二层遍历第i个阶段的每个状态；</li><li>第三层循环遍历第i+1个阶段的每一个状态。</li></ul><p><img src="/img/PathPlaning/多阶段决策过程示意图2.png" /></p><hr /><p>第四阶段 (D-&gt;E): D有两条路线到终点E。</p><p><span class="math display">\[f_4(D_1)=5, f_4(D_2)=2\]</span></p><hr /><p>第三阶段(C-&gt;D): C到D有6条路线</p><p>第3阶段的C有3个状态值，分别讨论经过该状态值的最优路线</p><p><strong>经过C1</strong></p><p><spanclass="math display">\[f_3(C_1)=min\begin{Bmatrix}d(C_1,D_1)+f_4(D_1)\\d(C_1,D_2)+f_4(D_2)\end{Bmatrix}=min\begin{Bmatrix}3+5 \\ 9+2 \end{Bmatrix} =8\]</span></p><p>最短路线为<span class="math display">\[C_1 \rightarrow D_1\rightarrow E\]</span></p><p><strong>经过C2</strong></p><p><span class="math display">\[f_3(C_2)=min \begin{Bmatrix}d(C_2,D_1)+f_4(D_1) \\ d(C_2,D_2)+f_4(D_2) \end{Bmatrix} = min\begin{Bmatrix}6+5 \\ 5+2 \end{Bmatrix} = 7\]</span></p><p>最短路线为<span class="math display">\[C_2 \rightarrow D_2\rightarrow E\]</span></p><p><strong>经过C3</strong></p><p><span class="math display">\[f_3(C_3)=min \begin{Bmatrix}d(C_3,D_1) +f_4(D_1) \\ d(C_3, D_2)+f_4(D_2) \end{Bmatrix} = min\begin{Bmatrix}8+5  \\ 10+2 \end{Bmatrix}=12\]</span></p><p>最短路线为<span class="math display">\[C_3 \rightarrow D_2\rightarrow E\]</span></p><hr /><p>第二阶段(B-&gt;C): B到C有9条路线。</p><p>第2阶段的B有3个状态值，分别讨论经过该状态值的最优路线</p><p><strong>经过B1</strong></p><p><span class="math display">\[f_2(B_1)=min \begin{Bmatrix}d(B_1, C_1)+ f_3(C_1) \\ d(B_1,C_2) + f_3(C_2) \\ d(B_1, C_3) + f_3(C_3)\end{Bmatrix} = min \begin{Bmatrix}12+8 \\ 14+7\\10+12 \end{Bmatrix} =20\]</span></p><p>最短路线为<span class="math display">\[B_1 \rightarrow C_1\rightarrow D_1 \rightarrow E\]</span></p><p><strong>经过B2</strong></p><p><span class="math display">\[f_2(B_2)=min \begin{Bmatrix}d(B_2, C_1)+ f_3(C_1) \\ d(B_2,C_2) + f_3(C_2) \\ d(B_2, C_3) + f_3(C_3)\end{Bmatrix} = min \begin{Bmatrix}6+8 \\ 10+7\\4+12 \end{Bmatrix} =14\]</span></p><p>最短路线为<span class="math display">\[B_2 \rightarrow C_1\rightarrow D_1 \rightarrow E\]</span></p><p><strong>经过C3</strong></p><p><span class="math display">\[f_2(B_3)=min \begin{Bmatrix}d(B_3, C_1)+ f_3(C_1) \\ d(B_3,C_2) + f_3(C_2) \\ d(B_3, C_3) + f_3(C_3)\end{Bmatrix} = min \begin{Bmatrix}13+8 \\ 12+7\\11+12 \end{Bmatrix} =19\]</span></p><p>最短路线为<span class="math display">\[B_3 \rightarrow C_2\rightarrow D_2 \rightarrow E\]</span></p><hr /><p>第一阶段(A-&gt;B)：A到B有3条路线</p><p><span class="math display">\[f_1(A)=min \begin{Bmatrix}d(A, B_1) +f_2(B_1) \\ d(A,B_2) + f_2(B_2) \\ d(A, B_3) + f_2(B_3) \end{Bmatrix} =min \begin{Bmatrix}2+20 \\ 5+14\\1+19 \end{Bmatrix} = 19\]</span></p><p>最短路线为<span class="math display">\[A \rightarrow B_2 \rightarrowC_1 \rightarrow D_1 \rightarrow E\]</span></p><h1 id="全局路径规划算法a算法">5.全局路径规划算法——A*算法</h1><h2 id="算法简介-3">算法简介</h2><ul><li>A*(A-Star)算法是一种静态路网求解最短路径最有效的直接搜索方法，也是解决许多搜索问题的有效算法，</li><li>广泛应用于室内机器人路径搜索、游戏动画路径搜索等。</li></ul><h2 id="算法思想-3">算法思想</h2><ul><li><p>A*算法结合了贪心算法（深度优先）和Dijkstra算法（广度优先），是一种启发是搜索算法。</p></li><li><p>路径优劣的评价公式为：<spanclass="math inline">\(\color{Red}f(n)=g(n) + h(n)\)</span></p></li><li><p><spanclass="math inline">\(f(n)\)</span>是从初始状态经由状态<spanclass="math inline">\(n\)</span>到目标状态的代价估计，</p><p><spanclass="math inline">\(g(n)\)</span>是在状态空间中从初始状态到状态<spanclass="math inline">\(n\)</span>的实际代价</p><p><span class="math inline">\(h(n)\)</span>是从状态<spanclass="math inline">\(n\)</span>到目标状态的最佳路径的估计代价</p></li><li><p>使用了两个状态表，分别称为<strong>openList表和closeList表</strong>。openList表由待考察的节点组成，closeList表由已经考察过节点组成。</p></li></ul><h2 id="算法精讲预处理">算法精讲——预处理</h2><ul><li>将地图栅格化，把每一个正方形格子的中央称为节点；</li><li>确定栅格属性，即每一个格子有两种状态：可走和不可走（体现障碍物）。</li><li>定义两个列表集合：openList和closeList。openList表由待考察的节点组成，closeList由已经考察的节点组成。类似Dijkstra算法的U集合和S集合。</li><li>确定起始节点和目标节点。</li></ul><p><img src="/img/PathPlaning/A-Star-1.png" /></p><p><img src="/img/PathPlaning/A-Star-2.png" /></p><p>初始时，定义A为父节点，节点A离自身的距离为0，路径完全确定，移入closeList中；</p><p>父节点周围共有8个节点，定义为子节点。将子节点放入openList中，成为待考察对象。</p><p>若某个节点既未在openList，也没在closeList中，则表明还有未搜索到该节点。</p><p>路径优劣的判断依据是移动代价，单步移动代价采取<font color='red'>Manhattan计算方式</font>，即把横向和纵向移动一个节点的定义为10。斜向移动代价参考等腰三角形计算斜边的方式，距离为14。</p><h2 id="算法精讲开始搜索">算法精讲——开始搜索</h2><ul><li>移动代价评价函数为：<spanclass="math inline">\(f(n)=g(n)+h(n)\)</span>。<spanclass="math inline">\(f(n)\)</span>是初始状态经由状态<spanclass="math inline">\(n\)</span>到目标状态的代价估计，<spanclass="math inline">\(g(n)\)</span>是在状态空间中从初始状态到状态<spanclass="math inline">\(n\)</span>的实际代价，<spanclass="math inline">\(h(n)\)</span>是从状态<spanclass="math inline">\(n\)</span>到目标状态的最佳路径的估计代价。<font color='red'>以节点<spanclass="math inline">\(I\)</span>为例。</font></li><li>首先考察<spanclass="math inline">\(g\)</span>，由于从A到该格子是斜向移动，单步移动距离为14，故<spanclass="math inline">\(g=14\)</span></li><li>在考察估计代价<spanclass="math inline">\(h\)</span>。估计的含义是忽略剩下的路径是否包含有障碍物（不可走），完全按照Manhattan计算方式，计算<font color='red'>只做横向或纵向移动</font>的累计代价：横向向右移动3步，纵向向上移动1步，总共4步，故为<spanclass="math inline">\(h=40\)</span>.</li><li>因此从A节点移动I节点的总移动代价为：<spanclass="math inline">\(f=54\)</span></li><li>以此类推，分别计算当前openList中余下的7个子节点的移动代价，挑选最小代价节点F，移动到closeList中。</li><li>现在<spanclass="math inline">\(openList=\{B,C,D,E,G,H,I\},closeList=\{A,F\}\)</span></li></ul><p><img src="/img/PathPlaning/A-Star-3.png" /></p>]]></content>
    
    
    <categories>
      
      <category>Self-Driving</category>
      
    </categories>
    
    
    <tags>
      
      <tag>note</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pacman 文档</title>
    <link href="/2022/04/28/Linux/pacman/"/>
    <url>/2022/04/28/Linux/pacman/</url>
    
    <content type="html"><![CDATA[<h1 id="pacman---arch-linux-软件管理器">pacman - Arch Linux软件管理器</h1><h3 id="synopsis">SYNOPSIS</h3><figure class="highlight shell"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs shell">pacman &lt;operation&gt; [options] [targets]<br></code></pre></td></tr></table></figure><h3 id="description">DESCRIPTION</h3><p>Pacman 是一个包管理的使用程序，用于跟踪 Linux系统上以安装的包。它具有依赖性支持、软件包组、安装和卸载脚本，以及将本地机器与远程存储库同步以自动升级包的功能。Pacman包是 tar 压缩格式。</p><p>调用 pacman涉及到指定一个带有任何潜在选项(options)和目标(targets)的操作(operation)。目标通常是包名(packagename)、文件名(file name)、URL或搜索字符串(searchstring)。目标可以作为命令行参数提供。</p><h3 id="operations">OPERATIONS</h3><ul><li><p><strong>-D， --database</strong></p><p>对包数据库进行操作。通过该操作，可以修改 pacman数据库中已安装软件包的某些属性。检查数据库内部一致性。</p></li><li><p><strong>-Q，--query</strong></p><p>查询包数据库。该操作可以查看已安装的包及其文件，以及关于单个包的元信息。这可以针对本地包数据库运行，可以用于单个包文件。</p></li><li><p><strong>-R，--remove</strong></p><p>从系统中移除包。还可以指定要删除的组，在这种情况下，该组中的每个包都会被删除。属于指定包的文件将会被删除，数据库将会更新。</p></li><li><p><strong>-S，--sync</strong></p><p>同步包。包直接从远程仓库中安装，包括所需的所有依赖项。如果一个包名存在于多个仓库中，可以显示的指定仓库来确定需要安装的包。对于版本要求：<code>pacman -S "bash&gt;=3.2"</code>(需要使用双引号)。</p><p>除了包之外，还可以指定组(group)。例：如果 gnome是一个已定义的包组，那么 <code>pacman -S gnome</code>将提供一个提示，允许从编号列表中选择要安装的包。包的选择是使用空格和"/"或逗号的包号(packagenumbers)列表来指定的。可以用连字符(-)分隔第一个和最后一个包号来选择连续的包。排除包可以在数字或数字范围前加上插入符号(^)来实现。</p><p>提供其他包的包(Packages that provide otherpackages)也被处理。例：<code>pacman -S foo</code> 将首先查找一个 foo包。如果没有找到 foo，将搜索提供与 foo 相同功能的包。</p><p>可以使用 <code>pacman -Su</code> 来升级所有过时的软件包。</p></li><li><p><strong>-T --deptest</strong></p><p>检查依赖关系；这在 makepkg等脚本中用于检查已安装的包。该操作检查指定的每个依赖项，并返回系统当前不满足的依赖项列表。例：<code>pacman -T qt "bash&gt;=3.2"</code></p></li><li><p><strong>-U，--upgrade</strong></p><p>向系统升级或添加包，并从同步仓库中安装所需的依赖项。可以指定URL或文件路径。这是一个“删除尔后添加”的过程。</p></li><li><p><strong>-F，--files</strong></p><p>查询 files数据库。查找或显示属于某个包的文件。只有作为同步数据库一部分的包才会被搜索。</p></li><li><p><strong>-V，--version</strong></p><p>版本信息</p></li><li><p><strong>-h，--help</strong></p><p>显示给定操作的语法。如果没有提供操作，则显示一般语法。</p></li></ul><h3 id="options">OPTIONS</h3><ul><li><p><strong>-b，--dbpath</strong> <path></p><p>指定数据库的位置(默认：<code>/var/lib/pacman</code>)。<strong>注意</strong>：这必须是一个绝对路径。</p></li><li><p><strong>-r，--root</strong> <path></p><p>指定安装跟目录(默认：<code>/</code>)。这不能作为将软件安装到/usr/local而不是/usr的一种方式。</p></li><li><p><strong>-v，--verbose</strong></p><p>输出路径，如根目录(Root)，配置文件(Conf File)，DB路径(DBPath)，缓存目录(Cache Dirs)等。</p></li><li><p><strong>--arch</strong> <arch></p><p>指定架构(architecture)</p></li><li><p><strong>--cachedir</strong></p><dir><p>指定包的缓存目录(默认：<code>/var/cache/pacman/pkg</code>)。可以指定多个缓存目录，并按照传递给pacman的顺序依次尝试它们。<strong>注意</strong>：这必须是一个绝对路径。</p></li><li><p><strong>--color</strong> <when></p><p>指定何时启动着色。选项有 [always, never, auto]。</p></li><li><p><strong>--config</strong> <file></p><p>指定配置文件</p></li><li><p><strong>--debug</strong></p><p>显示调试消息。当报告错误时，建议使用此选项。</p></li><li><p><strong>--gpgdir</strong></p><dir><p>指定 GnuPG校验包签名的文件目录(默认：<code>/etc/pacman.d/gnupg</code>)。这个目录应该包含两个文件：pubring.gpg和 trustdb.gpg。<strong>注意</strong>：这必须是一个绝对路径。</p></li><li><p><strong>--hookdir</strong></p><dir><p>指定一个有钩子文件(hookfiles)的目录(默认：<code>/etc/pacman.d/hooks</code>)。可以指定多个钩子目录，使后面目录中的钩子优先于前面目录中的钩子。<strong>注意</strong>:这是一个绝对路径。</p></li><li><p><strong>--logfile</strong> <file></p><p>指定一个备用日志文件。这是一个绝对路径，与安装根目录设置无关。</p></li><li><p><strong>--noconfirm</strong></p><p>绕过任何“你确定吗?””消息。这样做不是一个好主意，除非你想从脚本运行pacman。</p></li><li><p><strong>--confirm</strong></p><p>取消先前的<code>—noconfirm</code>的影响。</p></li><li><p><strong>--disable-download-timeout</strong></p><p>在下载时禁用默认的低速限制和超时。如果你用代理和/或安全网关下载文件有问题，请使用这个。</p></li><li><p><strong>--sysroot</strong></p><dir><p>指定一个替代系统根(systemroot)。在运行Pacman之前，将chroot和chdir放入系统根目录。这允许正确地操作挂载的客户系统。给出的任何其他路径都将被解释为相对于系统根。需要root特权。</p></li></ul><h3 id="sync-options-apply-to--s">SYNC OPTIONS (APPLY TO -S)</h3><ul><li><p><strong>-c，--clean</strong></p><p>从缓存和当前未使用的同步数据库中删除不再安装的包，以释放磁盘空间。当pacman 下载软件包时，它会把它们保存在一个缓存目录中。<code>-c</code>仅删除那些不再被安装的包，<code>-cc</code>会删除缓存中的所有文件。</p></li><li><p><strong>-g，--groups</strong></p><p>显示每个指定包组的所有成员。如果没有提供组名，将列出所有组；传递标志两次(<code>-gg</code>)以查看所有组及其成员。</p></li><li><p><strong>-i，--info</strong></p><p>显示给定同步数据库包的信息。<code>-ii</code>将显示所有依赖于此包的存储库中的那些包。</p></li><li><p><strong>-l，--list</strong></p><p>列出指定仓库中的所有包。可以在命令行上指定多个仓库。</p></li><li><p><strong>-q，--quiet</strong></p><p>为某些同步操作显示较少的信息。当在脚本中处理 pacman的输出时，这很有用。搜索将只显示包名，而不显示仓库、版本、组和描述信息；List将只显示包名，而忽略数据库和版本;组将只显示包名而忽略组名。</p></li><li><p><strong>-s，--search</strong> <regexp></p><p>这将搜索同步数据库中的每个包，以查找匹配regexp的名称或描述。当您包含多个搜索条件时，只有描述匹配所有这些条件的包将被返回。</p></li><li><p><strong>-u，--sysupgrade</strong></p><p>升级所有过期的软件包。如果有新的包存在，将检查和升级当前安装的每个包。所有要升级的包将会显示一个报告，没有用户的确认操作将不会进行。依赖关系将在此级别自动解决，并将在必要时进行安装/升级。</p></li><li><p><strong>-y，--refresh</strong></p><p>从 pacman.conf(<code>/etc/pacman.conf</code>)中定义的服务器下载一个新的主包数据库副本。这通常应该在每次使用<code>-u</code> 时使用。<code>-yy</code>将强制刷新所有包数据库，即使它们看起来是最新的。</p></li></ul><h3 id="remove-options-apply-to--r">REMOVE OPTIONS (APPLY TO -R)</h3><ul><li><p><strong>-c，--cascade</strong></p><p>删除所有目标包，以及依赖于一个或多个目标包的所有包。这个操作是递归的，必须小心使用，因为它可能会删除许多可能需要的包。</p></li><li><p><strong>-n，--nosave</strong></p><p>指示 pacman忽略文件备份指定。通常，当从系统中删除一个文件时，数据库会检查该文件是否应该以.pacsave 扩展名重命名。</p></li><li><p><strong>-s，--recursive</strong></p><p>删除指定的每个目标，包括它们的所有依赖项，前提是(A)其他包不需要它们;(B)它们不是由用户明确安装的。如果要忽略条件(B)，则传递此选项两次(<code>-ss</code>)。</p></li><li><p><strong>-u，--unneeded</strong></p><p>删除任何其他包不需要的目标。这在不使用 <code>-c</code>选项删除组时非常有用，以避免破坏任何依赖关系。</p></li></ul><hr /><h3 id="examples">EXAMPLES</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">pacman -Ss ne.hack<br><span class="hljs-meta prompt_"># </span><span class="language-bash">搜索仓库中符合正则表达式<span class="hljs-string">&quot;ne.hack&quot;</span>的包</span><br>pacman -S gpm<br><span class="hljs-meta prompt_"># </span><span class="language-bash">下载并安装gpm，包括依赖项。</span><br>pacman -U /home/user/ceofhack-0.6-1-x86_64.pkg.tar.gz<br><span class="hljs-meta prompt_"># </span><span class="language-bash">从本地文件安装<span class="hljs-string">&quot;ceofhack-0.6-1&quot;</span>软件包。</span><br>pacman -Syu<br><span class="hljs-meta prompt_"># </span><span class="language-bash">更新包列表并升级所有包。</span><br>pacman -Syu gpm<br><span class="hljs-meta prompt_"># </span><span class="language-bash">更新包列表，升级所有的包，然后安装gpm(如果还没有安装的话)。</span><br></code></pre></td></tr></table></figure><hr /><p>官方帮助文档：<ahref="https://man.archlinux.org/man/pacman.8">pacman</a></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>note</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker</title>
    <link href="/2022/04/25/Linux/Docker/"/>
    <url>/2022/04/25/Linux/Docker/</url>
    
    <content type="html"><![CDATA[<h1 id="docker">Docker</h1><ul><li><a href="https://www.docker.com/get-started">官方文档地址</a></li><li><ahref="https://docker_practice.gitee.io/zh-cn">中文参考手册</a></li></ul><hr /><h2 id="什么是docker">1.什么是Docker</h2><h3 id="官方定义">1.1 官方定义</h3><blockquote><blockquote><p>官方介绍</p></blockquote><ul><li>We have a vomplete container solution for you - no matter who youare where you are on your containeriztion jouery.</li><li>翻译：我们为你提供一个完整的容器解决方案，不管你是谁，无论你在哪，你都可以可是容器的旅程。</li><li>官方定义：docker 是一个容器技术</li></ul></blockquote><h3 id="docker-的起源">1.2 Docker 的起源</h3><blockquote><p>Docker 最初是 dotCloud 公司创始人 Solomon Hykes在法国期间发起的一个公司内部项目，它是基于dotCloud公司多年云服务技术的一次革新，并于 2013年 3月以Apache 2.0授权协议开源，主要项目代码在 Github 上进行维护。Docker 项目后来还加入Linux 基金会，并成功推动 开放容器联盟(OCI)。</p><p>Docker 自开源后受到了广泛的关注和讨论，至今其 Github 项目已经超过 5万7千个星标和一万多个 fork。甚至由于Docker 项目火爆，在 2013年底，dotCloud 公司决定改名为 Docker。 Docker 最初是在 Ubuntu 12.04上开发实现的；Red Hat 则从 RHEL.6.5 开始对 Docker 进行支持；Google也在其 PaaS 产品中广泛应用 Docker。</p><p>Docer 使用 Google 公司推出的 Go 语言进行开发实现，基于 Linux 内核的cgroup， namespace，以及 OverlayFS类等技术，对进程进行封装隔离，属于操作系统层面的虚拟化技术。由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。</p></blockquote><h2 id="为什么是docker">2. 为什么是Docker</h2><ul><li><p><code>在开发的时候，在本机测试环境可以跑，生成环境跑不起来</code></p><p>这里我们拿 java Web 应用程序举例，我们一个 java Web应用程序涉及的东西很多，比如jdk、tomcat、mysql等软件环境。当这些其中某一项版本不一致的时候，可能就会导致应用程序跑不起来这种情况。Docker则将程序以及使用的软件环境直接打包在一起，无论在哪个机器上都保证了环境一致。</p><p><strong>优势1：一致的运行环境，更轻松的迁移</strong></p></li><li><p><code>服务器自己的程序挂了，结果发现是别人程序出了问题把内存吃完了，自己的程序因为内存不够就挂了</code></p><p>这种也是一种比较常见的情况，如果你的程序重要性不是特别高的话，公司基本上不可能让你的程序独享一台服务器，这时候你的服务器就会跟公司其他人的程序共享一台服务器，所以不可避免地就会受到其他程序的干扰，导致自己的程序出现问题。Docker就很好解决了环境隔离的问题，别人的程序不会影响到自己的程序。</p><p><strong>优势2：对进程进行封装隔离，容器与容器之间互不影响，更高效的利用系统资源</strong></p></li><li><p><code>公司要弄一个活动，可能会有大量的流量进来，公司需要部署几十台服务器</code></p><p>在没有 Docker的情况下，要在几天内部署几十台服务器，这对运维来说是一件非常折磨人的事，而且每台服务器的环境还不一定一样，就会出现各种问题。用Docker的话，只需要将程序打包到镜像，需要多少台服务器，就跑多少容器，极大地提高了部署效率。</p><p><strong>优势3：通过镜像复制N多个环境一致的容器</strong></p></li></ul><h2 id="docker-和虚拟机的区别">3. Docker 和虚拟机的区别</h2><figure><img src="/img/docker/Docker.png" alt="Docker" /><figcaption aria-hidden="true">Docker</figcaption></figure><p>虚拟机是携带操作系统的，本身很小的应用却因为携带了操作系统而变得非常大，很笨重。Docker是不携带操作系统的，所以 Docker的应用就非常的轻巧。另外，在调用宿主机的CPU、磁盘等等资源的时候，拿内存举例，虚拟机时利用Hypervisor 去虚拟化内存，整个调用过程时虚拟内存 -&gt; 虚拟物理内存 -&gt;真正物理内存，但是 Docker 是利用Docker Engine去调用宿主机的资源，这个过程是 虚拟内存 -&gt; 真正物理内存。</p><table><colgroup><col style="width: 15%" /><col style="width: 42%" /><col style="width: 41%" /></colgroup><thead><tr class="header"><th></th><th>传统虚拟机</th><th>Docker 容器</th></tr></thead><tbody><tr class="odd"><td>磁盘占用</td><td>几个GB到几十个GB</td><td>几十MB到几百MB</td></tr><tr class="even"><td>CPU　内存占用</td><td>虚拟操作系统非常占用CPU和内存</td><td>Docker 引擎占用极低</td></tr><tr class="odd"><td>启动速度</td><td>几分钟</td><td>几秒</td></tr><tr class="even"><td>安装管理</td><td>需要专门的运维技术</td><td>安装、管理方便</td></tr><tr class="odd"><td>应用部署</td><td>每次部署都费时费力</td><td>从第二次部署开始轻松简洁</td></tr><tr class="even"><td>耦合性</td><td>多个应用服务安装到一起，容易相互影响</td><td>每个应用服务一个容器，达到隔离</td></tr><tr class="odd"><td>系统依赖</td><td>无</td><td>需求相同或相似的内核，目前推荐Linux</td></tr></tbody></table><h2 id="docker-的安装">4. Docker 的安装</h2><h3 id="安装-dockercentos-7.x">4.1 安装 docker(centos 7.x)</h3><ul><li><p>卸载原始 Docker</p><figure class="highlight shell"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo yum remove docker \</span><br><span class="language-bash">  docker-client \</span><br><span class="language-bash">  docker-client-latest \</span><br><span class="language-bash">  docker-common \</span><br><span class="language-bash">  docker-latest \</span><br><span class="language-bash">  docker-latest-logrotate \</span><br><span class="language-bash">  docker-logrotate \</span><br><span class="language-bash">  docker-engine</span><br></code></pre></td></tr></table></figure></li><li><p>安装 docker 依赖</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo yum install -y yum-utils \</span><br><span class="language-bash">  device-mapper-persistent-data \</span><br><span class="language-bash">  lvm2</span><br></code></pre></td></tr></table></figure></li><li><p>设置 docker 的 yum 源</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo yum-config-manager \</span><br><span class="language-bash">--add-repo \</span><br><span class="language-bash">https://download.docker.com/linux/centos/docker-ce.repo</span><br></code></pre></td></tr></table></figure></li><li><p>安装最新版的 docker</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo yum install docker-ce docker-cecli containerd.io</span><br></code></pre></td></tr></table></figure></li><li><p>指定版本安装 docker</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">yum install docker-ce --showduplicates | <span class="hljs-built_in">sort</span> -r</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">yum install docker-ce-&lt;VERSION_STRING&gt; docker-ce-cli-&lt;VERSION_STRING&gt; containerd.io</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">yum install docker-ce-18.09.5-3.e17 docker-ce-cli-18.09.5-3.e17 containerd.io</span><br></code></pre></td></tr></table></figure></li><li><p>启动 docker</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo systemctl <span class="hljs-built_in">enable</span> docker</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo systemctl start docker</span><br></code></pre></td></tr></table></figure></li><li><p>关闭 docker</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo systemctl stop docker</span><br></code></pre></td></tr></table></figure></li><li><p>测试 docker 安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo docker run hello-world</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="bash-安装通用所有平台">4.2 bash 安装(通用所有平台)</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">curl -fsSL get.docker.com -o get-docker.sh</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo sh get-docker.sh --mirror Aliyun</span><br></code></pre></td></tr></table></figure><ul><li><p>启动 docker</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo systemctl <span class="hljs-built_in">enable</span> docker</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo systemctl start doecker</span><br></code></pre></td></tr></table></figure></li><li><p>创建 docker 用户组</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo groupadd docker</span><br></code></pre></td></tr></table></figure></li><li><p>当前的用户加入 docker 组</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo usermod -aG docker <span class="hljs-variable">$USER</span></span><br></code></pre></td></tr></table></figure></li><li><p>测试 docker 安装是否正确</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker run hello-world</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="docker-的核心架构">5. Docker 的核心架构</h2><ol type="1"><li><p>镜像 image 复数 images</p><p>定义：一个镜像代表着一个软件 如：MySQL镜像 redis镜像nginx镜像····</p></li><li><p>容器 container</p><p>定义：基于某个镜像运行一次就会生成一个程序实例，一个实例称之为一个容器</p><p>特点：可读、可写</p></li><li><p>仓库 repository</p><p>定义：用来存储 docker 中的所有镜像</p><p>远程仓库：docker 官方维护的一个唯一的远程仓库</p><p>本地仓库：当前机器的镜像存储位置</p></li></ol><figure><img src="/img/docker/dockerKernel.jpg" alt="dockerKernel" /><figcaption aria-hidden="true">dockerKernel</figcaption></figure><h2 id="镜像的相关操作">6. 镜像的相关操作</h2><h3 id="辅助命令">6.1 辅助命令</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 1. 安装完成辅助命令</span><br><span class="hljs-code">docker version---------------------查看 docker 的信息</span><br><span class="hljs-code">docker info---------------------查看更详细的信息</span><br><span class="hljs-code">docker --help ---------------------帮助命令</span><br></code></pre></td></tr></table></figure><h3 id="images-镜像命令">6.2 Images 镜像命令</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 1. 查看本机中所有镜像</span><br><span class="hljs-code">docker images------------------------列出本地所有镜像</span><br><span class="hljs-code">-a列出所有镜像</span><br><span class="hljs-code">-q只显示镜像 id</span><br><span class="hljs-code"># 2. 搜素镜像</span><br><span class="hljs-code">docker search [options] 镜像名 -----------去 dockerhub 上查询当前镜像</span><br><span class="hljs-code">-s指定值列出收藏数不少于指定值的镜像</span><br><span class="hljs-code">--no-trunc  显示完整的镜像信息</span><br><span class="hljs-code"># 3. 从仓库下载镜像</span><br><span class="hljs-code">docker pull 镜像名[:TAG|@DIGEST] ----------下载镜像</span><br><span class="hljs-code"># 4. 删除镜像</span><br><span class="hljs-code">docker rmi 镜像名  ----------------------- 删除镜像</span><br><span class="hljs-code">-f强制删除</span><br><span class="hljs-code"># 5. 载入镜像</span><br><span class="hljs-code">docker load -i xxx.tar</span><br></code></pre></td></tr></table></figure><h3 id="contrainer-容器命令">6.3 Contrainer 容器命令</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 1. 运行容器</span><br><span class="hljs-code">docker run 镜像名---------------镜像名新建并启动容器</span><br><span class="hljs-code">--name为容器起一个名字</span><br><span class="hljs-code">-d启动守护容器（在后台启动容器）</span><br><span class="hljs-code">-p映射端口号：原始端口号指定端口号启动</span><br><span class="hljs-code"># 2. 查看运行的容器</span><br><span class="hljs-code">docker ps---------------------列出所有正在运行的容器</span><br><span class="hljs-code">-a正在运行的和历史运行的容器</span><br><span class="hljs-code">-q静默模式，只显示容器编号</span><br><span class="hljs-code"># 3. 停止|关闭|重启容器</span><br><span class="hljs-code">docker start 容器名称或容器ID---------- 开启容器</span><br><span class="hljs-code">docker restart 容器名或容器ID----------- 重启容器</span><br><span class="hljs-code">docker stop 容器名或容器ID----------- 正常停止容器</span><br><span class="hljs-code">docker kill 容器名或容器ID----------- 立即停止容器运行</span><br><span class="hljs-code"># 4. 删除容器</span><br><span class="hljs-code">docker rm 容器名称|容器ID----------- 删除停止的容器</span><br><span class="hljs-code">-f删除正在运行的容器</span><br><span class="hljs-code"># 5. 查看容器内进程</span><br><span class="hljs-code">docker top容器名称|容器ID----------- 查看容器内进程</span><br><span class="hljs-code"># 6. 查看容器内部细节</span><br><span class="hljs-code">docker inspect容器名称|容器ID----------- 查看容器内部细节</span><br><span class="hljs-code"># 7. 查看运行日志</span><br><span class="hljs-code">docker logs [OPTIONS] 容器名称|容器ID----------- 查看容器内进程</span><br><span class="hljs-code">-t加入时间戳</span><br><span class="hljs-code">-f跟随最新的日志打印</span><br><span class="hljs-code">--tail数字显示最后多少条</span><br><span class="hljs-code"># 8. 进入容器</span><br><span class="hljs-code">docker exec -it容器名称|容器ID bash--------- 进入容器bash，与容器交互</span><br><span class="hljs-code">退出容器exit</span><br><span class="hljs-code"># 9. 操作系统与容器的文件传输</span><br><span class="hljs-code">从容器到操作系统：docker cp 容器ID:容器内资源路径 操作系统路径</span><br><span class="hljs-code">从操作系统到容器：docker cp 文件|目录容器ID：容器路径</span><br><span class="hljs-code"># 10. 数据卷(volum)实现与宿主机共享目录</span><br><span class="hljs-code">docker run -v 宿主机的路径|任意别名:/容器内的路径镜像名</span><br><span class="hljs-code">docker run -v 宿主机的路径|任意别名:/容器内的路径:ro镜像名</span><br><span class="hljs-code">ro：镜像只读</span><br><span class="hljs-code">注意：</span><br><span class="hljs-code">1. 如果是宿主机类路径必须是绝对路径，宿主机目录会覆盖容器内目录内容</span><br><span class="hljs-code">2. 如果是别名则会在docker运行容器时自动在宿主机中创建一个目录，并将容器目录文件复制到宿主机中</span><br><span class="hljs-code"># 11. 打包镜像</span><br><span class="hljs-code">docker save 镜像名-o 名称.tar</span><br><span class="hljs-code"># 12. 载入镜像</span><br><span class="hljs-code">docker load -i 名称.tar</span><br><span class="hljs-code"># 13. 容器打包成新的镜像</span><br><span class="hljs-code">docker commit -m &quot;描述信息&quot; -a &quot;作者信息&quot;（容器ID或名称） 打包的镜像的名称：标签</span><br></code></pre></td></tr></table></figure><h2 id="dokcer-中容器之间的网络配置">7. Dokcer 中容器之间的网络配置</h2><blockquote><p>Docker 允许通过外部访问容器或容器互联的方式来提供网络服务</p></blockquote><h3 id="docker-容器与操作系统通信机制">7.1 docker容器与操作系统通信机制</h3><p>当 Docker 启动时，会自动在主机上创建一个 <code>docker0</code>虚拟网桥，实际上是 Linux 的一个bridge，可以理解为一个软件交换机。它会在挂载到它的网口之间进行转发。</p><p>同时，Docker 随机分配一个本地未占用的私有网段（在 <ahref="https://datatracker.ietf.org/doc/html/rfc1918">RFC1918</a>中定义）中的一个地址给<code>docker0</code> 接口。比如典型的 <code>172.17.0.1</code>，掩码为<code>255.255.0.0</code>。此后启动的容器内的网口也会自动分配一个同一网段（<code>172.17.0.0/16</code>）的地址。</p><figure><img src="/img/docker/netDokcer0.PNG" alt="netDocker0" /><figcaption aria-hidden="true">netDocker0</figcaption></figure><p>当创建一个 Docker 容器的时候，同时会创建了一对 <code>veth pair</code>接口（当数据包发送到一个接口时，另外一个接口也可以收到相同的数据包）。这对接口一端在容器内，即<code>eth0</code>；另一端在本地并被挂载到 <code>docker0</code>网桥，名称以 <code>veth</code> 开头（例如<code>vethAQI2QT</code>）。通过这种方式，主机可以跟容器通信，容器之间也可以相互通信。Docker就创建了在主机和所有容器之间一个虚拟共享网络。</p><figure><img src="/img/docker/docker0.png" alt="docker0" /><figcaption aria-hidden="true">docker0</figcaption></figure><h3 id="docker-网络使用">7.2 Docker 网络使用</h3><p>注意：一般在使用 docker 网桥(bridge)实现容器与容器通信时，都是站在一个应用的角度进行容器通信。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 1. 查看 docker 网桥配置</span><br><span class="hljs-code">docker network ls</span><br><span class="hljs-code"># 2. 自定义网桥</span><br><span class="hljs-code">docker network create -d bridge 网桥名称</span><br><span class="hljs-code"># 3. 指定容器网桥</span><br><span class="hljs-code">docker run --network 网桥名称 </span><br><span class="hljs-code">&gt; docker network [OPTION]</span><br><span class="hljs-code">     connect     Connect a container to a network</span><br><span class="hljs-code">     create      Create a network</span><br><span class="hljs-code">     disconnect  Disconnect a container from a network</span><br><span class="hljs-code">     inspect     Display detailed information on one or more networks</span><br><span class="hljs-code">     ls          List networks</span><br><span class="hljs-code">     prune       Remove all unused networks</span><br><span class="hljs-code">     rm          Remove one or more networks</span><br></code></pre></td></tr></table></figure><p>​</p><h2 id="数据卷">8. 数据卷</h2><p><strong>数据卷</strong>是一个可供一个或多个容器使用的特殊目录，它绕过UFS，可以提供很多有用的特性</p><ul><li><em>数据卷</em> 可以在容器之间共享和重用</li><li>对 <em>数据卷</em> 的修改会立马生效</li><li>对 <em>数据卷</em> 的更新，不会影响镜像</li><li><em>数据卷</em> 默认会一直存在，即使容器被删除</li></ul><blockquote><p>注意：<em>数据卷</em> 的使用，类似于 Linux 下对目录或文件进行mount，镜像中的被指定为挂载点的目录中的文件会复制到数据卷中（仅数据卷为空时会复制）。</p></blockquote><p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 1. 自定义数据卷目录</span><br><span class="hljs-code">docker run -v 绝对路径:容器内路径</span><br><span class="hljs-code"># 2. 自动创建数据卷</span><br><span class="hljs-code">docker run -v 卷名：容器内路径</span><br></code></pre></td></tr></table></figure></p><h3 id="docker-操作数据卷命令">docker 操作数据卷命令</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 1. 查看数据卷</span><br><span class="hljs-code">docker volume ls</span><br><span class="hljs-code"># 2. 查看数据卷细节</span><br><span class="hljs-code">docker volume inspect 卷名</span><br><span class="hljs-code">&gt; docker volume [OPTION]</span><br><span class="hljs-code">     create      Create a volume</span><br><span class="hljs-code">     inspect     Display detailed information on one or more volumes</span><br><span class="hljs-code">     ls          List volumes</span><br><span class="hljs-code">     prune       Remove all unused local volumes</span><br><span class="hljs-code">     rm          Remove one or more volumes</span><br></code></pre></td></tr></table></figure><h2 id="dockerfile">9. Dockerfile</h2><h3 id="什么是-dockerfile">什么是 Dockerfile</h3><p>定义：用来帮助我们自己构建一个自定义镜像 Dockerfile 成为镜像构建文件描述文件</p><h3 id="dockerfile-的保留命令">Dockerfile 的保留命令</h3><p>官方说明(https://docs.docker.com/engine/reference/builder/)</p><table><colgroup><col style="width: 18%" /><col style="width: 81%" /></colgroup><thead><tr class="header"><th>保留字</th><th>作用</th></tr></thead><tbody><tr class="odd"><td><strong>FROM</strong></td><td><strong>当前镜像是基于哪个镜像的</strong></td></tr><tr class="even"><td>MAINTAINER</td><td>镜像维护者的姓名和邮箱地址</td></tr><tr class="odd"><td><strong>RUN</strong></td><td><strong>构建镜像时需要运行的指令</strong></td></tr><tr class="even"><td><strong>EXPOSE</strong></td><td><strong>当前容器对外暴露的端口号</strong></td></tr><tr class="odd"><td><strong>WORKDIR</strong></td><td><strong>指定再创建容器后，终端默认登录进来的工作目录，一个落脚点</strong></td></tr><tr class="even"><td><strong>ENV</strong></td><td><strong>用来再构建镜像的过程中设置环境变量</strong></td></tr><tr class="odd"><td><strong>ADD</strong></td><td><strong>将宿主机目录下的文件拷贝进镜像且ADD命令会自动处理URL和解压tar包</strong></td></tr><tr class="even"><td><strong>COPY</strong></td><td><strong>类似于 ADD，拷贝文件和目录到镜像中</strong><br/><strong>将从构建上下文目录中<原路径>的文件/目录复制到新的一层的镜像内的<目标路径>位置</strong></td></tr><tr class="odd"><td><strong>VOLUME</strong></td><td><strong>容器数据卷，用于数据保存和持久化工作</strong></td></tr><tr class="even"><td><strong>CMD</strong></td><td><strong>指定一个容器启动时要运行的命令</strong><br/><strong>Dockerfile 中可以有多个CMD 指令，但只有最后一个生效， CMD会被 docker run 之后的参数替换</strong></td></tr><tr class="odd"><td><strong>ENTRYPOINT</strong></td><td><strong>指定一个容器启动时要运行的命令</strong><br/><strong>ENTRYPOINT 的目的和 CMD一样，都是在指定容器启动程序及其参数</strong></td></tr></tbody></table><h4 id="from-命令">FROM 命令</h4><ul><li><p>基于哪个镜像进行构建新的镜像，在构建时会自动从 docker hub 拉取base 镜像 必须作为 Dockerfile 的一个指令出现</p></li><li><p>语法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">FROM &lt;image&gt;<br>FROM &lt;image&gt;[:&lt;tag&gt;]使用版本<br>FROM &lt;image&gt;[@&lt;digest&gt;]使用摘要<br></code></pre></td></tr></table></figure></li></ul><h4 id="run-命令">RUN 命令</h4><ul><li><p>RUN指令将在当前映像之上的新层中执行任何命令并提交结果。生成的提交映像将用于Dockerfile 中下一步</p></li><li><p>语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">RUN &lt;command&gt;<br>RUN echo hello<br>RUN [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;](exec form)<br>RUN [&quot;/bin/bash&quot;, &quot;-c&quot;, &quot;echo hello&quot;]<br></code></pre></td></tr></table></figure></li></ul><h4 id="expose-命令">EXPOSE 命令</h4><ul><li><p>用来指定构建的镜像在运行为容器时对外暴露的端口</p></li><li><p>语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">EXPOSE 80/tcp如果没有显示指定则默认暴露都是 tcp<br>EXPOSE 80/udp <br></code></pre></td></tr></table></figure></li></ul><h4 id="cmd-命令">CMD 命令</h4><ul><li><p>用来为启动的容器指定执行的命令，在 Dockerfile 中只能有一条 CMD指令。如果列出多个命令，则只有最后一个命令才会生效。</p></li><li><p>注意：<strong>Dockerfile 中只能有一条 CMD指令。如果列出多个命令，则只有最后一个命令才会生效。</strong></p></li><li><p>语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">CMD [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]<br>CMD [&quot;param1&quot;, &quot;param2&quot;]<br>CMD command param1 param2 (shell form)<br></code></pre></td></tr></table></figure></li></ul><h4 id="workdir-命令">WORKDIR 命令</h4><ul><li><p>用来为 Dockerfile 中的任何 RUN、CMD、ENTRYPOINT、COPY 和 ADD指令设置工作目录。如果 WORKDIR 不存在，即使它没有在任何后续 Dockerfile指令中使用，它也将被创建。</p></li><li><p>语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">WORKDIR /path/to/workdir<br><br>WORKDIR /a<br>WORKDIR b<br>WORKDIR c<br></code></pre></td></tr></table></figure></li></ul><h4 id="add-命令">ADD 命令</h4><ul><li><p>用来从 context 上下文复制新文件、目录或远程文件url，并将它们添加到位于指定路径的映像文件系统中</p></li><li><p>语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">ADD hom* /mydir/ 通配符添加多个文件<br>ADD hom?.txt /mydir 通配符添加<br>ADD test.txt relativeDir/ 可以指定相对路径<br>ADD test.txt /absoluteDir/ 绝对路径<br>ADD url<br></code></pre></td></tr></table></figure></li></ul><h4 id="copy-命令">COPY 命令</h4><ul><li><p>用来将 context 目录中指定文件复制到镜像的指定目录中</p></li><li><p>语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">COPY src dest<br>COPY [&quot;&lt;src&gt;&quot;,... &quot;&lt;dest&gt;&quot;]<br></code></pre></td></tr></table></figure></li></ul><h4 id="volume-命令">VOLUME 命令</h4><ul><li><p>用来定义容器运行时可以挂载到宿主机的目录</p></li><li><p>语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">VOLUME [&quot;/data&quot;]<br></code></pre></td></tr></table></figure></li></ul><h4 id="env-命令">ENV 命令</h4><ul><li><p>用来为构建镜像设置环境变量。这个值将会出现在构建阶段中所有的后续指令的环境中。</p></li><li><p>语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">ENV &lt;key&gt; &lt;value&gt; <br>ENV &lt;key&gt; &lt;value&gt; ...<br></code></pre></td></tr></table></figure></li></ul><h4 id="entrypoint-命令">ENTRYPOINT 命令</h4><ul><li><p>用来指定容器启动时执行命令和 CMD 类似</p></li><li><p>语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]<br>ENTRYPOINT command param1 param2<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>note</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/04/24/hello-world/"/>
    <url>/2022/04/24/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your veryfirst post. Check <a href="https://hexo.io/docs/">documentation</a> formore info. If you get any problems when using Hexo, you can find theanswer in <ahref="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> oryou can ask me on <ahref="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="quick-start">Quick Start</h2><h3 id="create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
  
  
  <entry>
    <title>about</title>
    <link href="/"/>
    <url>/</url>
    
    <content type="html"><![CDATA[<p>about</p>]]></content>
    
  </entry>
  
  
  
</search>
