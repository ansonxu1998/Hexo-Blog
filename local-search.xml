<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Docker</title>
    <link href="/2022/04/25/Linux/Docker/"/>
    <url>/2022/04/25/Linux/Docker/</url>
    
    <content type="html"><![CDATA[<h1 id="docker">Docker</h1><ul><li><a href="https://www.docker.com/get-started">官方文档地址</a></li><li><ahref="https://docker_practice.gitee.io/zh-cn">中文参考手册</a></li></ul><hr /><h2 id="什么是docker">1.什么是Docker</h2><h3 id="官方定义">1.1 官方定义</h3><blockquote><blockquote><p>官方介绍</p></blockquote><ul><li>We have a vomplete container solution for you - no matter who youare where you are on your containeriztion jouery.</li><li>翻译：我们为你提供一个完整的容器解决方案，不管你是谁，无论你在哪，你都可以可是容器的旅程。</li><li>官方定义：docker 是一个容器技术</li></ul></blockquote><h3 id="docker-的起源">1.2 Docker 的起源</h3><blockquote><p>Docker 最初是 dotCloud 公司创始人 Solomon Hykes在法国期间发起的一个公司内部项目，它是基于dotCloud公司多年云服务技术的一次革新，并于 2013年 3月以Apache 2.0授权协议开源，主要项目代码在 Github 上进行维护。Docker 项目后来还加入Linux 基金会，并成功推动 开放容器联盟(OCI)。</p><p>Docker 自开源后受到了广泛的关注和讨论，至今其 Github 项目已经超过 5万7千个星标和一万多个 fork。甚至由于Docker 项目火爆，在 2013年底，dotCloud 公司决定改名为 Docker。 Docker 最初是在 Ubuntu 12.04上开发实现的；Red Hat 则从 RHEL.6.5 开始对 Docker 进行支持；Google也在其 PaaS 产品中广泛应用 Docker。</p><p>Docer 使用 Google 公司推出的 Go 语言进行开发实现，基于 Linux 内核的cgroup， namespace，以及 OverlayFS类等技术，对进程进行封装隔离，属于操作系统层面的虚拟化技术。由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。</p></blockquote><h2 id="为什么是docker">2. 为什么是Docker</h2><ul><li><p><code>在开发的时候，在本机测试环境可以跑，生成环境跑不起来</code></p><p>这里我们拿 java Web 应用程序举例，我们一个 java Web应用程序涉及的东西很多，比如jdk、tomcat、mysql等软件环境。当这些其中某一项版本不一致的时候，可能就会导致应用程序跑不起来这种情况。Docker则将程序以及使用的软件环境直接打包在一起，无论在哪个机器上都保证了环境一致。</p><p><strong>优势1：一致的运行环境，更轻松的迁移</strong></p></li><li><p><code>服务器自己的程序挂了，结果发现是别人程序出了问题把内存吃完了，自己的程序因为内存不够就挂了</code></p><p>这种也是一种比较常见的情况，如果你的程序重要性不是特别高的话，公司基本上不可能让你的程序独享一台服务器，这时候你的服务器就会跟公司其他人的程序共享一台服务器，所以不可避免地就会受到其他程序的干扰，导致自己的程序出现问题。Docker就很好解决了环境隔离的问题，别人的程序不会影响到自己的程序。</p><p><strong>优势2：对进程进行封装隔离，容器与容器之间互不影响，更高效的利用系统资源</strong></p></li><li><p><code>公司要弄一个活动，可能会有大量的流量进来，公司需要部署几十台服务器</code></p><p>在没有 Docker的情况下，要在几天内部署几十台服务器，这对运维来说是一件非常折磨人的事，而且每台服务器的环境还不一定一样，就会出现各种问题。用Docker的话，只需要将程序打包到镜像，需要多少台服务器，就跑多少容器，极大地提高了部署效率。</p><p><strong>优势3：通过镜像复制N多个环境一致的容器</strong></p></li></ul><h2 id="docker-和虚拟机的区别">3. Docker 和虚拟机的区别</h2><figure><img src="/img/docker/Docker.png" alt="Docker" /><figcaption aria-hidden="true">Docker</figcaption></figure><p>虚拟机是携带操作系统的，本身很小的应用却因为携带了操作系统而变得非常大，很笨重。Docker是不携带操作系统的，所以 Docker的应用就非常的轻巧。另外，在调用宿主机的CPU、磁盘等等资源的时候，拿内存举例，虚拟机时利用Hypervisor 去虚拟化内存，整个调用过程时虚拟内存 -&gt; 虚拟物理内存 -&gt;真正物理内存，但是 Docker 是利用Docker Engine去调用宿主机的资源，这个过程是 虚拟内存 -&gt; 真正物理内存。</p><table><colgroup><col style="width: 15%" /><col style="width: 42%" /><col style="width: 41%" /></colgroup><thead><tr class="header"><th></th><th>传统虚拟机</th><th>Docker 容器</th></tr></thead><tbody><tr class="odd"><td>磁盘占用</td><td>几个GB到几十个GB</td><td>几十MB到几百MB</td></tr><tr class="even"><td>CPU　内存占用</td><td>虚拟操作系统非常占用CPU和内存</td><td>Docker 引擎占用极低</td></tr><tr class="odd"><td>启动速度</td><td>几分钟</td><td>几秒</td></tr><tr class="even"><td>安装管理</td><td>需要专门的运维技术</td><td>安装、管理方便</td></tr><tr class="odd"><td>应用部署</td><td>每次部署都费时费力</td><td>从第二次部署开始轻松简洁</td></tr><tr class="even"><td>耦合性</td><td>多个应用服务安装到一起，容易相互影响</td><td>每个应用服务一个容器，达到隔离</td></tr><tr class="odd"><td>系统依赖</td><td>无</td><td>需求相同或相似的内核，目前推荐Linux</td></tr></tbody></table><h2 id="docker-的安装">4. Docker 的安装</h2><h3 id="安装-dockercentos-7.x">4.1 安装 docker(centos 7.x)</h3><ul><li><p>卸载原始 Docker</p><figure class="highlight shell"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo yum remove docker \</span><br><span class="language-bash">  docker-client \</span><br><span class="language-bash">  docker-client-latest \</span><br><span class="language-bash">  docker-common \</span><br><span class="language-bash">  docker-latest \</span><br><span class="language-bash">  docker-latest-logrotate \</span><br><span class="language-bash">  docker-logrotate \</span><br><span class="language-bash">  docker-engine</span><br></code></pre></td></tr></table></figure></li><li><p>安装 docker 依赖</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo yum install -y yum-utils \</span><br><span class="language-bash">  device-mapper-persistent-data \</span><br><span class="language-bash">  lvm2</span><br></code></pre></td></tr></table></figure></li><li><p>设置 docker 的 yum 源</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo yum-config-manager \</span><br><span class="language-bash">--add-repo \</span><br><span class="language-bash">https://download.docker.com/linux/centos/docker-ce.repo</span><br></code></pre></td></tr></table></figure></li><li><p>安装最新版的 docker</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo yum install docker-ce docker-cecli containerd.io</span><br></code></pre></td></tr></table></figure></li><li><p>指定版本安装 docker</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">yum install docker-ce --showduplicates | <span class="hljs-built_in">sort</span> -r</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">yum install docker-ce-&lt;VERSION_STRING&gt; docker-ce-cli-&lt;VERSION_STRING&gt; containerd.io</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">yum install docker-ce-18.09.5-3.e17 docker-ce-cli-18.09.5-3.e17 containerd.io</span><br></code></pre></td></tr></table></figure></li><li><p>启动 docker</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo systemctl <span class="hljs-built_in">enable</span> docker</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo systemctl start docker</span><br></code></pre></td></tr></table></figure></li><li><p>关闭 docker</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo systemctl stop docker</span><br></code></pre></td></tr></table></figure></li><li><p>测试 docker 安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo docker run hello-world</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="bash-安装通用所有平台">4.2 bash 安装(通用所有平台)</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">curl -fsSL get.docker.com -o get-docker.sh</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo sh get-docker.sh --mirror Aliyun</span><br></code></pre></td></tr></table></figure><ul><li><p>启动 docker</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo systemctl <span class="hljs-built_in">enable</span> docker</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo systemctl start doecker</span><br></code></pre></td></tr></table></figure></li><li><p>创建 docker 用户组</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo groupadd docker</span><br></code></pre></td></tr></table></figure></li><li><p>当前的用户加入 docker 组</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo usermod -aG docker <span class="hljs-variable">$USER</span></span><br></code></pre></td></tr></table></figure></li><li><p>测试 docker 安装是否正确</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker run hello-world</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="docker-的核心架构">5. Docker 的核心架构</h2><ol type="1"><li><p>镜像 image 复数 images</p><p>定义：一个镜像代表着一个软件 如：MySQL镜像 redis镜像nginx镜像····</p></li><li><p>容器 container</p><p>定义：基于某个镜像运行一次就会生成一个程序实例，一个实例称之为一个容器</p><p>特点：可读、可写</p></li><li><p>仓库 repository</p><p>定义：用来存储 docker 中的所有镜像</p><p>远程仓库：docker 官方维护的一个唯一的远程仓库</p><p>本地仓库：当前机器的镜像存储位置</p></li></ol><figure><img src="/img/docker/dockerKernel.jpg" alt="dockerKernel" /><figcaption aria-hidden="true">dockerKernel</figcaption></figure><h2 id="镜像的相关操作">6. 镜像的相关操作</h2><h3 id="辅助命令">6.1 辅助命令</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 1. 安装完成辅助命令</span><br><span class="hljs-code">docker version---------------------查看 docker 的信息</span><br><span class="hljs-code">docker info---------------------查看更详细的信息</span><br><span class="hljs-code">docker --help ---------------------帮助命令</span><br></code></pre></td></tr></table></figure><h3 id="images-镜像命令">6.2 Images 镜像命令</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 1. 查看本机中所有镜像</span><br><span class="hljs-code">docker images------------------------列出本地所有镜像</span><br><span class="hljs-code">-a列出所有镜像</span><br><span class="hljs-code">-q只显示镜像 id</span><br><span class="hljs-code"># 2. 搜素镜像</span><br><span class="hljs-code">docker search [options] 镜像名 -----------去 dockerhub 上查询当前镜像</span><br><span class="hljs-code">-s指定值列出收藏数不少于指定值的镜像</span><br><span class="hljs-code">--no-trunc  显示完整的镜像信息</span><br><span class="hljs-code"># 3. 从仓库下载镜像</span><br><span class="hljs-code">docker pull 镜像名[:TAG|@DIGEST] ----------下载镜像</span><br><span class="hljs-code"># 4. 删除镜像</span><br><span class="hljs-code">docker rmi 镜像名  ----------------------- 删除镜像</span><br><span class="hljs-code">-f强制删除</span><br><span class="hljs-code"># 5. 载入镜像</span><br><span class="hljs-code">docker load -i xxx.tar</span><br></code></pre></td></tr></table></figure><h3 id="contrainer-容器命令">6.3 Contrainer 容器命令</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 1. 运行容器</span><br><span class="hljs-code">docker run 镜像名---------------镜像名新建并启动容器</span><br><span class="hljs-code">--name为容器起一个名字</span><br><span class="hljs-code">-d启动守护容器（在后台启动容器）</span><br><span class="hljs-code">-p映射端口号：原始端口号指定端口号启动</span><br><span class="hljs-code"># 2. 查看运行的容器</span><br><span class="hljs-code">docker ps---------------------列出所有正在运行的容器</span><br><span class="hljs-code">-a正在运行的和历史运行的容器</span><br><span class="hljs-code">-q静默模式，只显示容器编号</span><br><span class="hljs-code"># 3. 停止|关闭|重启容器</span><br><span class="hljs-code">docker start 容器名称或容器ID---------- 开启容器</span><br><span class="hljs-code">docker restart 容器名或容器ID----------- 重启容器</span><br><span class="hljs-code">docker stop 容器名或容器ID----------- 正常停止容器</span><br><span class="hljs-code">docker kill 容器名或容器ID----------- 立即停止容器运行</span><br><span class="hljs-code"># 4. 删除容器</span><br><span class="hljs-code">docker rm 容器名称|容器ID----------- 删除停止的容器</span><br><span class="hljs-code">-f删除正在运行的容器</span><br><span class="hljs-code"># 5. 查看容器内进程</span><br><span class="hljs-code">docker top容器名称|容器ID----------- 查看容器内进程</span><br><span class="hljs-code"># 6. 查看容器内部细节</span><br><span class="hljs-code">docker inspect容器名称|容器ID----------- 查看容器内部细节</span><br><span class="hljs-code"># 7. 查看运行日志</span><br><span class="hljs-code">docker logs [OPTIONS] 容器名称|容器ID----------- 查看容器内进程</span><br><span class="hljs-code">-t加入时间戳</span><br><span class="hljs-code">-f跟随最新的日志打印</span><br><span class="hljs-code">--tail数字显示最后多少条</span><br><span class="hljs-code"># 8. 进入容器</span><br><span class="hljs-code">docker exec -it容器名称|容器ID bash--------- 进入容器bash，与容器交互</span><br><span class="hljs-code">退出容器exit</span><br><span class="hljs-code"># 9. 操作系统与容器的文件传输</span><br><span class="hljs-code">从容器到操作系统：docker cp 容器ID:容器内资源路径 操作系统路径</span><br><span class="hljs-code">从操作系统到容器：docker cp 文件|目录容器ID：容器路径</span><br><span class="hljs-code"># 10. 数据卷(volum)实现与宿主机共享目录</span><br><span class="hljs-code">docker run -v 宿主机的路径|任意别名:/容器内的路径镜像名</span><br><span class="hljs-code">docker run -v 宿主机的路径|任意别名:/容器内的路径:ro镜像名</span><br><span class="hljs-code">ro：镜像只读</span><br><span class="hljs-code">注意：</span><br><span class="hljs-code">1. 如果是宿主机类路径必须是绝对路径，宿主机目录会覆盖容器内目录内容</span><br><span class="hljs-code">2. 如果是别名则会在docker运行容器时自动在宿主机中创建一个目录，并将容器目录文件复制到宿主机中</span><br><span class="hljs-code"># 11. 打包镜像</span><br><span class="hljs-code">docker save 镜像名-o 名称.tar</span><br><span class="hljs-code"># 12. 载入镜像</span><br><span class="hljs-code">docker load -i 名称.tar</span><br><span class="hljs-code"># 13. 容器打包成新的镜像</span><br><span class="hljs-code">docker commit -m &quot;描述信息&quot; -a &quot;作者信息&quot;（容器ID或名称） 打包的镜像的名称：标签</span><br></code></pre></td></tr></table></figure><h2 id="dokcer-中容器之间的网络配置">7. Dokcer 中容器之间的网络配置</h2><blockquote><p>Docker 允许通过外部访问容器或容器互联的方式来提供网络服务</p></blockquote><h3 id="docker-容器与操作系统通信机制">7.1 docker容器与操作系统通信机制</h3><p>当 Docker 启动时，会自动在主机上创建一个 <code>docker0</code>虚拟网桥，实际上是 Linux 的一个bridge，可以理解为一个软件交换机。它会在挂载到它的网口之间进行转发。</p><p>同时，Docker 随机分配一个本地未占用的私有网段（在 <ahref="https://datatracker.ietf.org/doc/html/rfc1918">RFC1918</a>中定义）中的一个地址给<code>docker0</code> 接口。比如典型的 <code>172.17.0.1</code>，掩码为<code>255.255.0.0</code>。此后启动的容器内的网口也会自动分配一个同一网段（<code>172.17.0.0/16</code>）的地址。</p><figure><img src="/img/docker/netDokcer0.PNG" alt="netDocker0" /><figcaption aria-hidden="true">netDocker0</figcaption></figure><p>当创建一个 Docker 容器的时候，同时会创建了一对 <code>veth pair</code>接口（当数据包发送到一个接口时，另外一个接口也可以收到相同的数据包）。这对接口一端在容器内，即<code>eth0</code>；另一端在本地并被挂载到 <code>docker0</code>网桥，名称以 <code>veth</code> 开头（例如<code>vethAQI2QT</code>）。通过这种方式，主机可以跟容器通信，容器之间也可以相互通信。Docker就创建了在主机和所有容器之间一个虚拟共享网络。</p><figure><img src="/img/docker/docker0.png" alt="docker0" /><figcaption aria-hidden="true">docker0</figcaption></figure><h3 id="docker-网络使用">7.2 Docker 网络使用</h3><p>注意：一般在使用 docker 网桥(bridge)实现容器与容器通信时，都是站在一个应用的角度进行容器通信。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 1. 查看 docker 网桥配置</span><br><span class="hljs-code">docker network ls</span><br><span class="hljs-code"># 2. 自定义网桥</span><br><span class="hljs-code">docker network create -d bridge 网桥名称</span><br><span class="hljs-code"># 3. 指定容器网桥</span><br><span class="hljs-code">docker run --network 网桥名称 </span><br><span class="hljs-code">&gt; docker network [OPTION]</span><br><span class="hljs-code">     connect     Connect a container to a network</span><br><span class="hljs-code">     create      Create a network</span><br><span class="hljs-code">     disconnect  Disconnect a container from a network</span><br><span class="hljs-code">     inspect     Display detailed information on one or more networks</span><br><span class="hljs-code">     ls          List networks</span><br><span class="hljs-code">     prune       Remove all unused networks</span><br><span class="hljs-code">     rm          Remove one or more networks</span><br></code></pre></td></tr></table></figure><p>​</p><h2 id="数据卷">8. 数据卷</h2><p><strong>数据卷</strong>是一个可供一个或多个容器使用的特殊目录，它绕过UFS，可以提供很多有用的特性</p><ul><li><em>数据卷</em> 可以在容器之间共享和重用</li><li>对 <em>数据卷</em> 的修改会立马生效</li><li>对 <em>数据卷</em> 的更新，不会影响镜像</li><li><em>数据卷</em> 默认会一直存在，即使容器被删除</li></ul><blockquote><p>注意：<em>数据卷</em> 的使用，类似于 Linux 下对目录或文件进行mount，镜像中的被指定为挂载点的目录中的文件会复制到数据卷中（仅数据卷为空时会复制）。</p></blockquote><p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 1. 自定义数据卷目录</span><br><span class="hljs-code">docker run -v 绝对路径:容器内路径</span><br><span class="hljs-code"># 2. 自动创建数据卷</span><br><span class="hljs-code">docker run -v 卷名：容器内路径</span><br></code></pre></td></tr></table></figure></p><h3 id="docker-操作数据卷命令">docker 操作数据卷命令</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 1. 查看数据卷</span><br><span class="hljs-code">docker volume ls</span><br><span class="hljs-code"># 2. 查看数据卷细节</span><br><span class="hljs-code">docker volume inspect 卷名</span><br><span class="hljs-code">&gt; docker volume [OPTION]</span><br><span class="hljs-code">     create      Create a volume</span><br><span class="hljs-code">     inspect     Display detailed information on one or more volumes</span><br><span class="hljs-code">     ls          List volumes</span><br><span class="hljs-code">     prune       Remove all unused local volumes</span><br><span class="hljs-code">     rm          Remove one or more volumes</span><br></code></pre></td></tr></table></figure><h2 id="dockerfile">9. Dockerfile</h2><h3 id="什么是-dockerfile">什么是 Dockerfile</h3><p>定义：用来帮助我们自己构建一个自定义镜像 Dockerfile 成为镜像构建文件描述文件</p><h3 id="dockerfile-的保留命令">Dockerfile 的保留命令</h3><p>官方说明(https://docs.docker.com/engine/reference/builder/)</p><table><colgroup><col style="width: 18%" /><col style="width: 81%" /></colgroup><thead><tr class="header"><th>保留字</th><th>作用</th></tr></thead><tbody><tr class="odd"><td><strong>FROM</strong></td><td><strong>当前镜像是基于哪个镜像的</strong></td></tr><tr class="even"><td>MAINTAINER</td><td>镜像维护者的姓名和邮箱地址</td></tr><tr class="odd"><td><strong>RUN</strong></td><td><strong>构建镜像时需要运行的指令</strong></td></tr><tr class="even"><td><strong>EXPOSE</strong></td><td><strong>当前容器对外暴露的端口号</strong></td></tr><tr class="odd"><td><strong>WORKDIR</strong></td><td><strong>指定再创建容器后，终端默认登录进来的工作目录，一个落脚点</strong></td></tr><tr class="even"><td><strong>ENV</strong></td><td><strong>用来再构建镜像的过程中设置环境变量</strong></td></tr><tr class="odd"><td><strong>ADD</strong></td><td><strong>将宿主机目录下的文件拷贝进镜像且ADD命令会自动处理URL和解压tar包</strong></td></tr><tr class="even"><td><strong>COPY</strong></td><td><strong>类似于 ADD，拷贝文件和目录到镜像中</strong><br/><strong>将从构建上下文目录中<原路径>的文件/目录复制到新的一层的镜像内的<目标路径>位置</strong></td></tr><tr class="odd"><td><strong>VOLUME</strong></td><td><strong>容器数据卷，用于数据保存和持久化工作</strong></td></tr><tr class="even"><td><strong>CMD</strong></td><td><strong>指定一个容器启动时要运行的命令</strong><br/><strong>Dockerfile 中可以有多个CMD 指令，但只有最后一个生效， CMD会被 docker run 之后的参数替换</strong></td></tr><tr class="odd"><td><strong>ENTRYPOINT</strong></td><td><strong>指定一个容器启动时要运行的命令</strong><br/><strong>ENTRYPOINT 的目的和 CMD一样，都是在指定容器启动程序及其参数</strong></td></tr></tbody></table><h4 id="from-命令">FROM 命令</h4><ul><li><p>基于哪个镜像进行构建新的镜像，在构建时会自动从 docker hub 拉取base 镜像 必须作为 Dockerfile 的一个指令出现</p></li><li><p>语法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">FROM &lt;image&gt;<br>FROM &lt;image&gt;[:&lt;tag&gt;]使用版本<br>FROM &lt;image&gt;[@&lt;digest&gt;]使用摘要<br></code></pre></td></tr></table></figure></li></ul><h4 id="run-命令">RUN 命令</h4><ul><li><p>RUN指令将在当前映像之上的新层中执行任何命令并提交结果。生成的提交映像将用于Dockerfile 中下一步</p></li><li><p>语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">RUN &lt;command&gt;<br>RUN echo hello<br>RUN [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;](exec form)<br>RUN [&quot;/bin/bash&quot;, &quot;-c&quot;, &quot;echo hello&quot;]<br></code></pre></td></tr></table></figure></li></ul><h4 id="expose-命令">EXPOSE 命令</h4><ul><li><p>用来指定构建的镜像在运行为容器时对外暴露的端口</p></li><li><p>语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">EXPOSE 80/tcp如果没有显示指定则默认暴露都是 tcp<br>EXPOSE 80/udp <br></code></pre></td></tr></table></figure></li></ul><h4 id="cmd-命令">CMD 命令</h4><ul><li><p>用来为启动的容器指定执行的命令，在 Dockerfile 中只能有一条 CMD指令。如果列出多个命令，则只有最后一个命令才会生效。</p></li><li><p>注意：<strong>Dockerfile 中只能有一条 CMD指令。如果列出多个命令，则只有最后一个命令才会生效。</strong></p></li><li><p>语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">CMD [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]<br>CMD [&quot;param1&quot;, &quot;param2&quot;]<br>CMD command param1 param2 (shell form)<br></code></pre></td></tr></table></figure></li></ul><h4 id="workdir-命令">WORKDIR 命令</h4><ul><li><p>用来为 Dockerfile 中的任何 RUN、CMD、ENTRYPOINT、COPY 和 ADD指令设置工作目录。如果 WORKDIR 不存在，即使它没有在任何后续 Dockerfile指令中使用，它也将被创建。</p></li><li><p>语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">WORKDIR /path/to/workdir<br><br>WORKDIR /a<br>WORKDIR b<br>WORKDIR c<br></code></pre></td></tr></table></figure></li></ul><h4 id="add-命令">ADD 命令</h4><ul><li><p>用来从 context 上下文复制新文件、目录或远程文件url，并将它们添加到位于指定路径的映像文件系统中</p></li><li><p>语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">ADD hom* /mydir/ 通配符添加多个文件<br>ADD hom?.txt /mydir 通配符添加<br>ADD test.txt relativeDir/ 可以指定相对路径<br>ADD test.txt /absoluteDir/ 绝对路径<br>ADD url<br></code></pre></td></tr></table></figure></li></ul><h4 id="copy-命令">COPY 命令</h4><ul><li><p>用来将 context 目录中指定文件复制到镜像的指定目录中</p></li><li><p>语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">COPY src dest<br>COPY [&quot;&lt;src&gt;&quot;,... &quot;&lt;dest&gt;&quot;]<br></code></pre></td></tr></table></figure></li></ul><h4 id="volume-命令">VOLUME 命令</h4><ul><li><p>用来定义容器运行时可以挂载到宿主机的目录</p></li><li><p>语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">VOLUME [&quot;/data&quot;]<br></code></pre></td></tr></table></figure></li></ul><h4 id="env-命令">ENV 命令</h4><ul><li><p>用来为构建镜像设置环境变量。这个值将会出现在构建阶段中所有的后续指令的环境中。</p></li><li><p>语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">ENV &lt;key&gt; &lt;value&gt; <br>ENV &lt;key&gt; &lt;value&gt; ...<br></code></pre></td></tr></table></figure></li></ul><h4 id="entrypoint-命令">ENTRYPOINT 命令</h4><ul><li><p>用来指定容器启动时执行命令和 CMD 类似</p></li><li><p>语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]<br>ENTRYPOINT command param1 param2<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>note</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/04/24/hello-world/"/>
    <url>/2022/04/24/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your veryfirst post. Check <a href="https://hexo.io/docs/">documentation</a> formore info. If you get any problems when using Hexo, you can find theanswer in <ahref="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> oryou can ask me on <ahref="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="quick-start">Quick Start</h2><h3 id="create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
  
  
  <entry>
    <title>about</title>
    <link href="/"/>
    <url>/</url>
    
    <content type="html"><![CDATA[<p>about</p>]]></content>
    
  </entry>
  
  
  
</search>
