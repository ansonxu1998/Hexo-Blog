<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>pacman 文档</title>
    <link href="/2022/04/28/Linux/pacman/"/>
    <url>/2022/04/28/Linux/pacman/</url>
    
    <content type="html"><![CDATA[<h1 id="pacman---arch-linux-软件管理器">pacman - Arch Linux软件管理器</h1><h3 id="synopsis">SYNOPSIS</h3><figure class="highlight shell"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs shell">pacman &lt;operation&gt; [options] [targets]<br></code></pre></td></tr></table></figure><h3 id="description">DESCRIPTION</h3><p>Pacman 是一个包管理的使用程序，用于跟踪 Linux系统上以安装的包。它具有依赖性支持、软件包组、安装和卸载脚本，以及将本地机器与远程存储库同步以自动升级包的功能。Pacman包是 tar 压缩格式。</p><p>调用 pacman涉及到指定一个带有任何潜在选项(options)和目标(targets)的操作(operation)。目标通常是包名(packagename)、文件名(file name)、URL或搜索字符串(searchstring)。目标可以作为命令行参数提供。</p><h3 id="operations">OPERATIONS</h3><ul><li><p><strong>-D， --database</strong></p><p>对包数据库进行操作。通过该操作，可以修改 pacman数据库中已安装软件包的某些属性。检查数据库内部一致性。</p></li><li><p><strong>-Q，--query</strong></p><p>查询包数据库。该操作可以查看已安装的包及其文件，以及关于单个包的元信息。这可以针对本地包数据库运行，可以用于单个包文件。</p></li><li><p><strong>R，--remove</strong></p><p>从系统中移除包。还可以指定要删除的组，在这种情况下，该组中的每个包都会被删除。属于指定包的文件将会被删除，数据库将会更新。</p></li><li><p><strong>-S，--sync</strong></p><p>同步包。包直接从远程仓库中安装，包括所需的所有依赖项。如果一个包名存在于多个仓库中，可以显示的指定仓库来确定需要安装的包。对于版本要求：<code>pacman -S "bash&gt;=3.2"</code>(需要使用双引号)。</p><p>除了包之外，还可以指定组(group)。例：如果 gnome是一个已定义的包组，那么 <code>pacman -S gnome</code>将提供一个提示，允许从编号列表中选择要安装的包。包的选择是使用空格和"/"或逗号的包号(packagenumbers)列表来指定的。可以用连字符(-)分隔第一个和最后一个包号来选择连续的包。排除包可以在数字或数字范围前加上插入符号(^)来实现。</p><p>提供其他包的包(Packages that provide otherpackages)也被处理。例：<code>pacman -S foo</code> 将首先查找一个 foo包。如果没有找到 foo，将搜索提供与 foo 相同功能的包。</p><p>可以使用 <code>pacman -Su</code> 来升级所有过时的软件包。</p></li><li><p><strong>-T --deptest</strong></p><p>检查依赖关系；这在 makepkg等脚本中用于检查已安装的包。该操作检查指定的每个依赖项，并返回系统当前不满足的依赖项列表。例：<code>pacman -T qt "bash&gt;=3.2"</code></p></li><li><p><strong>-U，--upgrade</strong></p><p>向系统升级或添加包，并从同步仓库中安装所需的依赖项。可以指定URL或文件路径。这是一个“删除尔后添加”的过程。</p></li><li><p><strong>-F，--files</strong></p><p>查询 files数据库。查找或显示属于某个包的文件。只有作为同步数据库一部分的包才会被搜索。</p></li><li><p><strong>-V，--version</strong></p><p>版本信息</p></li><li><p><strong>-h，--help</strong></p><p>显示给定操作的语法。如果没有提供操作，则显示一般语法。</p></li></ul><h3 id="options">OPTIONS</h3><ul><li><p><strong>-b，--dbpath</strong> <path></p><p>指定数据库的位置(默认：<code>/var/lib/pacman</code>)。<strong>注意</strong>：这必须是一个绝对路径。</p></li><li><p><strong>-r，--root</strong> <path></p><p>指定安装跟目录(默认：<code>/</code>)。这不能作为将软件安装到/usr/local而不是/usr的一种方式。</p></li><li><p><strong>-v，--verbose</strong></p><p>输出路径，如根目录(Root)，配置文件(Conf File)，DB路径(DBPath)，缓存目录(Cache Dirs)等。</p></li><li><p><strong>--arch</strong> <arch></p><p>指定架构(architecture)</p></li><li><p><strong>--cachedir</strong></p><dir><p>指定包的缓存目录(默认：<code>/var/cache/pacman/pkg</code>)。可以指定多个缓存目录，并按照传递给pacman的顺序依次尝试它们。<strong>注意</strong>：这必须是一个绝对路径。</p></li><li><p><strong>--color</strong> <when></p><p>指定何时启动着色。选项有 [always, never, auto]。</p></li><li><p><strong>--config</strong> <file></p><p>指定配置文件</p></li><li><p><strong>debug</strong></p><p>显示调试消息。当报告错误时，建议使用此选项。</p></li><li><p><strong>gpgdir</strong></p><dir><p>指定 GnuPG校验包签名的文件目录(默认：<code>/etc/pacman.d/gnupg</code>)。这个目录应该包含两个文件：pubring.gpg和 trustdb.gpg。<strong>注意</strong>：这必须是一个绝对路径。</p></li><li><p><strong>hookdir</strong></p><dir><p>指定一个有钩子文件(hookfiles)的目录(默认：<code>/etc/pacman.d/hooks</code>)。可以指定多个钩子目录，使后面目录中的钩子优先于前面目录中的钩子。<strong>注意</strong>:这是一个绝对路径。</p></li><li><p><strong>--logfile</strong> <file></p><p>指定一个备用日志文件。这是一个绝对路径，与安装根目录设置无关。</p></li><li><p><strong>--noconfirm</strong></p><p>绕过任何“你确定吗?””消息。这样做不是一个好主意，除非你想从脚本运行pacman。</p></li><li><p><strong>--confirm</strong></p><p>取消先前的<code>—noconfirm</code>的影响。</p></li><li><p><strong>--disable-download-timeout</strong></p><p>在下载时禁用默认的低速限制和超时。如果你用代理和/或安全网关下载文件有问题，请使用这个。</p></li><li><p><strong>--sysroot</strong></p><dir><p>指定一个替代系统根(systemroot)。在运行Pacman之前，将chroot和chdir放入系统根目录。这允许正确地操作挂载的客户系统。给出的任何其他路径都将被解释为相对于系统根。需要root特权。</p></li></ul><h3 id="sync-options-apply-to--s">SYNC OPTIONS (APPLY TO -S)</h3><ul><li><p><strong>-c，--clean</strong></p><p>从缓存和当前未使用的同步数据库中删除不再安装的包，以释放磁盘空间。当pacman 下载软件包时，它会把它们保存在一个缓存目录中。<code>-c</code>仅删除那些不再被安装的包，<code>-cc</code>会删除缓存中的所有文件。</p></li><li><p><strong>-g，--groups</strong></p><p>显示每个指定包组的所有成员。如果没有提供组名，将列出所有组；传递标志两次(<code>-gg</code>)以查看所有组及其成员。</p></li><li><p><strong>-i，--info</strong></p><p>显示给定同步数据库包的信息。<code>-ii</code>将显示所有依赖于此包的存储库中的那些包。</p></li><li><p><strong>-l，--list</strong></p><p>列出指定仓库中的所有包。可以在命令行上指定多个仓库。</p></li><li><p><strong>-q，--quiet</strong></p><p>为某些同步操作显示较少的信息。当在脚本中处理 pacman的输出时，这很有用。搜索将只显示包名，而不显示仓库、版本、组和描述信息；List将只显示包名，而忽略数据库和版本;组将只显示包名而忽略组名。</p></li><li><p><strong>-s，--search</strong> <regexp></p><p>这将搜索同步数据库中的每个包，以查找匹配regexp的名称或描述。当您包含多个搜索条件时，只有描述匹配所有这些条件的包将被返回。</p></li><li><p><strong>-u，--sysupgrade</strong></p><p>升级所有过期的软件包。如果有新的包存在，将检查和升级当前安装的每个包。所有要升级的包将会显示一个报告，没有用户的确认操作将不会进行。依赖关系将在此级别自动解决，并将在必要时进行安装/升级。</p></li><li><p><strong>-y，--refresh</strong></p><p>从 pacman.conf(<code>/etc/pacman.conf</code>)中定义的服务器下载一个新的主包数据库副本。这通常应该在每次使用<code>-u</code> 时使用。<code>-yy</code>将强制刷新所有包数据库，即使它们看起来是最新的。</p></li></ul><h3 id="remove-options-apply-to--r">REMOVE OPTIONS (APPLY TO -R)</h3><ul><li><p><strong>-c，--cascade</strong></p><p>删除所有目标包，以及依赖于一个或多个目标包的所有包。这个操作是递归的，必须小心使用，因为它可能会删除许多可能需要的包。</p></li><li><p><strong>-n，--nosave</strong></p><p>指示 pacman忽略文件备份指定。通常，当从系统中删除一个文件时，数据库会检查该文件是否应该以.pacsave 扩展名重命名。</p></li><li><p><strong>-s，--recursive</strong></p><p>删除指定的每个目标，包括它们的所有依赖项，前提是(A)其他包不需要它们;(B)它们不是由用户明确安装的。如果要忽略条件(B)，则传递此选项两次(<code>-ss</code>)。</p></li><li><p><strong>-u，--unneeded</strong></p><p>删除任何其他包不需要的目标。这在不使用 <code>-c</code>选项删除组时非常有用，以避免破坏任何依赖关系。</p></li></ul><hr /><h3 id="examples">EXAMPLES</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">pacman -Ss ne.hack<br><span class="hljs-meta prompt_"># </span><span class="language-bash">搜索仓库中符合正则表达式<span class="hljs-string">&quot;ne.hack&quot;</span>的包</span><br>pacman -S gpm<br><span class="hljs-meta prompt_"># </span><span class="language-bash">下载并安装gpm，包括依赖项。</span><br>pacman -U /home/user/ceofhack-0.6-1-x86_64.pkg.tar.gz<br><span class="hljs-meta prompt_"># </span><span class="language-bash">从本地文件安装<span class="hljs-string">&quot;ceofhack-0.6-1&quot;</span>软件包。</span><br>pacman -Syu<br><span class="hljs-meta prompt_"># </span><span class="language-bash">更新包列表并升级所有包。</span><br>pacman -Syu gpm<br><span class="hljs-meta prompt_"># </span><span class="language-bash">更新包列表，升级所有的包，然后安装gpm(如果还没有安装的话)。</span><br></code></pre></td></tr></table></figure><hr /><p>官方帮助文档：<ahref="https://man.archlinux.org/man/pacman.8">pacman</a></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>note</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker</title>
    <link href="/2022/04/25/Linux/Docker/"/>
    <url>/2022/04/25/Linux/Docker/</url>
    
    <content type="html"><![CDATA[<h1 id="docker">Docker</h1><ul><li><a href="https://www.docker.com/get-started">官方文档地址</a></li><li><ahref="https://docker_practice.gitee.io/zh-cn">中文参考手册</a></li></ul><hr /><h2 id="什么是docker">1.什么是Docker</h2><h3 id="官方定义">1.1 官方定义</h3><blockquote><blockquote><p>官方介绍</p></blockquote><ul><li>We have a vomplete container solution for you - no matter who youare where you are on your containeriztion jouery.</li><li>翻译：我们为你提供一个完整的容器解决方案，不管你是谁，无论你在哪，你都可以可是容器的旅程。</li><li>官方定义：docker 是一个容器技术</li></ul></blockquote><h3 id="docker-的起源">1.2 Docker 的起源</h3><blockquote><p>Docker 最初是 dotCloud 公司创始人 Solomon Hykes在法国期间发起的一个公司内部项目，它是基于dotCloud公司多年云服务技术的一次革新，并于 2013年 3月以Apache 2.0授权协议开源，主要项目代码在 Github 上进行维护。Docker 项目后来还加入Linux 基金会，并成功推动 开放容器联盟(OCI)。</p><p>Docker 自开源后受到了广泛的关注和讨论，至今其 Github 项目已经超过 5万7千个星标和一万多个 fork。甚至由于Docker 项目火爆，在 2013年底，dotCloud 公司决定改名为 Docker。 Docker 最初是在 Ubuntu 12.04上开发实现的；Red Hat 则从 RHEL.6.5 开始对 Docker 进行支持；Google也在其 PaaS 产品中广泛应用 Docker。</p><p>Docer 使用 Google 公司推出的 Go 语言进行开发实现，基于 Linux 内核的cgroup， namespace，以及 OverlayFS类等技术，对进程进行封装隔离，属于操作系统层面的虚拟化技术。由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。</p></blockquote><h2 id="为什么是docker">2. 为什么是Docker</h2><ul><li><p><code>在开发的时候，在本机测试环境可以跑，生成环境跑不起来</code></p><p>这里我们拿 java Web 应用程序举例，我们一个 java Web应用程序涉及的东西很多，比如jdk、tomcat、mysql等软件环境。当这些其中某一项版本不一致的时候，可能就会导致应用程序跑不起来这种情况。Docker则将程序以及使用的软件环境直接打包在一起，无论在哪个机器上都保证了环境一致。</p><p><strong>优势1：一致的运行环境，更轻松的迁移</strong></p></li><li><p><code>服务器自己的程序挂了，结果发现是别人程序出了问题把内存吃完了，自己的程序因为内存不够就挂了</code></p><p>这种也是一种比较常见的情况，如果你的程序重要性不是特别高的话，公司基本上不可能让你的程序独享一台服务器，这时候你的服务器就会跟公司其他人的程序共享一台服务器，所以不可避免地就会受到其他程序的干扰，导致自己的程序出现问题。Docker就很好解决了环境隔离的问题，别人的程序不会影响到自己的程序。</p><p><strong>优势2：对进程进行封装隔离，容器与容器之间互不影响，更高效的利用系统资源</strong></p></li><li><p><code>公司要弄一个活动，可能会有大量的流量进来，公司需要部署几十台服务器</code></p><p>在没有 Docker的情况下，要在几天内部署几十台服务器，这对运维来说是一件非常折磨人的事，而且每台服务器的环境还不一定一样，就会出现各种问题。用Docker的话，只需要将程序打包到镜像，需要多少台服务器，就跑多少容器，极大地提高了部署效率。</p><p><strong>优势3：通过镜像复制N多个环境一致的容器</strong></p></li></ul><h2 id="docker-和虚拟机的区别">3. Docker 和虚拟机的区别</h2><figure><img src="/img/docker/Docker.png" alt="Docker" /><figcaption aria-hidden="true">Docker</figcaption></figure><p>虚拟机是携带操作系统的，本身很小的应用却因为携带了操作系统而变得非常大，很笨重。Docker是不携带操作系统的，所以 Docker的应用就非常的轻巧。另外，在调用宿主机的CPU、磁盘等等资源的时候，拿内存举例，虚拟机时利用Hypervisor 去虚拟化内存，整个调用过程时虚拟内存 -&gt; 虚拟物理内存 -&gt;真正物理内存，但是 Docker 是利用Docker Engine去调用宿主机的资源，这个过程是 虚拟内存 -&gt; 真正物理内存。</p><table><colgroup><col style="width: 15%" /><col style="width: 42%" /><col style="width: 41%" /></colgroup><thead><tr class="header"><th></th><th>传统虚拟机</th><th>Docker 容器</th></tr></thead><tbody><tr class="odd"><td>磁盘占用</td><td>几个GB到几十个GB</td><td>几十MB到几百MB</td></tr><tr class="even"><td>CPU　内存占用</td><td>虚拟操作系统非常占用CPU和内存</td><td>Docker 引擎占用极低</td></tr><tr class="odd"><td>启动速度</td><td>几分钟</td><td>几秒</td></tr><tr class="even"><td>安装管理</td><td>需要专门的运维技术</td><td>安装、管理方便</td></tr><tr class="odd"><td>应用部署</td><td>每次部署都费时费力</td><td>从第二次部署开始轻松简洁</td></tr><tr class="even"><td>耦合性</td><td>多个应用服务安装到一起，容易相互影响</td><td>每个应用服务一个容器，达到隔离</td></tr><tr class="odd"><td>系统依赖</td><td>无</td><td>需求相同或相似的内核，目前推荐Linux</td></tr></tbody></table><h2 id="docker-的安装">4. Docker 的安装</h2><h3 id="安装-dockercentos-7.x">4.1 安装 docker(centos 7.x)</h3><ul><li><p>卸载原始 Docker</p><figure class="highlight shell"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo yum remove docker \</span><br><span class="language-bash">  docker-client \</span><br><span class="language-bash">  docker-client-latest \</span><br><span class="language-bash">  docker-common \</span><br><span class="language-bash">  docker-latest \</span><br><span class="language-bash">  docker-latest-logrotate \</span><br><span class="language-bash">  docker-logrotate \</span><br><span class="language-bash">  docker-engine</span><br></code></pre></td></tr></table></figure></li><li><p>安装 docker 依赖</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo yum install -y yum-utils \</span><br><span class="language-bash">  device-mapper-persistent-data \</span><br><span class="language-bash">  lvm2</span><br></code></pre></td></tr></table></figure></li><li><p>设置 docker 的 yum 源</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo yum-config-manager \</span><br><span class="language-bash">--add-repo \</span><br><span class="language-bash">https://download.docker.com/linux/centos/docker-ce.repo</span><br></code></pre></td></tr></table></figure></li><li><p>安装最新版的 docker</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo yum install docker-ce docker-cecli containerd.io</span><br></code></pre></td></tr></table></figure></li><li><p>指定版本安装 docker</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">yum install docker-ce --showduplicates | <span class="hljs-built_in">sort</span> -r</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">yum install docker-ce-&lt;VERSION_STRING&gt; docker-ce-cli-&lt;VERSION_STRING&gt; containerd.io</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">yum install docker-ce-18.09.5-3.e17 docker-ce-cli-18.09.5-3.e17 containerd.io</span><br></code></pre></td></tr></table></figure></li><li><p>启动 docker</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo systemctl <span class="hljs-built_in">enable</span> docker</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo systemctl start docker</span><br></code></pre></td></tr></table></figure></li><li><p>关闭 docker</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo systemctl stop docker</span><br></code></pre></td></tr></table></figure></li><li><p>测试 docker 安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo docker run hello-world</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="bash-安装通用所有平台">4.2 bash 安装(通用所有平台)</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">curl -fsSL get.docker.com -o get-docker.sh</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo sh get-docker.sh --mirror Aliyun</span><br></code></pre></td></tr></table></figure><ul><li><p>启动 docker</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo systemctl <span class="hljs-built_in">enable</span> docker</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo systemctl start doecker</span><br></code></pre></td></tr></table></figure></li><li><p>创建 docker 用户组</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo groupadd docker</span><br></code></pre></td></tr></table></figure></li><li><p>当前的用户加入 docker 组</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo usermod -aG docker <span class="hljs-variable">$USER</span></span><br></code></pre></td></tr></table></figure></li><li><p>测试 docker 安装是否正确</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker run hello-world</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="docker-的核心架构">5. Docker 的核心架构</h2><ol type="1"><li><p>镜像 image 复数 images</p><p>定义：一个镜像代表着一个软件 如：MySQL镜像 redis镜像nginx镜像····</p></li><li><p>容器 container</p><p>定义：基于某个镜像运行一次就会生成一个程序实例，一个实例称之为一个容器</p><p>特点：可读、可写</p></li><li><p>仓库 repository</p><p>定义：用来存储 docker 中的所有镜像</p><p>远程仓库：docker 官方维护的一个唯一的远程仓库</p><p>本地仓库：当前机器的镜像存储位置</p></li></ol><figure><img src="/img/docker/dockerKernel.jpg" alt="dockerKernel" /><figcaption aria-hidden="true">dockerKernel</figcaption></figure><h2 id="镜像的相关操作">6. 镜像的相关操作</h2><h3 id="辅助命令">6.1 辅助命令</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 1. 安装完成辅助命令</span><br><span class="hljs-code">docker version---------------------查看 docker 的信息</span><br><span class="hljs-code">docker info---------------------查看更详细的信息</span><br><span class="hljs-code">docker --help ---------------------帮助命令</span><br></code></pre></td></tr></table></figure><h3 id="images-镜像命令">6.2 Images 镜像命令</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 1. 查看本机中所有镜像</span><br><span class="hljs-code">docker images------------------------列出本地所有镜像</span><br><span class="hljs-code">-a列出所有镜像</span><br><span class="hljs-code">-q只显示镜像 id</span><br><span class="hljs-code"># 2. 搜素镜像</span><br><span class="hljs-code">docker search [options] 镜像名 -----------去 dockerhub 上查询当前镜像</span><br><span class="hljs-code">-s指定值列出收藏数不少于指定值的镜像</span><br><span class="hljs-code">--no-trunc  显示完整的镜像信息</span><br><span class="hljs-code"># 3. 从仓库下载镜像</span><br><span class="hljs-code">docker pull 镜像名[:TAG|@DIGEST] ----------下载镜像</span><br><span class="hljs-code"># 4. 删除镜像</span><br><span class="hljs-code">docker rmi 镜像名  ----------------------- 删除镜像</span><br><span class="hljs-code">-f强制删除</span><br><span class="hljs-code"># 5. 载入镜像</span><br><span class="hljs-code">docker load -i xxx.tar</span><br></code></pre></td></tr></table></figure><h3 id="contrainer-容器命令">6.3 Contrainer 容器命令</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 1. 运行容器</span><br><span class="hljs-code">docker run 镜像名---------------镜像名新建并启动容器</span><br><span class="hljs-code">--name为容器起一个名字</span><br><span class="hljs-code">-d启动守护容器（在后台启动容器）</span><br><span class="hljs-code">-p映射端口号：原始端口号指定端口号启动</span><br><span class="hljs-code"># 2. 查看运行的容器</span><br><span class="hljs-code">docker ps---------------------列出所有正在运行的容器</span><br><span class="hljs-code">-a正在运行的和历史运行的容器</span><br><span class="hljs-code">-q静默模式，只显示容器编号</span><br><span class="hljs-code"># 3. 停止|关闭|重启容器</span><br><span class="hljs-code">docker start 容器名称或容器ID---------- 开启容器</span><br><span class="hljs-code">docker restart 容器名或容器ID----------- 重启容器</span><br><span class="hljs-code">docker stop 容器名或容器ID----------- 正常停止容器</span><br><span class="hljs-code">docker kill 容器名或容器ID----------- 立即停止容器运行</span><br><span class="hljs-code"># 4. 删除容器</span><br><span class="hljs-code">docker rm 容器名称|容器ID----------- 删除停止的容器</span><br><span class="hljs-code">-f删除正在运行的容器</span><br><span class="hljs-code"># 5. 查看容器内进程</span><br><span class="hljs-code">docker top容器名称|容器ID----------- 查看容器内进程</span><br><span class="hljs-code"># 6. 查看容器内部细节</span><br><span class="hljs-code">docker inspect容器名称|容器ID----------- 查看容器内部细节</span><br><span class="hljs-code"># 7. 查看运行日志</span><br><span class="hljs-code">docker logs [OPTIONS] 容器名称|容器ID----------- 查看容器内进程</span><br><span class="hljs-code">-t加入时间戳</span><br><span class="hljs-code">-f跟随最新的日志打印</span><br><span class="hljs-code">--tail数字显示最后多少条</span><br><span class="hljs-code"># 8. 进入容器</span><br><span class="hljs-code">docker exec -it容器名称|容器ID bash--------- 进入容器bash，与容器交互</span><br><span class="hljs-code">退出容器exit</span><br><span class="hljs-code"># 9. 操作系统与容器的文件传输</span><br><span class="hljs-code">从容器到操作系统：docker cp 容器ID:容器内资源路径 操作系统路径</span><br><span class="hljs-code">从操作系统到容器：docker cp 文件|目录容器ID：容器路径</span><br><span class="hljs-code"># 10. 数据卷(volum)实现与宿主机共享目录</span><br><span class="hljs-code">docker run -v 宿主机的路径|任意别名:/容器内的路径镜像名</span><br><span class="hljs-code">docker run -v 宿主机的路径|任意别名:/容器内的路径:ro镜像名</span><br><span class="hljs-code">ro：镜像只读</span><br><span class="hljs-code">注意：</span><br><span class="hljs-code">1. 如果是宿主机类路径必须是绝对路径，宿主机目录会覆盖容器内目录内容</span><br><span class="hljs-code">2. 如果是别名则会在docker运行容器时自动在宿主机中创建一个目录，并将容器目录文件复制到宿主机中</span><br><span class="hljs-code"># 11. 打包镜像</span><br><span class="hljs-code">docker save 镜像名-o 名称.tar</span><br><span class="hljs-code"># 12. 载入镜像</span><br><span class="hljs-code">docker load -i 名称.tar</span><br><span class="hljs-code"># 13. 容器打包成新的镜像</span><br><span class="hljs-code">docker commit -m &quot;描述信息&quot; -a &quot;作者信息&quot;（容器ID或名称） 打包的镜像的名称：标签</span><br></code></pre></td></tr></table></figure><h2 id="dokcer-中容器之间的网络配置">7. Dokcer 中容器之间的网络配置</h2><blockquote><p>Docker 允许通过外部访问容器或容器互联的方式来提供网络服务</p></blockquote><h3 id="docker-容器与操作系统通信机制">7.1 docker容器与操作系统通信机制</h3><p>当 Docker 启动时，会自动在主机上创建一个 <code>docker0</code>虚拟网桥，实际上是 Linux 的一个bridge，可以理解为一个软件交换机。它会在挂载到它的网口之间进行转发。</p><p>同时，Docker 随机分配一个本地未占用的私有网段（在 <ahref="https://datatracker.ietf.org/doc/html/rfc1918">RFC1918</a>中定义）中的一个地址给<code>docker0</code> 接口。比如典型的 <code>172.17.0.1</code>，掩码为<code>255.255.0.0</code>。此后启动的容器内的网口也会自动分配一个同一网段（<code>172.17.0.0/16</code>）的地址。</p><figure><img src="/img/docker/netDokcer0.PNG" alt="netDocker0" /><figcaption aria-hidden="true">netDocker0</figcaption></figure><p>当创建一个 Docker 容器的时候，同时会创建了一对 <code>veth pair</code>接口（当数据包发送到一个接口时，另外一个接口也可以收到相同的数据包）。这对接口一端在容器内，即<code>eth0</code>；另一端在本地并被挂载到 <code>docker0</code>网桥，名称以 <code>veth</code> 开头（例如<code>vethAQI2QT</code>）。通过这种方式，主机可以跟容器通信，容器之间也可以相互通信。Docker就创建了在主机和所有容器之间一个虚拟共享网络。</p><figure><img src="/img/docker/docker0.png" alt="docker0" /><figcaption aria-hidden="true">docker0</figcaption></figure><h3 id="docker-网络使用">7.2 Docker 网络使用</h3><p>注意：一般在使用 docker 网桥(bridge)实现容器与容器通信时，都是站在一个应用的角度进行容器通信。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 1. 查看 docker 网桥配置</span><br><span class="hljs-code">docker network ls</span><br><span class="hljs-code"># 2. 自定义网桥</span><br><span class="hljs-code">docker network create -d bridge 网桥名称</span><br><span class="hljs-code"># 3. 指定容器网桥</span><br><span class="hljs-code">docker run --network 网桥名称 </span><br><span class="hljs-code">&gt; docker network [OPTION]</span><br><span class="hljs-code">     connect     Connect a container to a network</span><br><span class="hljs-code">     create      Create a network</span><br><span class="hljs-code">     disconnect  Disconnect a container from a network</span><br><span class="hljs-code">     inspect     Display detailed information on one or more networks</span><br><span class="hljs-code">     ls          List networks</span><br><span class="hljs-code">     prune       Remove all unused networks</span><br><span class="hljs-code">     rm          Remove one or more networks</span><br></code></pre></td></tr></table></figure><p>​</p><h2 id="数据卷">8. 数据卷</h2><p><strong>数据卷</strong>是一个可供一个或多个容器使用的特殊目录，它绕过UFS，可以提供很多有用的特性</p><ul><li><em>数据卷</em> 可以在容器之间共享和重用</li><li>对 <em>数据卷</em> 的修改会立马生效</li><li>对 <em>数据卷</em> 的更新，不会影响镜像</li><li><em>数据卷</em> 默认会一直存在，即使容器被删除</li></ul><blockquote><p>注意：<em>数据卷</em> 的使用，类似于 Linux 下对目录或文件进行mount，镜像中的被指定为挂载点的目录中的文件会复制到数据卷中（仅数据卷为空时会复制）。</p></blockquote><p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 1. 自定义数据卷目录</span><br><span class="hljs-code">docker run -v 绝对路径:容器内路径</span><br><span class="hljs-code"># 2. 自动创建数据卷</span><br><span class="hljs-code">docker run -v 卷名：容器内路径</span><br></code></pre></td></tr></table></figure></p><h3 id="docker-操作数据卷命令">docker 操作数据卷命令</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 1. 查看数据卷</span><br><span class="hljs-code">docker volume ls</span><br><span class="hljs-code"># 2. 查看数据卷细节</span><br><span class="hljs-code">docker volume inspect 卷名</span><br><span class="hljs-code">&gt; docker volume [OPTION]</span><br><span class="hljs-code">     create      Create a volume</span><br><span class="hljs-code">     inspect     Display detailed information on one or more volumes</span><br><span class="hljs-code">     ls          List volumes</span><br><span class="hljs-code">     prune       Remove all unused local volumes</span><br><span class="hljs-code">     rm          Remove one or more volumes</span><br></code></pre></td></tr></table></figure><h2 id="dockerfile">9. Dockerfile</h2><h3 id="什么是-dockerfile">什么是 Dockerfile</h3><p>定义：用来帮助我们自己构建一个自定义镜像 Dockerfile 成为镜像构建文件描述文件</p><h3 id="dockerfile-的保留命令">Dockerfile 的保留命令</h3><p>官方说明(https://docs.docker.com/engine/reference/builder/)</p><table><colgroup><col style="width: 18%" /><col style="width: 81%" /></colgroup><thead><tr class="header"><th>保留字</th><th>作用</th></tr></thead><tbody><tr class="odd"><td><strong>FROM</strong></td><td><strong>当前镜像是基于哪个镜像的</strong></td></tr><tr class="even"><td>MAINTAINER</td><td>镜像维护者的姓名和邮箱地址</td></tr><tr class="odd"><td><strong>RUN</strong></td><td><strong>构建镜像时需要运行的指令</strong></td></tr><tr class="even"><td><strong>EXPOSE</strong></td><td><strong>当前容器对外暴露的端口号</strong></td></tr><tr class="odd"><td><strong>WORKDIR</strong></td><td><strong>指定再创建容器后，终端默认登录进来的工作目录，一个落脚点</strong></td></tr><tr class="even"><td><strong>ENV</strong></td><td><strong>用来再构建镜像的过程中设置环境变量</strong></td></tr><tr class="odd"><td><strong>ADD</strong></td><td><strong>将宿主机目录下的文件拷贝进镜像且ADD命令会自动处理URL和解压tar包</strong></td></tr><tr class="even"><td><strong>COPY</strong></td><td><strong>类似于 ADD，拷贝文件和目录到镜像中</strong><br/><strong>将从构建上下文目录中<原路径>的文件/目录复制到新的一层的镜像内的<目标路径>位置</strong></td></tr><tr class="odd"><td><strong>VOLUME</strong></td><td><strong>容器数据卷，用于数据保存和持久化工作</strong></td></tr><tr class="even"><td><strong>CMD</strong></td><td><strong>指定一个容器启动时要运行的命令</strong><br/><strong>Dockerfile 中可以有多个CMD 指令，但只有最后一个生效， CMD会被 docker run 之后的参数替换</strong></td></tr><tr class="odd"><td><strong>ENTRYPOINT</strong></td><td><strong>指定一个容器启动时要运行的命令</strong><br/><strong>ENTRYPOINT 的目的和 CMD一样，都是在指定容器启动程序及其参数</strong></td></tr></tbody></table><h4 id="from-命令">FROM 命令</h4><ul><li><p>基于哪个镜像进行构建新的镜像，在构建时会自动从 docker hub 拉取base 镜像 必须作为 Dockerfile 的一个指令出现</p></li><li><p>语法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">FROM &lt;image&gt;<br>FROM &lt;image&gt;[:&lt;tag&gt;]使用版本<br>FROM &lt;image&gt;[@&lt;digest&gt;]使用摘要<br></code></pre></td></tr></table></figure></li></ul><h4 id="run-命令">RUN 命令</h4><ul><li><p>RUN指令将在当前映像之上的新层中执行任何命令并提交结果。生成的提交映像将用于Dockerfile 中下一步</p></li><li><p>语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">RUN &lt;command&gt;<br>RUN echo hello<br>RUN [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;](exec form)<br>RUN [&quot;/bin/bash&quot;, &quot;-c&quot;, &quot;echo hello&quot;]<br></code></pre></td></tr></table></figure></li></ul><h4 id="expose-命令">EXPOSE 命令</h4><ul><li><p>用来指定构建的镜像在运行为容器时对外暴露的端口</p></li><li><p>语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">EXPOSE 80/tcp如果没有显示指定则默认暴露都是 tcp<br>EXPOSE 80/udp <br></code></pre></td></tr></table></figure></li></ul><h4 id="cmd-命令">CMD 命令</h4><ul><li><p>用来为启动的容器指定执行的命令，在 Dockerfile 中只能有一条 CMD指令。如果列出多个命令，则只有最后一个命令才会生效。</p></li><li><p>注意：<strong>Dockerfile 中只能有一条 CMD指令。如果列出多个命令，则只有最后一个命令才会生效。</strong></p></li><li><p>语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">CMD [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]<br>CMD [&quot;param1&quot;, &quot;param2&quot;]<br>CMD command param1 param2 (shell form)<br></code></pre></td></tr></table></figure></li></ul><h4 id="workdir-命令">WORKDIR 命令</h4><ul><li><p>用来为 Dockerfile 中的任何 RUN、CMD、ENTRYPOINT、COPY 和 ADD指令设置工作目录。如果 WORKDIR 不存在，即使它没有在任何后续 Dockerfile指令中使用，它也将被创建。</p></li><li><p>语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">WORKDIR /path/to/workdir<br><br>WORKDIR /a<br>WORKDIR b<br>WORKDIR c<br></code></pre></td></tr></table></figure></li></ul><h4 id="add-命令">ADD 命令</h4><ul><li><p>用来从 context 上下文复制新文件、目录或远程文件url，并将它们添加到位于指定路径的映像文件系统中</p></li><li><p>语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">ADD hom* /mydir/ 通配符添加多个文件<br>ADD hom?.txt /mydir 通配符添加<br>ADD test.txt relativeDir/ 可以指定相对路径<br>ADD test.txt /absoluteDir/ 绝对路径<br>ADD url<br></code></pre></td></tr></table></figure></li></ul><h4 id="copy-命令">COPY 命令</h4><ul><li><p>用来将 context 目录中指定文件复制到镜像的指定目录中</p></li><li><p>语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">COPY src dest<br>COPY [&quot;&lt;src&gt;&quot;,... &quot;&lt;dest&gt;&quot;]<br></code></pre></td></tr></table></figure></li></ul><h4 id="volume-命令">VOLUME 命令</h4><ul><li><p>用来定义容器运行时可以挂载到宿主机的目录</p></li><li><p>语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">VOLUME [&quot;/data&quot;]<br></code></pre></td></tr></table></figure></li></ul><h4 id="env-命令">ENV 命令</h4><ul><li><p>用来为构建镜像设置环境变量。这个值将会出现在构建阶段中所有的后续指令的环境中。</p></li><li><p>语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">ENV &lt;key&gt; &lt;value&gt; <br>ENV &lt;key&gt; &lt;value&gt; ...<br></code></pre></td></tr></table></figure></li></ul><h4 id="entrypoint-命令">ENTRYPOINT 命令</h4><ul><li><p>用来指定容器启动时执行命令和 CMD 类似</p></li><li><p>语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]<br>ENTRYPOINT command param1 param2<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>note</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/04/24/hello-world/"/>
    <url>/2022/04/24/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your veryfirst post. Check <a href="https://hexo.io/docs/">documentation</a> formore info. If you get any problems when using Hexo, you can find theanswer in <ahref="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> oryou can ask me on <ahref="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="quick-start">Quick Start</h2><h3 id="create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
  
  
  <entry>
    <title>about</title>
    <link href="/"/>
    <url>/</url>
    
    <content type="html"><![CDATA[<p>about</p>]]></content>
    
  </entry>
  
  
  
</search>
