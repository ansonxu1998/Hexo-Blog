

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/avatar1.jpg">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Anson">
  <meta name="keywords" content="">
  
    <meta name="description" content="Docker 是基于Go语言实现的开源容器项目，诞生于2013年初，最初的发起者是dotCloud公司。">
<meta property="og:type" content="article">
<meta property="og:title" content="Docker 基础入门">
<meta property="og:url" content="http://example.com/2022/06/24/Linux/Docker%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/index.html">
<meta property="og:site_name" content="Anson Blog">
<meta property="og:description" content="Docker 是基于Go语言实现的开源容器项目，诞生于2013年初，最初的发起者是dotCloud公司。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-06-24T06:44:00.000Z">
<meta property="article:modified_time" content="2022-06-24T06:50:13.343Z">
<meta property="article:author" content="Anson">
<meta property="article:tag" content="Docker">
<meta name="twitter:card" content="summary_large_image">
  
  
  <title>Docker 基础入门 - Anson Blog</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/arta.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.14","typing":{"enable":true,"typeSpeed":100,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 6.1.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Anson</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="Docker 基础入门">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2022-06-24 14:44" pubdate>
        2022年6月24日 下午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      14k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      113 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Docker 基础入门</h1>
            
            <div class="markdown-body">
              <h2 id="核心概念与安装配置">核心概念与安装配置</h2>
<p>Docker 的三大核心概念：</p>
<ul>
<li>镜像(Image)</li>
<li>容器(Container)</li>
<li>仓库(Repository)</li>
</ul>
<h3 id="核心概念">核心概念</h3>
<ol type="1">
<li>Docker 镜像</li>
</ol>
<p>Docker 镜像可以将其理解为一个只读的模板。它是 docker
容器的基础。用户可以从网络上下载已经配置好的镜像，并直接使用。</p>
<ol start="2" type="1">
<li>Docker 容器</li>
</ol>
<p>Docker
容器类似于一个轻量级的沙箱，用于运行和隔离应用。<font color='geen'>容器是从镜像创建的应用运行实例。</font>可以将其启动、开始、停止和删除。</p>
<p class="note note-primary">
镜像自身是只读的。容器从镜像启动的时候，会在镜像的最上层创建一个可写层
</p>
<ol start="3" type="1">
<li>Docker 仓库</li>
</ol>
<p>Docker 仓库是 Docker 集中存放镜像文件的场所。</p>
<p>Docker 仓库的类型：</p>
<ul>
<li>公开仓库(Public)</li>
<li>私有仓库(Private)</li>
</ul>
<h3 id="docker-的安装">Docker 的安装</h3>
<h4 id="ubuntu-环境下安装-docker">Ubuntu 环境下安装 Docker</h4>
<p>推荐至少使用 <code>14.04 LTS</code> 版本。</p>
<p>为了让 Docker 使用 aufs 存储，推荐安装 <code>linux-image-extra</code>
软件包：</p>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo apt-get install -y linux-image-extra-$(<span class="hljs-built_in">uname</span> -r)</span><br></code></pre></div></td></tr></table></figure>
<p><strong>添加镜像源</strong>：</p>
<p>安装 <code>apt-transport-https</code> 包支持 HTTP 协议的源：</p>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo apt-get install -y apt-transport-https</span><br></code></pre></div></td></tr></table></figure>
<p>添加源的 gpg 密钥：</p>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo apt-key adv --keyserver hkp://p80.pool.sks-keyservers.net:80 --recv-keys</span> <br>    58118E89F3A912897C070ADBF76221572C52609D<br></code></pre></div></td></tr></table></figure>
<p>获取当前操作系统的代号：</p>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">lsb_release -c</span><br>Codename:       trusty<br></code></pre></div></td></tr></table></figure>
<p>接下来就可以添加Docker的官方apt软件源了。通过下面的命令创建
<code>/etc/apt/sources.list.d/docker.list</code>
文件，并写入源的地址内容。非 trusty
版本的系统注意修改为自己对应的代号：</p>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo <span class="hljs-built_in">cat</span> &lt;&lt;<span class="hljs-string">EOF &gt; /etc/apt/sources.list.d/docker.list</span></span><br>deb https://apt.dockerproject.org/repo ubuntu-trusty main<br>EOF<br></code></pre></div></td></tr></table></figure>
<p>更新 apt 软件包缓存：</p>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo apt-get update</span><br></code></pre></div></td></tr></table></figure>
<p><strong>安装 Docker</strong>：</p>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo apt-get install -y docker-engine</span><br></code></pre></div></td></tr></table></figure>
<p>通过脚本自动化安装 Docker：</p>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo curl -sSL https://get.docker.com/ | sh</span><br></code></pre></div></td></tr></table></figure>
<p>启动 docker 服务：</p>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo systemctl start docker</span><br></code></pre></div></td></tr></table></figure>
<h4 id="centos-环境下安装-docker">CentOS 环境下安装 Docker</h4>
<p>添加 yum 软件源：</p>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo <span class="hljs-built_in">tee</span> /etc/yum.repos.d/docker.repo &lt;&lt;-<span class="hljs-string">&#x27;EOF&#x27;</span></span><br>[dockerrepo]<br>name=Docker Repository<br>baseurl=https://yum.dockerproject.org/repo/main/centos/$releasever/<br>enabled=1<br>gpgcheck=1<br>gpgkey=https://yum.dockerproject.org/gpg<br>EOF<br></code></pre></div></td></tr></table></figure>
<p>安装 docker：</p>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo yum update</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo yum install -y docker-engine</span><br></code></pre></div></td></tr></table></figure>
<h4 id="使用脚本安装">使用脚本安装</h4>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">curl -fsSL https://get.docker.com/ | sh</span><br></code></pre></div></td></tr></table></figure>
<p>或者：</p>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">wget -qO- https://get.docker.com/ | sh</span><br></code></pre></div></td></tr></table></figure>
<h3 id="配置-docker-服务">配置 Docker 服务</h3>
<p>将当前用户加入 docker 用户组：</p>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo usermod -aG docker USER_NAME</span><br></code></pre></div></td></tr></table></figure>
<p>Docker 服务的默认配置文件：<code>/etc/default/docker</code></p>
<p>可以通过修改 <code>DOCKER_OPTS</code> 来修改服务启动的参数。</p>
<p>Docker 服务的管理脚本：<code>/etc/init.d/docker</code></p>
<p>查看版本信息：</p>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker verison</span><br>Client: Docker Engine - Community<br> Version:           20.10.17<br> API version:       1.41<br> Go version:        go1.17.11<br> Git commit:        100c701<br> Built:             Mon Jun  6 23:02:56 2022<br> OS/Arch:           linux/amd64<br> Context:           default<br> Experimental:      true<br><br>Server: Docker Engine - Community<br> Engine:<br>  Version:          20.10.17<br>  API version:      1.41 (minimum version 1.12)<br>  Go version:       go1.17.11<br>  Git commit:       a89b842<br>  Built:            Mon Jun  6 23:01:02 2022<br>  OS/Arch:          linux/amd64<br>  Experimental:     false<br> containerd:<br>  Version:          1.6.6<br>  GitCommit:        10c12954828e7c7c9b6e0ea9b0c02b01407d3ae1<br> runc:<br>  Version:          1.1.2<br>  GitCommit:        v1.1.2-0-ga916309<br> docker-init:<br>  Version:          0.19.0<br>  GitCommit:        de40ad0<br><br></code></pre></div></td></tr></table></figure>
<h2 id="docker-镜像">Docker 镜像</h2>
<p>Docker 运行容器前需要本地存在对应的镜像，若本地无镜像，Docker
将从默认的镜像仓库下载，用户可以通过配置，使用自定义的镜像仓库。</p>
<h3 id="镜像获取">镜像获取</h3>
<p>使用 <code>docker pull</code> 命令从 <code>Docker Hub</code>
镜像仓库下载镜像。</p>
<p>命令格式：<code>docker pull Image-Name[: TAG]</code> (TAG
通常是版本信息)</p>
<p>没有指定 TAG，默认为 <code>latest</code></p>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker pull ubuntu</span><br>Using default tag: latest<br>latest: Pulling from library/ubuntu<br>405f018f9d1d: Pull complete<br>Digest:sha256:b6b83d3c331794420340093eb706a6f152d9c1fa51b262d9bf34594887c2c7ac<br>Status: Downloaded newer image for ubuntu:latest<br>docker.io/library/ubuntu:latest<br></code></pre></div></td></tr></table></figure>
<p>镜像文件一般由若干层(layer)组成，每个层都有一个唯一的 ID
(如：<code>405f018f9d1d</code>)。使用 <code>docker pull</code>
命令下载时会获取并输出镜像的各层信息。当不同的镜像包括相同的层时，本地仅存储层的一份内容，减小了需要的存储空间。</p>
<p>镜像名称之前应该加上仓库地址前缀，使用官方仓库时默认省略，即：<code>docker pull ubuntu：14.04</code>
相当于
<code>docker pull registry.hub.docker.com/ubuntu：14.04</code>。</p>
<p><font color='pink'>若从非官方仓库下载镜像，则必须指定仓库地址前缀。</font></p>
<p><code>pull</code> 子命令支持的选项：</p>
<p><code>-a,--all-tags=true|false</code> -
是由获取仓库中所有镜像，默认为 否。</p>
<h3 id="查看镜像信息">查看镜像信息</h3>
<h4 id="列出所有镜像">列出所有镜像</h4>
<p>命令：<code>docker images</code></p>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker images</span><br>REPOSITORY   TAG       IMAGE ID       CREATED       SIZE<br>ubuntu       latest    27941809078c   2 weeks ago   77.8MB<br></code></pre></div></td></tr></table></figure>
<ul>
<li>REPOSITORY - 来自于那个仓库</li>
<li>TAG - 版本信息</li>
<li>IMAGE ID - 唯一标识镜像</li>
<li>CREATED - 镜像的最后更新时间</li>
<li>SIZE - 镜像大小</li>
</ul>
<p><code>images</code> 子命令主要支持的选项：</p>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">-a, --all=true|false: 列出所有镜像（包含临时文件），默认为 否；<br>--digests=true|false: 列出镜像的数字摘要值，默认为 否；<br>-f, --filter=[]: 过滤列出镜像；<br>--format=&quot;TEMPLATE&quot;: 控制输出格式，.ID代表ID信息，.Repository代币哦仓库信息；<br>--no-trunc=true|false: 对输出结果中太长的部分是否进行截断，默认为 是；<br>-q, --quiet=true|false: 仅输出ID信息，默认为　否<br></code></pre></div></td></tr></table></figure>
<p>使用 <code>man docker-images</code> 查看更多命令选项。</p>
<h4 id="添加镜像标签">添加镜像标签</h4>
<p>使用 <code>tag</code>
命令来为一个本地镜像添加新的标签，以方便使用：</p>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker tag ubuntu:latest myubuntu:latest</span><br></code></pre></div></td></tr></table></figure>
<h4 id="查看详细信息">查看详细信息</h4>
<p>使用 <code>inspect</code> 命令获取镜像的详细信息：</p>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker inspect ubuntu:14.04</span><br></code></pre></div></td></tr></table></figure>
<p>返回的消息为 JSON 格式的消息，如果只想获取其中一项，使用
<code>-f</code> 参数来指定：</p>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker inspect -f &#123;&#123;<span class="hljs-string">&quot;.Architecture&quot;</span>&#125;&#125;</span><br></code></pre></div></td></tr></table></figure>
<h4 id="查看镜像的历史">查看镜像的历史</h4>
<p>使用 <code>history</code> 命令来查看镜像的历史：</p>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker <span class="hljs-built_in">history</span> ubuntu:14.04</span><br></code></pre></div></td></tr></table></figure>
<p>可以查看各个层的内容具体的创建信息。</p>
<h3 id="搜索镜像">搜索镜像</h3>
<p>使用 <code>docker search</code>
命令来搜索远程仓库中的镜像，默认使用官方仓库。</p>
<p>支持的参数有 ：</p>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">--no-trunc=true|false: 输出信息不截断显示，默认为 否；<br>-f, --filter=[]: 基于条件过滤输出<br>--limit=25: 搜索结果的最大数量<br></code></pre></div></td></tr></table></figure>
<p>搜索所有自动创建的评价为1+的带nginx关键字的镜像：</p>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker search --<span class="hljs-built_in">limit</span>=10 nginx</span><br></code></pre></div></td></tr></table></figure>
<h3 id="删除镜像">删除镜像</h3>
<p>使用 <code>docker rmi</code> 命令来删除镜像：</p>
<h4 id="使用标签删除">使用标签删除</h4>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker rmi ubuntu:latest</span><br></code></pre></div></td></tr></table></figure>
<div class="note note-success">
            <p>当一个镜像拥有多个标签时，删除某一个标签并不会影响原来的镜像</p>
          </div>
<h4 id="使用镜像-id-删除">使用镜像 ID 删除</h4>
<p>当使用 ID 进行删除时，所有的镜像标签包括原始镜像本身都会被删除。</p>
<div class="note note-success">
            <p>若镜像创建的容器存在时，则该镜像文件将无法被删除。</p>
          </div>
<p>如果需要强制删除，可以使用 <code>-f</code> 参数。</p>
<h3 id="创建镜像">创建镜像</h3>
<p>有三种方式创建镜像：</p>
<ul>
<li>基于已有镜像的容器创建</li>
<li>基于本地模板导入</li>
<li>基于 Dockerfile 创建</li>
</ul>
<h4 id="基于已有镜像的容器创建">基于已有镜像的容器创建</h4>
<p>使用 <code>docker commit</code> 命令来创建。</p>
<p>主要选项包括：</p>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">-a, --author=&quot;&quot;: 作者信息<br>-c, --change=[]: 提交的执行 Dockerfile 指令<br>-m, --message=&quot;&quot;: 提交信息<br>-p, --pause=true: 提交时暂停容器的运行<br></code></pre></div></td></tr></table></figure>
<p>提交时使用容器的 ID 或名称来指定容器：</p>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker commit -m <span class="hljs-string">&quot;Added a new file&quot;</span> -a <span class="hljs-string">&quot;Anson&quot;</span> a925cb40b3f0 <span class="hljs-built_in">test</span>:0.1</span><br></code></pre></div></td></tr></table></figure>
<h4 id="基于本地模板导入">基于本地模板导入</h4>
<p>使用 <code>docker inport</code> 命令来创建。</p>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cat</span> ubuntu-14.04-x86_64-minimal.tar.gz | docker import - ubuntu:14.04</span><br></code></pre></div></td></tr></table></figure>
<h3 id="存出和载入镜像">存出和载入镜像</h3>
<h4 id="存出镜像">存出镜像</h4>
<p>使用 <code>docker save</code> 来存出镜像：</p>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker save -o ubuntu_14.04.tar ubuntu:14.04</span><br></code></pre></div></td></tr></table></figure>
<h4 id="载入镜像">载入镜像</h4>
<p>使用 <code>docker load</code> 来载入镜像：</p>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker load --input ubuntu_14.04.tar</span><br></code></pre></div></td></tr></table></figure>
<p>或者：</p>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker load &lt; ubuntu_14.04.tar</span><br></code></pre></div></td></tr></table></figure>
<h3 id="上传镜像">上传镜像</h3>
<p>使用 <code>docker push</code> 命令来上传镜像到仓库，默认为官方 Docker
Hub仓库：</p>
<p><code>docker push NAME[:TAG] | [REGISTRY_HOST[:REGISTRY_PORT]/]NAME[:TAG]</code></p>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker tag <span class="hljs-built_in">test</span>:latest user/test:latest</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker push user/test:latest</span><br></code></pre></div></td></tr></table></figure>
<h2 id="docker-容器">Docker 容器</h2>
<p>容器是镜像运行的实例。镜像是静态的只读文件，而容器带有运行时需要的可写文件层。</p>
<h3 id="创建容器">创建容器</h3>
<h4 id="新建容器">新建容器</h4>
<p>使用 <code>docker create</code> 命令来创建一个容器：</p>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker create -it ubuntu:latest</span><br></code></pre></div></td></tr></table></figure>
<p>此时容器处于停止状态，可以使用 <code>docker start</code>
命令来启动它。</p>
<h4 id="启动容器">启动容器</h4>
<p>使用 <code>docker start</code> 命令来启动一个已经创建的容器：</p>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker start af</span><br>af<br></code></pre></div></td></tr></table></figure>
<h4 id="新建并启动容器">新建并启动容器</h4>
<p>使用 <code>docker run</code> 命令来创建并执行。</p>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker run ubuntu /bin/echo <span class="hljs-string">&#x27;Hello world&#x27;</span></span><br>Hello world<br></code></pre></div></td></tr></table></figure>
<p>启动一个 bash 终端：</p>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker run -it ubuntu:14.04 /bin/bash</span><br></code></pre></div></td></tr></table></figure>
<ul>
<li><code>-t</code> - 让 Docker
分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上</li>
<li><code>-i</code> - 让容器的标准输入保持打开</li>
</ul>
<p><code>Ctrl + d</code> 或 输入 exit 退出容器。</p>
<h4 id="守护态运行">守护态运行</h4>
<p>通过添加 <code>-d</code> 参数实现：</p>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">docker run -d ubuntu  /bin/sh -c &quot;while true; do echo hello world; sleep 1; done&quot;<br></code></pre></div></td></tr></table></figure>
<h3 id="终止容器">终止容器</h3>
<p>使用 <code>docker stop</code> 命令来终止一个运行中的容器。</p>
<p><code>docker stop[-t|--time[=10]][CONTAINER...]</code></p>
<p>首先向容器发送 SIGTERM 信号，等待一段超时时间（默认为10秒）后，再发送
SIGKILL信号来终止容器：</p>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker stop ce5</span><br>ce5<br></code></pre></div></td></tr></table></figure>
<p><font color='red'><code>docker kill</code> 命令会直接发送 SIGKILL
信号来强行终止容器。</font></p>
<p>重新启动一个容器使用 <code>docker restart</code> 命令。</p>
<h3 id="进入容器">进入容器</h3>
<p>进入容器的方法：</p>
<ul>
<li><code>attach</code></li>
<li><code>exec</code></li>
<li><code>nsenter</code></li>
<li>...</li>
</ul>
<h4 id="attach-命令"><code>attach</code> 命令</h4>
<p><code>docker attach [--detach-keys[=[]]] [--no-stdin] [--sig-proxy[=true]] CONTAINER</code></p>
<p>主要选项：</p>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">--detach-keys=&quot;&quot;: 重写用于退出容器的键序列<br>--no-stdin[=false]: 是否关闭标准输入<br>--sig-proxy[=true]: 代理进程接收到的所有信号<br><br></code></pre></div></td></tr></table></figure>
<div class="note note-success">
            <p>当多个窗口同时使用 attach命令连接到同一个容器时，所有的窗口都会同步显示。当某个窗口阻塞时，其他窗口也无法执行操作了。</p>
          </div>
<h4 id="exec-命令"><code>exec</code> 命令</h4>
<p>主要参数：</p>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">-i, --interactive[=false]: 使用标准输入接受用户命令<br>--privileged[=false]: 赋予命令拓展权限<br>-t, --tty[=false]: 分配 pseudo-TTY<br>-u, --user=&quot;&quot;: 用户名或 UID (format:[:])<br></code></pre></div></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker <span class="hljs-built_in">exec</span> -it 55c0389b9d7c /bin/bash</span><br></code></pre></div></td></tr></table></figure>
<h4 id="nsenter-工具">nsenter 工具</h4>
<ol type="1">
<li><p>找到容器进程的 PID，命令如下：</p>
<p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">PID=$(docker inspect --format &quot;&#123;&#123;.State.Pid&#125;&#125;&quot; &lt;container&gt;)<br></code></pre></div></td></tr></table></figure></p></li>
<li><p>通过 PID 连接到容器</p>
<p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">nsenter --target <span class="hljs-variable">$PID</span> --mount --uts --ipc --net --pid</span><br></code></pre></div></td></tr></table></figure></p></li>
</ol>
<p>例子：</p>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker run -idt ubuntu</span><br>243c32535da7d142fb0e6df616a3c3ada0b8ab417937c853a9e1c251f499f550<br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker ps</span><br>CONTAINER ID   IMAGE   COMMAND   CREATED  STATUS   PORTS  NAMES<br>243c32535da7  ubuntu:latest   &quot;/bin/bash&quot;  18 seconds ago  Up 17 seconds <br>    nostalgic_hypatia<br><span class="hljs-meta prompt_">$ </span><span class="language-bash">PID=$(docker-pid 243c32535da7)</span><br>10981<br><span class="hljs-meta prompt_">$ </span><span class="language-bash">nsenter --target 10981 --mount --uts --ipc --net --pid</span><br>root@243c32535da7:/#<br></code></pre></div></td></tr></table></figure>
<h3 id="删除容器">删除容器</h3>
<p>使用 <code>docker rm</code> 命令来删除容器。</p>
<p>主要参数：</p>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">-f, --force[=false]: 强制删除正在运行的容器<br>-l,	--link[=false]: 删除指定的链接，但保留容器<br>-v, --volumes[=false]: 删除容器挂载的数据卷<br></code></pre></div></td></tr></table></figure>
<h3 id="导入和导出容器">导入和导出容器</h3>
<p>在需要将容器从一个系统迁移到另一个系统的情况下，可以使用 Docker
的导入和导出功能。</p>
<h4 id="导出容器">导出容器</h4>
<p>使用 <code>docker export</code> 命令来导出容器：</p>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker <span class="hljs-built_in">export</span> -o test_for_run.tar ce5</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker <span class="hljs-built_in">export</span> e81 &gt; test_for_stop.tar</span><br></code></pre></div></td></tr></table></figure>
<h4 id="导入容器">导入容器</h4>
<p>使用 <code>docker import</code> 命令来导入容器：</p>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker import test_for_run.tar - <span class="hljs-built_in">test</span>/ubuntu:v1.0</span><br></code></pre></div></td></tr></table></figure>
<h2 id="访问-docker-仓库">访问 Docker 仓库</h2>
<p>仓库（Repository）是集中存放镜像的地方，分公共仓库和私有仓库。</p>
<h3 id="docker-hub公共镜像市场">Docker Hub公共镜像市场</h3>
<p>Docker官方维护了一个公共镜像仓库 https://hub.docker.com</p>
<h3 id="时速云镜像市场">时速云镜像市场</h3>
<p>访问地址 https://hub.tenxcloud.com</p>
<h3 id="搭建本地私有仓库">搭建本地私有仓库</h3>
<h4 id="使用-registry-镜像创建私有仓库">使用 registry
镜像创建私有仓库</h4>
<p>使用 <code>registry</code> 镜像来简单搭建一套本地私有仓库环境：</p>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker run -d -p 5000:5000 registry</span><br></code></pre></div></td></tr></table></figure>
<p>默认情况下，会将仓库创建在容器的 <code>/tmp/registry</code>
目录下。使用参数 <code>-v</code> 将镜像文件存放在本地的指定路径。</p>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker run -d -p 5000:5000 -v /opt/data/registry:/tmp/registry registry</span><br><br></code></pre></div></td></tr></table></figure>
<h4 id="管理私有仓库">管理私有仓库</h4>
<p>使用 <code>docker tag</code> 命令将这个镜像标记为
10.0.2.2：5000/test</p>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker tag ubuntu:14.04 10.0.2.2:5000/test</span><br></code></pre></div></td></tr></table></figure>
<p>使用 <code>docker push</code> 上传标记的镜像：</p>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker push 10.0.2.2:5000/test</span><br></code></pre></div></td></tr></table></figure>
<h2 id="docker-数据管理">Docker 数据管理</h2>
<p>生产环境中使用 Docker
的过程中，往往需要对数据进行持久化，或者需要在多个容器之间进行数据共享，这必然涉及容器的数据管理操作。</p>
<p>容器中管理数据主要有两种方式：</p>
<ul>
<li>数据卷(Data Volumes)：容器内数据直接映射到本地主机环境；</li>
<li>数据卷容器(Data Volume Containers)：使用特定容器维护数据卷。</li>
</ul>
<h3 id="数据卷">数据卷</h3>
<p>数据卷的特性：</p>
<ul>
<li>数据卷可以在容器之间共享和重用，容器间传递数据将变得高效方便；</li>
<li>对数据卷内数据的修改会立马生效，无论是容器内操作还是本地操作；</li>
<li>对数据卷的更新不会影响镜像，解耦了应用和数据；</li>
<li>卷会一直存在，直到没有容器使用，可以安全地卸载它。</li>
</ul>
<h4 id="在容器内创建一个数据卷">在容器内创建一个数据卷</h4>
<p>在 <code>docker run</code> 命令下，使用参数 <code>-v</code>
在容器内创建一个数据卷。重复使用可创建多个。</p>
<p>例：</p>
<p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker run -d -P --name web -v /webapp training/webapp python app.py</span><br></code></pre></div></td></tr></table></figure></p>
<h4 id="挂载一个主机目录作为数据卷">挂载一个主机目录作为数据卷</h4>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker run -d -P --name web -v /src/webapp:/opt/webapp training/webapp python app.py</span><br></code></pre></div></td></tr></table></figure>
<p>加载主机的 <code>/src/webapp</code> 目录到容器的
<code>/opt/webapp</code> 目录</p>
<p>注：本地目录的路径必须是绝对路径，如果目录不存在，Docker会自动创建。</p>
<p>Docker 挂载数据卷的默认权限是读写（rw），用户也可以通过 ro
指定为只读：</p>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker run -d -P --name web -v /src/webapp:/opt/webapp:ro</span><br>training/webapp python app.py<br></code></pre></div></td></tr></table></figure>
<h4
id="挂载一个本地主机文件作为数据卷">挂载一个本地主机文件作为数据卷</h4>
<p><code>-v</code>
也可以从主机挂载单个文件到容器中作为数据卷（不推荐）。</p>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker run --<span class="hljs-built_in">rm</span> -it -v ~/.bash_history:/.bash_history ubuntu /bin/bash</span><br></code></pre></div></td></tr></table></figure>
<h3 id="数据卷容器">数据卷容器</h3>
<p>如果用户需要在多个容器之间共享一些持续更新的数据，最简单的方式是使用数据卷容器。数据卷容器也是一个容器，但是它的目的是专门用来提供数据卷供其他容器挂载。</p>
<ol type="1">
<li><p>创建一个数据卷容器 dbdata，并在其中创建一个数据卷挂载到
/dbdata:</p>
<p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker run -it -v /dbdata --name dbdata ubuntu</span><br>root@3ed94f279b6f:/#<br></code></pre></div></td></tr></table></figure></p></li>
<li><p>然后，可以在其他容器中使用 <code>--volumes-from</code> 来挂载
dbdata 容器中的数据卷，例如创建 db1 和 db2
两个容器，并从dbdata容器挂载数据卷：</p>
<p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker run -it --volumes-from dbdata --name db1 ubuntu</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker run -it --volumes-from dbdata --name db2 ubuntu</span><br></code></pre></div></td></tr></table></figure></p></li>
</ol>
<div class="note note-success">
            <p>使用 <code>--volumes-from</code>参数所挂载数据卷的容器自身并不需要保持在运行状态。</p><p>如果删除了挂载的容器（包括dbdata、db1和db2），数据卷并不会被自动删除。如果要删除一个数据卷，必须在删除最后一个还挂载着它的容器时显式使用<code>docker rm-v</code> 命令来指定同时删除关联的容器。</p>
          </div>
<h3 id="利用数据卷容器来迁移数据">利用数据卷容器来迁移数据</h3>
<ol type="1">
<li>备份</li>
</ol>
<p>备份 dbdata 数据卷容器内的数据卷：</p>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker run --volumes-from dbdata -v $(<span class="hljs-built_in">pwd</span>):/backup --name worker ubuntu tar cvf /backup/backup.tar /dbdata</span><br></code></pre></div></td></tr></table></figure>
<ul>
<li>镜像：ubuntu</li>
<li>容器：worker</li>
<li><code>-v $(pwd):/backup</code>：挂载本地的当前目录到 worker 容器的
<code>/backup</code> 目录</li>
<li><code>--volumes-from dbdata</code>：让 worker 容器挂载 dbdata
容器的数据卷</li>
<li><code>tar cvf/backup/backup.tar /dbdata</code>：将
<code>/dbdata</code> 下内容备份为容器内的
<code>/backup/backup.tar</code></li>
</ul>
<ol start="2" type="1">
<li>恢复</li>
</ol>
<p>将数据恢复到一个容器：</p>
<p>首先创建一个带有数据卷的容器 dbdata2：</p>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker run -v /dbdata --name dbdata2 ubuntu /bin/bash</span><br></code></pre></div></td></tr></table></figure>
<p>然后创建另一个新的容器，挂载dbdata2的容器，并使用untar解压备份文件到所挂载的容器卷中：</p>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker run --volumes-from dbdata2 -v $(<span class="hljs-built_in">pwd</span>):/backup busybox tar xvf /backup/backup.tar</span><br></code></pre></div></td></tr></table></figure>
<h2 id="端口映射与容器互联">端口映射与容器互联</h2>
<h3 id="端口映射实现访问容器">端口映射实现访问容器</h3>
<ol type="1">
<li>从外部访问容器应用</li>
</ol>
<p>在启动容器的时候，如果不指定对应的参数，在容器外部是无法通过网络来访问容器内的网络应用和服务的。</p>
<p>当容器中运行一些网络应用，要让外部访问这些应用时，可以通过
<code>-P</code> 或 <code>-p</code> 参数来指定端口映射。当使用
<code>-P</code> 参数时，Docker会随机映射一个 49000~49900
的端口到内部容器开放的网络端口：</p>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">docker run -d -P training/webapp python app.py<br></code></pre></div></td></tr></table></figure>
<p>可以使用 <code>docker logs</code> 命令来查看应用的信息：</p>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker logs -f nostalgic_morse</span><br></code></pre></div></td></tr></table></figure>
<p><code>-p</code>可以指定要映射的端口，并且，在一个指定端口上只可以绑定一个容器。支持的格式有
<code>IP：HostPort：ContainerPort</code>、
<code>IP：：ContainerPort</code>、
<code>HostPort：ContainerPort</code>。</p>
<ol start="2" type="1">
<li>映射所有接口地址</li>
</ol>
<p>使用 <code>HostPort：ContainerPort</code> 格式将本地的 5000
端口映射到容器的 5000 端口，可以执行：</p>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker run -d -p 5000:5000 training/webapp python app.py</span><br></code></pre></div></td></tr></table></figure>
<p>多次使用 <code>-p</code> 参数可以绑定多个端口。</p>
<ol start="3" type="1">
<li>映射到指定地址的指定端口</li>
</ol>
<p>可以使用 <code>IP：HostPort：ContainerPort</code>
格式指定映射使用一个特定地址，比如localhost 地址 127.0.0.1：</p>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker run -d -p 127.0.0.1:5000:5000 training/webapp python app.py</span><br></code></pre></div></td></tr></table></figure>
<ol start="4" type="1">
<li>映射到指定地址的任意端口</li>
</ol>
<p>使用 <code>IP：：ContainerPort</code> 绑定 localhost
的任意端口到容器的 5000端 口，本地主机会自动分配一个端口：</p>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker run -d -p 127.0.0.1::5000 training/webapp python app.py</span><br></code></pre></div></td></tr></table></figure>
<p>还可以使用 upd 标记来指定 UDP 端口：</p>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker run -d -p 127.0.0.1:5000:5000/udp training/webapp python app.py</span><br></code></pre></div></td></tr></table></figure>
<ol start="5" type="1">
<li>查看映射端口配置</li>
</ol>
<p>使用 <code>docker port</code>
命令来查看当前映射的端口配置，也可以查看绑定的地址：</p>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker port nostalgic_morse 5000</span><br>127.0.0.1:49155<br></code></pre></div></td></tr></table></figure>
<h3 id="互联机制实现便捷互访">互联机制实现便捷互访</h3>
<p>容器的互联（linking）是一种让多个容器中应用进行快速交互的方式。它会在源和接收容器之间创建连接关系，接收容器可以通过容器名快速访问到源容器，而不用指定具体的
IP 地址。</p>
<ol type="1">
<li>自定义容器命名</li>
</ol>
<p>使用 <code>--name</code> 参数可以为容器自定义命名：</p>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker run -d -P --name web training/webapp python app.py</span><br></code></pre></div></td></tr></table></figure>
<div class="note note-success">
            <p>容器的名称是唯一的。</p>
          </div>
<ol start="2" type="1">
<li>容器互联</li>
</ol>
<p>使用 <code>--link</code> 参数可以让容器之间安全地进行交互。</p>
<p>创建一个新的数据库容器：</p>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker run -d --name db training/postgres</span><br></code></pre></div></td></tr></table></figure>
<p>创建一个新的 web 容器，并将它连接到 db 容器：</p>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker run -d -P --name web --<span class="hljs-built_in">link</span> db:db training/webapp python app.py</span><br></code></pre></div></td></tr></table></figure>
<p><code>--link</code> 参数的格式为
<code>--link name: alias</code>，其中 name 是要连接的容器名称，alias
是这个连接的别名。</p>
<p>web 容器连接到 db 容器，这允许web容器访问db容器的信息。</p>
<p>Docker通过两种方式为容器公开连接信息：</p>
<ul>
<li>更新环境变量</li>
<li>更新 <code>/etc/hosts</code> 文件</li>
</ul>
<h2 id="使用-dockerfile-创建镜像">使用 Dockerfile 创建镜像</h2>
<p>Dockerfile 是一个文本格式的配置文件，用户可以使用 Dockerfile
来快速创建自定义的镜像。</p>
<h3 id="基本结构">基本结构</h3>
<p>Dockerfile 由一行行命令语句组成，并且支持以 <code>#</code>
开头的注释行。</p>
<p>一般而言，Dockerfile分为四部分：</p>
<ul>
<li>基础镜像信息</li>
<li>维护者信息</li>
<li>镜像操作指令</li>
<li>容器启动时执行指令</li>
</ul>
<h3 id="指令说明">指令说明</h3>
<p>指令的一般格式为 <code>INSTRUCTION arguments</code></p>
<table>
<colgroup>
<col style="width: 15%" />
<col style="width: 84%" />
</colgroup>
<thead>
<tr class="header">
<th>指令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>FROM</td>
<td>指定所创建镜像的基础镜像</td>
</tr>
<tr class="even">
<td>MAINTAINER</td>
<td>指定维护者信息</td>
</tr>
<tr class="odd">
<td>RUN</td>
<td>运行命令</td>
</tr>
<tr class="even">
<td>CMD</td>
<td>指定启动容器时默认执行的命令</td>
</tr>
<tr class="odd">
<td>LABEL</td>
<td>指定生成镜像的元数据标签信息</td>
</tr>
<tr class="even">
<td>EXPOSE</td>
<td>声明镜像内服务所监听的端口</td>
</tr>
<tr class="odd">
<td>ENV</td>
<td>指定环境变量</td>
</tr>
<tr class="even">
<td>ADD</td>
<td>复制指定的 <src> 路径下的内容到容器的 <dest> 路径下，<src> 可以为
URL；如果为 tar 文件，会自动解压到 <dest> 路径下</td>
</tr>
<tr class="odd">
<td>CPOY</td>
<td>复制本地主机的 <src> 路径下的内容到镜像中的 <dest>
路径下；一般情况下推荐使用 COPY，而不是 ADD</td>
</tr>
<tr class="even">
<td>ENTERPOINT</td>
<td>指定镜像的默认入口</td>
</tr>
<tr class="odd">
<td>VOLUME</td>
<td>创建数据卷挂载点</td>
</tr>
<tr class="even">
<td>USER</td>
<td>指定运行容器时的用户名或 UID</td>
</tr>
<tr class="odd">
<td>WORKDIR</td>
<td>配置工作目录</td>
</tr>
<tr class="even">
<td>ARG</td>
<td>指定镜像使用的参数</td>
</tr>
<tr class="odd">
<td>ONBUILD</td>
<td>配置当所创建的镜像为其他镜像的基础镜像时，所执行的创建操作指令</td>
</tr>
<tr class="even">
<td>STOPSIGNAL</td>
<td>容器退出的信号值</td>
</tr>
<tr class="odd">
<td>HEALTHCHECK</td>
<td>如何进行健康检查</td>
</tr>
<tr class="even">
<td>SHELL</td>
<td>指定使用 shell 时的默认 shell 类型</td>
</tr>
</tbody>
</table>
<h4 id="from">FROM</h4>
<p>指定所创建镜像的基础镜像，如果本地不存在，则默认会去 Docker Hub
下载指定镜像。</p>
<p>格式：<code>FROM &lt;image&gt;</code> or
<code>FROM &lt;imgae&gt;: &lt;tag&gt;</code> or
<code>FROM &lt;image&gt;@&lt;digest&gt;</code></p>
<p><font color='pink'> 任何 Dockerfile 中的第一条指令必须为 FROM
指令。并且，如果在同一个Dockerfile中创建多个镜像，可以使用多个FROM指令（每个镜像一次）。</font></p>
<h4 id="maintainer">MAINTAINER</h4>
<p>指定维护者信息。</p>
<p>格式：<code>MAINTAINER &lt;name&gt;</code></p>
<h4 id="run">RUN</h4>
<p>运行指定命令。</p>
<p>格式：<code>RUN &lt;command&gt;</code> or
<code>RUN ["executable", "param1", "param2"]</code></p>
<p>注：必须使用双引号</p>
<p>前者默认将在 shell 终端中运行命令，即/bin/sh-c；后者则使用 exec
执行，不会启动shell环境。</p>
<h4 id="cmd">CMD</h4>
<p>指定启动容器时默认执行的命令。</p>
<p>格式：</p>
<ul>
<li><code>CMD ["executable", "param1", "param2"]</code> 使用 exec
执行</li>
<li><code>CMD command param1 param2</code> 在 <code>/bin/sh</code>
中执行</li>
<li><code>CMD ["param1", "param2"]</code> 提供给 ENTERPOINT
的默认参数</li>
</ul>
<p><font color='pink'>每个Dockerfile只能有一条 CMD
命令。如果指定了多条命令，只有最后一条会被执行。</font></p>
<h4 id="label">LABEL</h4>
<p>用来指定生成镜像的元数据标签信息。</p>
<p>格式：<code>LABEL &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; ...</code></p>
<h4 id="expose">EXPOSE</h4>
<p>声明镜像内服务所监听的端口。</p>
<p>格式：<code>EXPOSE &lt;port&gt; [&lt;port&gt; ...]</code></p>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">EXPOSE 22 80 8443<br></code></pre></div></td></tr></table></figure>
<p><font color='pink'>注意，该指令只是起到声明作用，并不会自动完成端口映射。</font></p>
<h4 id="env">ENV</h4>
<p>指定环境变量，在镜像生成过程中会被后续 RUN
指令使用，在镜像启动的容器中也会存在。</p>
<p>格式：<code>ENV &lt;key&gt;&lt;value&gt;</code> or
<code>ENV &lt;key&gt;=value</code></p>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">ENV PG_MAJOR 9.3<br>ENV PG_VERSION 9.3.4<br>RUN curl -SL http://example.com/postgres-$PG_VERSION.tar.xz | tar -xJC /usr/src/<br>    postgress &amp;&amp; …<br><br><br>ENV PATH /usr/local/postgres-$PG_MAJOR/bin:$PATH<br></code></pre></div></td></tr></table></figure>
<h4 id="add">ADD</h4>
<p>该命令将复制指定的<src>路径下的内容到容器中的<dest>路径下。</p>
<p>格式：<code>ADD &lt;src&gt; &lt;dest&gt;</code></p>
<p><font color='geen'>路径支持正则格式。</font></p>
<h4 id="copy">COPY</h4>
<p>格式：<code>COPY &lt;src&gt; &lt;dest&gt;</code></p>
<h4 id="entrypoint">ENTRYPOINT</h4>
<p>指定镜像的默认入口命令，该入口命令会在启动容器时作为根命令执行，所有传入值作为该命令的参数。</p>
<p>格式：</p>
<ul>
<li><code>ENTRYPOINT ["executable", "param1", "param2"]</code> exec
调用执行</li>
<li><code>ENTRYPOINT command param1, param2</code> shell 中执行</li>
</ul>
<p><font color='pink'>每个Dockerfile中只能有一个ENTRYPOINT，当指定多个时，只有最后一个有效。</font></p>
<h4 id="volume">VOLUME</h4>
<p>创建一个数据卷挂载点。</p>
<p>格式：<code>VOLUME ["/data"]</code></p>
<h4 id="user">USER</h4>
<p>指定运行容器时的用户名或UID，后续的RUN等指令也会使用指定的用户身份。</p>
<p>格式：<code>USER daemon</code></p>
<h4 id="workdir">WORKDIR</h4>
<p>为后续的 RUN、CMD 和 ENTRYPOINT 指令配置工作目录。</p>
<p>格式：<code>WORKDIR /path/to/workdir</code></p>
<p>可以使用多个 WORKDIR
指令，后续命令如果参数是相对路径，则会基于之前命令指定的路径。</p>
<h4 id="arg">ARG</h4>
<p>指定一些镜像内使用的参数，这些参数在执行 <code>docker build</code>
命令时才以 <code>--build-arg&lt;varname&gt;=&lt;value&gt;</code>
格式传入。</p>
<p>格式：<code>ARG &lt;name&gt;[=&lt;default value&gt;]</code></p>
<h4 id="onbuild">ONBUILD</h4>
<p>配置当所创建的镜像作为其他镜像的基础镜像时，所执行的创建操作指令。</p>
<p>格式：<code>ONBUILD[INSTRUCTION]</code></p>
<h4 id="stopsignal">STOPSIGNAL</h4>
<p>指定所创建镜像启动的容器接收退出的信号值。例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">STOPSIGNAL signal<br></code></pre></div></td></tr></table></figure>
<h4 id="healthcheck">HEALTHCHECK</h4>
<p>配置所启动容器如何进行健康检查（如何判断健康与否），自Docker
1.12开始支持。</p>
<p>格式：</p>
<ul>
<li><code>HEALTHCHECK [OPTIONS] CMD command</code>：根据所执行命令返回值是否为0来判断；</li>
<li><code>HEALTHCHECK NONE</code>：禁止基础镜像中的健康检查。</li>
</ul>
<p>OPTIONS：</p>
<ul>
<li><code>--interval=DURATION</code>（默认为：30s）：过多久检查一次；</li>
<li><code>--timeout=DURATION</code>（默认为：30s）：每次检查等待结果的超时；</li>
<li><code>--retries=N</code>（默认为：3）：如果失败了，重试几次才最终确定失败。</li>
</ul>
<h4 id="shell">SHELL</h4>
<p>指定其他命令使用 shell 时的默认 shell 类型。</p>
<h3 id="创建镜像-1">创建镜像</h3>
<p>编写完成 Dockerfile 之后，可以通过 <code>docker build</code>
命令来创建镜像。</p>
<ul>
<li>如果使用非内容路径下的 Dockerfile，可以通过 <code>-f</code>
选项来指定其路径。</li>
<li>要指定生成镜像的标签信息，可以使用 <code>-t</code> 选项。</li>
</ul>
<p>格式：<code>docker build [OPTION] Path</code> 读取指定路径下的
Dockerfile，并将该路径下的所有内容发送到 Docker
服务端，由服务端创建镜像。</p>
<p>例如，指定 Dockerfile 所在路径为
<code>/tmp/docker_builder/</code>，并且希望生成镜像标签为<code>build_repo/first_image</code>，可以使用下面的命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker build -t build_repo/first_image /tmp/docker_builder/</span><br></code></pre></div></td></tr></table></figure>
<h3 id="使用-.dockerignore-文件">使用 .dockerignore 文件</h3>
<p>可以通过 .dockerignore 文件（每一行添加一条匹配模式）来让 Docker
忽略匹配模式路径下的目录和文件。</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E3%80%8ADocker%E6%8A%80%E6%9C%AF%E5%85%A5%E9%97%A8%E4%B8%8E%E5%AE%9E%E8%B7%B5%E3%80%8B/">《Docker技术入门与实践》</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Docker/">Docker</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/06/20/Math/Latex_formula/">
                        <span class="hidden-mobile">Latex数学公式</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                

              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://blog.xuyinsong.cn" target="_blank" rel="nofollow noopener"><span>Anson</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
        typing(title);
      
    })(window, document);
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
