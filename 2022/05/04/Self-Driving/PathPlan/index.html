

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Anson">
  <meta name="keywords" content="">
  
    <meta name="description" content="1. 自动驾驶汽车定位-感知-规划-决策-控制概述 定位  定位，即通过GPS、惯导、激光雷达等传感器，获取车辆的位置和航向信息。 绝对定位是指通过GPS实现，采用双天线，通过卫星获得车辆在地球上的绝对位置和航向信息。 相对定位是指根据车辆的初始位姿，通过惯导、里程计等传感器获得加速度信息，将其对时间进行积分，即可得到相对初始位姿的当前位姿信息。  感知  环境感知，即通过摄像头、激光雷达、毫米波">
<meta property="og:type" content="article">
<meta property="og:title" content="路径规划算法">
<meta property="og:url" content="http://example.com/2022/05/04/Self-Driving/PathPlan/index.html">
<meta property="og:site_name" content="Anson Blog">
<meta property="og:description" content="1. 自动驾驶汽车定位-感知-规划-决策-控制概述 定位  定位，即通过GPS、惯导、激光雷达等传感器，获取车辆的位置和航向信息。 绝对定位是指通过GPS实现，采用双天线，通过卫星获得车辆在地球上的绝对位置和航向信息。 相对定位是指根据车辆的初始位姿，通过惯导、里程计等传感器获得加速度信息，将其对时间进行积分，即可得到相对初始位姿的当前位姿信息。  感知  环境感知，即通过摄像头、激光雷达、毫米波">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/PathPlaning/A-Star-1.png">
<meta property="article:published_time" content="2022-05-03T16:00:00.000Z">
<meta property="article:modified_time" content="2022-05-04T11:40:18.423Z">
<meta property="article:author" content="Anson">
<meta property="article:tag" content="note">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/img/PathPlaning/A-Star-1.png">
  
  
  <title>路径规划算法 - Anson Blog</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/arta.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.14","typing":{"enable":true,"typeSpeed":100,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 6.1.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Anson</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="路径规划算法">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2022-05-04 00:00" pubdate>
        2022年5月4日 凌晨
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      13k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      112 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">路径规划算法</h1>
            
            <div class="markdown-body">
              <h1 id="自动驾驶汽车定位-感知-规划-决策-控制概述">1.
自动驾驶汽车定位-感知-规划-决策-控制概述</h1>
<h3 id="定位">定位</h3>
<ul>
<li>定位，即通过GPS、惯导、激光雷达等传感器，获取车辆的位置和航向信息。</li>
<li><strong>绝对定位</strong>是指通过GPS实现，采用双天线，通过卫星获得车辆在地球上的绝对位置和航向信息。</li>
<li><strong>相对定位</strong>是指根据车辆的初始位姿，通过惯导、里程计等传感器获得加速度信息，将其对时间进行积分，即可得到相对初始位姿的当前位姿信息。</li>
</ul>
<h3 id="感知">感知</h3>
<ul>
<li>环境感知，即通过<strong>摄像头、激光雷达、毫米波雷达、超声波雷达</strong>等队中传感器，感知周围环境信息和车辆状态信息。</li>
<li>环境信息包括：道路、方向、曲率、坡度、交通标志，信号灯；车辆状态信息包括：车辆前进的速度、加速度、转向角度、车身位置及姿态。</li>
<li>多种传感器虽然可以获得丰富、细致的环境信息，但如何对多种传感器的信息进行<strong>融合统一处理</strong></li>
</ul>
<h3 id="规划">规划</h3>
<ul>
<li>规划是对未来时域、空域的车辆一系列动作的计划。从涉及的时空大小全局（宏观）路径规划和局部（微观）路径规划。</li>
<li><strong>全局路径规划</strong>指在已知全局地图的情况下，从车辆当前位置规划出一条到目的地的全局路径。</li>
<li><strong>局部路径规划</strong>指根据环境感知的信息在环道、转弯、躲避障碍物等情况下，实时规划出一条安全、平顺、舒适的行驶路径。</li>
</ul>
<h3 id="决策控制">决策控制</h3>
<ul>
<li>决策控制，包括决策和控制两部分</li>
<li>决策，在整个无人驾驶系统中，扮演<strong>驾驶员大脑</strong>的角色，根据定位、感知、路径规划的信息，决定无人车的形式策略。包括：选取哪条车道、是否换道、是否跟车行驶、是否绕道、是否停车等。</li>
<li>控制，主要包括<strong>转向、驱动、制动</strong>三方面的控制，执行规划决策模块下发的期望速度和期望转向角度，也包括转向灯、喇叭、门窗等的控制。</li>
</ul>
<h1
id="全局路径规划算法dijkstra算法">2.全局路径规划算法——Dijkstra算法</h1>
<h2 id="算法简介">算法简介</h2>
<p>迪杰斯特拉算法(Dijkstra)是由荷兰计算机科学家狄克斯特拉于1959年提出的，因此又叫狄克斯特拉算法。是从一个节点遍历其余各节点的最短路径算法，解决的是有权图中最短路径问题</p>
<h2 id="算法思想">算法思想</h2>
<ul>
<li>设<span
class="math inline">\(G=(V,E)\)</span>是一个带权有向图，把图中节点集合V分成两组，<font color='green'>第一组为已求出最短路径的集合</font>,(用S表示，初始时S中只有一个源点，以后每求得一条最短路径，就将该节点加入到集合S中，直到全部节点都加入到S中，算法结束)</li>
<li><font color='green'>第二组为区域未确定最短路径的节点集合</font>（用U表示），按最短路径长度的递增次序依次把第二组的节点加入S中。在加入的过程中，总保持从源点v到S中各节点的最短路径长度不大于从源点v到U中任何节点的最短路径长度。</li>
<li>此外，每个节点对应一个距离，S中的节点的距离就是从v到此节点的最短距离路径长度，U中的节点的距离，是从v到此节点只包括S中的节点为中间节点的当前最短路径长度。</li>
</ul>
<p><img src="/img/PathPlaning/Dijkstra.png" srcset="/img/loading.gif" lazyload /></p>
<h2 id="算法精讲">算法精讲</h2>
<ul>
<li>初始时，S只包含起点s；U包含除s外的其他节点，且U中节点的距离为”起点s到该节点的距离“[例如，U中节点v的距离为(s,v)的长度，然后s和v不相邻，则v的距离为<span
class="math inline">\(\infty\)</span>].</li>
<li>从U中选出”距离最短的节点k“，并将节点k加入到S中；同时，从U中移除节点k。</li>
<li>更新U中各节点到起点s的距离。之所以更新U中节点的距离，是因为上一步确定了k是求出最短路径的节点，从而可以利用k来更新其他节点的距离；例如，<span
class="math inline">\((s,v)\)</span>的距离可能大于<span
class="math inline">\((s,k)+(k,v)\)</span>的距离。</li>
<li>重复步骤(2)和(3)，直到遍历完所有节点。</li>
</ul>
<p><img src="/img/PathPlaning/Dijkstra1.png" srcset="/img/loading.gif" lazyload /></p>
<p><strong>选取节点<span class="math inline">\(D\)</span>，<span
class="math inline">\(S=\{D(0)\}\)</span> <span
class="math inline">\(U=\{A(\infty),B(\infty),{\color{Red}C(3)},E(4),F(\infty),G(\infty)\}\)</span></strong></p>
<p><img src="/img/PathPlaning/Dijkstra2.png" srcset="/img/loading.gif" lazyload /></p>
<p><strong>选取节点<span class="math inline">\(C\)</span>，<span
class="math inline">\(S=\{D(0),C(3)\}\)</span>，<span
class="math inline">\(\{A(\infty),B(13),{\color{Red}E(4)},F(9),G(\infty)\}\)</span>.</strong></p>
<p><img src="/img/PathPlaning/Dijkstra3.png" srcset="/img/loading.gif" lazyload /></p>
<p><strong>选取节点<span class="math inline">\(E\)</span>，<span
class="math inline">\(S=\{D(0),C(3),E(4)\}\)</span>，<span
class="math inline">\(U=\{A(\infty),B(13),{\color{Red}F(6)},G(12)\}\)</span>.</strong></p>
<p><img src="/img/PathPlaning/Dijkstra4.png" srcset="/img/loading.gif" lazyload /></p>
<p><strong>选取节点<span class="math inline">\(F\)</span>，<span
class="math inline">\(S=\{D(0),C(3),E(4),F(6)\}\)</span>，<span
class="math inline">\(U=\{A(2),B(13),{\color{Red}G(12)}\}\)</span>.</strong></p>
<p><img src="/img/PathPlaning/Dijkstra5.png" srcset="/img/loading.gif" lazyload /></p>
<p><span
class="math inline">\(S=\{D(0),C(3),E(4),F(6),G(12)\}\)</span>，<span
class="math inline">\(U=\{A(22),{\color{Red}B(13)}\}\)</span>.</p>
<p><img src="/img/PathPlaning/Dijkstra6.png" srcset="/img/loading.gif" lazyload /></p>
<p><span
class="math inline">\(S=\{D(0),C(3),E(4),F(6),G(12),B(13)\}\)</span>，<span
class="math inline">\(U=\{\color{Red}A(22)\}\)</span>.</p>
<p><img src="/img/PathPlaning/Dijkstra7.png" srcset="/img/loading.gif" lazyload /></p>
<p><span
class="math inline">\(S=\{D(0),C(3),E(4),F(6),G(12),B(13),A(22)\}\)</span>，<span
class="math inline">\(U=\varnothing\)</span>.</p>
<p><img src="/img/PathPlaning/Dijkstra8.png" srcset="/img/loading.gif" lazyload /></p>
<p><span class="math inline">\(D\rightarrow A\)</span>的最优路径为<span
class="math inline">\(D\rightarrow E \rightarrow F \rightarrow
A\)</span></p>
<p>最短距离为22</p>
<h2 id="matlab实现">Matlab实现</h2>
<figure class="highlight matlab"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></div></td><td class="code"><pre><code class="hljs matlab">clc<br>clear<br>close all<br><span class="hljs-comment">%% 图定义</span><br><span class="hljs-comment">% 根据节点的邻近节点表及字母点-数字节点对应表，构造节点元胞数组</span><br>nodes_dist = cell(<span class="hljs-number">0</span>);<br>nodes_dist(<span class="hljs-number">1</span>,:) = &#123;<span class="hljs-number">1</span>, [<span class="hljs-number">2</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>], [<span class="hljs-number">12</span>, <span class="hljs-number">16</span>, <span class="hljs-number">14</span>]&#125;;<br>nodes_dist(<span class="hljs-number">2</span>,:) = &#123;<span class="hljs-number">2</span>, [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>], [<span class="hljs-number">12</span>, <span class="hljs-number">10</span>, <span class="hljs-number">7</span>]&#125;;<br>nodes_dist(<span class="hljs-number">3</span>,:) = &#123;<span class="hljs-number">3</span>, [<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>], [<span class="hljs-number">10</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]&#125;;<br>nodes_dist(<span class="hljs-number">4</span>,:) = &#123;<span class="hljs-number">4</span>, [<span class="hljs-number">3</span>, <span class="hljs-number">5</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]&#125;;<br>nodes_dist(<span class="hljs-number">5</span>,:) = &#123;<span class="hljs-number">5</span>, [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>], [<span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">8</span>]&#125;;<br>nodes_dist(<span class="hljs-number">6</span>,:) = &#123;<span class="hljs-number">6</span>, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>], [<span class="hljs-number">16</span>, <span class="hljs-number">7</span>, <span class="hljs-number">6</span>, <span class="hljs-number">2</span>, <span class="hljs-number">9</span>]&#125;;<br>nodes_dist(<span class="hljs-number">7</span>,:) = &#123;<span class="hljs-number">7</span>, [<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>], [<span class="hljs-number">14</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>]&#125;;<br><br><span class="hljs-comment">%% 算法初始化</span><br><span class="hljs-comment">% S/U的第一列表示节点编号</span><br><span class="hljs-comment">% 对于S,第二列表示从源节点到本节点已求得的最小距离，不再变更；</span><br><span class="hljs-comment">% 对于U,第二列表示从源节点到本节点暂时求得的最小距离，可能会变更</span><br>S = [<span class="hljs-number">4</span>, <span class="hljs-number">0</span>];<br>U(:,<span class="hljs-number">1</span>) = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>];<br>U(:,<span class="hljs-number">2</span>) = [<span class="hljs-built_in">inf</span>, <span class="hljs-built_in">inf</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-built_in">inf</span>, <span class="hljs-built_in">inf</span>]&#125;;<br><br><span class="hljs-comment">% 最优路径及暂时的最优路径的初始化</span><br>path_opt = cell(<span class="hljs-number">7</span>, <span class="hljs-number">2</span>);<br>path_opt(<span class="hljs-number">4</span>,:) = &#123;<span class="hljs-number">4</span>, <span class="hljs-number">4</span>&#125;;<br><br>path_temp = cell(<span class="hljs-number">7</span>, <span class="hljs-number">2</span>);<br>path_temp(<span class="hljs-number">3</span>,:) = &#123;<span class="hljs-number">3</span>, [<span class="hljs-number">4</span>, <span class="hljs-number">3</span>]&#125;;<br>path_temp(<span class="hljs-number">4</span>,:) = &#123;<span class="hljs-number">4</span>, <span class="hljs-number">4</span>&#125;;<br>path_temp(<span class="hljs-number">5</span>,:) = &#123;<span class="hljs-number">5</span>, [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>]&#125;;<br><br><span class="hljs-comment">%% 循环遍历所有节点</span><br><span class="hljs-keyword">while</span> ~<span class="hljs-built_in">isempty</span>(U)<br>[dist_min, idx] = <span class="hljs-built_in">min</span>(U(:,<span class="hljs-number">2</span>));<br>node_min = U(idx, <span class="hljs-number">1</span>);<br>S(<span class="hljs-keyword">end</span>+<span class="hljs-number">1</span>,:) = [node_min, dist_min];<br>U(idx,:) = [];<br><br><span class="hljs-comment">% 将最小的距离值的节点添加到到最优路径集合</span><br>path_opt(node_min,:) = path_temp(node_min,:);<br><br><span class="hljs-comment">%% 依次遍历最小距离节点的邻节点，判断是否在U集合中更新邻节点的距离值</span><br><span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span> = <span class="hljs-number">1</span>:<span class="hljs-built_in">length</span>(nodes_dist&#123;node_min, <span class="hljs-number">2</span>&#125;)<br>	<span class="hljs-built_in">i</span> = <span class="hljs-number">1</span>;<br>	<span class="hljs-comment">% 需要判断的节点</span><br>	node_temp = nodes_dist&#123;node_min, <span class="hljs-number">2</span>&#125;(<span class="hljs-built_in">i</span>);<br>	<br>	<span class="hljs-comment">% 找出U集合中节点node_temp的索引值</span><br>	idx_temp = <span class="hljs-built_in">find</span>(node_temp == U(:,<span class="hljs-number">1</span>));<br>	<br>	<span class="hljs-comment">% 判断是否更新</span><br>	<span class="hljs-keyword">if</span> ~<span class="hljs-built_in">isempty</span>(idx_temp)<br>		<span class="hljs-keyword">if</span> dist_min + node_dist&#123;node_min, <span class="hljs-number">3</span>&#125;(<span class="hljs-built_in">i</span>) &lt; U(idx_temp, <span class="hljs-number">2</span>)<br>			U(idx_temp, <span class="hljs-number">2</span>) = dist_min + nodes_dist&#123;node_min, <span class="hljs-number">3</span>&#125;(<span class="hljs-built_in">i</span>)<br>			<br>			<span class="hljs-comment">% 更新暂时最优路径</span><br>			path_temp&#123;node_temp, <span class="hljs-number">1</span>&#125; = node_temp;<br>            path_temp&#123;node_temp, <span class="hljs-number">2</span>&#125; = [path_opt&#123;node_min, <span class="hljs-number">2</span>&#125;, node_temp];<br>            <span class="hljs-keyword">end</span>        <br></code></pre></td></tr></table></figure>
<h2 id="python实现">Python实现</h2>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 图定义</span><br><span class="hljs-comment"># 根据节点的邻近节点表-数字对应表，构造图</span><br>nodes_dist = <span class="hljs-built_in">dict</span>()<br>nodes_dist[<span class="hljs-number">1</span>] = &#123;<span class="hljs-number">2</span>: <span class="hljs-number">12</span>, <span class="hljs-number">6</span>: <span class="hljs-number">16</span>, <span class="hljs-number">7</span>: <span class="hljs-number">14</span>&#125;<br>nodes_dist[<span class="hljs-number">2</span>] = &#123;<span class="hljs-number">1</span>: <span class="hljs-number">12</span>, <span class="hljs-number">3</span>: <span class="hljs-number">10</span>, <span class="hljs-number">6</span>: <span class="hljs-number">7</span>&#125;<br>nodes_dist[<span class="hljs-number">3</span>] = &#123;<span class="hljs-number">2</span>: <span class="hljs-number">10</span>, <span class="hljs-number">4</span>: <span class="hljs-number">3</span>, <span class="hljs-number">5</span>: <span class="hljs-number">5</span>, <span class="hljs-number">6</span>: <span class="hljs-number">6</span>&#125;<br>nodes_dist[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">3</span>: <span class="hljs-number">3</span>, <span class="hljs-number">5</span>: <span class="hljs-number">4</span>&#125;<br>nodes_dist[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">3</span>: <span class="hljs-number">5</span>, <span class="hljs-number">4</span>: <span class="hljs-number">4</span>, <span class="hljs-number">6</span>: <span class="hljs-number">2</span>, <span class="hljs-number">7</span>: <span class="hljs-number">8</span>&#125;<br>nodes_dist[<span class="hljs-number">6</span>] = &#123;<span class="hljs-number">1</span>: <span class="hljs-number">16</span>, <span class="hljs-number">2</span>: <span class="hljs-number">7</span>, <span class="hljs-number">3</span>: <span class="hljs-number">6</span>, <span class="hljs-number">5</span>: <span class="hljs-number">2</span>, <span class="hljs-number">7</span>: <span class="hljs-number">9</span>&#125;<br>nodes_dist[<span class="hljs-number">7</span>] = &#123;<span class="hljs-number">1</span>: <span class="hljs-number">14</span>, <span class="hljs-number">5</span>: <span class="hljs-number">8</span>, <span class="hljs-number">6</span>: <span class="hljs-number">9</span>&#125;<br><br><span class="hljs-comment"># S 集合</span><br>S = <span class="hljs-built_in">dict</span>()<br><br><span class="hljs-comment"># U 集合</span><br>U = <span class="hljs-built_in">dict</span>()<br>U[<span class="hljs-number">1</span>] = <span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;inf&#x27;</span>)<br>U[<span class="hljs-number">2</span>] = <span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;inf&#x27;</span>)<br>U[<span class="hljs-number">3</span>] = <span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;inf&#x27;</span>)<br>U[<span class="hljs-number">4</span>] = <span class="hljs-number">0</span><br>U[<span class="hljs-number">5</span>] = <span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;inf&#x27;</span>)<br>U[<span class="hljs-number">6</span>] = <span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;inf&#x27;</span>)<br>U[<span class="hljs-number">7</span>] = <span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;inf&#x27;</span>)<br><br><span class="hljs-comment"># 当前最优路径</span><br>keys = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">8</span>)]<br>path_temp = <span class="hljs-built_in">dict</span>([(k, []) <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> keys])<br><br><br><span class="hljs-comment"># 最终最优路径</span><br>path_opt = <span class="hljs-built_in">dict</span>([(k, []) <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> keys])<br><br><span class="hljs-comment"># 循环遍历U集合，直到所有节点被确定，并移出集合</span><br><span class="hljs-keyword">while</span> U:<br>    <span class="hljs-comment"># 寻找U集合中的最小值，及其对应的节点</span><br>    dist_min = <span class="hljs-built_in">min</span>(U.values())<br>    node_min = <span class="hljs-built_in">min</span>(U, key=U.get)<br>    <span class="hljs-comment"># 将最小值节点移出U集合，移入S集合</span><br>    S[node_min] = dist_min<br>    <span class="hljs-keyword">del</span> U[node_min]<br><br>    <span class="hljs-comment"># 确定该最小值节点的最终最优路径</span><br>    path_opt[node_min] += path_temp[node_min]<br>    path_opt[node_min].append(node_min)<br><br>    <span class="hljs-comment"># 围绕该最小值节点，循环遍历其相邻节点</span><br>    <span class="hljs-keyword">for</span> node_temp <span class="hljs-keyword">in</span> nodes_dist[node_min].keys():<br>        <span class="hljs-comment"># 判断该相邻节点是否在集合U中，即该节点是否已经被确定。若已确定，则不做考虑</span><br>        <span class="hljs-keyword">if</span> node_temp <span class="hljs-keyword">in</span> <span class="hljs-built_in">list</span>(U.keys()):<br>            <span class="hljs-comment"># 判断该路径是否比原有路径短</span><br>            <span class="hljs-keyword">if</span> (dist_min + nodes_dist[node_min][node_temp]) &lt; U[node_temp]:<br>                <span class="hljs-comment"># 更新最短距离</span><br>                U[node_temp] = dist_min + nodes_dist[node_min][node_temp]<br>                <span class="hljs-comment"># 该最短距离所对应的新路径</span><br>                path_temp[node_temp] = path_opt[node_min]<br><br><span class="hljs-built_in">print</span>(S, U)<br><span class="hljs-built_in">print</span>(path_opt)<br></code></pre></td></tr></table></figure>
<h1 id="全局路径规划算法蚁群算法">3.全局路径规划算法——蚁群算法</h1>
<h2 id="算法简介-1">算法简介</h2>
<p>蚁群算法是一种智能算法，它是由一群无智能或有微智能的个体(Agent)通过相互协作表现出智能行为，从而为求解复杂问题提供了一个新的可能性。</p>
<ul>
<li>蚁群算法(Ant Colony Algorithm, ACA)
于1992年首次提出，该算法模拟了自然界中<font color='green'>蚂蚁的觅食行为</font>.</li>
<li>蚂蚁在寻找食物源时，会在其经过的路径上释放一种信息素，并能够感知其他蚂蚁释放的信息素，信息素<font color='green'>浓度的大小表征路径的远近</font>，信息素浓度越高，表示对应的路径距离越短。</li>
<li>通常，蚂蚁会以较大的概率优先选择信息素浓度较大路径，并释放一定量的信息素，以增强该条路径上的信息素浓度，这样，会形成正反馈。最终，蚂蚁能够找到一条从巢穴到食物源的最佳路径，即距离最短。</li>
</ul>
<h3 id="tsp问题描述">TSP问题描述</h3>
<p>蚁群算法最早用来解决TSP问题，并且表现出很大的优越性，因为它有分布式特性、鲁棒性强并且容易与其他算法结合，但是同时也存在收敛速度慢，容易陷入局部最优等缺点。</p>
<p>TSP问题(Travel Salesperson
Problem，即旅行商问题或者称为中国邮递员问题)，是一种NP-hard问题，此类问题用一般的算法很难得到最优解的，所以一般需要借助一些启发式算法求解，例如遗传算法(GA)，蚁群算法(ACO)，微粒群算法(PSO)等。</p>
<blockquote>
<p>TSP问题（旅行商问题）是指旅行家旅行n个城市，要求<strong>各个城市经历且仅经历一次</strong>然后回到出发城市，并要求所走路程最短。</p>
</blockquote>
<p>一个TSP问题可以表达为：求解遍历图<span
class="math inline">\(G=(V,E,C)\)</span>，所有的节点一次并且回到起始节点，使得连接这些节点的路径成本最低。</p>
<h2 id="算法思想-1">算法思想</h2>
<ul>
<li>用蚂蚁的行走路径并表示待优化问题的可行解，整个蚂蚁群的所有路径构成待优化问题的解空间。</li>
<li>路径较短的，蚂蚁会释放较多的信息素，随着时间的推进，<font color='green'>较短的路径上积累的信息素浓度逐渐增高</font>，选择该路径的蚂蚁个数也愈来愈多。</li>
<li>最终，整个蚂蚁会在正反馈的作用下集中到最佳的路径上，此时对应的便是待优化问题的最优解。</li>
</ul>
<p><img src="/img/PathPlaning/ACA.jpg" srcset="/img/loading.gif" lazyload /></p>
<h2 id="算法精讲-1">算法精讲</h2>
<h3 id="原理">原理</h3>
<p>假如蚁群中所有蚂蚁的数量为<span
class="math inline">\(m\)</span>，所有城市之间的信息素用矩阵<span
class="math inline">\(pheromone\)</span>表示，最短路径为<span
class="math inline">\(bestLength\)</span></p>
<p>，最佳路径为<span
class="math inline">\(bestTour\)</span>。每只蚂蚁都有自己的内存，内存中用一个禁忌表(Tabu)来存储蚂蚁已经访问过的城市，表示以后的搜索将不能访问这些城市；还有用另外一个允许访问的城市表(Allowed)来存储它还可以访问的城市；另外还用矩阵(Delta)来储存它在一个循环（或者迭代）中经过的路径释放的信息素；还有另外一些数据，例如一些控制参数<span
class="math inline">\((\alpha,\beta,\rho,Q)\)</span>，该蚂蚁行走完全程的总成本或距离(tourLength)，等等。假定算法总共运行MAX_GEN次，运行时间为t.</p>
<p>蚁群算法计算过程如下：</p>
<ol type="1">
<li><p>初始化</p></li>
<li><p>为每只蚂蚁选择下一个节点。</p></li>
<li><p>更新信息素矩阵</p></li>
<li><p>检查终止条件</p></li>
</ol>
<blockquote>
<p>如果达到最大迭代数MAX_GEN，算法终止，转到第(5)步；否则，重新初始化所有蚂蚁的Delta矩阵所有元素初始化为0，Tabu表清空，Allowed表加入所有城市节点。随机选择它们的起始位置（也可以人为指定）。在Tabu表中加入起始节点，Allowed表中删除该起始节点，重复执行(2),(3),(4)步。</p>
</blockquote>
<ol start="5" type="1">
<li>输出最优值</li>
</ol>
<hr />
<p>不失一般性，设整个蚂蚁群体中蚂蚁的数量为<span
class="math inline">\(m\)</span>，城市的数量为<span
class="math inline">\(n\)</span>，城市<span
class="math inline">\(i\)</span>与城市<span
class="math inline">\(j\)</span>之间的相互距离为<span
class="math inline">\(d_{ij}(i,j=1,2,...,n)\)</span>，<span
class="math inline">\(t\)</span>时刻城市<span
class="math inline">\(i\)</span>与城市<span
class="math inline">\(j\)</span>连接路径上的信息素浓度为<span
class="math inline">\(\tau_{ij}(t)\)</span>。初始时刻，各个城市间连接路径上的信息素浓度相同，不妨设为<span
class="math inline">\(\tau_{ij}(0)=\tau_0\)</span>。</p>
<p>蚂蚁<span
class="math inline">\(k(k=1,2,...,m)\)</span>根据各个城市间连接路径上的信息素浓度决定其下一个访问的城市，设<span
class="math inline">\(P^k_{ij}(t)\)</span>表示<span
class="math inline">\(t\)</span>时刻蚂蚁<span
class="math inline">\(k\)</span>从城市<span
class="math inline">\(i\)</span>转移到城市<span
class="math inline">\(j\)</span>的概率，其计算公式如下：</p>
<p>​ <span
class="math display">\[P^K_{ij}=\begin{cases}\dfrac{[\tau_{ij}(t)]^\alpha
\cdot [\eta_{ij}(t)]^\beta}{\sum\limits_{S \in
allow_k}[\tau_{is}(t)]^\alpha\cdot [\eta_{is}(t)]^\beta},&amp;S \in
allow_k \\ 0, &amp;S \notin allow_k\end{cases}\]</span></p>
<p>其中，<span
class="math inline">\(\eta_{ij}(t)\)</span>为启发函数，<span
class="math inline">\(\eta_{ij}(t)=\frac{1}{d_{ij}}\)</span>，表示蚂蚁从城市<span
class="math inline">\(i\)</span>转移到城市<span
class="math inline">\(j\)</span>的期望程度，<span
class="math inline">\(allow_k(k=1,2,...,m)\)</span>蚂蚁<span
class="math inline">\(k\)</span>待访问城市的集合。开始时，<span
class="math inline">\(allow_k\)</span>中有<span
class="math inline">\((n-1)\)</span>个元素，即包括除了蚂蚁<span
class="math inline">\(k\)</span>出发城市的其他所有城市，随着时间的推进，<span
class="math inline">\(allow_k\)</span>中的元素不断减少，直至为空，即表示所有的城市均访问完毕。<span
class="math inline">\(\alpha\)</span>为信息素重要程度因子，其值越大，表示信息素的浓度在转移中起的作用越大；<span
class="math inline">\(\beta\)</span>为启发函数重要程度因子，其值越大，表示启发函数转移中的作用越大，即蚂蚁会以较大的概率转移到距离短的城市。</p>
<p>在蚂蚁释放信息素的同时，各个城市间连接路径上的信息素逐渐消失，设参数<span
class="math inline">\(\rho(0&lt;\rho&lt;1)\)</span>表示信息挥发程度。因此，当所有蚂蚁完成一次循环后，各个城市间连接路径上的信息素浓度需要进行实时更新，具体公式如下：</p>
<p>​ <span class="math display">\[\begin{cases}\tau_{ij}(t+1) =
(1-\rho)*\tau_{ij}(t)+\Delta\tau_{ij} \\
\Delta\tau_{ij}=\sum\limits_{k=1}^m \Delta\tau^k_{ij}, &amp;
0&lt;\rho&lt;1\end{cases}\]</span></p>
<p>其中，<span
class="math inline">\(\Delta\tau^k_{ij}\)</span>表示第<span
class="math inline">\(k\)</span>只蚂蚁在城市<span
class="math inline">\(i\)</span>与城市<span
class="math inline">\(j\)</span>连接路径上释放的信息素浓度，<span
class="math inline">\(\Delta\tau_{ij}\)</span>表示所有蚂蚁在城市<span
class="math inline">\(i\)</span>与城市<span
class="math inline">\(j\)</span>连接路径上释放的信息素浓度之和。</p>
<p>ant cycle system 模型中，<span
class="math inline">\(\Delta\tau^k_{ij}\)</span>的计算公式如下：</p>
<p>​ <span class="math display">\[\Delta\tau^k_{ij}=\begin{cases}Q/L_k,
&amp; 第k只蚂蚁从城市i访问城市j \\ 0, &amp; 其它\end{cases}\]</span></p>
<table>
<colgroup>
<col style="width: 9%" />
<col style="width: 33%" />
<col style="width: 56%" />
</colgroup>
<thead>
<tr class="header">
<th></th>
<th style="text-align: center;">定义</th>
<th style="text-align: center;">参数影响分析</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(\alpha\)</span></td>
<td style="text-align: center;">信息启发式因子</td>
<td style="text-align: center;"><span
class="math inline">\(\alpha\)</span>值越大，蚂蚁选择之前走过的路径可能性就越大，搜索路径的随机性减弱，<span
class="math inline">\(\alpha\)</span>越小，蚁群搜索范围就会减少，容易陷入局部最优</td>
</tr>
<tr class="even">
<td><span class="math inline">\(\beta\)</span></td>
<td style="text-align: center;">期望启发式因子</td>
<td style="text-align: center;"><span
class="math inline">\(\beta\)</span>值越大，蚁群越容易选择局部较短路径，这时算法的收敛速度是加快了，但是随机性却不高，容易得到局部最优解</td>
</tr>
<tr class="odd">
<td><span class="math inline">\(m\)</span></td>
<td style="text-align: center;">蚁群数量</td>
<td style="text-align: center;"><span
class="math inline">\(m\)</span>数目越多，得到的最优解就越精确，但是会产生不少重复解，随着算法接近最优解的收敛，信息正反馈作用降低，大量的重复工作，消耗了资源，增加了时间复杂度</td>
</tr>
<tr class="even">
<td><span class="math inline">\(\rho\)</span></td>
<td style="text-align: center;">信息挥发因子，<span
class="math inline">\(1-\rho\)</span>表示残留因子</td>
<td style="text-align: center;"><span
class="math inline">\(\rho\)</span>过小时，在各路径上残留的信息素过多，导致无效的路径继续被搜索，影响到算法的收敛速率；<span
class="math inline">\(\rho\)</span>过大，无效的路径虽然可以被排除搜索，但是不能保证有效的路径也会被搜索，影响到最优值的搜索。</td>
</tr>
</tbody>
</table>
<p>蚁群算法中主要参数的理想选择如下：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">参数</th>
<th style="text-align: center;">取值范围</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><span
class="math inline">\(\alpha\)</span></td>
<td style="text-align: center;"><span
class="math inline">\([0,5]\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span
class="math inline">\(\beta\)</span></td>
<td style="text-align: center;"><span
class="math inline">\([0,5]\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span
class="math inline">\(Q\)</span></td>
<td style="text-align: center;"><span class="math inline">\([10,
10000]\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span
class="math inline">\(\rho\)</span></td>
<td style="text-align: center;"><span
class="math inline">\([0.1,0.99]\)</span></td>
</tr>
</tbody>
</table>
<hr />
<p><strong>流程图</strong>：</p>
<p><img src="/img/PathPlaning/aca.png" srcset="/img/loading.gif" lazyload /></p>
<h2 id="文献">文献</h2>
<h3 id="蚁群算法中参数-αβ-ρ设置的研究-以-tsp-问题为例">1.蚁群算法中参数
α、β 、ρ设置的研究 ———以 TSP 问题为例</h3>
<p>蚁群算法在TSP问题应用中取得了良好的效果，但也存在一些不足：</p>
<ul>
<li>如果参数<span class="math inline">\(\alpha 、\beta
、\rho\)</span>设置不当，导致求解速度很慢且所得的解质量特别差；</li>
<li>基本蚁群算法计算量大，求解所需要的时间较长；</li>
<li>基本蚁群算法中理论上要求所有的蚂蚁选择同一路线，该线路即为所求的最优线路；但在实际计算中，在给定一定循环次数的条件下很难实现这种情况。</li>
<li>另一方面，在其他实际应用中，如图像处理中寻求最优模板问题，并不要求所有的蚂蚁都能找到最优的模板，而只需要一只找到即可。</li>
</ul>
<p><span class="math inline">\((t+n)\)</span>时刻在<span
class="math inline">\(ij\)</span>路径上的信息素浓度为：</p>
<p>​ <span
class="math display">\[\tau_{ij}(t+n)=(1-\rho)\tau_{ij}(t)+\Delta\tau_{ij}(t+n)\]</span></p>
<p><span class="math inline">\(\Delta\tau_{ij}\)</span>表示蚂蚁<span
class="math inline">\(k\)</span>在时间段<span
class="math inline">\(t\)</span>到<span
class="math inline">\((t+n)\)</span>的过程中，在<span
class="math inline">\(i\)</span>到<span
class="math inline">\(j\)</span>的路径上留下的残留信息浓度。根据信息素更新策略的不同，有3种不同的蚁群算法模型：</p>
<ol type="1">
<li><p>ant-quantity模型</p>
<p><span
class="math display">\[\Delta\tau_{ij}(t,t+1)=\begin{cases}\dfrac{Q_1}{d_{ij}}，
&amp;如果蚂蚁k经过ij \\ 0， &amp;如果蚂蚁k不经过ij
\end{cases}\]</span></p>
<p>式中，<span
class="math inline">\(Q_1\)</span>是常量，信息素的增量与<span
class="math inline">\(ij\)</span>之间的距离有关。</p></li>
<li><p>ant-density模型</p>
<p><span
class="math display">\[\Delta\tau_(t,t+1)=\begin{cases}Q_2，&amp;如果蚂蚁k经过ij
\\ 0，&amp; 如果蚂蚁k不经过ij \end{cases}\]</span></p>
<p>式中，<span
class="math inline">\(Q_2\)</span>是常量，则信息素增加一个固定值，与<span
class="math inline">\(ij\)</span>之间的距离无关</p></li>
<li><p>ant-cycle模型</p>
<p><span
class="math display">\[\Delta\tau_{ij}(t,t+1)=\begin{cases}Q_3/L^k，&amp;如果蚂蚁k在巡回中经过ij
\\ 0，&amp;如果蚂蚁k在巡回中不经过ij \end{cases}\]</span></p>
<p>式中，<span class="math inline">\(Q_3\)</span>是常量；<span
class="math inline">\(L^k\)</span>表示第<span
class="math inline">\(k\)</span>只蚂蚁的循环路线，即如果蚂蚁经过<span
class="math inline">\(ij\)</span>，则信息素增量为一个常量除以蚂蚁<span
class="math inline">\(k\)</span>的巡回路线长。这里，信息素增量只与蚂蚁的巡回路线和<span
class="math inline">\(Q_3\)</span>有关系，而和具体的<span
class="math inline">\(d_{ij}\)</span>无关。</p></li>
</ol>
<h2 id="代码实现">代码实现</h2>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> random<br><span class="hljs-keyword">import</span> copy<br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">import</span> math<br><span class="hljs-keyword">import</span> tkinter<br><span class="hljs-keyword">import</span> threading<br><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> reduce<br><br><span class="hljs-comment"># 参数</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">Alpha:信息启发因子，值越大，则蚂蚁选择之前走过的路径可能性就越大，值越小，则蚁群搜索范围就会减少，容易陷入局部最优</span><br><span class="hljs-string">Beta:值越大，蚁群就越容易选择局部最短路径，这时算法收敛速度加快，但是随机性不高，容易得到局部的相对最优</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br>(Alpha, Beta, Rho, Q) = (<span class="hljs-number">1.0</span>, <span class="hljs-number">2.0</span>, <span class="hljs-number">0.5</span>, <span class="hljs-number">100.0</span>)<br><span class="hljs-comment"># 城市数，蚁群</span><br>(city_num, ant_num) = (<span class="hljs-number">50</span>, <span class="hljs-number">50</span>)<br>distance_x = [<br>    <span class="hljs-number">178</span>,<span class="hljs-number">272</span>,<span class="hljs-number">176</span>,<span class="hljs-number">171</span>,<span class="hljs-number">650</span>,<span class="hljs-number">499</span>,<span class="hljs-number">267</span>,<span class="hljs-number">703</span>,<span class="hljs-number">408</span>,<span class="hljs-number">437</span>,<span class="hljs-number">491</span>,<span class="hljs-number">74</span>,<span class="hljs-number">532</span>,<br>    <span class="hljs-number">416</span>,<span class="hljs-number">626</span>,<span class="hljs-number">42</span>,<span class="hljs-number">271</span>,<span class="hljs-number">359</span>,<span class="hljs-number">163</span>,<span class="hljs-number">508</span>,<span class="hljs-number">229</span>,<span class="hljs-number">576</span>,<span class="hljs-number">147</span>,<span class="hljs-number">560</span>,<span class="hljs-number">35</span>,<span class="hljs-number">714</span>,<br>    <span class="hljs-number">757</span>,<span class="hljs-number">517</span>,<span class="hljs-number">64</span>,<span class="hljs-number">314</span>,<span class="hljs-number">675</span>,<span class="hljs-number">690</span>,<span class="hljs-number">391</span>,<span class="hljs-number">628</span>,<span class="hljs-number">87</span>,<span class="hljs-number">240</span>,<span class="hljs-number">705</span>,<span class="hljs-number">699</span>,<span class="hljs-number">258</span>,<br>    <span class="hljs-number">428</span>,<span class="hljs-number">614</span>,<span class="hljs-number">36</span>,<span class="hljs-number">360</span>,<span class="hljs-number">482</span>,<span class="hljs-number">666</span>,<span class="hljs-number">597</span>,<span class="hljs-number">209</span>,<span class="hljs-number">201</span>,<span class="hljs-number">492</span>,<span class="hljs-number">294</span>]<br>distance_y = [<br>    <span class="hljs-number">170</span>,<span class="hljs-number">395</span>,<span class="hljs-number">198</span>,<span class="hljs-number">151</span>,<span class="hljs-number">242</span>,<span class="hljs-number">556</span>,<span class="hljs-number">57</span>,<span class="hljs-number">401</span>,<span class="hljs-number">305</span>,<span class="hljs-number">421</span>,<span class="hljs-number">267</span>,<span class="hljs-number">105</span>,<span class="hljs-number">525</span>,<br>    <span class="hljs-number">381</span>,<span class="hljs-number">244</span>,<span class="hljs-number">330</span>,<span class="hljs-number">395</span>,<span class="hljs-number">169</span>,<span class="hljs-number">141</span>,<span class="hljs-number">380</span>,<span class="hljs-number">153</span>,<span class="hljs-number">442</span>,<span class="hljs-number">528</span>,<span class="hljs-number">329</span>,<span class="hljs-number">232</span>,<span class="hljs-number">48</span>,<br>    <span class="hljs-number">498</span>,<span class="hljs-number">265</span>,<span class="hljs-number">343</span>,<span class="hljs-number">120</span>,<span class="hljs-number">165</span>,<span class="hljs-number">50</span>,<span class="hljs-number">433</span>,<span class="hljs-number">63</span>,<span class="hljs-number">491</span>,<span class="hljs-number">275</span>,<span class="hljs-number">348</span>,<span class="hljs-number">222</span>,<span class="hljs-number">288</span>,<br>    <span class="hljs-number">490</span>,<span class="hljs-number">213</span>,<span class="hljs-number">524</span>,<span class="hljs-number">244</span>,<span class="hljs-number">114</span>,<span class="hljs-number">104</span>,<span class="hljs-number">552</span>,<span class="hljs-number">70</span>,<span class="hljs-number">425</span>,<span class="hljs-number">227</span>,<span class="hljs-number">331</span>]<br><br><span class="hljs-comment"># 城市距离和信息素</span><br>distance_graph = [[<span class="hljs-number">0.0</span> <span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(city_num)] <span class="hljs-keyword">for</span> raw <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(city_num)]<br>pheromone_graph = [[<span class="hljs-number">1.0</span> <span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(city_num)] <span class="hljs-keyword">for</span> raw <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(city_num)]<br><br><br><span class="hljs-comment">#----------蚂蚁-----------</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Ant</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span>  <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, ID</span>):<br>        self.ID = ID                    <span class="hljs-comment"># ID</span><br>        self.__clean_data()             <span class="hljs-comment"># 随机初始化出生点</span><br></code></pre></td></tr></table></figure>
<h1
id="全局路径规划算法动态规划算法">4.全局路径规划算法——动态规划算法</h1>
<h2 id="算法简介-2">算法简介</h2>
<ul>
<li>动态规划是运筹学的一个分支，是求解<strong>多阶段决策过程</strong>最优化问题的数学方法。</li>
<li>各个阶段决策的选取不是任意确定的，它依赖于<strong>当前面临的状态</strong>，又<strong>影响以后的发展</strong>。当各个阶段的决策确定以后，就组成一个<strong>决策序列</strong>，因而也就决定了整个过程的一条活动路线，这样的一个前后关联具有链状结构的多阶段过程就称为多阶段决策问题。</li>
<li>动态规划在车辆工程技术领域有着广泛的应用，如“<strong>两档变速器的最优换挡规律</strong>”、“<strong>混合动力汽车最优能量管理策略</strong>”、“<strong>栅格地图最优路径搜索</strong>”等。</li>
</ul>
<p>动态规划算法是通过拆分问题，定义问题状态和状态之间的关系，使得问题能够以递推（或者说分治）的方式去解决。动态规划算法的基本思想与分治法类似，也是将待求解问题分解为若干子问题（阶段），按顺序求解子阶段，前一子问题的解，为后一子问题的求解提供了有用的信息。在求解任一子问题时，列出各种可能的局部解，最后一个子问题就是初始问题的解。</p>
<h2 id="算法思想-2">算法思想</h2>
<ul>
<li>美国数学家Bellman等人在20世纪50年代初提出了著名的最优化原理，把多阶段决策问题转化为<strong>一系列单阶段最优化</strong>问题。</li>
<li>对最佳路径（最佳决策过程）所经过的各个阶段，其中每各阶段起始点到全过程终点的路径，必定是该阶段起始点到全过程终点的一切可能路径中的最佳路径（最优决策），这就是Bellman提出的著名的最优化原理。</li>
<li>简言之，<strong>一个最优决策的子决策必然是最优的</strong>。</li>
</ul>
<p><img src="/img/PathPlaning/多阶段决策过程示意图.png" srcset="/img/loading.gif" lazyload /></p>
<h2 id="算法精讲-2">算法精讲</h2>
<ul>
<li>逆向寻优，正向求解</li>
<li>DP算法本质由三层循环构成</li>
<li>第一层遍历每一个阶段；</li>
<li>第二层遍历第i个阶段的每个状态；</li>
<li>第三层循环遍历第i+1个阶段的每一个状态。</li>
</ul>
<p><img src="/img/PathPlaning/多阶段决策过程示意图2.png" srcset="/img/loading.gif" lazyload /></p>
<hr />
<p>第四阶段 (D-&gt;E): D有两条路线到终点E。</p>
<p><span class="math display">\[f_4(D_1)=5, f_4(D_2)=2\]</span></p>
<hr />
<p>第三阶段(C-&gt;D): C到D有6条路线</p>
<p>第3阶段的C有3个状态值，分别讨论经过该状态值的最优路线</p>
<p><strong>经过C1</strong></p>
<p><span
class="math display">\[f_3(C_1)=min\begin{Bmatrix}d(C_1,D_1)+f_4(D_1)\\d(C_1,D_2)+f_4(D_2)
\end{Bmatrix}=min\begin{Bmatrix}3+5 \\ 9+2 \end{Bmatrix} =
8\]</span></p>
<p>最短路线为<span class="math display">\[C_1 \rightarrow D_1
\rightarrow E\]</span></p>
<p><strong>经过C2</strong></p>
<p><span class="math display">\[f_3(C_2)=min \begin{Bmatrix}d(C_2,
D_1)+f_4(D_1) \\ d(C_2,D_2)+f_4(D_2) \end{Bmatrix} = min
\begin{Bmatrix}6+5 \\ 5+2 \end{Bmatrix} = 7\]</span></p>
<p>最短路线为<span class="math display">\[C_2 \rightarrow D_2
\rightarrow E\]</span></p>
<p><strong>经过C3</strong></p>
<p><span class="math display">\[f_3(C_3)=min \begin{Bmatrix}d(C_3,D_1) +
f_4(D_1) \\ d(C_3, D_2)+f_4(D_2) \end{Bmatrix} = min
\begin{Bmatrix}8+5  \\ 10+2 \end{Bmatrix}=12\]</span></p>
<p>最短路线为<span class="math display">\[C_3 \rightarrow D_2
\rightarrow E\]</span></p>
<hr />
<p>第二阶段(B-&gt;C): B到C有9条路线。</p>
<p>第2阶段的B有3个状态值，分别讨论经过该状态值的最优路线</p>
<p><strong>经过B1</strong></p>
<p><span class="math display">\[f_2(B_1)=min \begin{Bmatrix}d(B_1, C_1)
+ f_3(C_1) \\ d(B_1,C_2) + f_3(C_2) \\ d(B_1, C_3) + f_3(C_3)
\end{Bmatrix} = min \begin{Bmatrix}12+8 \\ 14+7\\10+12 \end{Bmatrix} =
20\]</span></p>
<p>最短路线为<span class="math display">\[B_1 \rightarrow C_1
\rightarrow D_1 \rightarrow E\]</span></p>
<p><strong>经过B2</strong></p>
<p><span class="math display">\[f_2(B_2)=min \begin{Bmatrix}d(B_2, C_1)
+ f_3(C_1) \\ d(B_2,C_2) + f_3(C_2) \\ d(B_2, C_3) + f_3(C_3)
\end{Bmatrix} = min \begin{Bmatrix}6+8 \\ 10+7\\4+12 \end{Bmatrix} =
14\]</span></p>
<p>最短路线为<span class="math display">\[B_2 \rightarrow C_1
\rightarrow D_1 \rightarrow E\]</span></p>
<p><strong>经过C3</strong></p>
<p><span class="math display">\[f_2(B_3)=min \begin{Bmatrix}d(B_3, C_1)
+ f_3(C_1) \\ d(B_3,C_2) + f_3(C_2) \\ d(B_3, C_3) + f_3(C_3)
\end{Bmatrix} = min \begin{Bmatrix}13+8 \\ 12+7\\11+12 \end{Bmatrix} =
19\]</span></p>
<p>最短路线为<span class="math display">\[B_3 \rightarrow C_2
\rightarrow D_2 \rightarrow E\]</span></p>
<hr />
<p>第一阶段(A-&gt;B)：A到B有3条路线</p>
<p><span class="math display">\[f_1(A)=min \begin{Bmatrix}d(A, B_1) +
f_2(B_1) \\ d(A,B_2) + f_2(B_2) \\ d(A, B_3) + f_2(B_3) \end{Bmatrix} =
min \begin{Bmatrix}2+20 \\ 5+14\\1+19 \end{Bmatrix} = 19\]</span></p>
<p>最短路线为<span class="math display">\[A \rightarrow B_2 \rightarrow
C_1 \rightarrow D_1 \rightarrow E\]</span></p>
<h1 id="全局路径规划算法a算法">5.全局路径规划算法——A*算法</h1>
<h2 id="算法简介-3">算法简介</h2>
<ul>
<li>A*(A-Star)算法是一种静态路网求解最短路径最有效的直接搜索方法，也是解决许多搜索问题的有效算法，</li>
<li>广泛应用于室内机器人路径搜索、游戏动画路径搜索等。</li>
</ul>
<h2 id="算法思想-3">算法思想</h2>
<ul>
<li><p>A*算法结合了贪心算法（深度优先）和Dijkstra算法（广度优先），是一种启发是搜索算法。</p></li>
<li><p>路径优劣的评价公式为：<span
class="math inline">\(\color{Red}f(n)=g(n) + h(n)\)</span></p></li>
<li><p><span
class="math inline">\(f(n)\)</span>是从初始状态经由状态<span
class="math inline">\(n\)</span>到目标状态的代价估计，</p>
<p><span
class="math inline">\(g(n)\)</span>是在状态空间中从初始状态到状态<span
class="math inline">\(n\)</span>的实际代价</p>
<p><span class="math inline">\(h(n)\)</span>是从状态<span
class="math inline">\(n\)</span>到目标状态的最佳路径的估计代价</p></li>
<li><p>使用了两个状态表，分别称为<strong>openList表和closeList表</strong>。openList表由待考察的节点组成，closeList表由已经考察过节点组成。</p></li>
</ul>
<h2 id="算法精讲预处理">算法精讲——预处理</h2>
<ul>
<li>将地图栅格化，把每一个正方形格子的中央称为节点；</li>
<li>确定栅格属性，即每一个格子有两种状态：可走和不可走（体现障碍物）。</li>
<li>定义两个列表集合：openList和closeList。openList表由待考察的节点组成，closeList由已经考察的节点组成。类似Dijkstra算法的U集合和S集合。</li>
<li>确定起始节点和目标节点。</li>
</ul>
<p><img src="/img/PathPlaning/A-Star-1.png" srcset="/img/loading.gif" lazyload /></p>
<p><img src="/img/PathPlaning/A-Star-2.png" srcset="/img/loading.gif" lazyload /></p>
<p>初始时，定义A为父节点，节点A离自身的距离为0，路径完全确定，移入closeList中；</p>
<p>父节点周围共有8个节点，定义为子节点。将子节点放入openList中，成为待考察对象。</p>
<p>若某个节点既未在openList，也没在closeList中，则表明还有未搜索到该节点。</p>
<p>路径优劣的判断依据是移动代价，单步移动代价采取<font color='red'>Manhattan
计算方式</font>，即把横向和纵向移动一个节点的定义为10。斜向移动代价参考等腰三角形计算斜边的方式，距离为14。</p>
<h2 id="算法精讲开始搜索">算法精讲——开始搜索</h2>
<ul>
<li>移动代价评价函数为：<span
class="math inline">\(f(n)=g(n)+h(n)\)</span>。<span
class="math inline">\(f(n)\)</span>是初始状态经由状态<span
class="math inline">\(n\)</span>到目标状态的代价估计，<span
class="math inline">\(g(n)\)</span>是在状态空间中从初始状态到状态<span
class="math inline">\(n\)</span>的实际代价，<span
class="math inline">\(h(n)\)</span>是从状态<span
class="math inline">\(n\)</span>到目标状态的最佳路径的估计代价。<font color='red'>以节点<span
class="math inline">\(I\)</span>为例。</font></li>
<li>首先考察<span
class="math inline">\(g\)</span>，由于从A到该格子是斜向移动，单步移动距离为14，故<span
class="math inline">\(g=14\)</span></li>
<li>在考察估计代价<span
class="math inline">\(h\)</span>。估计的含义是忽略剩下的路径是否包含有障碍物（不可走），完全按照Manhattan计算方式，计算<font color='red'>只做横向或纵向移动</font>的累计代价：横向向右移动3步，纵向向上移动1步，总共4步，故为<span
class="math inline">\(h=40\)</span>.</li>
<li>因此从A节点移动I节点的总移动代价为：<span
class="math inline">\(f=54\)</span></li>
<li>以此类推，分别计算当前openList中余下的7个子节点的移动代价，挑选最小代价节点F，移动到closeList中。</li>
<li>现在<span
class="math inline">\(openList=\{B,C,D,E,G,H,I\},closeList=\{A,F\}\)</span></li>
</ul>
<p><img src="/img/PathPlaning/A-Star-3.png" srcset="/img/loading.gif" lazyload /></p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/Self-Driving/">Self-Driving</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/note/">note</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/04/28/Linux/pacman/">
                        <span class="hidden-mobile">pacman 文档</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                

              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://blog.xuyinsong.cn" target="_blank" rel="nofollow noopener"><span>Anson</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
        typing(title);
      
    })(window, document);
  </script>





  

  
    <!-- MathJax -->
    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']]
        },
        loader: {
          load: ['ui/lazy']
        },
        options: {
          renderActions: {
            findScript: [10, doc => {
              document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
                const display = !!node.type.match(/; *mode=display/);
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                const text = document.createTextNode('');
                node.parentNode.replaceChild(text, node);
                math.start = { node: text, delim: '', n: 0 };
                math.end = { node: text, delim: '', n: 0 };
                doc.math.push(math);
              });
            }, '', false],
            insertedScript: [200, () => {
              document.querySelectorAll('mjx-container').forEach(node => {
                let target = node.parentNode;
                if (target.nodeName.toLowerCase() === 'li') {
                  target.parentNode.classList.add('has-jax');
                }
              });
            }, '', false]
          }
        }
      };
    </script>

    <script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js" ></script>

  











<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
