{"title":"链表 linked list","uid":"0d8865dd6f5b4fb80b5a9df16b916aeb","slug":"DSAA/链表","date":"2023-04-14T12:00:00.000Z","updated":"2023-04-15T02:49:14.057Z","comments":true,"path":"api/articles/DSAA/链表.json","keywords":null,"cover":"/img/DSAA/linked list 1.png","content":"<h1 id=\"链表-linked-list\">链表 linked list</h1>\n<h2 id=\"什么是链表\">什么是链表</h2>\n<p><strong>链表</strong>是数据元素的线性集合，其顺序不是由它们在内存中的物理位置给出的。每个元素都指向下一个元素。它是一种<em>数据结构</em>，由一组节点组成，这些节点共同表示一个序列。在其最基本的形式中，每个节点都包含：数据和指向序列中下一个节点的指针（链接）。这种结构允许在迭代期间从序列中的任何位置有效地插入或删除元素。<em>链表的一个缺点是访问时间是线性的(difficult\nto\npipeline)。</em>更快的访问（例如随机访问）是不行的。与链表相比，数组具有更好的缓存局部性(cache\nlocality)。</p>\n<p>链表是最简单和最常见的数据结构之一。它们可用于实现其它几种常见的抽象数据类型，包括列表、栈(Stack)、队列、关联数组和\nS 表达式，尽管直接实现这些数据结构而不使用链表作为基础并不罕见。</p>\n<p>链表相对于传统数组的主要优点是，可以轻松插入或删除列表中的元素，而无需重新分配或重组整个结构，因为数据项不需要连续存储在内存或磁盘上，而在运行时重组数组是一项成本更高的操作。链表允许在列表中的任意位置\n插入和删除节点，并且允许在列表遍历期间将链接保留在内存中添加或删除的链接之前，以恒定数量的操作来执行次操作。</p>\n<p>但是，由于简单链表本身不允许随机访问数据或任何形式的有效索引，因此许多基本操作（例如获取列表的最后一个节点、查找包含给定基准的节点或定位应插入新节点的位置）可能需要遍历大部分或全部列表元素。</p>\n<p><img src=\"/img/DSAA/linked list 1.png\" style=\"zoom:33%;\" /></p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>链表的每条记录通常称为“元素”(element)\n或节点(node)。包含下一个节点地址的字段通常称为“下一个链接”或“下一个指针”。其余称为“数据”。</p></blockquote>\n<h3 id=\"为什么要使用链表\">为什么要使用链表？</h3>\n<p>数组(Arrays)可以用来存储相似类型的线性数据，但数组有以下的限制：</p>\n<ul>\n<li><strong>数组的大小是固定的</strong>：因此使用数组时必须先预设元素数量的上限。此外，通常情况下，无论是否使用，都需要分配数组上限大小的内存。</li>\n<li><strong>插入一个元素或删除一个数组中的已有元素花费很大</strong>：必须为新元素创建空间，为了创建这个空间，现有的数组元素必须移动。</li>\n</ul>\n<p>Example：</p>\n<p>在一个系统中，如果我们在一个数组\n<code>id[] = [1000, 1010, 1050, 2000, 2040]</code> 中维护一个有序的 ID\n列表。此时，想要插入一个新的 ID\n1005，那么为了维持排序的顺序，我们必须移动 1000 之后的所有元素。</p>\n<h3 id=\"链表相对于数组的优点\">链表相对于数组的优点</h3>\n<ul>\n<li>动态数组</li>\n<li>易于插入和删除</li>\n<li>在开头插入一个元素是一个常数时间操作，需要 <code>O(1)</code>\n时间，而在数组的开头插入一个元素需要 <code>O(n)</code> 时间，其中 n\n是数组中元素的数量。</li>\n</ul>\n<h3 id=\"链表的缺点\">链表的缺点</h3>\n<ul>\n<li>不能随机访问。必须从第一个节点开始按顺序访问节点。因此，不能用它的默认实现对链表进行有效的二分搜索。</li>\n<li>对于列表中的每个元素，指针都需要额外的内存空间。</li>\n<li>不是缓存友好(cache-friendly)。由于数组元素是连续位置，因此存在引用的局部性，这在链表中是不存在的。</li>\n<li>遍历和更改指针需要花费大量的时间。</li>\n<li>反向遍历<strong>单链表</strong>是不可能的。</li>\n<li>链表不可能像在数组中那样通过索引直接访问元素。</li>\n<li>所搜一个元素的代价很高，需要 <code>O(n)</code> 时间复杂度。</li>\n<li>链表的排序是十分复杂的，同时花费巨大。</li>\n</ul>\n<h3 id=\"链表的种类\">链表的种类</h3>\n<ul>\n<li>简单链表 (Simple Linked List) -\n只能在一个方向上移动或遍历链表。每个节点的 <code>next</code>\n指针指向其它节点，最后一个节点的 <code>next</code> 指针指向\n<code>NULL</code>。它也被称为“单链表”。</li>\n<li>双链表 (Doubly Linked List) -\n在这种类型的链表中看，可以在两个方向（向前和向后）移动或遍历链表。</li>\n<li>循环链表 (Circular Linked List) - 链表的最后一个节点的\n<code>next</code> 指针指向第一个节点。</li>\n<li>双向循环链表 (Doubly Circular Linked List) -\n这是一种更复杂的链表类型，它包含指向列表中下一个节点和上一个节点的指针。双链表和循环双向链表的区别，与单链表和循环链表的区别一样的。循环双向链表在第一个节点的前一个字段中不包含\n<code>NULL</code>。</li>\n<li>Header Linked List - 它在列表的开头包含一个标题节点。</li>\n</ul>\n<h3 id=\"链表的基本操作\">链表的基本操作</h3>\n<ul>\n<li>Deletion</li>\n<li>Insertion</li>\n<li>Search</li>\n<li>Display</li>\n</ul>\n<h3 id=\"单链表的简单实现\">单链表的简单实现</h3>\n<h4 id=\"c\">C</h4>\n<pre class=\"line-numbers language-C\" data-language=\"C\"><code class=\"language-C\">&#x2F;&#x2F; A linked list node\nstruct Node&#123;\n    int data;\n    struct Node* next;\n&#125;</code></pre>\n<h4 id=\"c-1\">C++</h4>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Node&#123;\npublic:\n    int data;\n    Node* next;\n&#125;</code></pre>\n<h4 id=\"python\">Python</h4>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\"># Node class\nclass Node:\n    # Function to initialize the node object\n    def __init__(self, data):\n        self.data &#x3D; data\t# Assign data\n        self.next &#x3D; Node</code></pre>\n<h3 id=\"遍历链表\">遍历链表</h3>\n<h4 id=\"c-2\">C</h4>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nstruct Node&#123;\n    int data;\n    struct Node* next;\n&#125;;\n\nvoid printList(struct Node* n)&#123;\n    while(n !&#x3D; NULL)&#123;\n        printf(&quot;%d&quot;, n-&gt;data);\n        n &#x3D; n-&gt;next;\n    &#125;\n&#125;\n\nint main()&#123;\n    struct Node* head &#x3D; NULL;\n    struct Node* second &#x3D; NULL;\n    struct Node* third &#x3D; NULL;\n    \n    &#x2F;&#x2F; allocate 3 nodes in the heap\n    head &#x3D; (struct Node*)malloc(sizeof(struct Node));\n    second &#x3D; (struct Node*)malloc(sizeof(struct Node));\n    third &#x3D; (struct Node*)malloc(sizeof(struct Node));\n    \n    head-&gt;data &#x3D; 1;\n    head-&gt;next &#x3D; second;\n    \n    seconde-&gt;data &#x3D; 2;\n    seconde-&gt;next &#x3D; third;\n    \n    third-&gt;data &#x3D; 3;\n    third-&gt;next &#x3D; NULL;\n    \n    prinfList(head);\n    \n    return 0;\n&#125;</code></pre>\n<h4 id=\"c-3\">C++</h4>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">using namespace std;\n\nclass Node&#123;\npublic:\n    int data;\n    Node* next;\n&#125;;\n\nvoid printList(Node* n)&#123;\n    while(n !&#x3D; NULL)&#123;\n        cout &lt;&lt; n-&gt;data &lt;&lt; &quot; &quot;;\n        n &#x3D; n-&gt;next;\n    &#125;\n&#125;\n\nint main()&#123;\n    Node* head &#x3D; NULL;\n    Node* second &#x3D; NULL;\n    Node* third &#x3D; NULL;\n    \n    &#x2F;&#x2F; allocate 3 nodes in the heap\n    head &#x3D; new Node();\n    second &#x3D; new Node();\n    third &#x3D; new Node();\n    \n    head-&gt;data &#x3D; 1;\n    head-&gt;next &#x3D; second;\n    \n    second-&gt;data &#x3D; 2;\n    second-&gt;next &#x3D; third;\n    \n    third-&gt;data &#x3D; 3;\n    third-&gt;next &#x3D; NULL;\n    \n    printList(head);\n    \n    return 0;\n&#125;</code></pre>\n<h4 id=\"python-1\">Python</h4>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">class Node:\n    def __init__(self, data):\n        self.data &#x3D; data\n        self.next &#x3D; None\n        \nclass LinkedList:\n    def __init__(self):\n        self.head &#x3D; None\n       \n    def printList(self):\n        temp &#x3D; self.head\n        while(temp):\n            print(temp.data)\n            temp &#x3D; temp.next\n            \nif __name__ &#x3D;&#x3D; &quot;__main__&quot;:\n    llist &#x3D; LinkedList()\n    \n    llist.head &#x3D; Node(1)\n    second &#x3D; Node(2)\n    third &#x3D; Node(3)\n    \n    llist.head.next &#x3D; second\n    second.next &#x3D; third\n    \n    llist.printList()</code></pre>\n<h3 id=\"链表的应用\">链表的应用</h3>\n<ul>\n<li>链表可以用来实现其它的数据结构，如堆栈和队列</li>\n<li>链表可以用来实现哈希表</li>\n<li>链表可以用来实现图</li>\n</ul>\n<h2 id=\"链表的操作traverse-insert-and-delete\">链表的操作：Traverse,\nInsert and Delete</h2>\n<ul>\n<li>Traversal - 访问链表的每一个元素</li>\n<li>Insertion - 添加一个新的元素到链表中</li>\n<li>Deletion - 删除一个已有元素</li>\n<li>Search - 在链表中找到一个节点</li>\n<li>Sort - 对链表的节点进行排序</li>\n</ul>\n<h3 id=\"遍历一个链表\">遍历一个链表</h3>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">struct node *temp &#x3D; head;\nprintf(&quot;\\n\\nList elements are - \\n&quot;);\nwhile(temp !&#x3D; NULL)&#123;\n    printf(&quot;%d ---&gt;&quot;, temp-&gt;data);\n    temp &#x3D; temp-&gt;next;\n&#125;</code></pre>\n<h3 id=\"插入一个元素到链表中\">插入一个元素到链表中</h3>\n<ol type=\"1\">\n<li>在开头插入</li>\n</ol>\n<ul>\n<li>为新节点分配内存</li>\n<li>存入数据</li>\n<li>新节点的 <code>next</code> 指向 <code>head</code></li>\n<li>更改 <code>head</code> 指向最新创建的节点</li>\n</ul>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">struct node *newNode;\nnewNode &#x3D; malloc(sizeof(struct node));\nnewNode-&gt;data &#x3D; 4;\nnewNode-&gt;next &#x3D; head;\nhead &#x3D; newNode;</code></pre>\n<ol start=\"2\" type=\"1\">\n<li>在末尾插入</li>\n</ol>\n<ul>\n<li>为新节点分配内存</li>\n<li>存入数据</li>\n<li>遍历到最后一个节点</li>\n<li>更改最后一个节点的 <code>next</code> 指向最新的节点</li>\n</ul>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">struct node *newNode;\nnewNode &#x3D; malloc(sizeof(struct node));\nnewNode-&gt;data &#x3D; 4;\nnewNode-&gt;next &#x3D; NULL;\n\nstruct node *temp &#x3D; head;\nwhile(temp-&gt;next !&#x3D; NULL)&#123;\n    temp &#x3D; temp-&gt;next;\n&#125;\ntemp-&gt;next &#x3D; newNode</code></pre>\n<ol start=\"3\" type=\"1\">\n<li>在中间插入</li>\n</ol>\n<ul>\n<li>为新节点分配内存</li>\n<li>存入数据</li>\n<li>遍历到新节点存入位置之前的节点</li>\n<li>更改 <code>next</code> 指针</li>\n</ul>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">struct node *newNode;\nnewNode &#x3D; malloc(sizeof(struct node));\nnewNode-&gt;data &#x3D; 4;\n\nstruct node *temp &#x3D; head;\nfor(int i &#x3D; 2; i &lt; position; i++)&#123;\n    if(temp-&gt;next !&#x3D; NULL)&#123;\n        temp &#x3D; temp-&gt;next;\n    &#125;\n&#125;\nnewNode-&gt;next &#x3D; temp-&gt;next;\ntemp-&gt;next &#x3D; newNode;</code></pre>\n<h3 id=\"从链表中删除一个节点\">从链表中删除一个节点</h3>\n<ol type=\"1\">\n<li>删除头节点</li>\n</ol>\n<ul>\n<li>将 <code>head</code> 指向第二个节点</li>\n</ul>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">head &#x3D; head-&gt;next;</code></pre>\n<ol start=\"2\" type=\"1\">\n<li>删除末尾的节点</li>\n</ol>\n<ul>\n<li>遍历到倒数第二个元素</li>\n<li>将它的 <code>next</code> 指针指向 <code>NULL</code></li>\n</ul>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">struct node* temp &#x3D; head;\nwhile(temp-&gt;next-&gt;next !&#x3D; NULL)&#123;\n    temp &#x3D; temp-&gt;next;\n&#125;\ntemp-&gt;next &#x3D; NULL;</code></pre>\n<ol start=\"3\" type=\"1\">\n<li>删除中间的节点</li>\n</ol>\n<ul>\n<li>遍历到要删除节点之前的节点</li>\n<li>更改其 <code>next</code> 指针， 将要删除的节点从链表中排除</li>\n</ul>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">for(int i &#x3D; 2; i &lt; position; i++)&#123;\n    if(temp-&gt;next !&#x3D; NULL)&#123;\n        temp &#x3D; temp-&gt;next;\n    &#125;\n&#125;\ntemp-&gt;next &#x3D; temp-&gt;next-&gt;next;</code></pre>\n<h3 id=\"在链表中搜索一个元素\">在链表中搜索一个元素</h3>\n<ul>\n<li>将 <code>head</code> 作为 <code>current</code> 节点</li>\n<li>运行一个循环，直到 <code>current</code> 节点是\n<code>NULL</code>，因为最后一个节点指向 <code>NULL</code></li>\n<li>在每次迭代中，检测节点是否等于 <code>item</code>。如果与\n<code>item</code> 匹配，则返回 <code>true</code>，否则返回\n<code>false</code>。</li>\n</ul>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">bool searchNode(struct Node** head_ref, int key)&#123;\n    struct Node* current &#x3D; *head_ref;\n    \n    while(current !&#x3D; NULL)&#123;\n        if(current-&gt;data &#x3D;&#x3D; key) return true;\n        current &#x3D; current-&gt;next;\n    &#125;\n    return false;\n&#125;</code></pre>\n<h3 id=\"链表元素排序\">链表元素排序</h3>\n<p>冒泡排序：</p>\n<ol type=\"1\">\n<li>将 <code>head</code> 作为 <code>current</code> 节点，并创建一个\n<code>index</code> 节点备用。</li>\n<li>如果 <code>head</code> 是空，则返回。</li>\n<li>否则，运行一个循环直到以后一个节点。</li>\n<li>在每次迭代中依次执行 5-6 步。</li>\n<li>存储 <code>current</code> 的下一个节点在 <code>index</code>\n中。</li>\n<li>检查 <code>current</code>\n节点的数据是否大于下一个节点的。如果是，则交换 <code>current</code> 和\n<code>index</code>。</li>\n</ol>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">void sortLinkedList(struct Node** head_ref)&#123;\n    struct Node *current &#x3D; *head_ref, *index &#x3D; NULL;\n    int temp;\n    \n    if(head_ref &#x3D;&#x3D; NULL)&#123;\n        return;\n    &#125;else&#123;\n        while(current !&#x3D; NULL)&#123;\n            &#x2F;&#x2F; index points to the node next to current\n            index &#x3D; current-&gt;next;\n            \n            while(index !&#x3D; NULL)&#123;\n                if(current-&gt;data &gt; index-&gt;data)&#123;\n                    temp &#x3D; current-&gt;data;\n                    current-&gt;data &#x3D; index-&gt;data;\n                    index-&gt;data &#x3D; temp;\n                &#125;\n                index &#x3D; index-&gt;next;\n            &#125;\n            current &#x3D; current-&gt;next;\n        &#125;\n    &#125;\n&#125;</code></pre>\n<h3 id=\"python-2\">Python</h3>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\"># Linked list operations in Python\n\n# create a node\nclass Node:\n    def __init__(self, data):\n        self.data &#x3D; data\n        self.next &#x3D; None\n\nclass LinkedList:\n    def __init__(self):\n        self.head &#x3D; None\n        \n    # Insert at the begining\n    def insertAtBegining(self, new_data):\n        new_node &#x3D; Node(new_data)\n        \n        new_node.next &#x3D; self.head\n        self.head &#x3D; new_node\n    \n    # Insert after a node\n    def insertAfter(self, prev_node, new_data):\n        if prev_node is None:\n            print(&quot;The given previous node must inLinkedList.&quot;)\n            return\n        new_node &#x3D; Node(new_data)\n        new_node.next &#x3D; prev_node.next\n        prev_node.next &#x3D; new_node\n    # Insert at the end\n    def insertAtEnd(self, new_data):\n        new_node &#x3D; Node(new_data)\n        \n        if self.head is None:\n            self.head &#x3D; new_node\n            return\n        \n        last &#x3D; self.head\n        while(last.next):\n            last &#x3D; last.next\n        \n        last.next &#x3D; new_node\n        \n    # Deleting a node\n    def deleteNode(self, position):\n        if self.head is None:\n            return\n        \n        temp &#x3D; self.head\n        \n        if position &#x3D;&#x3D; 0:\n            self.head &#x3D; temp.next\n            temp &#x3D; None\n            return\n        \n        # Find the key to be deleted\n        for i in range(position - 1):\n            temp &#x3D; temp.next\n            if temp is None:\n                break\n        \n        # If the key is not present\n        if temp is None:\n            return \n        \n        if temp.next is None:\n            return\n        \n        next &#x3D; temp.next.next\n        temp.next &#x3D; None\n        temp.next &#x3D; next\n    \n    # Search an element\n    def search(self, key):\n        current &#x3D; self.head\n        \n        while current is not None:\n            if current.data &#x3D;&#x3D; key:\n                return True\n            \n            current &#x3D; current.next\n        \n        return False\n    \n    # Sort the linked list\n    def sortLinkedList(self, head):\n        current &#x3D; head\n        index &#x3D; Node(None)\n        \n        if head is None:\n            return\n        else:\n            while current is not None:\n                # index points to the node next to current \n                index &#x3D; current.next\n                \n                while index is not None:\n                    if current.data &gt; index.data:\n                        current.data, index.data &#x3D; index.data, current.data\n                    index &#x3D; index.next\n                current &#x3D; current.next\n\n    # Print the linked list\n    def printList(self):\n        temp &#x3D; self.head\n        while(temp):\n            print(str(temp.data) + &quot; &quot;, end&#x3D;&quot;&quot;)\n            temp &#x3D; temp.next\n\nif __name__ &#x3D;&#x3D; &#39;__main__&#39;:\n    llist &#x3D; LinkedList()\n    llist.insertAtEnd(1)\n    llist.insertAtBeginning(2)\n    llist.insertAtBeginning(3)\n    llist.insertAtEnd(4)\n    llist.inserAfter(llist.head.next, 5)\n    \n    print(&quot;linked list: &quot;)\n    llist.printList()\n    \n    print(&quot;\\nAfter deleting an element:&quot;)\n    llist.deleteNode(3)\n    llist.printList()\n    \n    print()\n    item_to_find &#x3D; 3\n    if llist.search(item_to_find):\n        print(str(item_to_find) + &quot;is found&quot;)\n    else:\n        print(str(item_to_find) + &quot;is not found&quot;)\n        \n    llist.sortLinkedList(llist.head)\n    print(&quot;Sorted List: &quot;)\n    llist.printList()</code></pre>\n<h3 id=\"c-4\">C</h3>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nstruct Node&#123;\n    int data;\n    struct Node* next;\n&#125;;\n\n&#x2F;&#x2F; Insert at the beginning\nvoid insertAtBeginning(struct Node** head_ref, int new_data)&#123;\n    &#x2F;&#x2F; Allocate memory to a node\n    struct Node* new_node &#x3D; (struct Node*)malloc(sizeof(struct Node));\n    \n    &#x2F;&#x2F; insert the data\n    new_node-&gt;data &#x3D; new_data;\n    new_node-&gt;next &#x3D; (*head_ref);\n    \n    &#x2F;&#x2F; Move head to new node\n    (*head_ref) &#x3D; new_node;\n&#125;\n\n&#x2F;&#x2F; Insert a node after a node\nvoid insertAfter(struct Node* prev_node, int new_data)&#123;\n    if(prev_node &#x3D;&#x3D; NULL)&#123;\n        printf(&quot;the given previous node cannot be NULL&quot;);\n        return;\n    &#125;\n    struct Node* new_node &#x3D; (struct Node*)malloc(sizeof(struct Node));\n    new_node-&gt;data &#x3D; new_data;\n    new_node-&gt;next &#x3D; prev_node-&gt;next;\n    prev_node-&gt;next &#x3D; new_node;\n&#125;\n\n&#x2F;&#x2F; Insert the end\nvoid insertAtEnd(struct Node** head_ref, int new_data)&#123;\n    struct Node* new_node &#x3D; (struct Node*)malloc(sizeof(struct Node));\n    struct Node* last &#x3D; *head_ref;\n    \n    new_node-&gt;data &#x3D; new_data;\n    new_node-&gt;next &#x3D; NULL;\n    \n    if(*head_ref &#x3D;&#x3D; NULL)&#123;\n        *head_ref &#x3D; new_node;\n        return;\n    &#125;\n    while(last-&gt;next !&#x3D; NULL) last &#x3D; last-&gt;next;\n    last-&gt;next &#x3D; new_node;\n    return;\n&#125;\n\n&#x2F;&#x2F; Delete a node\nvoid deleteNode(struct Node** head_ref, int key)&#123;\n    struct Node *temp &#x3D; *head_ref, *prev;\n    \n    if(temp !&#x3D; NULL &amp;&amp; temp-&gt;data &#x3D;&#x3D; key)&#123;\n        *head_ref &#x3D; temp-&gt;next;\n        free(temp);\n        return;\n    &#125;\n    &#x2F;&#x2F; Find the key to be deleted\n    while(temp !&#x3D; NULL &amp;&amp; temp-&gt;data !&#x3D; key)&#123;\n        prev &#x3D; temp;\n        temp &#x3D; temp-&gt;next;\n    &#125;\n    \n    &#x2F;&#x2F; If the key is not present\n    if(temp &#x3D;&#x3D; NULL) return;\n    \n    &#x2F;&#x2F; Remove the node\n    prev-&gt;next &#x3D; temp-&gt;next;\n    free(temp);\n&#125;\n\n&#x2F;&#x2F; Search a node\nint searchNode(struct Node** head_ref, int key)&#123;\n    struct Node* current &#x3D; *head_ref;\n    \n    while(current !&#x3D; NULL)&#123;\n        if (current-&gt;data &#x3D;&#x3D; key) return 1;\n        current &#x3D; current-&gt;next;\n    &#125;\n    return 0;\n&#125;\n\n&#x2F;&#x2F; Sort the linked list\nvoid sortLinkedList(struct Node** head_ref)&#123;\n    struct Node* current &#x3D; *head_ref, *index &#x3D; NULL;\n    int temp;\n    if(head_ref &#x3D;&#x3D; NULL)&#123;\n        return;\n    &#125;else&#123;\n        while(current !&#x3D; NULL)&#123;\n            index &#x3D; current-&gt;next;\n            \n            while(index !&#x3D; NULL)&#123;\n                if(current-&gt;data &gt; index-&gt;data)&#123;\n                    temp &#x3D; current-&gt;data;\n                    current-&gt;data &#x3D; index-&gt;data;\n                    index-&gt;data &#x3D; temp;\n                &#125;\n                index &#x3D; index-&gt;next;\n           &#125;\n            current &#x3D; current-&gt;next;\n        &#125;\n    &#125;\n&#125;\n\n&#x2F;&#x2F; Print the linked list\nvoid printList(struct Node* node)&#123;\n    while(node !&#x3D; NULL)&#123;\n        printf(&quot; %d &quot;, node-&gt;data);\n        node &#x3D; node-&gt;next;\n    &#125;\n&#125;\n\nint main()&#123;\n    struct Node* head &#x3D; NULL;\n    \n    insertAtEnd(&amp;head, 1);\n    insertAtBeginning(&amp;head, 2);\n    insertAtBeginning(&amp;head, 3);\n    insertAtEnd(&amp;head, 4);\n    insertAfter(head-&gt;next, 5);\n    \n    printf(&quot;Linked list: &quot;);\n    printList(head);\n    \n    printf(&quot;\\nAfter deleting an element: &quot;);\n    deleteNode(&amp;head, 3);\n    printList(head);\n    \n    int item_to_find &#x3D; 3;\n    if(searchNode(&amp;head, item_to_find))&#123;\n        printf(&quot;\\n%d is found&quot;, item_to_find);\n    &#125;else&#123;\n        printf(&quot;\\n%d is not found&quot;, item_to_find);\n    &#125;\n    \n    sortLinkedList(&amp;head);\n    printf(&quot;\\nSorted List: &quot;);\n    printList(head);\n&#125;\n</code></pre>\n","text":"链表 linked list 什么是链表 链表是数据元素的线性集合，其顺序不是由它们在内存中的物理位置给出的。每个元素都指向下一个元素。它是一种数据结构，由一组节点组成，这些节点共同表示一个序列。在其最基本的形式中，每个节点都包含：数据和指向序列中下一个节点的指针（链接）。这种结...","link":"","photos":[],"count_time":{"symbolsCount":"15k","symbolsTime":"14 mins."},"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","count":1,"path":"api/categories/数据结构与算法.json"}],"tags":[{"name":"计算机","slug":"计算机","count":1,"path":"api/tags/计算机.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E9%93%BE%E8%A1%A8-linked-list\"><span class=\"toc-text\">链表 linked list</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E9%93%BE%E8%A1%A8\"><span class=\"toc-text\">什么是链表</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E9%93%BE%E8%A1%A8\"><span class=\"toc-text\">为什么要使用链表？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%93%BE%E8%A1%A8%E7%9B%B8%E5%AF%B9%E4%BA%8E%E6%95%B0%E7%BB%84%E7%9A%84%E4%BC%98%E7%82%B9\"><span class=\"toc-text\">链表相对于数组的优点</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%93%BE%E8%A1%A8%E7%9A%84%E7%BC%BA%E7%82%B9\"><span class=\"toc-text\">链表的缺点</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%93%BE%E8%A1%A8%E7%9A%84%E7%A7%8D%E7%B1%BB\"><span class=\"toc-text\">链表的种类</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%93%BE%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">链表的基本操作</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">单链表的简单实现</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#c\"><span class=\"toc-text\">C</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#c-1\"><span class=\"toc-text\">C++</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#python\"><span class=\"toc-text\">Python</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%81%8D%E5%8E%86%E9%93%BE%E8%A1%A8\"><span class=\"toc-text\">遍历链表</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#c-2\"><span class=\"toc-text\">C</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#c-3\"><span class=\"toc-text\">C++</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#python-1\"><span class=\"toc-text\">Python</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%93%BE%E8%A1%A8%E7%9A%84%E5%BA%94%E7%94%A8\"><span class=\"toc-text\">链表的应用</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%93%BE%E8%A1%A8%E7%9A%84%E6%93%8D%E4%BD%9Ctraverse-insert-and-delete\"><span class=\"toc-text\">链表的操作：Traverse,\nInsert and Delete</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%81%8D%E5%8E%86%E4%B8%80%E4%B8%AA%E9%93%BE%E8%A1%A8\"><span class=\"toc-text\">遍历一个链表</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%8F%92%E5%85%A5%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0%E5%88%B0%E9%93%BE%E8%A1%A8%E4%B8%AD\"><span class=\"toc-text\">插入一个元素到链表中</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%8E%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%88%A0%E9%99%A4%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9\"><span class=\"toc-text\">从链表中删除一个节点</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9C%A8%E9%93%BE%E8%A1%A8%E4%B8%AD%E6%90%9C%E7%B4%A2%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0\"><span class=\"toc-text\">在链表中搜索一个元素</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\">链表元素排序</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#python-2\"><span class=\"toc-text\">Python</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#c-4\"><span class=\"toc-text\">C</span></a></li></ol></li></ol></li></ol>","author":{"name":"爱慢跑的乌龟","slug":"blog-author","avatar":"/img/avatar1.jpg","link":"/","description":"求知若饥，虚心若愚！","socials":{"github":"https://github.com/ansonxu1998","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"FreeRTOS 的任务 (Task)","uid":"01ed63026d9bc8723f828c17bac96fdf","slug":"FreeRTOS/Task","date":"2023-04-23T09:13:00.000Z","updated":"2023-04-23T09:24:55.803Z","comments":true,"path":"api/articles/FreeRTOS/Task.json","keywords":null,"cover":"/img/FreeRTOS/logo.jpg","text":"FreeRTOS 的任务 (Task) FreeRTOS 是由 Real Time Engineers 公司独家拥有、开发和维护的。Real Time Engineers 公司已经与世界领先的芯片公司密切合作了十多年，为您提供屡获殊荣的商业级和完全免费的高质量软件。 FreeRT...","link":"","photos":[],"count_time":{"symbolsCount":"20k","symbolsTime":"18 mins."},"categories":[{"name":"嵌入式","slug":"嵌入式","count":1,"path":"api/categories/嵌入式.json"}],"tags":[{"name":"FreeRTOS","slug":"FreeRTOS","count":1,"path":"api/tags/FreeRTOS.json"}],"author":{"name":"爱慢跑的乌龟","slug":"blog-author","avatar":"/img/avatar1.jpg","link":"/","description":"求知若饥，虚心若愚！","socials":{"github":"https://github.com/ansonxu1998","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"CAN 总线协议","uid":"386d227c4f88ed4186d8b0b65da86630","slug":"Communication Protocol/CAN 总线","date":"2023-04-01T09:02:00.000Z","updated":"2023-04-15T03:21:50.770Z","comments":true,"path":"api/articles/Communication Protocol/CAN 总线.json","keywords":null,"cover":"/img/CAN/CAN.jpg","text":"CAN 总线协议 Controller Area Network (CAN bus) 是一种车辆总线标准，允许为控制器和设备在没有主机的情况下与彼此的应用程序进行通信（没有主从关系）。它是一种基于消息的协议，最初设计用于汽车内的多路复用电线以节省铜线，但它也可以许多其他情况。对于...","link":"","photos":[],"count_time":{"symbolsCount":"12k","symbolsTime":"11 mins."},"categories":[{"name":"通信协议","slug":"通信协议","count":2,"path":"api/categories/通信协议.json"}],"tags":[{"name":"CAN 总线","slug":"CAN-总线","count":1,"path":"api/tags/CAN-总线.json"}],"author":{"name":"爱慢跑的乌龟","slug":"blog-author","avatar":"/img/avatar1.jpg","link":"/","description":"求知若饥，虚心若愚！","socials":{"github":"https://github.com/ansonxu1998","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}