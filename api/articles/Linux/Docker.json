{"title":"Docker","uid":"a48e6dda0c21e40880cba7e763278b04","slug":"Linux/Docker","date":"2022-04-24T16:00:00.000Z","updated":"2023-04-15T05:27:17.837Z","comments":true,"path":"api/articles/Linux/Docker.json","keywords":null,"cover":"/img/docker/docker_logo.jpg","content":"<h1 id=\"docker\">Docker</h1>\n<ul>\n<li><a href=\"https://www.docker.com/get-started\">官方文档地址</a></li>\n<li><a\nhref=\"https://docker_practice.gitee.io/zh-cn\">中文参考手册</a></li>\n</ul>\n<hr />\n<h2 id=\"什么是docker\">1.什么是Docker</h2>\n<h3 id=\"官方定义\">1.1 官方定义</h3>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><blockquote>\n<p>官方介绍</p></blockquote>\n<ul>\n<li>We have a vomplete container solution for you - no matter who you\nare where you are on your containeriztion jouery.</li>\n<li>翻译：我们为你提供一个完整的容器解决方案，不管你是谁，无论你在哪，你都可以可是容器的旅程。</li>\n<li>官方定义：docker 是一个容器技术</li>\n</ul>\n</blockquote>\n<h3 id=\"docker-的起源\">1.2 Docker 的起源</h3>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>Docker 最初是 dotCloud 公司创始人 Solomon Hykes\n在法国期间发起的一个公司内部项目，它是基于dotCloud\n公司多年云服务技术的一次革新，并于 2013年 3月以Apache 2.0\n授权协议开源，主要项目代码在 Github 上进行维护。Docker 项目后来还加入\nLinux 基金会，并成功推动 开放容器联盟(OCI)。</p>\n<p>Docker 自开源后受到了广泛的关注和讨论，至今其 Github 项目已经超过 5万\n7千个星标和一万多个 fork。甚至由于Docker 项目火爆，在 2013\n年底，dotCloud 公司决定改名为 Docker。 Docker 最初是在 Ubuntu 12.04\n上开发实现的；Red Hat 则从 RHEL.6.5 开始对 Docker 进行支持；Google\n也在其 PaaS 产品中广泛应用 Docker。</p>\n<p>Docer 使用 Google 公司推出的 Go 语言进行开发实现，基于 Linux 内核的\ncgroup， namespace，以及 OverlayFS\n类等技术，对进程进行封装隔离，属于操作系统层面的虚拟化技术。由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。</p></blockquote>\n<h2 id=\"为什么是docker\">2. 为什么是Docker</h2>\n<ul>\n<li><p><code>在开发的时候，在本机测试环境可以跑，生成环境跑不起来</code></p>\n<p>这里我们拿 java Web 应用程序举例，我们一个 java Web\n应用程序涉及的东西很多，比如\njdk、tomcat、mysql等软件环境。当这些其中某一项版本不一致的时候，可能就会导致应用程序跑不起来这种情况。Docker\n则将程序以及使用的软件环境直接打包在一起，无论在哪个机器上都保证了环境一致。</p>\n<p><strong>优势1：一致的运行环境，更轻松的迁移</strong></p></li>\n<li><p><code>服务器自己的程序挂了，结果发现是别人程序出了问题把内存吃完了，自己的程序因为内存不够就挂了</code></p>\n<p>这种也是一种比较常见的情况，如果你的程序重要性不是特别高的话，公司基本上不可能让你的程序独享一台服务器，这时候你的服务器就会跟公司其他人的程序共享一台服务器，所以不可避免地就会受到其他程序的干扰，导致自己的程序出现问题。Docker\n就很好解决了环境隔离的问题，别人的程序不会影响到自己的程序。</p>\n<p><strong>优势2：对进程进行封装隔离，容器与容器之间互不影响，更高效的利用系统资源</strong></p></li>\n<li><p><code>公司要弄一个活动，可能会有大量的流量进来，公司需要部署几十台服务器</code></p>\n<p>在没有 Docker\n的情况下，要在几天内部署几十台服务器，这对运维来说是一件非常折磨人的事，而且每台服务器的环境还不一定一样，就会出现各种问题。用\nDocker\n的话，只需要将程序打包到镜像，需要多少台服务器，就跑多少容器，极大地提高了部署效率。</p>\n<p><strong>优势3：通过镜像复制N多个环境一致的容器</strong></p></li>\n</ul>\n<h2 id=\"docker-和虚拟机的区别\">3. Docker 和虚拟机的区别</h2>\n<figure>\n<img src=\"/img/docker/Docker.png\" alt=\"Docker\" />\n<figcaption aria-hidden=\"true\">Docker</figcaption>\n</figure>\n<p>虚拟机是携带操作系统的，本身很小的应用却因为携带了操作系统而变得非常大，很笨重。Docker\n是不携带操作系统的，所以 Docker\n的应用就非常的轻巧。另外，在调用宿主机的CPU、磁盘等等资源的时候，拿内存举例，虚拟机时利用\nHypervisor 去虚拟化内存，整个调用过程时虚拟内存 -&gt; 虚拟物理内存 -&gt;\n真正物理内存，但是 Docker 是利用Docker Engine\n去调用宿主机的资源，这个过程是 虚拟内存 -&gt; 真正物理内存。</p>\n<table>\n<colgroup>\n<col style=\"width: 15%\" />\n<col style=\"width: 42%\" />\n<col style=\"width: 41%\" />\n</colgroup>\n<thead>\n<tr class=\"header\">\n<th></th>\n<th>传统虚拟机</th>\n<th>Docker 容器</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>磁盘占用</td>\n<td>几个GB到几十个GB</td>\n<td>几十MB到几百MB</td>\n</tr>\n<tr class=\"even\">\n<td>CPU　内存占用</td>\n<td>虚拟操作系统非常占用CPU和内存</td>\n<td>Docker 引擎占用极低</td>\n</tr>\n<tr class=\"odd\">\n<td>启动速度</td>\n<td>几分钟</td>\n<td>几秒</td>\n</tr>\n<tr class=\"even\">\n<td>安装管理</td>\n<td>需要专门的运维技术</td>\n<td>安装、管理方便</td>\n</tr>\n<tr class=\"odd\">\n<td>应用部署</td>\n<td>每次部署都费时费力</td>\n<td>从第二次部署开始轻松简洁</td>\n</tr>\n<tr class=\"even\">\n<td>耦合性</td>\n<td>多个应用服务安装到一起，容易相互影响</td>\n<td>每个应用服务一个容器，达到隔离</td>\n</tr>\n<tr class=\"odd\">\n<td>系统依赖</td>\n<td>无</td>\n<td>需求相同或相似的内核，目前推荐Linux</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"docker-的安装\">4. Docker 的安装</h2>\n<h3 id=\"安装-dockercentos-7.x\">4.1 安装 docker(centos 7.x)</h3>\n<ul>\n<li><p>卸载原始 Docker</p>\n<pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\">$ sudo yum remove docker \\\n\t\t\t\t  docker-client \\\n\t\t\t\t  docker-client-latest \\\n\t\t\t\t  docker-common \\\n\t\t\t\t  docker-latest \\\n\t\t\t\t  docker-latest-logrotate \\\n\t\t\t\t  docker-logrotate \\\n\t\t\t\t  docker-engine</code></pre></li>\n<li><p>安装 docker 依赖</p>\n<pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\">$ sudo yum install -y yum-utils \\\n  device-mapper-persistent-data \\\n  lvm2</code></pre></li>\n<li><p>设置 docker 的 yum 源</p>\n<pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\">$ sudo yum-config-manager \\\n\t--add-repo \\\n\thttps:&#x2F;&#x2F;download.docker.com&#x2F;linux&#x2F;centos&#x2F;docker-ce.repo</code></pre></li>\n<li><p>安装最新版的 docker</p>\n<pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\">$ sudo yum install docker-ce docker-cecli containerd.io</code></pre></li>\n<li><p>指定版本安装 docker</p>\n<pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\">$ yum install docker-ce --showduplicates | sort -r\n$ yum install docker-ce-&lt;VERSION_STRING&gt; docker-ce-cli-&lt;VERSION_STRING&gt; containerd.io\n$ yum install docker-ce-18.09.5-3.e17 docker-ce-cli-18.09.5-3.e17 containerd.io</code></pre></li>\n<li><p>启动 docker</p>\n<pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\">$ sudo systemctl enable docker\n$ sudo systemctl start docker</code></pre></li>\n<li><p>关闭 docker</p>\n<pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\">$ sudo systemctl stop docker</code></pre></li>\n<li><p>测试 docker 安装</p>\n<pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\">$ sudo docker run hello-world</code></pre></li>\n</ul>\n<h3 id=\"bash-安装通用所有平台\">4.2 bash 安装(通用所有平台)</h3>\n<pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\">$ curl -fsSL get.docker.com -o get-docker.sh\n$ sudo sh get-docker.sh --mirror Aliyun</code></pre>\n<ul>\n<li><p>启动 docker</p>\n<pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\">$ sudo systemctl enable docker\n$ sudo systemctl start doecker</code></pre></li>\n<li><p>创建 docker 用户组</p>\n<pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\">$ sudo groupadd docker</code></pre></li>\n<li><p>当前的用户加入 docker 组</p>\n<pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\">$ sudo usermod -aG docker $USER</code></pre></li>\n<li><p>测试 docker 安装是否正确</p>\n<pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\">$ docker run hello-world</code></pre></li>\n</ul>\n<h2 id=\"docker-的核心架构\">5. Docker 的核心架构</h2>\n<ol type=\"1\">\n<li><p>镜像 image 复数 images</p>\n<p>定义：一个镜像代表着一个软件 如：MySQL镜像 redis镜像\nnginx镜像····</p></li>\n<li><p>容器 container</p>\n<p>定义：基于某个镜像运行一次就会生成一个程序实例，一个实例称之为一个容器</p>\n<p>特点：可读、可写</p></li>\n<li><p>仓库 repository</p>\n<p>定义：用来存储 docker 中的所有镜像</p>\n<p>远程仓库：docker 官方维护的一个唯一的远程仓库</p>\n<p>本地仓库：当前机器的镜像存储位置</p></li>\n</ol>\n<figure>\n<img src=\"/img/docker/dockerKernel.jpg\" alt=\"dockerKernel\" />\n<figcaption aria-hidden=\"true\">dockerKernel</figcaption>\n</figure>\n<h2 id=\"镜像的相关操作\">6. 镜像的相关操作</h2>\n<h3 id=\"辅助命令\">6.1 辅助命令</h3>\n<pre class=\"line-numbers language-markdown\" data-language=\"markdown\"><code class=\"language-markdown\"># 1. 安装完成辅助命令\n\tdocker version\t---------------------\t查看 docker 的信息\n\tdocker info\t\t---------------------\t查看更详细的信息\n\tdocker --help \t---------------------\t帮助命令</code></pre>\n<h3 id=\"images-镜像命令\">6.2 Images 镜像命令</h3>\n<pre class=\"line-numbers language-markdown\" data-language=\"markdown\"><code class=\"language-markdown\"># 1. 查看本机中所有镜像\n\tdocker images\t------------------------\t列出本地所有镜像\n\t\t-a\t列出所有镜像\n\t\t-q\t只显示镜像 id\n# 2. 搜素镜像\n\tdocker search [options] 镜像名 -----------\t去 dockerhub 上查询当前镜像\n\t\t-s\t指定值\t\t列出收藏数不少于指定值的镜像\n\t\t--no-trunc\t  显示完整的镜像信息\n# 3. 从仓库下载镜像\n\tdocker pull 镜像名[:TAG|@DIGEST] ----------\t下载镜像\n# 4. 删除镜像\n\tdocker rmi 镜像名  -----------------------\t 删除镜像\n\t\t-f\t强制删除\n# 5. 载入镜像\n\tdocker load -i xxx.tar</code></pre>\n<h3 id=\"contrainer-容器命令\">6.3 Contrainer 容器命令</h3>\n<pre class=\"line-numbers language-markdown\" data-language=\"markdown\"><code class=\"language-markdown\"># 1. 运行容器\n\tdocker run 镜像名\t---------------\t镜像名新建并启动容器\n\t--name\t\t为容器起一个名字\n\t-d\t\t\t启动守护容器（在后台启动容器）\n\t-p\t\t\t映射端口号：原始端口号\t\t指定端口号启动\n# 2. 查看运行的容器\n\tdocker ps\t---------------------\t列出所有正在运行的容器\n\t-a\t\t\t正在运行的和历史运行的容器\n\t-q\t\t\t静默模式，只显示容器编号\n# 3. 停止|关闭|重启容器\n\tdocker start 容器名称或容器ID\t---------- 开启容器\n\tdocker restart 容器名或容器ID\t----------- 重启容器\n\tdocker stop 容器名或容器ID\t----------- 正常停止容器\n\tdocker kill 容器名或容器ID\t----------- 立即停止容器运行\n# 4. 删除容器\n\tdocker rm 容器名称|容器ID\t\t----------- 删除停止的容器\n\t-f\t\t删除正在运行的容器\n# 5. 查看容器内进程\n\tdocker top\t容器名称|容器ID\t----------- 查看容器内进程\n# 6. 查看容器内部细节\n\tdocker inspect\t容器名称|容器ID\t----------- 查看容器内部细节\n# 7. 查看运行日志\n\tdocker logs [OPTIONS] 容器名称|容器ID\t----------- 查看容器内进程\n\t-t\t\t加入时间戳\n\t-f\t\t跟随最新的日志打印\n\t--tail\t数字\t显示最后多少条\n# 8. 进入容器\n\tdocker exec -it\t容器名称|容器ID bash\t--------- 进入容器bash，与容器交互\n\t退出容器\texit\n# 9. 操作系统与容器的文件传输\n\t从容器到操作系统：\tdocker cp 容器ID:容器内资源路径 \t操作系统路径\n\t从操作系统到容器：\tdocker cp 文件|目录\t容器ID：容器路径\n# 10. 数据卷(volum)实现与宿主机共享目录\n\tdocker run -v 宿主机的路径|任意别名:&#x2F;容器内的路径\t\t镜像名\n\tdocker run -v 宿主机的路径|任意别名:&#x2F;容器内的路径:ro\t镜像名\n\tro：镜像只读\n\t\t注意：\n\t\t\t1. 如果是宿主机类路径必须是绝对路径，宿主机目录会覆盖容器内目录内容\n\t\t\t2. 如果是别名则会在docker运行容器时自动在宿主机中创建一个目录，并将容器目录文件复制到宿主机中\n# 11. 打包镜像\n\tdocker save 镜像名\t-o 名称.tar\n# 12. 载入镜像\n\tdocker load -i 名称.tar\n# 13. 容器打包成新的镜像\n\tdocker commit -m &quot;描述信息&quot; -a &quot;作者信息&quot;\t（容器ID或名称） 打包的镜像的名称：标签</code></pre>\n<h2 id=\"dokcer-中容器之间的网络配置\">7. Dokcer 中容器之间的网络配置</h2>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>Docker 允许通过外部访问容器或容器互联的方式来提供网络服务</p></blockquote>\n<h3 id=\"docker-容器与操作系统通信机制\">7.1 docker\n容器与操作系统通信机制</h3>\n<p>当 Docker 启动时，会自动在主机上创建一个 <code>docker0</code>\n虚拟网桥，实际上是 Linux 的一个\nbridge，可以理解为一个软件交换机。它会在挂载到它的网口之间进行转发。</p>\n<p>同时，Docker 随机分配一个本地未占用的私有网段（在 <a\nhref=\"https://datatracker.ietf.org/doc/html/rfc1918\">RFC1918</a>中定义）中的一个地址给\n<code>docker0</code> 接口。比如典型的 <code>172.17.0.1</code>，掩码为\n<code>255.255.0.0</code>。此后启动的容器内的网口也会自动分配一个同一网段（<code>172.17.0.0/16</code>）的地址。</p>\n<figure>\n<img src=\"/img/docker/netDokcer0.PNG\" alt=\"netDocker0\" />\n<figcaption aria-hidden=\"true\">netDocker0</figcaption>\n</figure>\n<p>当创建一个 Docker 容器的时候，同时会创建了一对 <code>veth pair</code>\n接口（当数据包发送到一个接口时，另外一个接口也可以收到相同的数据包）。这对接口一端在容器内，即\n<code>eth0</code>；另一端在本地并被挂载到 <code>docker0</code>\n网桥，名称以 <code>veth</code> 开头（例如\n<code>vethAQI2QT</code>）。通过这种方式，主机可以跟容器通信，容器之间也可以相互通信。Docker\n就创建了在主机和所有容器之间一个虚拟共享网络。</p>\n<figure>\n<img src=\"/img/docker/docker0.png\" alt=\"docker0\" />\n<figcaption aria-hidden=\"true\">docker0</figcaption>\n</figure>\n<h3 id=\"docker-网络使用\">7.2 Docker 网络使用</h3>\n<p>注意：一般在使用 docker 网桥(bridge)\n实现容器与容器通信时，都是站在一个应用的角度进行容器通信。</p>\n<pre class=\"line-numbers language-markdown\" data-language=\"markdown\"><code class=\"language-markdown\"># 1. 查看 docker 网桥配置\n\tdocker network ls\n# 2. 自定义网桥\n\tdocker network create -d bridge 网桥名称\n# 3. 指定容器网桥\n\tdocker run --network 网桥名称 \n&gt; docker network [OPTION]\n     connect     Connect a container to a network\n     create      Create a network\n     disconnect  Disconnect a container from a network\n     inspect     Display detailed information on one or more networks\n     ls          List networks\n     prune       Remove all unused networks\n     rm          Remove one or more networks</code></pre>\n<p>​</p>\n<h2 id=\"数据卷\">8. 数据卷</h2>\n<p><strong>数据卷</strong>\n是一个可供一个或多个容器使用的特殊目录，它绕过\nUFS，可以提供很多有用的特性</p>\n<ul>\n<li><em>数据卷</em> 可以在容器之间共享和重用</li>\n<li>对 <em>数据卷</em> 的修改会立马生效</li>\n<li>对 <em>数据卷</em> 的更新，不会影响镜像</li>\n<li><em>数据卷</em> 默认会一直存在，即使容器被删除</li>\n</ul>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>注意：<em>数据卷</em> 的使用，类似于 Linux 下对目录或文件进行\nmount，镜像中的被指定为挂载点的目录中的文件会复制到数据卷中（仅数据卷为空时会复制）。</p></blockquote>\n<p><pre class=\"line-numbers language-markdown\" data-language=\"markdown\"><code class=\"language-markdown\"># 1. 自定义数据卷目录\n\tdocker run -v 绝对路径:容器内路径\n# 2. 自动创建数据卷\n\tdocker run -v 卷名：容器内路径</code></pre></p>\n<h3 id=\"docker-操作数据卷命令\">docker 操作数据卷命令</h3>\n<pre class=\"line-numbers language-markdown\" data-language=\"markdown\"><code class=\"language-markdown\"># 1. 查看数据卷\n\tdocker volume ls\n# 2. 查看数据卷细节\n\tdocker volume inspect 卷名\n&gt; docker volume [OPTION]\n     create      Create a volume\n     inspect     Display detailed information on one or more volumes\n     ls          List volumes\n     prune       Remove all unused local volumes\n     rm          Remove one or more volumes</code></pre>\n<h2 id=\"dockerfile\">9. Dockerfile</h2>\n<h3 id=\"什么是-dockerfile\">什么是 Dockerfile</h3>\n<p>定义：用来帮助我们自己构建一个自定义镜像 Dockerfile 成为镜像构建文件\n描述文件</p>\n<h3 id=\"dockerfile-的保留命令\">Dockerfile 的保留命令</h3>\n<p>官方说明(https://docs.docker.com/engine/reference/builder/)</p>\n<table>\n<colgroup>\n<col style=\"width: 18%\" />\n<col style=\"width: 81%\" />\n</colgroup>\n<thead>\n<tr class=\"header\">\n<th>保留字</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td><strong>FROM</strong></td>\n<td><strong>当前镜像是基于哪个镜像的</strong></td>\n</tr>\n<tr class=\"even\">\n<td>MAINTAINER</td>\n<td>镜像维护者的姓名和邮箱地址</td>\n</tr>\n<tr class=\"odd\">\n<td><strong>RUN</strong></td>\n<td><strong>构建镜像时需要运行的指令</strong></td>\n</tr>\n<tr class=\"even\">\n<td><strong>EXPOSE</strong></td>\n<td><strong>当前容器对外暴露的端口号</strong></td>\n</tr>\n<tr class=\"odd\">\n<td><strong>WORKDIR</strong></td>\n<td><strong>指定再创建容器后，终端默认登录进来的工作目录，一个落脚点</strong></td>\n</tr>\n<tr class=\"even\">\n<td><strong>ENV</strong></td>\n<td><strong>用来再构建镜像的过程中设置环境变量</strong></td>\n</tr>\n<tr class=\"odd\">\n<td><strong>ADD</strong></td>\n<td><strong>将宿主机目录下的文件拷贝进镜像且ADD命令会自动处理URL和解压tar包</strong></td>\n</tr>\n<tr class=\"even\">\n<td><strong>COPY</strong></td>\n<td><strong>类似于 ADD\n，拷贝文件和目录到镜像中</strong><br/><strong>将从构建上下文目录中<原路径>的文件/目录复制到新的一层的镜像内的<目标路径>位置</strong></td>\n</tr>\n<tr class=\"odd\">\n<td><strong>VOLUME</strong></td>\n<td><strong>容器数据卷，用于数据保存和持久化工作</strong></td>\n</tr>\n<tr class=\"even\">\n<td><strong>CMD</strong></td>\n<td><strong>指定一个容器启动时要运行的命令</strong>\n<br/><strong>Dockerfile 中可以有多个CMD 指令，但只有最后一个生效， CMD\n会被 docker run 之后的参数替换</strong></td>\n</tr>\n<tr class=\"odd\">\n<td><strong>ENTRYPOINT</strong></td>\n<td><strong>指定一个容器启动时要运行的命令</strong>\n<br/><strong>ENTRYPOINT 的目的和 CMD\n一样，都是在指定容器启动程序及其参数</strong></td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"from-命令\">FROM 命令</h4>\n<ul>\n<li><p>基于哪个镜像进行构建新的镜像，在构建时会自动从 docker hub 拉取\nbase 镜像 必须作为 Dockerfile 的一个指令出现</p></li>\n<li><p>语法</p>\n<pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\">FROM &lt;image&gt;\nFROM &lt;image&gt;[:&lt;tag&gt;]\t使用版本\nFROM &lt;image&gt;[@&lt;digest&gt;]\t使用摘要</code></pre></li>\n</ul>\n<h4 id=\"run-命令\">RUN 命令</h4>\n<ul>\n<li><p>RUN\n指令将在当前映像之上的新层中执行任何命令并提交结果。生成的提交映像将用于\nDockerfile 中下一步</p></li>\n<li><p>语法：</p>\n<pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\">RUN &lt;command&gt;\nRUN echo hello\nRUN [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;](exec form)\nRUN [&quot;&#x2F;bin&#x2F;bash&quot;, &quot;-c&quot;, &quot;echo hello&quot;]</code></pre></li>\n</ul>\n<h4 id=\"expose-命令\">EXPOSE 命令</h4>\n<ul>\n<li><p>用来指定构建的镜像在运行为容器时对外暴露的端口</p></li>\n<li><p>语法：</p>\n<pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\">EXPOSE 80&#x2F;tcp\t如果没有显示指定则默认暴露都是 tcp\nEXPOSE 80&#x2F;udp </code></pre></li>\n</ul>\n<h4 id=\"cmd-命令\">CMD 命令</h4>\n<ul>\n<li><p>用来为启动的容器指定执行的命令，在 Dockerfile 中只能有一条 CMD\n指令。如果列出多个命令，则只有最后一个命令才会生效。</p></li>\n<li><p>注意：<strong>Dockerfile 中只能有一条 CMD\n指令。如果列出多个命令，则只有最后一个命令才会生效。</strong></p></li>\n<li><p>语法：</p>\n<pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\">CMD [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]\nCMD [&quot;param1&quot;, &quot;param2&quot;]\nCMD command param1 param2 (shell form)</code></pre></li>\n</ul>\n<h4 id=\"workdir-命令\">WORKDIR 命令</h4>\n<ul>\n<li><p>用来为 Dockerfile 中的任何 RUN、CMD、ENTRYPOINT、COPY 和 ADD\n指令设置工作目录。如果 WORKDIR 不存在，即使它没有在任何后续 Dockerfile\n指令中使用，它也将被创建。</p></li>\n<li><p>语法：</p>\n<pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\">WORKDIR &#x2F;path&#x2F;to&#x2F;workdir\n\nWORKDIR &#x2F;a\nWORKDIR b\nWORKDIR c</code></pre></li>\n</ul>\n<h4 id=\"add-命令\">ADD 命令</h4>\n<ul>\n<li><p>用来从 context 上下文复制新文件、目录或远程文件\nurl，并将它们添加到位于指定路径的映像文件系统中</p></li>\n<li><p>语法：</p>\n<pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\">ADD hom* &#x2F;mydir&#x2F; \t通配符添加多个文件\nADD hom?.txt &#x2F;mydir 通配符添加\nADD test.txt relativeDir&#x2F; 可以指定相对路径\nADD test.txt &#x2F;absoluteDir&#x2F; 绝对路径\nADD url</code></pre></li>\n</ul>\n<h4 id=\"copy-命令\">COPY 命令</h4>\n<ul>\n<li><p>用来将 context 目录中指定文件复制到镜像的指定目录中</p></li>\n<li><p>语法：</p>\n<pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\">COPY src dest\nCOPY [&quot;&lt;src&gt;&quot;,... &quot;&lt;dest&gt;&quot;]</code></pre></li>\n</ul>\n<h4 id=\"volume-命令\">VOLUME 命令</h4>\n<ul>\n<li><p>用来定义容器运行时可以挂载到宿主机的目录</p></li>\n<li><p>语法：</p>\n<pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\">VOLUME [&quot;&#x2F;data&quot;]</code></pre></li>\n</ul>\n<h4 id=\"env-命令\">ENV 命令</h4>\n<ul>\n<li><p>用来为构建镜像设置环境变量。这个值将会出现在构建阶段中所有的后续指令的环境中。</p></li>\n<li><p>语法：</p>\n<pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\">ENV &lt;key&gt; &lt;value&gt; \nENV &lt;key&gt; &lt;value&gt; ...</code></pre></li>\n</ul>\n<h4 id=\"entrypoint-命令\">ENTRYPOINT 命令</h4>\n<ul>\n<li><p>用来指定容器启动时执行命令和 CMD 类似</p></li>\n<li><p>语法：</p>\n<pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\">[&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]\nENTRYPOINT command param1 param2</code></pre></li>\n</ul>\n","text":"Docker 官方文档地址 中文参考手册 1.什么是Docker 1.1 官方定义 官方介绍 We have a vomplete container solution for you - no matter who you are where you are on your c...","link":"","photos":[],"count_time":{"symbolsCount":"9.3k","symbolsTime":"8 mins."},"categories":[{"name":"Docker","slug":"Docker","count":3,"path":"api/categories/Docker.json"}],"tags":[{"name":"Docker 入门","slug":"Docker-入门","count":1,"path":"api/tags/Docker-入门.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#docker\"><span class=\"toc-text\">Docker</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AFdocker\"><span class=\"toc-text\">1.什么是Docker</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AE%98%E6%96%B9%E5%AE%9A%E4%B9%89\"><span class=\"toc-text\">1.1 官方定义</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#docker-%E7%9A%84%E8%B5%B7%E6%BA%90\"><span class=\"toc-text\">1.2 Docker 的起源</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AFdocker\"><span class=\"toc-text\">2. 为什么是Docker</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#docker-%E5%92%8C%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">3. Docker 和虚拟机的区别</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#docker-%E7%9A%84%E5%AE%89%E8%A3%85\"><span class=\"toc-text\">4. Docker 的安装</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AE%89%E8%A3%85-dockercentos-7.x\"><span class=\"toc-text\">4.1 安装 docker(centos 7.x)</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#bash-%E5%AE%89%E8%A3%85%E9%80%9A%E7%94%A8%E6%89%80%E6%9C%89%E5%B9%B3%E5%8F%B0\"><span class=\"toc-text\">4.2 bash 安装(通用所有平台)</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#docker-%E7%9A%84%E6%A0%B8%E5%BF%83%E6%9E%B6%E6%9E%84\"><span class=\"toc-text\">5. Docker 的核心架构</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%95%9C%E5%83%8F%E7%9A%84%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">6. 镜像的相关操作</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BE%85%E5%8A%A9%E5%91%BD%E4%BB%A4\"><span class=\"toc-text\">6.1 辅助命令</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#images-%E9%95%9C%E5%83%8F%E5%91%BD%E4%BB%A4\"><span class=\"toc-text\">6.2 Images 镜像命令</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#contrainer-%E5%AE%B9%E5%99%A8%E5%91%BD%E4%BB%A4\"><span class=\"toc-text\">6.3 Contrainer 容器命令</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#dokcer-%E4%B8%AD%E5%AE%B9%E5%99%A8%E4%B9%8B%E9%97%B4%E7%9A%84%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE\"><span class=\"toc-text\">7. Dokcer 中容器之间的网络配置</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#docker-%E5%AE%B9%E5%99%A8%E4%B8%8E%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">7.1 docker\n容器与操作系统通信机制</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#docker-%E7%BD%91%E7%BB%9C%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">7.2 Docker 网络使用</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%95%B0%E6%8D%AE%E5%8D%B7\"><span class=\"toc-text\">8. 数据卷</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#docker-%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%E5%8D%B7%E5%91%BD%E4%BB%A4\"><span class=\"toc-text\">docker 操作数据卷命令</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#dockerfile\"><span class=\"toc-text\">9. Dockerfile</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AF-dockerfile\"><span class=\"toc-text\">什么是 Dockerfile</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#dockerfile-%E7%9A%84%E4%BF%9D%E7%95%99%E5%91%BD%E4%BB%A4\"><span class=\"toc-text\">Dockerfile 的保留命令</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#from-%E5%91%BD%E4%BB%A4\"><span class=\"toc-text\">FROM 命令</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#run-%E5%91%BD%E4%BB%A4\"><span class=\"toc-text\">RUN 命令</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#expose-%E5%91%BD%E4%BB%A4\"><span class=\"toc-text\">EXPOSE 命令</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#cmd-%E5%91%BD%E4%BB%A4\"><span class=\"toc-text\">CMD 命令</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#workdir-%E5%91%BD%E4%BB%A4\"><span class=\"toc-text\">WORKDIR 命令</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#add-%E5%91%BD%E4%BB%A4\"><span class=\"toc-text\">ADD 命令</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#copy-%E5%91%BD%E4%BB%A4\"><span class=\"toc-text\">COPY 命令</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#volume-%E5%91%BD%E4%BB%A4\"><span class=\"toc-text\">VOLUME 命令</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#env-%E5%91%BD%E4%BB%A4\"><span class=\"toc-text\">ENV 命令</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#entrypoint-%E5%91%BD%E4%BB%A4\"><span class=\"toc-text\">ENTRYPOINT 命令</span></a></li></ol></li></ol></li></ol></li></ol>","author":{"name":"爱慢跑的乌龟","slug":"blog-author","avatar":"/img/avatar1.jpg","link":"/","description":"求知若饥，虚心若愚！","socials":{"github":"https://github.com/ansonxu1998","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"pacman 文档","uid":"b64cd93b72faed23ef520531eb71c1e8","slug":"Linux/pacman","date":"2022-04-28T07:42:04.000Z","updated":"2023-04-15T05:25:45.930Z","comments":true,"path":"api/articles/Linux/pacman.json","keywords":null,"cover":"/img/pacman/arch_logo.png","text":"pacman - Arch Linux 软件管理器 SYNOPSIS pacman &lt;operation&gt; [options] [targets] DESCRIPTION Pacman 是一个包管理的使用程序，用于跟踪 Linux 系统上以安装的包。它具有依赖性支持、...","link":"","photos":[],"count_time":{"symbolsCount":"3.6k","symbolsTime":"3 mins."},"categories":[{"name":"Linux","slug":"Linux","count":2,"path":"api/categories/Linux.json"}],"tags":[{"name":"Pacman 命令","slug":"Pacman-命令","count":1,"path":"api/tags/Pacman-命令.json"}],"author":{"name":"爱慢跑的乌龟","slug":"blog-author","avatar":"/img/avatar1.jpg","link":"/","description":"求知若饥，虚心若愚！","socials":{"github":"https://github.com/ansonxu1998","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{}}