{"title":"Docker 基础入门","uid":"e8df40174e1c8fdb0eda4ca741803291","slug":"Linux/Docker基础入门","date":"2022-06-24T06:44:00.000Z","updated":"2023-04-15T05:18:04.613Z","comments":true,"path":"api/articles/Linux/Docker基础入门.json","keywords":null,"cover":"/img/docker/DockerLogo.png","content":"<h2 id=\"核心概念与安装配置\">核心概念与安装配置</h2>\n<p>Docker 的三大核心概念：</p>\n<ul>\n<li>镜像(Image)</li>\n<li>容器(Container)</li>\n<li>仓库(Repository)</li>\n</ul>\n<h3 id=\"核心概念\">核心概念</h3>\n<h4 id=\"docker-镜像\">Docker 镜像</h4>\n<p>Docker 镜像可以将其理解为一个只读的模板。它是 docker\n容器的基础。用户可以从网络上下载已经配置好的镜像，并直接使用。</p>\n<h4 id=\"docker-容器\">Docker 容器</h4>\n<p>Docker\n容器类似于一个轻量级的沙箱，用于运行和隔离应用。<font color='geen'>容器是从镜像创建的应用运行实例。</font>可以将其启动、开始、停止和删除。</p>\n<p class=\"note note-primary\">\n镜像自身是只读的。容器从镜像启动的时候，会在镜像的最上层创建一个可写层\n</p>\n<h4 id=\"docker-仓库\">Docker 仓库</h4>\n<p>Docker 仓库是 Docker 集中存放镜像文件的场所。</p>\n<p>Docker 仓库的类型：</p>\n<ul>\n<li>公开仓库(Public)</li>\n<li>私有仓库(Private)</li>\n</ul>\n<h3 id=\"docker-的安装\">Docker 的安装</h3>\n<h4 id=\"ubuntu-环境下安装-docker\">Ubuntu 环境下安装 Docker</h4>\n<p>推荐至少使用 <code>14.04 LTS</code> 版本。</p>\n<p>为了让 Docker 使用 aufs 存储，推荐安装 <code>linux-image-extra</code>\n软件包：</p>\n<pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\">$ sudo apt-get install -y linux-image-extra-$(uname -r)</code></pre>\n<p><strong>添加镜像源</strong>：</p>\n<p>安装 <code>apt-transport-https</code> 包支持 HTTP 协议的源：</p>\n<pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\">$ sudo apt-get install -y apt-transport-https</code></pre>\n<p>添加源的 gpg 密钥：</p>\n<pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\">$ sudo apt-key adv --keyserver hkp:&#x2F;&#x2F;p80.pool.sks-keyservers.net:80 --recv-keys \n    58118E89F3A912897C070ADBF76221572C52609D</code></pre>\n<p>获取当前操作系统的代号：</p>\n<pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\">$ lsb_release -c\nCodename:       trusty</code></pre>\n<p>接下来就可以添加Docker的官方apt软件源了。通过下面的命令创建\n<code>/etc/apt/sources.list.d/docker.list</code>\n文件，并写入源的地址内容。非 trusty\n版本的系统注意修改为自己对应的代号：</p>\n<pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\">$ sudo cat &lt;&lt;EOF &gt; &#x2F;etc&#x2F;apt&#x2F;sources.list.d&#x2F;docker.list\ndeb https:&#x2F;&#x2F;apt.dockerproject.org&#x2F;repo ubuntu-trusty main\nEOF</code></pre>\n<p>更新 apt 软件包缓存：</p>\n<pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\">$ sudo apt-get update</code></pre>\n<p><strong>安装 Docker</strong>：</p>\n<pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\">$ sudo apt-get install -y docker-engine</code></pre>\n<p>通过脚本自动化安装 Docker：</p>\n<pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\">$ sudo curl -sSL https:&#x2F;&#x2F;get.docker.com&#x2F; | sh</code></pre>\n<p>启动 docker 服务：</p>\n<pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\">$ sudo systemctl start docker</code></pre>\n<h4 id=\"centos-环境下安装-docker\">CentOS 环境下安装 Docker</h4>\n<p>添加 yum 软件源：</p>\n<pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\">$ sudo tee &#x2F;etc&#x2F;yum.repos.d&#x2F;docker.repo &lt;&lt;-&#39;EOF&#39;\n[dockerrepo]\nname&#x3D;Docker Repository\nbaseurl&#x3D;https:&#x2F;&#x2F;yum.dockerproject.org&#x2F;repo&#x2F;main&#x2F;centos&#x2F;$releasever&#x2F;\nenabled&#x3D;1\ngpgcheck&#x3D;1\ngpgkey&#x3D;https:&#x2F;&#x2F;yum.dockerproject.org&#x2F;gpg\nEOF</code></pre>\n<p>安装 docker：</p>\n<pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\">$ sudo yum update\n$ sudo yum install -y docker-engine</code></pre>\n<h4 id=\"使用脚本安装\">使用脚本安装</h4>\n<pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\">$ curl -fsSL https:&#x2F;&#x2F;get.docker.com&#x2F; | sh</code></pre>\n<p>或者：</p>\n<pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\">$ wget -qO- https:&#x2F;&#x2F;get.docker.com&#x2F; | sh</code></pre>\n<h3 id=\"配置-docker-服务\">配置 Docker 服务</h3>\n<p>将当前用户加入 docker 用户组：</p>\n<pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\">$ sudo usermod -aG docker USER_NAME</code></pre>\n<p>Docker 服务的默认配置文件：<code>/etc/default/docker</code></p>\n<p>可以通过修改 <code>DOCKER_OPTS</code> 来修改服务启动的参数。</p>\n<p>Docker 服务的管理脚本：<code>/etc/init.d/docker</code></p>\n<p>查看版本信息：</p>\n<pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\">$ docker verison\nClient: Docker Engine - Community\n Version:           20.10.17\n API version:       1.41\n Go version:        go1.17.11\n Git commit:        100c701\n Built:             Mon Jun  6 23:02:56 2022\n OS&#x2F;Arch:           linux&#x2F;amd64\n Context:           default\n Experimental:      true\n\nServer: Docker Engine - Community\n Engine:\n  Version:          20.10.17\n  API version:      1.41 (minimum version 1.12)\n  Go version:       go1.17.11\n  Git commit:       a89b842\n  Built:            Mon Jun  6 23:01:02 2022\n  OS&#x2F;Arch:          linux&#x2F;amd64\n  Experimental:     false\n containerd:\n  Version:          1.6.6\n  GitCommit:        10c12954828e7c7c9b6e0ea9b0c02b01407d3ae1\n runc:\n  Version:          1.1.2\n  GitCommit:        v1.1.2-0-ga916309\n docker-init:\n  Version:          0.19.0\n  GitCommit:        de40ad0\n</code></pre>\n<h2 id=\"docker-镜像-1\">Docker 镜像</h2>\n<p>Docker 运行容器前需要本地存在对应的镜像，若本地无镜像，Docker\n将从默认的镜像仓库下载，用户可以通过配置，使用自定义的镜像仓库。</p>\n<h3 id=\"镜像获取\">镜像获取</h3>\n<p>使用 <code>docker pull</code> 命令从 <code>Docker Hub</code>\n镜像仓库下载镜像。</p>\n<p>命令格式：<code>docker pull Image-Name[: TAG]</code> (TAG\n通常是版本信息)</p>\n<p>没有指定 TAG，默认为 <code>latest</code></p>\n<pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\">$ docker pull ubuntu\nUsing default tag: latest\nlatest: Pulling from library&#x2F;ubuntu\n405f018f9d1d: Pull complete\nDigest:sha256:b6b83d3c331794420340093eb706a6f152d9c1fa51b262d9bf34594887c2c7ac\nStatus: Downloaded newer image for ubuntu:latest\ndocker.io&#x2F;library&#x2F;ubuntu:latest</code></pre>\n<p>镜像文件一般由若干层(layer)组成，每个层都有一个唯一的 ID\n(如：<code>405f018f9d1d</code>)。使用 <code>docker pull</code>\n命令下载时会获取并输出镜像的各层信息。当不同的镜像包括相同的层时，本地仅存储层的一份内容，减小了需要的存储空间。</p>\n<p>镜像名称之前应该加上仓库地址前缀，使用官方仓库时默认省略，即：<code>docker pull ubuntu：14.04</code>\n相当于\n<code>docker pull registry.hub.docker.com/ubuntu：14.04</code>。</p>\n<p><font color='pink'>若从非官方仓库下载镜像，则必须指定仓库地址前缀。</font></p>\n<p><code>pull</code> 子命令支持的选项：</p>\n<p><code>-a,--all-tags=true|false</code> -\n是由获取仓库中所有镜像，默认为 否。</p>\n<h3 id=\"查看镜像信息\">查看镜像信息</h3>\n<h4 id=\"列出所有镜像\">列出所有镜像</h4>\n<p>命令：<code>docker images</code></p>\n<pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\">$ docker images\nREPOSITORY   TAG       IMAGE ID       CREATED       SIZE\nubuntu       latest    27941809078c   2 weeks ago   77.8MB</code></pre>\n<ul>\n<li>REPOSITORY - 来自于那个仓库</li>\n<li>TAG - 版本信息</li>\n<li>IMAGE ID - 唯一标识镜像</li>\n<li>CREATED - 镜像的最后更新时间</li>\n<li>SIZE - 镜像大小</li>\n</ul>\n<p><code>images</code> 子命令主要支持的选项：</p>\n<pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\">-a, --all&#x3D;true|false: 列出所有镜像（包含临时文件），默认为 否；\n--digests&#x3D;true|false: 列出镜像的数字摘要值，默认为 否；\n-f, --filter&#x3D;[]: 过滤列出镜像；\n--format&#x3D;&quot;TEMPLATE&quot;: 控制输出格式，.ID代表ID信息，.Repository代币哦仓库信息；\n--no-trunc&#x3D;true|false: 对输出结果中太长的部分是否进行截断，默认为 是；\n-q, --quiet&#x3D;true|false: 仅输出ID信息，默认为　否</code></pre>\n<p>使用 <code>man docker-images</code> 查看更多命令选项。</p>\n<h4 id=\"添加镜像标签\">添加镜像标签</h4>\n<p>使用 <code>tag</code>\n命令来为一个本地镜像添加新的标签，以方便使用：</p>\n<pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\">$ docker tag ubuntu:latest myubuntu:latest</code></pre>\n<h4 id=\"查看详细信息\">查看详细信息</h4>\n<p>使用 <code>inspect</code> 命令获取镜像的详细信息：</p>\n<pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\">$ docker inspect ubuntu:14.04</code></pre>\n<p>返回的消息为 JSON 格式的消息，如果只想获取其中一项，使用\n<code>-f</code> 参数来指定：</p>\n<pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\">$ docker inspect -f &#123;&#123;&quot;.Architecture&quot;&#125;&#125;</code></pre>\n<h4 id=\"查看镜像的历史\">查看镜像的历史</h4>\n<p>使用 <code>history</code> 命令来查看镜像的历史：</p>\n<pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\">$ docker history ubuntu:14.04</code></pre>\n<p>可以查看各个层的内容具体的创建信息。</p>\n<h3 id=\"搜索镜像\">搜索镜像</h3>\n<p>使用 <code>docker search</code>\n命令来搜索远程仓库中的镜像，默认使用官方仓库。</p>\n<p>支持的参数有 ：</p>\n<pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\">--no-trunc&#x3D;true|false: 输出信息不截断显示，默认为 否；\n-f, --filter&#x3D;[]: 基于条件过滤输出\n--limit&#x3D;25: 搜索结果的最大数量</code></pre>\n<p>搜索所有自动创建的评价为1+的带nginx关键字的镜像：</p>\n<pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\">$ docker search --limit&#x3D;10 nginx</code></pre>\n<h3 id=\"删除镜像\">删除镜像</h3>\n<p>使用 <code>docker rmi</code> 命令来删除镜像：</p>\n<h4 id=\"使用标签删除\">使用标签删除</h4>\n<pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\">$ docker rmi ubuntu:latest</code></pre>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>当一个镜像拥有多个标签时，删除某一个标签并不会影响原来的镜像</p></blockquote>\n<h4 id=\"使用镜像-id-删除\">使用镜像 ID 删除</h4>\n<p>当使用 ID 进行删除时，所有的镜像标签包括原始镜像本身都会被删除。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>若镜像创建的容器存在时，则该镜像文件将无法被删除</p></blockquote>\n<p>如果需要强制删除，可以使用 <code>-f</code> 参数。</p>\n<h3 id=\"创建镜像\">创建镜像</h3>\n<p>有三种方式创建镜像：</p>\n<ul>\n<li>基于已有镜像的容器创建</li>\n<li>基于本地模板导入</li>\n<li>基于 Dockerfile 创建</li>\n</ul>\n<h4 id=\"基于已有镜像的容器创建\">基于已有镜像的容器创建</h4>\n<p>使用 <code>docker commit</code> 命令来创建。</p>\n<p>主要选项包括：</p>\n<pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\">-a, --author&#x3D;&quot;&quot;: 作者信息\n-c, --change&#x3D;[]: 提交的执行 Dockerfile 指令\n-m, --message&#x3D;&quot;&quot;: 提交信息\n-p, --pause&#x3D;true: 提交时暂停容器的运行</code></pre>\n<p>提交时使用容器的 ID 或名称来指定容器：</p>\n<pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\">$ docker commit -m &quot;Added a new file&quot; -a &quot;Anson&quot; a925cb40b3f0 test:0.1</code></pre>\n<h4 id=\"基于本地模板导入\">基于本地模板导入</h4>\n<p>使用 <code>docker inport</code> 命令来创建。</p>\n<pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\">$ cat ubuntu-14.04-x86_64-minimal.tar.gz | docker import - ubuntu:14.04</code></pre>\n<h3 id=\"存出和载入镜像\">存出和载入镜像</h3>\n<h4 id=\"存出镜像\">存出镜像</h4>\n<p>使用 <code>docker save</code> 来存出镜像：</p>\n<pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\">$ docker save -o ubuntu_14.04.tar ubuntu:14.04</code></pre>\n<h4 id=\"载入镜像\">载入镜像</h4>\n<p>使用 <code>docker load</code> 来载入镜像：</p>\n<pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\">$ docker load --input ubuntu_14.04.tar</code></pre>\n<p>或者：</p>\n<pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\">$ docker load &lt; ubuntu_14.04.tar</code></pre>\n<h3 id=\"上传镜像\">上传镜像</h3>\n<p>使用 <code>docker push</code> 命令来上传镜像到仓库，默认为官方 Docker\nHub仓库：</p>\n<p><code>docker push NAME[:TAG] | [REGISTRY_HOST[:REGISTRY_PORT]/]NAME[:TAG]</code></p>\n<pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\">$ docker tag test:latest user&#x2F;test:latest\n$ docker push user&#x2F;test:latest</code></pre>\n<h2 id=\"docker-容器-1\">Docker 容器</h2>\n<p>容器是镜像运行的实例。镜像是静态的只读文件，而容器带有运行时需要的可写文件层。</p>\n<h3 id=\"创建容器\">创建容器</h3>\n<h4 id=\"新建容器\">新建容器</h4>\n<p>使用 <code>docker create</code> 命令来创建一个容器：</p>\n<pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\">$ docker create -it ubuntu:latest</code></pre>\n<p>此时容器处于停止状态，可以使用 <code>docker start</code>\n命令来启动它。</p>\n<h4 id=\"启动容器\">启动容器</h4>\n<p>使用 <code>docker start</code> 命令来启动一个已经创建的容器：</p>\n<pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\">$ docker start af\naf</code></pre>\n<h4 id=\"新建并启动容器\">新建并启动容器</h4>\n<p>使用 <code>docker run</code> 命令来创建并执行。</p>\n<pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\">$ docker run ubuntu &#x2F;bin&#x2F;echo &#39;Hello world&#39;\nHello world</code></pre>\n<p>启动一个 bash 终端：</p>\n<pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\">$ docker run -it ubuntu:14.04 &#x2F;bin&#x2F;bash</code></pre>\n<ul>\n<li><code>-t</code> - 让 Docker\n分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上</li>\n<li><code>-i</code> - 让容器的标准输入保持打开</li>\n</ul>\n<p><code>Ctrl + d</code> 或 输入 exit 退出容器。</p>\n<h4 id=\"守护态运行\">守护态运行</h4>\n<p>通过添加 <code>-d</code> 参数实现：</p>\n<pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\">docker run -d ubuntu  &#x2F;bin&#x2F;sh -c &quot;while true; do echo hello world; sleep 1; done&quot;</code></pre>\n<h3 id=\"终止容器\">终止容器</h3>\n<p>使用 <code>docker stop</code> 命令来终止一个运行中的容器。</p>\n<p><code>docker stop[-t|--time[=10]][CONTAINER...]</code></p>\n<p>首先向容器发送 SIGTERM 信号，等待一段超时时间（默认为10秒）后，再发送\nSIGKILL信号来终止容器：</p>\n<pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\">$ docker stop ce5\nce5</code></pre>\n<p><font color='red'><code>docker kill</code> 命令会直接发送 SIGKILL\n信号来强行终止容器。</font></p>\n<p>重新启动一个容器使用 <code>docker restart</code> 命令。</p>\n<h3 id=\"进入容器\">进入容器</h3>\n<p>进入容器的方法：</p>\n<ul>\n<li><code>attach</code></li>\n<li><code>exec</code></li>\n<li><code>nsenter</code></li>\n<li>...</li>\n</ul>\n<h4 id=\"attach-命令\"><code>attach</code> 命令</h4>\n<p><code>docker attach [--detach-keys[=[]]] [--no-stdin] [--sig-proxy[=true]] CONTAINER</code></p>\n<p>主要选项：</p>\n<pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\">--detach-keys&#x3D;&quot;&quot;: 重写用于退出容器的键序列\n--no-stdin[&#x3D;false]: 是否关闭标准输入\n--sig-proxy[&#x3D;true]: 代理进程接收到的所有信号\n</code></pre>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>当多个窗口同时使用 attach\n命令连接到同一个容器时，所有的窗口都会同步显示。当某个窗口阻塞时，其他窗口也无法执行操作了。</p></blockquote>\n<h4 id=\"exec-命令\"><code>exec</code> 命令</h4>\n<p>主要参数：</p>\n<pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\">-i, --interactive[&#x3D;false]: 使用标准输入接受用户命令\n--privileged[&#x3D;false]: 赋予命令拓展权限\n-t, --tty[&#x3D;false]: 分配 pseudo-TTY\n-u, --user&#x3D;&quot;&quot;: 用户名或 UID (format:[:])</code></pre>\n<pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\">$ docker exec -it 55c0389b9d7c &#x2F;bin&#x2F;bash</code></pre>\n<h4 id=\"nsenter-工具\">nsenter 工具</h4>\n<ol type=\"1\">\n<li><p>找到容器进程的 PID，命令如下：</p>\n<p><pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\">PID&#x3D;$(docker inspect --format &quot;&#123;&#123;.State.Pid&#125;&#125;&quot; &lt;container&gt;)</code></pre></p></li>\n<li><p>通过 PID 连接到容器</p>\n<p><pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\">$ nsenter --target $PID --mount --uts --ipc --net --pid</code></pre></p></li>\n</ol>\n<p>例子：</p>\n<pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\">$ docker run -idt ubuntu\n243c32535da7d142fb0e6df616a3c3ada0b8ab417937c853a9e1c251f499f550\n$ docker ps\nCONTAINER ID   IMAGE   COMMAND   CREATED  STATUS   PORTS  NAMES\n243c32535da7  ubuntu:latest   &quot;&#x2F;bin&#x2F;bash&quot;  18 seconds ago  Up 17 seconds \n    nostalgic_hypatia\n$ PID&#x3D;$(docker-pid 243c32535da7)\n10981\n$ nsenter --target 10981 --mount --uts --ipc --net --pid\nroot@243c32535da7:&#x2F;#</code></pre>\n<h3 id=\"删除容器\">删除容器</h3>\n<p>使用 <code>docker rm</code> 命令来删除容器。</p>\n<p>主要参数：</p>\n<pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\">-f, --force[&#x3D;false]: 强制删除正在运行的容器\n-l,\t--link[&#x3D;false]: 删除指定的链接，但保留容器\n-v, --volumes[&#x3D;false]: 删除容器挂载的数据卷</code></pre>\n<h3 id=\"导入和导出容器\">导入和导出容器</h3>\n<p>在需要将容器从一个系统迁移到另一个系统的情况下，可以使用 Docker\n的导入和导出功能。</p>\n<h4 id=\"导出容器\">导出容器</h4>\n<p>使用 <code>docker export</code> 命令来导出容器：</p>\n<pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\">$ docker export -o test_for_run.tar ce5\n$ docker export e81 &gt; test_for_stop.tar</code></pre>\n<h4 id=\"导入容器\">导入容器</h4>\n<p>使用 <code>docker import</code> 命令来导入容器：</p>\n<pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\">$ docker import test_for_run.tar - test&#x2F;ubuntu:v1.0</code></pre>\n<h2 id=\"访问-docker-仓库\">访问 Docker 仓库</h2>\n<p>仓库（Repository）是集中存放镜像的地方，分公共仓库和私有仓库。</p>\n<h3 id=\"docker-hub公共镜像市场\">Docker Hub公共镜像市场</h3>\n<p>Docker官方维护了一个公共镜像仓库 https://hub.docker.com</p>\n<h3 id=\"时速云镜像市场\">时速云镜像市场</h3>\n<p>访问地址 https://hub.tenxcloud.com</p>\n<h3 id=\"搭建本地私有仓库\">搭建本地私有仓库</h3>\n<h4 id=\"使用-registry-镜像创建私有仓库\">使用 registry\n镜像创建私有仓库</h4>\n<p>使用 <code>registry</code> 镜像来简单搭建一套本地私有仓库环境：</p>\n<pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\">$ docker run -d -p 5000:5000 registry</code></pre>\n<p>默认情况下，会将仓库创建在容器的 <code>/tmp/registry</code>\n目录下。使用参数 <code>-v</code> 将镜像文件存放在本地的指定路径。</p>\n<pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\">$ docker run -d -p 5000:5000 -v &#x2F;opt&#x2F;data&#x2F;registry:&#x2F;tmp&#x2F;registry registry\n</code></pre>\n<h4 id=\"管理私有仓库\">管理私有仓库</h4>\n<p>使用 <code>docker tag</code> 命令将这个镜像标记为\n10.0.2.2：5000/test</p>\n<pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\">$ docker tag ubuntu:14.04 10.0.2.2:5000&#x2F;test</code></pre>\n<p>使用 <code>docker push</code> 上传标记的镜像：</p>\n<pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\">$ docker push 10.0.2.2:5000&#x2F;test</code></pre>\n<h2 id=\"docker-数据管理\">Docker 数据管理</h2>\n<p>生产环境中使用 Docker\n的过程中，往往需要对数据进行持久化，或者需要在多个容器之间进行数据共享，这必然涉及容器的数据管理操作。</p>\n<p>容器中管理数据主要有两种方式：</p>\n<ul>\n<li>数据卷(Data Volumes)：容器内数据直接映射到本地主机环境；</li>\n<li>数据卷容器(Data Volume Containers)：使用特定容器维护数据卷。</li>\n</ul>\n<h3 id=\"数据卷\">数据卷</h3>\n<p>数据卷的特性：</p>\n<ul>\n<li>数据卷可以在容器之间共享和重用，容器间传递数据将变得高效方便；</li>\n<li>对数据卷内数据的修改会立马生效，无论是容器内操作还是本地操作；</li>\n<li>对数据卷的更新不会影响镜像，解耦了应用和数据；</li>\n<li>卷会一直存在，直到没有容器使用，可以安全地卸载它。</li>\n</ul>\n<h4 id=\"在容器内创建一个数据卷\">在容器内创建一个数据卷</h4>\n<p>在 <code>docker run</code> 命令下，使用参数 <code>-v</code>\n在容器内创建一个数据卷。重复使用可创建多个。</p>\n<p>例：</p>\n<p><pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\">$ docker run -d -P --name web -v &#x2F;webapp training&#x2F;webapp python app.py</code></pre></p>\n<h4 id=\"挂载一个主机目录作为数据卷\">挂载一个主机目录作为数据卷</h4>\n<pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\">$ docker run -d -P --name web -v &#x2F;src&#x2F;webapp:&#x2F;opt&#x2F;webapp training&#x2F;webapp python app.py</code></pre>\n<p>加载主机的 <code>/src/webapp</code> 目录到容器的\n<code>/opt/webapp</code> 目录</p>\n<p>注：本地目录的路径必须是绝对路径，如果目录不存在，Docker会自动创建。</p>\n<p>Docker 挂载数据卷的默认权限是读写（rw），用户也可以通过 ro\n指定为只读：</p>\n<pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\">$ docker run -d -P --name web -v &#x2F;src&#x2F;webapp:&#x2F;opt&#x2F;webapp:ro\ntraining&#x2F;webapp python app.py</code></pre>\n<h4\nid=\"挂载一个本地主机文件作为数据卷\">挂载一个本地主机文件作为数据卷</h4>\n<p><code>-v</code>\n也可以从主机挂载单个文件到容器中作为数据卷（不推荐）。</p>\n<pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\">$ docker run --rm -it -v ~&#x2F;.bash_history:&#x2F;.bash_history ubuntu &#x2F;bin&#x2F;bash</code></pre>\n<h3 id=\"数据卷容器\">数据卷容器</h3>\n<p>如果用户需要在多个容器之间共享一些持续更新的数据，最简单的方式是使用数据卷容器。数据卷容器也是一个容器，但是它的目的是专门用来提供数据卷供其他容器挂载。</p>\n<ol type=\"1\">\n<li><p>创建一个数据卷容器 dbdata，并在其中创建一个数据卷挂载到\n/dbdata:</p>\n<p><pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\">$ docker run -it -v &#x2F;dbdata --name dbdata ubuntu\nroot@3ed94f279b6f:&#x2F;#</code></pre></p></li>\n<li><p>然后，可以在其他容器中使用 <code>--volumes-from</code> 来挂载\ndbdata 容器中的数据卷，例如创建 db1 和 db2\n两个容器，并从dbdata容器挂载数据卷：</p>\n<p><pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\">$ docker run -it --volumes-from dbdata --name db1 ubuntu\n$ docker run -it --volumes-from dbdata --name db2 ubuntu</code></pre></p></li>\n</ol>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>使用 <code>--volumes-from</code>\n参数所挂载数据卷的容器自身并不需要保持在运行状态。\n如果删除了挂载的容器（包括dbdata、db1和db2），数据卷并不会被自动删除。如果要删除一个数据卷，必须在删除最后一个还挂载着它的容器时显式使用\n<code>docker rm-v</code> 命令来指定同时删除关联的容器。</p></blockquote>\n<h3 id=\"利用数据卷容器来迁移数据\">利用数据卷容器来迁移数据</h3>\n<ol type=\"1\">\n<li>备份</li>\n</ol>\n<p>备份 dbdata 数据卷容器内的数据卷：</p>\n<pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\">$ docker run --volumes-from dbdata -v $(pwd):&#x2F;backup --name worker ubuntu tar cvf &#x2F;backup&#x2F;backup.tar &#x2F;dbdata</code></pre>\n<ul>\n<li>镜像：ubuntu</li>\n<li>容器：worker</li>\n<li><code>-v $(pwd):/backup</code>：挂载本地的当前目录到 worker 容器的\n<code>/backup</code> 目录</li>\n<li><code>--volumes-from dbdata</code>：让 worker 容器挂载 dbdata\n容器的数据卷</li>\n<li><code>tar cvf/backup/backup.tar /dbdata</code>：将\n<code>/dbdata</code> 下内容备份为容器内的\n<code>/backup/backup.tar</code></li>\n</ul>\n<ol start=\"2\" type=\"1\">\n<li>恢复</li>\n</ol>\n<p>将数据恢复到一个容器：</p>\n<p>首先创建一个带有数据卷的容器 dbdata2：</p>\n<pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\">$ docker run -v &#x2F;dbdata --name dbdata2 ubuntu &#x2F;bin&#x2F;bash</code></pre>\n<p>然后创建另一个新的容器，挂载dbdata2的容器，并使用untar解压备份文件到所挂载的容器卷中：</p>\n<pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\">$ docker run --volumes-from dbdata2 -v $(pwd):&#x2F;backup busybox tar xvf &#x2F;backup&#x2F;backup.tar</code></pre>\n<h2 id=\"端口映射与容器互联\">端口映射与容器互联</h2>\n<h3 id=\"端口映射实现访问容器\">端口映射实现访问容器</h3>\n<ol type=\"1\">\n<li>从外部访问容器应用</li>\n</ol>\n<p>在启动容器的时候，如果不指定对应的参数，在容器外部是无法通过网络来访问容器内的网络应用和服务的。</p>\n<p>当容器中运行一些网络应用，要让外部访问这些应用时，可以通过\n<code>-P</code> 或 <code>-p</code> 参数来指定端口映射。当使用\n<code>-P</code> 参数时，Docker会随机映射一个 49000~49900\n的端口到内部容器开放的网络端口：</p>\n<pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\">docker run -d -P training&#x2F;webapp python app.py</code></pre>\n<p>可以使用 <code>docker logs</code> 命令来查看应用的信息：</p>\n<pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\">$ docker logs -f nostalgic_morse</code></pre>\n<p><code>-p</code>可以指定要映射的端口，并且，在一个指定端口上只可以绑定一个容器。支持的格式有\n<code>IP：HostPort：ContainerPort</code>、\n<code>IP：：ContainerPort</code>、\n<code>HostPort：ContainerPort</code>。</p>\n<ol start=\"2\" type=\"1\">\n<li>映射所有接口地址</li>\n</ol>\n<p>使用 <code>HostPort：ContainerPort</code> 格式将本地的 5000\n端口映射到容器的 5000 端口，可以执行：</p>\n<pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\">$ docker run -d -p 5000:5000 training&#x2F;webapp python app.py</code></pre>\n<p>多次使用 <code>-p</code> 参数可以绑定多个端口。</p>\n<ol start=\"3\" type=\"1\">\n<li>映射到指定地址的指定端口</li>\n</ol>\n<p>可以使用 <code>IP：HostPort：ContainerPort</code>\n格式指定映射使用一个特定地址，比如localhost 地址 127.0.0.1：</p>\n<pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\">$ docker run -d -p 127.0.0.1:5000:5000 training&#x2F;webapp python app.py</code></pre>\n<ol start=\"4\" type=\"1\">\n<li>映射到指定地址的任意端口</li>\n</ol>\n<p>使用 <code>IP：：ContainerPort</code> 绑定 localhost\n的任意端口到容器的 5000端 口，本地主机会自动分配一个端口：</p>\n<pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\">$ docker run -d -p 127.0.0.1::5000 training&#x2F;webapp python app.py</code></pre>\n<p>还可以使用 upd 标记来指定 UDP 端口：</p>\n<pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\">$ docker run -d -p 127.0.0.1:5000:5000&#x2F;udp training&#x2F;webapp python app.py</code></pre>\n<ol start=\"5\" type=\"1\">\n<li>查看映射端口配置</li>\n</ol>\n<p>使用 <code>docker port</code>\n命令来查看当前映射的端口配置，也可以查看绑定的地址：</p>\n<pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\">$ docker port nostalgic_morse 5000\n127.0.0.1:49155</code></pre>\n<h3 id=\"互联机制实现便捷互访\">互联机制实现便捷互访</h3>\n<p>容器的互联（linking）是一种让多个容器中应用进行快速交互的方式。它会在源和接收容器之间创建连接关系，接收容器可以通过容器名快速访问到源容器，而不用指定具体的\nIP 地址。</p>\n<ol type=\"1\">\n<li>自定义容器命名</li>\n</ol>\n<p>使用 <code>--name</code> 参数可以为容器自定义命名：</p>\n<pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\">$ docker run -d -P --name web training&#x2F;webapp python app.py</code></pre>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>容器的名称是唯一的。</p></blockquote>\n<ol start=\"2\" type=\"1\">\n<li>容器互联</li>\n</ol>\n<p>使用 <code>--link</code> 参数可以让容器之间安全地进行交互。</p>\n<p>创建一个新的数据库容器：</p>\n<pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\">$ docker run -d --name db training&#x2F;postgres</code></pre>\n<p>创建一个新的 web 容器，并将它连接到 db 容器：</p>\n<pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\">$ docker run -d -P --name web --link db:db training&#x2F;webapp python app.py</code></pre>\n<p><code>--link</code> 参数的格式为\n<code>--link name: alias</code>，其中 name 是要连接的容器名称，alias\n是这个连接的别名。</p>\n<p>web 容器连接到 db 容器，这允许web容器访问db容器的信息。</p>\n<p>Docker通过两种方式为容器公开连接信息：</p>\n<ul>\n<li>更新环境变量</li>\n<li>更新 <code>/etc/hosts</code> 文件</li>\n</ul>\n<h2 id=\"使用-dockerfile-创建镜像\">使用 Dockerfile 创建镜像</h2>\n<p>Dockerfile 是一个文本格式的配置文件，用户可以使用 Dockerfile\n来快速创建自定义的镜像。</p>\n<h3 id=\"基本结构\">基本结构</h3>\n<p>Dockerfile 由一行行命令语句组成，并且支持以 <code>#</code>\n开头的注释行。</p>\n<p>一般而言，Dockerfile分为四部分：</p>\n<ul>\n<li>基础镜像信息</li>\n<li>维护者信息</li>\n<li>镜像操作指令</li>\n<li>容器启动时执行指令</li>\n</ul>\n<h3 id=\"指令说明\">指令说明</h3>\n<p>指令的一般格式为 <code>INSTRUCTION arguments</code></p>\n<table>\n<colgroup>\n<col style=\"width: 15%\" />\n<col style=\"width: 84%\" />\n</colgroup>\n<thead>\n<tr class=\"header\">\n<th>指令</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>FROM</td>\n<td>指定所创建镜像的基础镜像</td>\n</tr>\n<tr class=\"even\">\n<td>MAINTAINER</td>\n<td>指定维护者信息</td>\n</tr>\n<tr class=\"odd\">\n<td>RUN</td>\n<td>运行命令</td>\n</tr>\n<tr class=\"even\">\n<td>CMD</td>\n<td>指定启动容器时默认执行的命令</td>\n</tr>\n<tr class=\"odd\">\n<td>LABEL</td>\n<td>指定生成镜像的元数据标签信息</td>\n</tr>\n<tr class=\"even\">\n<td>EXPOSE</td>\n<td>声明镜像内服务所监听的端口</td>\n</tr>\n<tr class=\"odd\">\n<td>ENV</td>\n<td>指定环境变量</td>\n</tr>\n<tr class=\"even\">\n<td>ADD</td>\n<td>复制指定的 <src> 路径下的内容到容器的 <dest> 路径下，<src> 可以为\nURL；如果为 tar 文件，会自动解压到 <dest> 路径下</td>\n</tr>\n<tr class=\"odd\">\n<td>CPOY</td>\n<td>复制本地主机的 <src> 路径下的内容到镜像中的 <dest>\n路径下；一般情况下推荐使用 COPY，而不是 ADD</td>\n</tr>\n<tr class=\"even\">\n<td>ENTERPOINT</td>\n<td>指定镜像的默认入口</td>\n</tr>\n<tr class=\"odd\">\n<td>VOLUME</td>\n<td>创建数据卷挂载点</td>\n</tr>\n<tr class=\"even\">\n<td>USER</td>\n<td>指定运行容器时的用户名或 UID</td>\n</tr>\n<tr class=\"odd\">\n<td>WORKDIR</td>\n<td>配置工作目录</td>\n</tr>\n<tr class=\"even\">\n<td>ARG</td>\n<td>指定镜像使用的参数</td>\n</tr>\n<tr class=\"odd\">\n<td>ONBUILD</td>\n<td>配置当所创建的镜像为其他镜像的基础镜像时，所执行的创建操作指令</td>\n</tr>\n<tr class=\"even\">\n<td>STOPSIGNAL</td>\n<td>容器退出的信号值</td>\n</tr>\n<tr class=\"odd\">\n<td>HEALTHCHECK</td>\n<td>如何进行健康检查</td>\n</tr>\n<tr class=\"even\">\n<td>SHELL</td>\n<td>指定使用 shell 时的默认 shell 类型</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"from\">FROM</h4>\n<p>指定所创建镜像的基础镜像，如果本地不存在，则默认会去 Docker Hub\n下载指定镜像。</p>\n<p>格式：<code>FROM &lt;image&gt;</code> or\n<code>FROM &lt;imgae&gt;: &lt;tag&gt;</code> or\n<code>FROM &lt;image&gt;@&lt;digest&gt;</code></p>\n<p><font color='pink'> 任何 Dockerfile 中的第一条指令必须为 FROM\n指令。并且，如果在同一个Dockerfile中创建多个镜像，可以使用多个FROM指令（每个镜像一次）。</font></p>\n<h4 id=\"maintainer\">MAINTAINER</h4>\n<p>指定维护者信息。</p>\n<p>格式：<code>MAINTAINER &lt;name&gt;</code></p>\n<h4 id=\"run\">RUN</h4>\n<p>运行指定命令。</p>\n<p>格式：<code>RUN &lt;command&gt;</code> or\n<code>RUN [\"executable\", \"param1\", \"param2\"]</code></p>\n<p>注：必须使用双引号</p>\n<p>前者默认将在 shell 终端中运行命令，即/bin/sh-c；后者则使用 exec\n执行，不会启动shell环境。</p>\n<h4 id=\"cmd\">CMD</h4>\n<p>指定启动容器时默认执行的命令。</p>\n<p>格式：</p>\n<ul>\n<li><code>CMD [\"executable\", \"param1\", \"param2\"]</code> 使用 exec\n执行</li>\n<li><code>CMD command param1 param2</code> 在 <code>/bin/sh</code>\n中执行</li>\n<li><code>CMD [\"param1\", \"param2\"]</code> 提供给 ENTERPOINT\n的默认参数</li>\n</ul>\n<p><font color='pink'>每个Dockerfile只能有一条 CMD\n命令。如果指定了多条命令，只有最后一条会被执行。</font></p>\n<h4 id=\"label\">LABEL</h4>\n<p>用来指定生成镜像的元数据标签信息。</p>\n<p>格式：<code>LABEL &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; ...</code></p>\n<h4 id=\"expose\">EXPOSE</h4>\n<p>声明镜像内服务所监听的端口。</p>\n<p>格式：<code>EXPOSE &lt;port&gt; [&lt;port&gt; ...]</code></p>\n<pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\">EXPOSE 22 80 8443</code></pre>\n<p><font color='pink'>注意，该指令只是起到声明作用，并不会自动完成端口映射。</font></p>\n<h4 id=\"env\">ENV</h4>\n<p>指定环境变量，在镜像生成过程中会被后续 RUN\n指令使用，在镜像启动的容器中也会存在。</p>\n<p>格式：<code>ENV &lt;key&gt;&lt;value&gt;</code> or\n<code>ENV &lt;key&gt;=value</code></p>\n<pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\">ENV PG_MAJOR 9.3\nENV PG_VERSION 9.3.4\nRUN curl -SL http:&#x2F;&#x2F;example.com&#x2F;postgres-$PG_VERSION.tar.xz | tar -xJC &#x2F;usr&#x2F;src&#x2F;\n    postgress &amp;&amp; …\n\n\nENV PATH &#x2F;usr&#x2F;local&#x2F;postgres-$PG_MAJOR&#x2F;bin:$PATH</code></pre>\n<h4 id=\"add\">ADD</h4>\n<p>该命令将复制指定的<src>路径下的内容到容器中的<dest>路径下。</p>\n<p>格式：<code>ADD &lt;src&gt; &lt;dest&gt;</code></p>\n<p><font color='geen'>路径支持正则格式。</font></p>\n<h4 id=\"copy\">COPY</h4>\n<p>格式：<code>COPY &lt;src&gt; &lt;dest&gt;</code></p>\n<h4 id=\"entrypoint\">ENTRYPOINT</h4>\n<p>指定镜像的默认入口命令，该入口命令会在启动容器时作为根命令执行，所有传入值作为该命令的参数。</p>\n<p>格式：</p>\n<ul>\n<li><code>ENTRYPOINT [\"executable\", \"param1\", \"param2\"]</code> exec\n调用执行</li>\n<li><code>ENTRYPOINT command param1, param2</code> shell 中执行</li>\n</ul>\n<p><font color='pink'>每个Dockerfile中只能有一个ENTRYPOINT，当指定多个时，只有最后一个有效。</font></p>\n<h4 id=\"volume\">VOLUME</h4>\n<p>创建一个数据卷挂载点。</p>\n<p>格式：<code>VOLUME [\"/data\"]</code></p>\n<h4 id=\"user\">USER</h4>\n<p>指定运行容器时的用户名或UID，后续的RUN等指令也会使用指定的用户身份。</p>\n<p>格式：<code>USER daemon</code></p>\n<h4 id=\"workdir\">WORKDIR</h4>\n<p>为后续的 RUN、CMD 和 ENTRYPOINT 指令配置工作目录。</p>\n<p>格式：<code>WORKDIR /path/to/workdir</code></p>\n<p>可以使用多个 WORKDIR\n指令，后续命令如果参数是相对路径，则会基于之前命令指定的路径。</p>\n<h4 id=\"arg\">ARG</h4>\n<p>指定一些镜像内使用的参数，这些参数在执行 <code>docker build</code>\n命令时才以 <code>--build-arg&lt;varname&gt;=&lt;value&gt;</code>\n格式传入。</p>\n<p>格式：<code>ARG &lt;name&gt;[=&lt;default value&gt;]</code></p>\n<h4 id=\"onbuild\">ONBUILD</h4>\n<p>配置当所创建的镜像作为其他镜像的基础镜像时，所执行的创建操作指令。</p>\n<p>格式：<code>ONBUILD[INSTRUCTION]</code></p>\n<h4 id=\"stopsignal\">STOPSIGNAL</h4>\n<p>指定所创建镜像启动的容器接收退出的信号值。例如：</p>\n<pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\">STOPSIGNAL signal</code></pre>\n<h4 id=\"healthcheck\">HEALTHCHECK</h4>\n<p>配置所启动容器如何进行健康检查（如何判断健康与否），自Docker\n1.12开始支持。</p>\n<p>格式：</p>\n<ul>\n<li><code>HEALTHCHECK [OPTIONS] CMD command</code>：根据所执行命令返回值是否为0来判断；</li>\n<li><code>HEALTHCHECK NONE</code>：禁止基础镜像中的健康检查。</li>\n</ul>\n<p>OPTIONS：</p>\n<ul>\n<li><code>--interval=DURATION</code>（默认为：30s）：过多久检查一次；</li>\n<li><code>--timeout=DURATION</code>（默认为：30s）：每次检查等待结果的超时；</li>\n<li><code>--retries=N</code>（默认为：3）：如果失败了，重试几次才最终确定失败。</li>\n</ul>\n<h4 id=\"shell\">SHELL</h4>\n<p>指定其他命令使用 shell 时的默认 shell 类型。</p>\n<h3 id=\"创建镜像-1\">创建镜像</h3>\n<p>编写完成 Dockerfile 之后，可以通过 <code>docker build</code>\n命令来创建镜像。</p>\n<ul>\n<li>如果使用非内容路径下的 Dockerfile，可以通过 <code>-f</code>\n选项来指定其路径。</li>\n<li>要指定生成镜像的标签信息，可以使用 <code>-t</code> 选项。</li>\n</ul>\n<p>格式：<code>docker build [OPTION] Path</code> 读取指定路径下的\nDockerfile，并将该路径下的所有内容发送到 Docker\n服务端，由服务端创建镜像。</p>\n<p>例如，指定 Dockerfile 所在路径为\n<code>/tmp/docker_builder/</code>，并且希望生成镜像标签为<code>build_repo/first_image</code>，可以使用下面的命令：</p>\n<pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\">$ docker build -t build_repo&#x2F;first_image &#x2F;tmp&#x2F;docker_builder&#x2F;</code></pre>\n<h3 id=\"使用-.dockerignore-文件\">使用 .dockerignore 文件</h3>\n<p>可以通过 .dockerignore 文件（每一行添加一条匹配模式）来让 Docker\n忽略匹配模式路径下的目录和文件。</p>\n","text":"核心概念与安装配置 Docker 的三大核心概念： 镜像(Image) 容器(Container) 仓库(Repository) 核心概念 Docker 镜像 Docker 镜像可以将其理解为一个只读的模板。它是 docker 容器的基础。用户可以从网络上下载已经配置好的镜像，并...","link":"","photos":[],"count_time":{"symbolsCount":"16k","symbolsTime":"15 mins."},"categories":[{"name":"Docker","slug":"Docker","count":3,"path":"api/categories/Docker.json"}],"tags":[{"name":"《Docker技术入门与实践》","slug":"《Docker技术入门与实践》","count":2,"path":"api/tags/《Docker技术入门与实践》.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE\"><span class=\"toc-text\">核心概念与安装配置</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">核心概念</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#docker-%E9%95%9C%E5%83%8F\"><span class=\"toc-text\">Docker 镜像</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#docker-%E5%AE%B9%E5%99%A8\"><span class=\"toc-text\">Docker 容器</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#docker-%E4%BB%93%E5%BA%93\"><span class=\"toc-text\">Docker 仓库</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#docker-%E7%9A%84%E5%AE%89%E8%A3%85\"><span class=\"toc-text\">Docker 的安装</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#ubuntu-%E7%8E%AF%E5%A2%83%E4%B8%8B%E5%AE%89%E8%A3%85-docker\"><span class=\"toc-text\">Ubuntu 环境下安装 Docker</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#centos-%E7%8E%AF%E5%A2%83%E4%B8%8B%E5%AE%89%E8%A3%85-docker\"><span class=\"toc-text\">CentOS 环境下安装 Docker</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8%E8%84%9A%E6%9C%AC%E5%AE%89%E8%A3%85\"><span class=\"toc-text\">使用脚本安装</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%85%8D%E7%BD%AE-docker-%E6%9C%8D%E5%8A%A1\"><span class=\"toc-text\">配置 Docker 服务</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#docker-%E9%95%9C%E5%83%8F-1\"><span class=\"toc-text\">Docker 镜像</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%95%9C%E5%83%8F%E8%8E%B7%E5%8F%96\"><span class=\"toc-text\">镜像获取</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9F%A5%E7%9C%8B%E9%95%9C%E5%83%8F%E4%BF%A1%E6%81%AF\"><span class=\"toc-text\">查看镜像信息</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%88%97%E5%87%BA%E6%89%80%E6%9C%89%E9%95%9C%E5%83%8F\"><span class=\"toc-text\">列出所有镜像</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%B7%BB%E5%8A%A0%E9%95%9C%E5%83%8F%E6%A0%87%E7%AD%BE\"><span class=\"toc-text\">添加镜像标签</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%9F%A5%E7%9C%8B%E8%AF%A6%E7%BB%86%E4%BF%A1%E6%81%AF\"><span class=\"toc-text\">查看详细信息</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%9F%A5%E7%9C%8B%E9%95%9C%E5%83%8F%E7%9A%84%E5%8E%86%E5%8F%B2\"><span class=\"toc-text\">查看镜像的历史</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%90%9C%E7%B4%A2%E9%95%9C%E5%83%8F\"><span class=\"toc-text\">搜索镜像</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%A0%E9%99%A4%E9%95%9C%E5%83%8F\"><span class=\"toc-text\">删除镜像</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8%E6%A0%87%E7%AD%BE%E5%88%A0%E9%99%A4\"><span class=\"toc-text\">使用标签删除</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8%E9%95%9C%E5%83%8F-id-%E5%88%A0%E9%99%A4\"><span class=\"toc-text\">使用镜像 ID 删除</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%9B%E5%BB%BA%E9%95%9C%E5%83%8F\"><span class=\"toc-text\">创建镜像</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E4%BA%8E%E5%B7%B2%E6%9C%89%E9%95%9C%E5%83%8F%E7%9A%84%E5%AE%B9%E5%99%A8%E5%88%9B%E5%BB%BA\"><span class=\"toc-text\">基于已有镜像的容器创建</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E4%BA%8E%E6%9C%AC%E5%9C%B0%E6%A8%A1%E6%9D%BF%E5%AF%BC%E5%85%A5\"><span class=\"toc-text\">基于本地模板导入</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AD%98%E5%87%BA%E5%92%8C%E8%BD%BD%E5%85%A5%E9%95%9C%E5%83%8F\"><span class=\"toc-text\">存出和载入镜像</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%AD%98%E5%87%BA%E9%95%9C%E5%83%8F\"><span class=\"toc-text\">存出镜像</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%BD%BD%E5%85%A5%E9%95%9C%E5%83%8F\"><span class=\"toc-text\">载入镜像</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%8A%E4%BC%A0%E9%95%9C%E5%83%8F\"><span class=\"toc-text\">上传镜像</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#docker-%E5%AE%B9%E5%99%A8-1\"><span class=\"toc-text\">Docker 容器</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%9B%E5%BB%BA%E5%AE%B9%E5%99%A8\"><span class=\"toc-text\">创建容器</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%96%B0%E5%BB%BA%E5%AE%B9%E5%99%A8\"><span class=\"toc-text\">新建容器</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%90%AF%E5%8A%A8%E5%AE%B9%E5%99%A8\"><span class=\"toc-text\">启动容器</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%96%B0%E5%BB%BA%E5%B9%B6%E5%90%AF%E5%8A%A8%E5%AE%B9%E5%99%A8\"><span class=\"toc-text\">新建并启动容器</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%AE%88%E6%8A%A4%E6%80%81%E8%BF%90%E8%A1%8C\"><span class=\"toc-text\">守护态运行</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BB%88%E6%AD%A2%E5%AE%B9%E5%99%A8\"><span class=\"toc-text\">终止容器</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BF%9B%E5%85%A5%E5%AE%B9%E5%99%A8\"><span class=\"toc-text\">进入容器</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#attach-%E5%91%BD%E4%BB%A4\"><span class=\"toc-text\">attach 命令</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#exec-%E5%91%BD%E4%BB%A4\"><span class=\"toc-text\">exec 命令</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#nsenter-%E5%B7%A5%E5%85%B7\"><span class=\"toc-text\">nsenter 工具</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%A0%E9%99%A4%E5%AE%B9%E5%99%A8\"><span class=\"toc-text\">删除容器</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AF%BC%E5%85%A5%E5%92%8C%E5%AF%BC%E5%87%BA%E5%AE%B9%E5%99%A8\"><span class=\"toc-text\">导入和导出容器</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%AF%BC%E5%87%BA%E5%AE%B9%E5%99%A8\"><span class=\"toc-text\">导出容器</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%AF%BC%E5%85%A5%E5%AE%B9%E5%99%A8\"><span class=\"toc-text\">导入容器</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%AE%BF%E9%97%AE-docker-%E4%BB%93%E5%BA%93\"><span class=\"toc-text\">访问 Docker 仓库</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#docker-hub%E5%85%AC%E5%85%B1%E9%95%9C%E5%83%8F%E5%B8%82%E5%9C%BA\"><span class=\"toc-text\">Docker Hub公共镜像市场</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%97%B6%E9%80%9F%E4%BA%91%E9%95%9C%E5%83%8F%E5%B8%82%E5%9C%BA\"><span class=\"toc-text\">时速云镜像市场</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%90%AD%E5%BB%BA%E6%9C%AC%E5%9C%B0%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93\"><span class=\"toc-text\">搭建本地私有仓库</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8-registry-%E9%95%9C%E5%83%8F%E5%88%9B%E5%BB%BA%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93\"><span class=\"toc-text\">使用 registry\n镜像创建私有仓库</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%AE%A1%E7%90%86%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93\"><span class=\"toc-text\">管理私有仓库</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#docker-%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86\"><span class=\"toc-text\">Docker 数据管理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%95%B0%E6%8D%AE%E5%8D%B7\"><span class=\"toc-text\">数据卷</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%9C%A8%E5%AE%B9%E5%99%A8%E5%86%85%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%8D%B7\"><span class=\"toc-text\">在容器内创建一个数据卷</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%8C%82%E8%BD%BD%E4%B8%80%E4%B8%AA%E4%B8%BB%E6%9C%BA%E7%9B%AE%E5%BD%95%E4%BD%9C%E4%B8%BA%E6%95%B0%E6%8D%AE%E5%8D%B7\"><span class=\"toc-text\">挂载一个主机目录作为数据卷</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%8C%82%E8%BD%BD%E4%B8%80%E4%B8%AA%E6%9C%AC%E5%9C%B0%E4%B8%BB%E6%9C%BA%E6%96%87%E4%BB%B6%E4%BD%9C%E4%B8%BA%E6%95%B0%E6%8D%AE%E5%8D%B7\"><span class=\"toc-text\">挂载一个本地主机文件作为数据卷</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%95%B0%E6%8D%AE%E5%8D%B7%E5%AE%B9%E5%99%A8\"><span class=\"toc-text\">数据卷容器</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%A9%E7%94%A8%E6%95%B0%E6%8D%AE%E5%8D%B7%E5%AE%B9%E5%99%A8%E6%9D%A5%E8%BF%81%E7%A7%BB%E6%95%B0%E6%8D%AE\"><span class=\"toc-text\">利用数据卷容器来迁移数据</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%AB%AF%E5%8F%A3%E6%98%A0%E5%B0%84%E4%B8%8E%E5%AE%B9%E5%99%A8%E4%BA%92%E8%81%94\"><span class=\"toc-text\">端口映射与容器互联</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%AB%AF%E5%8F%A3%E6%98%A0%E5%B0%84%E5%AE%9E%E7%8E%B0%E8%AE%BF%E9%97%AE%E5%AE%B9%E5%99%A8\"><span class=\"toc-text\">端口映射实现访问容器</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BA%92%E8%81%94%E6%9C%BA%E5%88%B6%E5%AE%9E%E7%8E%B0%E4%BE%BF%E6%8D%B7%E4%BA%92%E8%AE%BF\"><span class=\"toc-text\">互联机制实现便捷互访</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8-dockerfile-%E5%88%9B%E5%BB%BA%E9%95%9C%E5%83%8F\"><span class=\"toc-text\">使用 Dockerfile 创建镜像</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">基本结构</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%8C%87%E4%BB%A4%E8%AF%B4%E6%98%8E\"><span class=\"toc-text\">指令说明</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#from\"><span class=\"toc-text\">FROM</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#maintainer\"><span class=\"toc-text\">MAINTAINER</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#run\"><span class=\"toc-text\">RUN</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#cmd\"><span class=\"toc-text\">CMD</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#label\"><span class=\"toc-text\">LABEL</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#expose\"><span class=\"toc-text\">EXPOSE</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#env\"><span class=\"toc-text\">ENV</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#add\"><span class=\"toc-text\">ADD</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#copy\"><span class=\"toc-text\">COPY</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#entrypoint\"><span class=\"toc-text\">ENTRYPOINT</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#volume\"><span class=\"toc-text\">VOLUME</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#user\"><span class=\"toc-text\">USER</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#workdir\"><span class=\"toc-text\">WORKDIR</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#arg\"><span class=\"toc-text\">ARG</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#onbuild\"><span class=\"toc-text\">ONBUILD</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#stopsignal\"><span class=\"toc-text\">STOPSIGNAL</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#healthcheck\"><span class=\"toc-text\">HEALTHCHECK</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#shell\"><span class=\"toc-text\">SHELL</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%9B%E5%BB%BA%E9%95%9C%E5%83%8F-1\"><span class=\"toc-text\">创建镜像</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8-.dockerignore-%E6%96%87%E4%BB%B6\"><span class=\"toc-text\">使用 .dockerignore 文件</span></a></li></ol></li></ol>","author":{"name":"爱慢跑的乌龟","slug":"blog-author","avatar":"/img/avatar1.jpg","link":"/","description":"求知若饥，虚心若愚！","socials":{"github":"https://github.com/ansonxu1998","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"棋盘格角点检测","uid":"1eaff4e22fb5fa029043d1942e6ee81c","slug":"Digital-Image/X-Corner","date":"2022-06-29T07:11:00.000Z","updated":"2023-04-15T05:07:30.420Z","comments":true,"path":"api/articles/Digital-Image/X-Corner.json","keywords":null,"cover":"/img/X-Corners/checkerboard.png","text":"A New Sub-Pixel Detector for X-Corners in Camera Calibration Targets 基于海塞矩阵的方法 一个标准的 X-Corners 如下图所示： 其表达式为： 由于实际的图像中存在噪点，所以需要对图像进行低通滤波，这里使用...","link":"","photos":[],"count_time":{"symbolsCount":"1.3k","symbolsTime":"1 mins."},"categories":[{"name":"图像处理","slug":"图像处理","count":1,"path":"api/categories/图像处理.json"}],"tags":[{"name":"相机标定","slug":"相机标定","count":1,"path":"api/tags/相机标定.json"},{"name":"角点检测","slug":"角点检测","count":1,"path":"api/tags/角点检测.json"}],"author":{"name":"爱慢跑的乌龟","slug":"blog-author","avatar":"/img/avatar1.jpg","link":"/","description":"求知若饥，虚心若愚！","socials":{"github":"https://github.com/ansonxu1998","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Latex数学公式","uid":"409671003844af96bee509bb7a2097ee","slug":"Math/Latex_formula","date":"2022-06-20T02:24:00.000Z","updated":"2023-04-15T03:06:51.950Z","comments":true,"path":"api/articles/Math/Latex_formula.json","keywords":null,"cover":"/img/index_img/LatexLogo.png","text":"数学公式的插入 类型 环境名称 行内公式 $...$ 独行公式 $$...$$ 希腊字母 命令 大写 小写 alpha gamma epsilon eta iota lambda nu xi rho tau phi psi beta delta zeta theta kappa ...","link":"","photos":[],"count_time":{"symbolsCount":"6.8k","symbolsTime":"6 mins."},"categories":[{"name":"数学","slug":"数学","count":2,"path":"api/categories/数学.json"}],"tags":[{"name":"手册","slug":"手册","count":1,"path":"api/tags/手册.json"}],"author":{"name":"爱慢跑的乌龟","slug":"blog-author","avatar":"/img/avatar1.jpg","link":"/","description":"求知若饥，虚心若愚！","socials":{"github":"https://github.com/ansonxu1998","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}