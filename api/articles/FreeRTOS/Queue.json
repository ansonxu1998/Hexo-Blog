{"title":"FreeRTOS 的队列 (Queue)","uid":"b5bbb50a4ed24d8a8d9fcbeb2df5e6ea","slug":"FreeRTOS/Queue","date":"2023-05-05T12:57:00.000Z","updated":"2023-05-06T11:27:20.463Z","comments":true,"path":"api/articles/FreeRTOS/Queue.json","keywords":null,"cover":"/img/FreeRTOS/logo.jpg","content":"<p>队列提供一种任务到任务、任务到中断和中断到任务之间的通信机制。</p>\n<h2 id=\"队列的特点\">队列的特点</h2>\n<h3 id=\"数据存储\">数据存储</h3>\n<p>队列可保存有限数量的<strong>固定大小</strong>的数据项。一个队列可以容纳的最大数据量称为它的长度。在创建队列时需要指定每个数据项的长度和大小。队列通常使用先进先出(FIFO)缓冲区，数据在队列末尾被被写入并仓队列前端删除。</p>\n<p><img src=\"/img/FreeRTOS/queue.png\" style=\"zoom:50%;\"></p>\n<p>有两种方式实现队列行为：</p>\n<ul>\n<li><p>复制</p>\n<p>将发送到队列的数据逐字节地复制到队列中。</p></li>\n<li><p>引用</p>\n<p>只保存指向发送到队列的数据的指针，而不是数据本身。</p></li>\n</ul>\n<p>FreeRTOS\n采用的复制的方法。复制的方法通常比引用更强大，同时也更简单，原因如下：</p>\n<ul>\n<li>栈变量可以直接发送到队列，即便声明它的函数退出后，该变量不存在了。</li>\n<li>可以将数据发送到队列，而无需首先分配一个缓冲区来保存数据，然后将数据复制到已分配的缓冲区中。</li>\n<li>发送任务可以立即重用发送到队列的变量或缓冲区。</li>\n<li>发送任务和接收任务是完全解耦的。</li>\n<li>RTOS 完全负责分配用于存储数据的内存。</li>\n</ul>\n<h3 id=\"多任务访问\">多任务访问</h3>\n<p>队列本身就是对象，任何的任务和 ISR\n都可以访问它。任意数量的任务都可以写入同一队列，任意数量的任务都可以从同一队列中读取数据。在实际中，多个任务写同一队列很常见，而多个任务读同一队列却并不常见。</p>\n<h3 id=\"读队列阻塞\">读队列阻塞</h3>\n<p>当一个任务试图从队列中读取数据时，它可以选择指定一个阻塞时间。当队列为空时，任务将保持阻塞状态以等待队列中有可用的数据。当有数据写入到队列时，处于阻塞状态的任务将自动转为就绪状态。如果指定的阻塞时间到了，还没有等到队列中的数据，任务也将自动从阻塞状态转为就绪状态。</p>\n<p>可以有多个数据读队列，因此一个队列可能会有多个任务阻塞在它上面等地数据。在这种情况下，当队列中有可用数据时，只有一个任务能被解除阻塞状态。解除阻塞的任务将始终是所有等待数据的任务中最高优先级的，如果优先级相同，解除阻塞的将是等待时间最长的任务。</p>\n<h3 id=\"写队列阻塞\">写队列阻塞</h3>\n<p>任务向对列写入时可以指定阻塞时间。如果队列在准备写入时已满，任务将进入阻塞状态，阻塞时间是任务等待队列可写入的最长时间。可以有多个任务向队列写入，因此一个队列可能阻塞多个任务。当队列上有一个可写入空间时，则只能有一个任务完成写入而解除阻塞。解除阻塞的任务将是所有阻塞任务中优先级最高的。如果阻塞任务的优先级相同，则解除阻塞的任务将是等待时间最长的任务。</p>\n<h3 id=\"多队列上的阻塞\">多队列上的阻塞</h3>\n<p>可以将队列分组为集合，允许任务进入阻塞状态，以等待数据在集合中的任何队列上可用</p>\n<h2 id=\"使用一个队列\">使用一个队列</h2>\n<h3 id=\"xqueuecreate-api-函数\"><code>xQueueCreate()</code> API 函数</h3>\n<p>在队列使用之前，必须显式低创建队列。</p>\n<p>队列通过一个句柄来引用，句柄是 <code>QueueHandle_t</code>\n类型的变量。 <code>xQueueCreate()</code> API 函数创建一个队列并返回一个\n<code>QueueHandle_t</code>，这个句柄引用了它创建的队列。</p>\n<p>当创建队列时，FreeRTOS 从 FreeRTOS 堆中分配 RAM。RAM\n用于保存队列数据结构和包含在队列中的项。如果要创建的队列没有足够的堆内存可用，<code>xQueueCreate()</code>\n将返回 <code>NULL</code>。</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">QueueHandle_t xQueueCreate( UBaseType_t uxQueueLength, UBaseType_t uxItemSize );</code></pre>\n<table>\n<colgroup>\n<col style=\"width: 18%\">\n<col style=\"width: 81%\">\n</colgroup>\n<thead>\n<tr class=\"header\">\n<th>Parameter Name</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>uxQueueLength</td>\n<td>队列长度，最多能存放多少个数据(item)</td>\n</tr>\n<tr class=\"even\">\n<td>uxItemSize</td>\n<td>每个数据(item)的大小：以字节为单位</td>\n</tr>\n<tr class=\"odd\">\n<td>Return Value</td>\n<td>非\n0：成功，返回句柄，以后使用句柄来操作队列<br>NULL：失败，因为内存不足</td>\n</tr>\n</tbody>\n</table>\n<p>创建队列后，可以使用 <code>xQueueReset()</code> API\n函数将队列返回到其原始空状态。</p>\n<h3 id=\"xqueuesendtoback-和-xqueuesendtofront-api-函数\"><code>xQueueSendToBack()</code>\n和 <code>xQueueSendToFront()</code> API 函数</h3>\n<p><code>xQueueSendToBack()</code>\n函数用于将数据发送到队列的末尾。<code>xQueueSendToFront()</code>\n用于将数据发送到队列的开头。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>不要在中断服务函数中调用 <code>xQueueSendToBack()</code> 和\n<code>xQueueSendToFront()</code> 函数。应该在中断服务程序中使用\n<code>xQueueSendToFrontFromISR()</code> 和\n<code>xQueueSendToBackFromISR()</code> 安全版本。</p></blockquote>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">BaseType_t xQueueSendToFront(QueueHandle_t xQueue,\n\t\t\t\t\t\t\t const void * pvItemToQueue,\n\t\t\t\t\t\t\t TickType_t xTicksToWait );</code></pre>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">BaseType_t xQueueSendToBack(QueueHandle_t xQueue,\n\t\t\t\t\t\t\tconst void * pvItemToQueue,\n\t\t\t\t\t\t\tTickType_t xTicksToWait );</code></pre>\n<table>\n<colgroup>\n<col style=\"width: 18%\">\n<col style=\"width: 81%\">\n</colgroup>\n<thead>\n<tr class=\"header\">\n<th>Parameter Name</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>xQueue</td>\n<td>队列的句柄。</td>\n</tr>\n<tr class=\"even\">\n<td>pvItemToQueue</td>\n<td>指向要复制到队列中的数据的指针。<br>在创建队列时设置了队列可以容纳的数据的长度，因此这些字节将从\npvItemToQueue 复制到队列存储区域。</td>\n</tr>\n<tr class=\"odd\">\n<td>xTicksToWait</td>\n<td>阻塞时间。<br>等待时间为 tick 中断数。<br>设置为\n0，则不等待立即返回。<br>设置为 <code>portMAX_DELAY</code>，将永远等待\n(<code>INCLUDE_vTaskSuspend</code> 要设置为 1)。</td>\n</tr>\n<tr class=\"even\">\n<td>Returned value</td>\n<td>pdPASS: 数据成功发送到队列。<br>errQUEUE_FULL:\n写入失败，队列已满。</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"xqueuereceive-api-函数\"><code>xQueueReceive()</code> API\n函数</h3>\n<p><code>xQueueReceive()</code>\n用于从队列中读取数据。读取过的数据将从队列中删除。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>不要从中断服务程序中调用\n<code>xqueuerreceive()</code>。中断服务函数中使用安全的\n<code>xQueueReceiveFromISR()</code> API函数。</p></blockquote>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">BaseType_t xQueueReceive(QueueHandle_t xQueue,\n\t\t\t\t\t\t void * const pvBuffer,\n\t\t\t\t\t\t TickType_t xTicksToWait );</code></pre>\n<table>\n<colgroup>\n<col style=\"width: 18%\">\n<col style=\"width: 81%\">\n</colgroup>\n<thead>\n<tr class=\"header\">\n<th>Parameter Name</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>xQueue</td>\n<td>队列句柄。</td>\n</tr>\n<tr class=\"even\">\n<td>pvBuffer</td>\n<td>指向内存的指针，读取到的数据将被复制到其中</td>\n</tr>\n<tr class=\"odd\">\n<td>xTicksToWait</td>\n<td>阻塞时间。<br>等待时间为 tick 中断数。<br>设置为\n0，则不等待立即返回。<br>设置为 <code>portMAX_DELAY</code>，将永远等待\n(<code>INCLUDE_vTaskSuspend</code> 要设置为 1)。</td>\n</tr>\n<tr class=\"even\">\n<td>Returned value</td>\n<td>pdPASS: 数据成功发送到队列。<br>errQUEUE_FULL:\n写入失败，队列已满。</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"uxqueuemessageswaiting-api-函数\"><code>uxQueueMessagesWaiting()</code>\nAPI 函数</h3>\n<p><code>uxQueueMessagesWaiting()</code>\n用于查询当前在队列中的数据个数。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>在中断服务函数中使用 <code>uxQueueMessagesWaitingFromISR()</code></p></blockquote>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">UBaseType_t uxQueueMessagesWaiting( QueueHandle_t xQueue );</code></pre>\n<table>\n<thead>\n<tr class=\"header\">\n<th>Parameter Name</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>xQueue</td>\n<td>队列句柄。</td>\n</tr>\n<tr class=\"even\">\n<td>Returned value</td>\n<td>队列中的存在的数据个数。如果返回0，则队列为空。</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"example-10-接受队列数据时阻塞\">Example 10\n接受队列数据时阻塞</h3>\n<p>创建队列、从多个任务向队列发送数据以及从队列接收数据的过程。发送到队列的任务的优先级低于从队列接收的任务的优先级。这意味着队列不应该包含多数据，因为一旦数据被发送到队列，接收任务就会解除阻塞，抢占发送任务，并删除数据，使队列再次为空。</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">static void vSenderTask(void *pvParameters){\n  int32_t lValueToSend;\n  BaseType_t xStatus;\n\n  lValueToSend = (int32_t)pvParameters;\n\n  while (1){\n    xStatus = xQueueSendToBack(xQueue, &amp;lValueToSend, 0);\n    if (xStatus != pdPASS){\n      printf(\"Could not send to the queue.\\r\\n\");\n    }\n  }\n}</code></pre>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">static void vReceiverTask(void *pvParameters){\n    int32_t lReceivedValue;\n    BaseType_t xStatus;\n    \n    while (1)\n    {\n      if(uxQueueMessagesWaiting(xQueue) != 0){\n        printf(\"Queue should have been empty!\\r\\n\");\n      }\n\n      xStatus = xQueueReceive(xQueue, &amp;lReceivedValue, pdMS_TO_TICKS(100));\n      if(xStatus == pdPASS){\n        printf(\"Received = %d\", lReceivedValue);\n      }else{\n        printf(\"Could not receive from the queue.\\r\\n\");\n      }\n    } \n}</code></pre>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">int main(void)\n{\n    USART_Printf_Init(115200);\n    printf(\"SystemClk:%d\\r\\n\",SystemCoreClock);\n    printf(\"FreeRTOS Kernel Version:%s\\r\\n\",tskKERNEL_VERSION_NUMBER);\n\n    GPIO_Toggle_INIT();\n    xQueue = xQueueCreate(5, sizeof(int32_t));\n    \n    if(xQueue != NULL){\n      xTaskCreate(vSenderTask, \"Sender1\", 1000, (void*) 100, 1, NULL);\n      xTaskCreate(vSenderTask, \"Sender2\", 1000, (void*) 200, 1, NULL);\n\n      xTaskCreate(vReceiverTask, \"Receiver\", 1000, NULL, 2, NULL);\n      vTaskStartScheduler();\n    }else{\n      printf(\"The queue could not be created.\");\n    }\n    while(1)\n    {\n        printf(\"shouldn't run at here!!\\n\");\n    }\n}</code></pre>\n<p>实验结果：</p>\n<p><img src=\"/img/FreeRTOS/queue%20example.png\"></p>\n<h2 id=\"从多个来源接收数据\">从多个来源接收数据</h2>\n<p>一个任务从多个来源接收数据是很常见的。接收数据的任务需要直到数据来自何处，以确定应该如何处理数据。一个简单的设计方案是使用单个队列来传输一个结构体，在结构体的字段中包含数据值和数据来源。</p>\n<p><img src=\"/img/FreeRTOS/queue 2.png\" style=\"zoom:50%;\"></p>\n<ul>\n<li>创建一个保存 Data_t\n结构体类型的队列。结构体成员允许在一条消息中将数据值和枚举类型（指示数据的含义）发送到队列。</li>\n<li>Controller\n任务用于执行系统的主要功能。它必须对队列上传递给它的系统状态的输入和更改做出反应。</li>\n<li>CAN 总线任务用于封装 CAN 总线接口功能。当 CAN\n总线任务接收并解码消息后，它将已解码的消息以 Data_t 结构体发送给\nController 任务。传输结构体的 eDataID 成员用于让 Controller\n任务知道数据是什么。</li>\n<li>人机界面 (HMI) 任务用于封装所有 HMI\n功能。机器操作员可能会以多种方式输入命令和查询值，这些方式必须在 HMI\n任务中进行检测和解释。当输入一个新命令时，HMI 任务将命令以Data_t\n结构体发送给 Controller 任务。</li>\n</ul>\n<h3 id=\"example-11-向队列发送结构体\">Example 11 向队列发送结构体</h3>\n<p>创建消息结构体：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">typedef enum{\n    eSender1,\n    eSender2,\n} DataSource_t;\n\ntypedef struct{\n    uint8_t ucValue;\n    DataSource_t eDataSource;\n} Data_t;\n\nstatic const Data_t xStructsToSend[2] = {\n    {100, eSender1},\n    {200, eSender2}\n};</code></pre>\n<p>发送任务具有更高的优先级，因此队列通常是满的。这是因为，一旦接收任务从队列中删除一个项目，它就会被其中一个发送任务抢占，然后立即重新填充队列。然后，发送任务重新进入阻塞状态，等待队列上的空间再次可用。</p>\n<p>发送任务：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">static void vSenderTask(void *pvParameters){\n    BaseType_t xStatus;\n    \n    while(1){\n        xStatus = xQueueSendToBack(xQueue, pvParameters, pdMS_TO_TICKS(100));\n        if(xStatus != pdPASS){\n            printf(\"Could not send to the queue.\\r\\n\");\n        }\n    }\n}</code></pre>\n<p>接收任务：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">static void vReceiverTask(void *pvParameters){\n    Data_t xReceivedStructure;\n    BaseType_t xStatus;\n    \n    while(1){\n        if(uxQueueMessagesWaiting(xQueue) != 3){\n            printf(\"Queue should have been full!\\r\\n\");\n        }\n        xStatus = xQueueReceive(xQueue, &amp;xReceivedStructure, 0);\n        if(xStatus == pdPASS){\n            if(xReceivedStructure.eDataSource == eSender1){\n                printf(\"From Sender 1 = %d \\r\\n\", xReceivedStructure.ucValue);\n            }else{\n                printf(\"From Sender 2 = %d \\r\\n\", xReceivedStructure.ucValue);\n            }\n        }else{\n            printf(\"Could not receive from the queue.\\r\\n\");\n        }\n    }\n}</code></pre>\n<p>主函数：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">int main(void){\n    xQueue = xQueueCreate(3, sizeof(Data_t));\n    if(xQueue != NULL){\n        xTaskCreate(vSenderTask, \"Sender1\", 256, (void *) &amp;(xStructsToSend[0]), 2, NULL);\n         xTaskCreate(vSenderTask, \"Sender2\", 256, (void *) &amp;(xStructsToSend[1]), 2, NULL);\n        xTaskCreate(vReceiverTask, \"Receiver\", 256, NULL, 1, NULL);\n        vTaskStartScheduler();\n    }else{\n        printf(\"The queue could not be created\");\n    }\n    while(1);\n}</code></pre>\n<p>实验结果：</p>\n<p><img src=\"/img/FreeRTOS/queue%20multi%20source.png\"></p>\n<h2 id=\"处理大型或可变大小的数据\">处理大型或可变大小的数据</h2>\n<h3 id=\"queuing-pointers\">Queuing Pointers</h3>\n<p>如果存储在队列中的数据的大小很大，那么最好使用队列来传输指向数据的指针，而不是将数据本身一个字节一个字节地复制到队列中或从队列中复制出来。传递指针在处理时间和创建队列所需内存空间方面都更有效。但是，在使用指针队列时，必须非常小心，以确保：</p>\n<ul>\n<li><p>被指向的 RAM 所有者是明确定义的。</p>\n<p>当通过指针在任务之间共享内存时，必须确保两个任务不会同时修改内存内容，或者采取任何其他可能导致内存内容无效或不一致的操作。理想情况下，应该只允许发送任务访问内存，直到指向内存的指针进入队列，并且在从队列接收指针之后，应该只允许接收任务访问内存。</p></li>\n<li><p>所指向的 RAM 始终有效</p>\n<p>如果所指向的内存是动态分配的，或者是从预分配的缓冲区池中获得的，那么应该只有一个任务负责释放内存。在内存被释放后，任何任务都不应该尝试访问内存。</p>\n<p>绝不应该使用指针来访问已在任务栈上分配的数据。在栈帧改变后，数据将无效。</p></li>\n</ul>\n<p><strong>示例：创建一个最多可容纳 5 个指针的队列。</strong></p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">QueueHandle_t xPointerQueue;\nxPointerQueue = xQueueCreate( 5, sizeof( char * ) );</code></pre>\n<p><strong>示例：分配一个缓冲区，向缓冲区写入一个字符串，然后向队列发送一个指向缓冲区的指针。</strong></p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">void vStringSendingTask(void *pvParameters){\n    char *pcStringToSend;\n    const size_t xMaxStringLength = 50;\n    BaseType_t xStringNumber = 0;\n    while(1){\n        pcStringToSend = (char *)prvGetBuffer(xMaxStringLength);\n        snprintf(pcStringToSend, xMaxStrintLength, \"String number %d\\r\\n\", xStringNumber);\n        xStringNumber++;\n        xQueueSend(xPointerQueue,\n                   &amp;pcStringToSend,\n                   portMAX_DELAY);\n    }\n}</code></pre>\n<p><strong>示例：从队列接收一个指向缓冲区的指针，然后打印缓冲区中包含的字符串。</strong></p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">void vStringReceivingTask(void *pvParameters){\n    char *pcReceivedString;\n    while(1){\n        xQueueReceive(xPointerQueue,\n                      &amp;pcReceivedString,\n                      portMAX_DELAY);\n        vPrintString(pcReceivedString);\n        prvReleaseBuffer(pcReceivedString);\n    }\n}</code></pre>\n<h3 id=\"使用队列发送不同类型和长度的数据\">使用队列发送不同类型和长度的数据</h3>\n<p>结合<strong>将结构体发送到队列</strong>和<strong>将指针发送到队列</strong>的技术，任务可以使用单个队列从任何数据源接收任何数据类型。FreeRTOS+TCP\nTCP/IP 栈提供了如何实现这一目标的实际示例。</p>\n<p>TCP/IP\n栈在自己的任务中运行，必须处理来自许多不同源的事件。不同的事件类型与不同的数据类型和长度相关联。所有发生在\nTCP/IP 任务之外的事件都由 IPStackEvent_t\n类型的结构体描述，并以队列的形式发送给 TCP/IP 任务。IPStackEvent_t\n结构体的 pvData\n成员是一个指针，可以用来直接保存一个值，或者指向一个缓冲区。</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">/* A subset of the enumerated types used in the TCP/IP stack to identify events. */\ntypedef enum{\n    eNetworkDownEvent = 0, /* The network interface has been lost, or needs (re)connecting. */\n    eNetworkRxEvent, /* A packet has been received from the network. */\n    eTCPAcceptEvent, /* FreeRTOS_accept() called to accept or wait for a new client. */\n    /* Other event types appear here but are not shown in this listing. */\n} eIPEvent_t;\n\n/* The structure that describes events, and is sent on a queue to the TCP/IP task. */\ntypedef struct IP_TASK_COMMANDS\n{\n    /* An enumerated type that identifies the event. See the eIPEvent_t definition above. */\n    eIPEvent_t eEventType;\n    /* A generic pointer that can hold a value, or point to a buffer. */\n    void *pvData;\n} IPStackEvent_t;</code></pre>\n<p>TCP/IP事件及其相关数据包括:</p>\n<ul>\n<li>eNetworkRxEvent: 从网络接收到一个数据包。</li>\n</ul>\n<p>从网络接收到的数据使用 IPStackEvent_t 类型的结构体发送到 TCP/IP\n任务。结构体的 eEventType 成员被设置为 eNetworkRxEvent，结构体的 pvData\n成员被用来<strong>指向包含接收数据的缓冲区</strong>。</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">void vSendRxDataToTheTCPTask(NetworkBufferDescriptor_t *pxRxedData){\n    IPStackEvent_t xEventStruct;\n    /* Complete the IPStackEvent_t structure. The received data is stored in pxRxedData. */\n    xEventStruct.eEventType = eNetworkRxEvent;\n    xEventStruct.pvData = (void*) pxRxedData;\n    /* Send the IPStackEvent_t structure to the TCP/IP task. */\n    xSendEventStructToIPTask(&amp;xEventStruct);\n}</code></pre>\n<ul>\n<li>eTCPAcceptEvent: 套接字将接受或等待来自客户端的连接。</li>\n</ul>\n<p>接收事件从调用 <code>FreeRTOS_accept()</code> 的任务发送到使用\nIPStackEvent_t 类型结构的 TCP/IP 任务。结构体的 eEventType 成员设置为\n<strong>eTCPAcceptEvent</strong>，结构体的 pvData\n成员设置为<strong>正在接受连接的套接字的句柄</strong>。</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">void vSendAcceptRequestToTheTCPTask(Socket_t xSocket){\n    IPStackEvent_t xEventStruct;\n    /* complete the IPStackEvent_t structure. */\n    xEventStruct.eEventType = eTCPAcceptEvent;\n    xEventStruct.pvData = (void*) xSocket;\n    \n    /* Send the IPStackEvent_t structure to the TCP/IP task. */\n    xSendEventStructToIPTask(&amp;xEventStruct);\n}</code></pre>\n<ul>\n<li>eNetworkDownEvent: 网络需要连接或重新连接。</li>\n</ul>\n<p>网络 down 事件使用 IPStackEvent_t 类型的结构体从网络接口发送到 TCP/IP\n任务。结构体的eEventType 成员被设置为\n<strong>eNetworkDownEvent</strong>。网络关闭事件不与任何数据相关联，因此不使用结构的\npvData 成员。</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">void vSendNetworkDownEventToTheTCPTask(Socket_t xSocket){\n    IPStackEvent_t xEventStruct;\n    /* Complete the IPStackEvent_t structure. */\n    xEventStruct.eEventType = eNetworkDownEvent;\n    xEventStruct.pvData = NULL;\n    /* Send the IPStackEvent_t structure to the TCP/IP task.*/\n    xSend the IPStackStructToIPTask(&amp;xEventStruct);\n}</code></pre>\n<p>TCP/IP 任务：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">IPStackEvent_t xReceivedEvent;\nxReceivedEvent.eEventType = eNoEvent;\nxQueueReceive(xNetworkEventQueue, &amp;xReceivedEvent, xNextIPSleep);\n/* Which event was received, if any? */\nswitch( xReceivedEvent.eEventType )\n{\n    case eNetworkDownEvent :\n        prvProcessNetworkDownEvent();\n        break;\n    case eNetworkRxEvent:\n        prvHandleEthernetPacket( ( NetworkBufferDescriptor_t * )( xReceivedEvent.pvData ) );\n        break;\n    case eTCPAcceptEvent:\n        xSocket = ( FreeRTOS_Socket_t * ) ( xReceivedEvent.pvData );\n        xTCPCheckNewClient( pxSocket );\n        break;\n    /* Other event types are processed in the same way, but are not shown here. */\n}</code></pre>\n<h2 id=\"从多个队列接收数据\">从多个队列接收数据</h2>\n<h3 id=\"队列集\">队列集</h3>\n<p>一个任务有时候需要接收不同大小的数据、不同含义的数据和来自不来源的数据。使用单队列发送结构体数据是一种简单有效的方法。但是有时需要为某些数据源提供单独的队列来传输数据。例如，将第三方代码集成到设计中时，可能需要为这些数据提供专门的队列。在这种情况下，可以使用队列集。</p>\n<p>队列集允许任务从多个队列接收数据，而无需一次轮询每个队列以确定哪个队列包含数据。</p>\n<p>与使用单个队列接收结构体的方法相比，使用队列集从多个来源接收数据的设计不那么整洁，效率也更低。因此，仅在设计受到约束而绝对有必要使用队列集时才使用队列集。</p>\n<p>使用队列集的方法：</p>\n<ul>\n<li><p>创建一个队列集</p></li>\n<li><p>添加队列到集合中（信号量也可以添加到队列中）</p></li>\n<li><p>读取队列集以确定该集合中的哪些队列包含数据。</p>\n<p>当作为集合成员的队列接收数据时，接收队列的句柄被发送到队列集中，并在任务调用函数读取队列集时返回给任务。因此，如果从队列集返回队列句柄，则确定该句柄引用的队列包含数据，然后任务可以直接从队列中读取数据。</p></li>\n</ul>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>如果队列是队列集的成员，则不要从队列中读取数据，除非队列的句柄已从队列集中读取。</p></blockquote>\n<p>若要启用队列集功能，则需要将 <code>configUSE_QUEUE_SETS</code> 配置为\n1.</p>\n<h3 id=\"xqueuecreateset-api-函数\"><code>xQueueCreateSet()</code> API\n函数</h3>\n<p>队列集由句柄引用，句柄是 QueueSetHandle_t\n类型的变量。<code>xQueueCreateSet()</code>\n函数创建一个队列集，并返回一个引用它创建的队列集的 QueueSetHandle_t\n句柄。</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">QueueSetHandle_t xQueueCreateSet( const UBaseType_t uxEventQueueLength );</code></pre>\n<table>\n<colgroup>\n<col style=\"width: 23%\">\n<col style=\"width: 76%\">\n</colgroup>\n<thead>\n<tr class=\"header\">\n<th>Parameter Name</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>uxEventQueueLength</td>\n<td>当作为队列集成员的队列接收数据时，接收队列的句柄被发送到队列集。uxEventQueueLength\n定义了队列集可以包含的队列句柄的数量。</td>\n</tr>\n<tr class=\"even\">\n<td>Return Value</td>\n<td>若成功则返回队列集的句柄，否则返回 NULL。</td>\n</tr>\n</tbody>\n</table>\n<p>只有当队列集内的队列接收到数据时，才会将队列的句柄发送到队列集中。如果队列已满，则无关接收数据，因此如果队列集中的所有队列都已满看，则不能向队列集发送队列句柄。因此，队列集一次必须容纳的最大数据量是集合中每个队列长度的总和。</p>\n<p>例如，如果集合中有三个空队列，每个队列的长度为\n5，那么在集合中的所有队列都满之前，集合中的队列总共可以接收 15\n个数据。在该示例中，uxEventQueueLength 必须设置为\n15，以保证队列集可以接收发送给它的每个数据。</p>\n<p>信号量也可以添加到队列集中，二进制信号量的长度为\n1，计数信号量的长度有信号量的最大计数值给出。</p>\n<p>如果队列集包含一个长度为 3 的队列和一个二进制信号量，则\nuxEventQueueLength 必须设置为 4。</p>\n<h3 id=\"xqueueaddtoset-api-函数\">xQueueAddToSet() API 函数</h3>\n<p><code>xQueueAddToSet()</code> 向队列集添加队列或信号量。</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">BaseType_t xQueueAddToSet(QueueSetMemberHandle_t xQueueOrSemaphore,\n\t\t\t\t\t\t  QueueSetHandle_t xQueueSet );</code></pre>\n<table>\n<thead>\n<tr class=\"header\">\n<th>Parameter Name</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>xQueueOrSemaphore</td>\n<td>队列或信号量的句柄。</td>\n</tr>\n<tr class=\"even\">\n<td>xQueueSet</td>\n<td>队列集句柄。</td>\n</tr>\n<tr class=\"odd\">\n<td>Return Value</td>\n<td>pdPASS：添加成功<br>pdFAIL：添加失败</td>\n</tr>\n</tbody>\n</table>\n<p>队列和二进制信号量只有在为空时才能添加到集合中。计数信号量只有在计数为零时才能添加到集合中。队列和信号量一次只能是一个集合的成员。</p>\n<h3 id=\"xqueueselectfromset-api-函数\"><code>xQueueSelectFromSet()</code>\nAPI 函数</h3>\n<p><code>xQueueSelectFromSet()</code> 从队列集中读取队列句柄。</p>\n<p>当集合成员接收到数据，接收队列或信号量的句柄将被发送到队列集，并在任务调用\n<code>xQueueSelectFromSet()</code> 时返回。如果调用\n<code>xQueueSelectFromSet()</code>\n返回句柄，则该句柄引用的队列或信号量已知包含数据，然后调用任务必须直接从队列或信号量中读取数据。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>不要直接从队列集的成员中直接读取数据，必须使用该函数返回的队列或信号量的句柄来读取数据。</p></blockquote>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">QueueSetMemberHandle_t xQueueSelectFromSet(QueueSetHandle_t xQueueSet,\n\t\t\t\t\t\t\t\t\t\t   const TickType_t xTicksToWait);</code></pre>\n<table>\n<thead>\n<tr class=\"header\">\n<th>Parameter Name</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>xQueueSet</td>\n<td>队列集句柄</td>\n</tr>\n<tr class=\"even\">\n<td>xTicksToWait</td>\n<td>阻塞等待时间</td>\n</tr>\n<tr class=\"odd\">\n<td>Return Value</td>\n<td>已包含数据的队列或信号量的句柄，否则返回 NULL</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"example-12-使用一个队列集\">Example 12 使用一个队列集</h3>\n<p>创建 2 个发送任务和 1\n个接收任务。发送任务通过两个单独的队列向接收任务发送数据，每个任务一个队列。将这两个队列添加到一个队列集中，接收任务从队列集读取数据，以确定两个队列中哪一个包含数据。</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">static QueueHandle_t xQueue1 = NULL, xQueue2 = NULL;\nstatic QueueSetHandle_t xQueueSet = NULL;\n\nint main(void)\n{\n    USART_Printf_Init(115200);\n    printf(\"SystemClk:%d\\r\\n\", SystemCoreClock);\n    printf(\"FreeRTOS Kernel Version:%s\\r\\n\",tskKERNEL_VERSION_NUMBER);\n\n    GPIO_Toggle_INIT();\n    /* 创建两个队列 */\n    xQueue1 = xQueueCreate(1, sizeof(char *));\n    xQueue2 = xQueueCreate(1, sizeof(char *));\n    /* 创建一个队列集 */\n    xQueueSet = xQueueCreateSet(1 * 2);\n    /* 添加队列到队列集 */\n    xQueueAddToSet(xQueue1, xQueueSet);\n    xQueueAddToSet(xQueue2, xQueueSet);\n    /* 创建任务发送数据到队列 */\n    xTaskCreate(vSenderTask1, \"Sender1\", 256, NULL, 1, NULL);\n    xTaskCreate(vSenderTask2, \"Sender2\", 256, NULL, 1, NULL);\n    /* 创建一个接收任务 */\n    xTaskCreate(vReceiverTask, \"Receiver\", 256, NULL, 2, NULL);\n    /* 启动调度器 */\n    vTaskStartScheduler();\n    while(1)\n    {\n        printf(\"shouldn't run at here!!\\n\");\n    }\n}</code></pre>\n<p>第一个发送任务使用 xQueue1 每 100\n毫秒向接收任务发送一个字符指针。第二个发送任务使用xQueue2 每 200\n毫秒向接收任务发送一个字符指针。</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">static void vSenderTask1(void *pvParameters){\n    const char * const pcMeassge = \"Message from vSenderTask1\\r\\n\";\n    while(1){\n        vTaskDelay(pdMS_TO_TICKS(100));\n        xQueueSend(xQueue1, &amp;pcMeassge, 0);\n    }\n}\n\nstatic void vSenderTask2(void *pvParameters){\n    const char * const pcMeassge = \"Message from vSenderTask2\\r\\n\";\n    while(1){\n        vTaskDelay(pdMS_TO_TICKS(200));\n        xQueueSend(xQueue2, &amp;pcMeassge, 0);\n    }\n}</code></pre>\n<p>接收任务：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">static void vReceiverTask(void *pvParameters){\n    QueueHandle_t xQueueThatContainsData;\n    char *pcReceivedString;\n    while(1){\n        xQueueThatContainsData = (QueueHandle_t) xQueueSelectFromSet(xQueueSet, portMAX_DELAY);\n\n        xQueueReceive(xQueueThatContainsData, &amp;pcReceivedString, 0);\n        printf(pcReceivedString);\n    }\n}</code></pre>\n<p>实验结果：</p>\n<p><img src=\"/img/FreeRTOS/queue%20set%20example.png\"></p>\n<h3 id=\"更现实的队列集用例\">更现实的队列集用例</h3>\n<p>在实际应用程序中，队列集可能同时包含队列和信号量，并且队列可能并不都持有相同的数据类型。在这种情况下，有必要在使用返回值之前测试\n<code>xQueueSelectFromSet()</code> 返回的值。</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">/* char 指针队列 */\nQueueHandle_t xCharPointerQueue;\n/* Uint32_t 队列 */\nQueueHandle_t xUint32tQueue;\n/* 二值信号量 队列 */\nQueueHandle_t xBinarySemaphore;\n/* 队列集队列 */\nQueueSetHandle_t xQueueSet;\n\nvoid vAMoreRealisticReceiverTask(void *pvParameters){\n    QueueSetMemberHandle_t xHandle;\n    char *pcReceivedString;\n    uint32_t ulRecievedValue;\n    while(1){\n        xHandle = xQueueSelectFromSet(xQueueSet, pdMS_TO_TICKS(100));\n        \n        if(xHandle == NULL){\n            printf(\"The call to xQueueSelectFromSet() timed out.\");\n        }else if(xHandle == (xQueueSetMemberHandle_t) xCharPointerQueue){\n            xQueueReceive(xCharPointerQueue, &amp;pcReceivedString, 0);\n        }else if(xHandle == (xQueueSetMemberHandle_t) xUint32tQueue){\n            xQueueReceive(xUint32tQueue, &amp;ulRecievedValue, 0);\n        }else if(xHandle == (xQueueSetMemberHandle_t) xBinarySemaphore){\n            xSemaphoreTake( xBinarySemaphore, 0 );\n        }\n    }\n}</code></pre>\n<h2 id=\"使用队列创建一个邮箱\">使用队列创建一个邮箱</h2>\n<p>“邮箱”在不同的 RTOS 中有不同的含义。在 Free RTOS\n中，术语邮箱指的是长度为 1\n的队列。之所以称这种队列为邮箱，是因为它再引用程序中的使用方式，而不是因为它与队列有功能上的区别:</p>\n<ul>\n<li>队列用于将数据从一个任务发送到另一个任务，或从中断服务例程发送到另一个任务。发送方将一个数据项放入队列，接收方从队列中删除该数据项。数据通过队列从发送方传递到接收方。</li>\n<li>邮箱用于保存可由任何任务或任何中断服务例程读取的数据。数据不通过邮箱，而是保留在邮箱中，直到它被覆盖。发件人将覆盖邮箱中的值。接收方将从邮箱中读取该值，但不从邮箱中删除该值。</li>\n</ul>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">typedef struct xExampleStructure\n{\n    TickType_t xTimeStamp;\n    uint32_t ulValue;\n} Example_t;\n/* 邮箱是一个队列，因此它的句柄存储在类型的变量 QueueHandle_t 中 */\nQueueHandle_t xMailbox;\n\nvoid vAFunction(void)\n{\n    /* 创建将用作邮箱的队列。队列的长度为 1，允许它与 xQueueOverwrite() API函数一起使用 */\n\txMailbox = xQueueCreate(1, sizeof(Example_t));\n}</code></pre>\n<h3 id=\"xqueueoverwrite-api-函数\"><code>xQueueOverwrite()</code> API\n函数</h3>\n<p>与 <code>xQueueSendToBack()</code> API\n函数一样，<code>xQueueOverwrite()</code> API\n函数将数据发送到队列。与<code>xQueueSendToBack()</code>\n不同的是，如果队列已经满了，那么 <code>xQueueOverwrite()</code>\n将覆盖队列中已经存在的数据。</p>\n<p><code>xQueueOverwrite()</code>只能用于长度为 1 的队列。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>在中断中应当使用 <code>xQueueOverwriteFromISR()</code> API 函数</p></blockquote>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">BaseType_t xQueueOverwrite( QueueHandle_t xQueue, const void * pvItemToQueue );</code></pre>\n<table>\n<colgroup>\n<col style=\"width: 19%\">\n<col style=\"width: 80%\">\n</colgroup>\n<thead>\n<tr class=\"header\">\n<th>Parameter Name</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>xQueue</td>\n<td>队列句柄</td>\n</tr>\n<tr class=\"even\">\n<td>pvItemToQueue</td>\n<td>指向要复制到队列中的数据的指针。</td>\n</tr>\n<tr class=\"odd\">\n<td>Return Value</td>\n<td>即使队列已满，函数也会覆盖原有值。因此，pdPASS 是唯一返回值</td>\n</tr>\n</tbody>\n</table>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">void vUpdateMailbox(uint32_t ulNewValue)\n{\n    Example_t xData;\n    xData.ulValue = ulNewValue;\n    xData.xTimeStamp = xTaskGetTickCount();\n    xQueueOverwrite(xMailbox, &amp;xData);\n}</code></pre>\n<h3 id=\"xqueuepeek-api-函数\"><code>xQueuePeek()</code> API 函数</h3>\n<p><code>xQueuePeek()</code>\n用于从队列中接收一个数据项，而不从队列中删除该项目。<code>xQueuePeek()</code>\n从队列的头部接收数据，而不修改队列中存储的数据，也不修改队列中存储数据的顺序。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>在中断中应当使用 <code>xQueuePeekFromISR()</code> API 函数</p></blockquote>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">BaseType_t xQueuePeek(QueueHandle_t xQueue,\n                      void * const pvBuffer,\n                      TickType_t xTicksToWait );</code></pre>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">BaseType_t vReadMailbox(Example_t *pxData)\n{\n    TickType_t xPreviousTimeStamp;\n    BaseType_t xDataUpdated;\n    xPreviousTimeStamp = pxData-&gt;xTimeStamp;\n    xQueuePeek(xMailbox, pxData, portMAX_DELAY);\n    if(pxData-&gt;xTimeStamp &gt; xPreviousTimeStamp )\n    {\n    \txDataUpdated = pdTRUE;\n    }\n    else\n    {\n    \txDataUpdated = pdFALSE;\n    }\n    return xDataUpdated;\n}</code></pre>\n","text":"队列提供一种任务到任务、任务到中断和中断到任务之间的通信机制。 队列的特点 数据存储 队列可保存有限数量的固定大小的数据项。一个队列可以容纳的最大数据量称为它的长度。在创建队列时需要指定每个数据项的长度和大小。队列通常使用先进先出(FIFO)缓冲区，数据在队列末尾被被写入并仓队列...","link":"","photos":[],"count_time":{"symbolsCount":"19k","symbolsTime":"17 mins."},"categories":[{"name":"嵌入式","slug":"嵌入式","count":2,"path":"api/categories/嵌入式.json"}],"tags":[{"name":"FreeRTOS","slug":"FreeRTOS","count":2,"path":"api/tags/FreeRTOS.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%98%9F%E5%88%97%E7%9A%84%E7%89%B9%E7%82%B9\"><span class=\"toc-text\">队列的特点</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8\"><span class=\"toc-text\">数据存储</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A4%9A%E4%BB%BB%E5%8A%A1%E8%AE%BF%E9%97%AE\"><span class=\"toc-text\">多任务访问</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%AF%BB%E9%98%9F%E5%88%97%E9%98%BB%E5%A1%9E\"><span class=\"toc-text\">读队列阻塞</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%86%99%E9%98%9F%E5%88%97%E9%98%BB%E5%A1%9E\"><span class=\"toc-text\">写队列阻塞</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A4%9A%E9%98%9F%E5%88%97%E4%B8%8A%E7%9A%84%E9%98%BB%E5%A1%9E\"><span class=\"toc-text\">多队列上的阻塞</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8%E4%B8%80%E4%B8%AA%E9%98%9F%E5%88%97\"><span class=\"toc-text\">使用一个队列</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#xqueuecreate-api-%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">xQueueCreate() API 函数</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#xqueuesendtoback-%E5%92%8C-xqueuesendtofront-api-%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">xQueueSendToBack()\n和 xQueueSendToFront() API 函数</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#xqueuereceive-api-%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">xQueueReceive() API\n函数</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#uxqueuemessageswaiting-api-%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">uxQueueMessagesWaiting()\nAPI 函数</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#example-10-%E6%8E%A5%E5%8F%97%E9%98%9F%E5%88%97%E6%95%B0%E6%8D%AE%E6%97%B6%E9%98%BB%E5%A1%9E\"><span class=\"toc-text\">Example 10\n接受队列数据时阻塞</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BB%8E%E5%A4%9A%E4%B8%AA%E6%9D%A5%E6%BA%90%E6%8E%A5%E6%94%B6%E6%95%B0%E6%8D%AE\"><span class=\"toc-text\">从多个来源接收数据</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#example-11-%E5%90%91%E9%98%9F%E5%88%97%E5%8F%91%E9%80%81%E7%BB%93%E6%9E%84%E4%BD%93\"><span class=\"toc-text\">Example 11 向队列发送结构体</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A4%84%E7%90%86%E5%A4%A7%E5%9E%8B%E6%88%96%E5%8F%AF%E5%8F%98%E5%A4%A7%E5%B0%8F%E7%9A%84%E6%95%B0%E6%8D%AE\"><span class=\"toc-text\">处理大型或可变大小的数据</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#queuing-pointers\"><span class=\"toc-text\">Queuing Pointers</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8%E9%98%9F%E5%88%97%E5%8F%91%E9%80%81%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%9E%8B%E5%92%8C%E9%95%BF%E5%BA%A6%E7%9A%84%E6%95%B0%E6%8D%AE\"><span class=\"toc-text\">使用队列发送不同类型和长度的数据</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BB%8E%E5%A4%9A%E4%B8%AA%E9%98%9F%E5%88%97%E6%8E%A5%E6%94%B6%E6%95%B0%E6%8D%AE\"><span class=\"toc-text\">从多个队列接收数据</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%98%9F%E5%88%97%E9%9B%86\"><span class=\"toc-text\">队列集</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#xqueuecreateset-api-%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">xQueueCreateSet() API\n函数</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#xqueueaddtoset-api-%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">xQueueAddToSet() API 函数</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#xqueueselectfromset-api-%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">xQueueSelectFromSet()\nAPI 函数</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#example-12-%E4%BD%BF%E7%94%A8%E4%B8%80%E4%B8%AA%E9%98%9F%E5%88%97%E9%9B%86\"><span class=\"toc-text\">Example 12 使用一个队列集</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9B%B4%E7%8E%B0%E5%AE%9E%E7%9A%84%E9%98%9F%E5%88%97%E9%9B%86%E7%94%A8%E4%BE%8B\"><span class=\"toc-text\">更现实的队列集用例</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8%E9%98%9F%E5%88%97%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E9%82%AE%E7%AE%B1\"><span class=\"toc-text\">使用队列创建一个邮箱</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#xqueueoverwrite-api-%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">xQueueOverwrite() API\n函数</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#xqueuepeek-api-%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">xQueuePeek() API 函数</span></a></li></ol></li></ol>","author":{"name":"爱慢跑的乌龟","slug":"blog-author","avatar":"/img/avatar1.jpg","link":"/","description":"求知若饥，虚心若愚！","socials":{"github":"https://github.com/ansonxu1998","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{},"next_post":{"title":"FreeRTOS 的任务 (Task)","uid":"01ed63026d9bc8723f828c17bac96fdf","slug":"FreeRTOS/Task","date":"2023-04-23T09:13:00.000Z","updated":"2023-05-06T11:23:21.557Z","comments":true,"path":"api/articles/FreeRTOS/Task.json","keywords":null,"cover":"/img/FreeRTOS/logo.jpg","text":" FreeRTOS 是由 Real Time Engineers 公司独家拥有、开发和维护的。Real Time Engineers 公司已经与世界领先的芯片公司密切合作了十多年，为您提供屡获殊荣的商业级和完全免费的高质量软件。 FreeRTOS 非常适合使用微控制器或小型微处理...","link":"","photos":[],"count_time":{"symbolsCount":"20k","symbolsTime":"18 mins."},"categories":[{"name":"嵌入式","slug":"嵌入式","count":2,"path":"api/categories/嵌入式.json"}],"tags":[{"name":"FreeRTOS","slug":"FreeRTOS","count":2,"path":"api/tags/FreeRTOS.json"}],"author":{"name":"爱慢跑的乌龟","slug":"blog-author","avatar":"/img/avatar1.jpg","link":"/","description":"求知若饥，虚心若愚！","socials":{"github":"https://github.com/ansonxu1998","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}