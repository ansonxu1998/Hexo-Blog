{"title":"FreeRTOS 的任务 (Task)","uid":"01ed63026d9bc8723f828c17bac96fdf","slug":"FreeRTOS/Task","date":"2023-04-23T09:13:00.000Z","updated":"2023-05-06T11:23:21.557Z","comments":true,"path":"api/articles/FreeRTOS/Task.json","keywords":null,"cover":"/img/FreeRTOS/logo.jpg","content":"<hr>\n<p>FreeRTOS 是由 Real Time Engineers 公司独家拥有、开发和维护的。Real\nTime Engineers\n公司已经与世界领先的芯片公司密切合作了十多年，为您提供屡获殊荣的商业级和完全免费的高质量软件。</p>\n<p>FreeRTOS\n非常适合使用微控制器或小型微处理器的深度嵌入式实时应用程序。这种类型的应用程序通常包括硬实时和软实时需求的混合。</p>\n<hr>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><a href=\"https://www.freertos.org/\">FreeRTOS 的官网</a></p>\n<p><a href=\"https://www.freertos.org/zh-cn-cmn-s/Documentation/RTOS_book.html\">官方文档下载地址</a></p></blockquote>\n<h2 id=\"freertos-的基本概念\">FreeRTOS 的基本概念</h2>\n<h3 id=\"freertos-的核心文件\">FreeRTOS 的核心文件</h3>\n<p>最核心的文件有两个：</p>\n<ul>\n<li><code>FreeRTOS/Source/task.c</code></li>\n<li><code>FreeRTOS/Source/list.c</code></li>\n</ul>\n<table>\n<thead>\n<tr class=\"header\">\n<th>核心文件</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>task.c</td>\n<td>必需，用于实现任务操作</td>\n</tr>\n<tr class=\"even\">\n<td>list.c</td>\n<td>必需，用于实现列表</td>\n</tr>\n<tr class=\"odd\">\n<td>queue.c</td>\n<td>必需，队列用于实现任务间的数据传递</td>\n</tr>\n<tr class=\"even\">\n<td>timer.c</td>\n<td>可选，实现软件定时器</td>\n</tr>\n<tr class=\"odd\">\n<td>event_groups.c</td>\n<td>可选，提供事件组功能</td>\n</tr>\n<tr class=\"even\">\n<td>croutine.c</td>\n<td>可选，弃用</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"移植时涉及的文件\">移植时涉及的文件</h3>\n<p>FreeRTOS 移植时需要使用的文件位于\n<code>FreeRTOS/Source/portable/[compiler]/[architecture]</code>\n目录中。例如：<code>RVDS/ARM_CM3</code>，表示 cortex M3 架构在 RVDS 或\nKeil 工具上的移植文件，内有 2 个文件：</p>\n<ul>\n<li><code>port.c</code></li>\n<li><code>portmacro.h</code></li>\n</ul>\n<h3 id=\"头文件目录\">头文件目录</h3>\n<p>FreeRTOS 需要 3 个头文件目录：</p>\n<ul>\n<li>FreeRTOS 核心代码的头文件：<code>FreeRTOS/Source/include</code></li>\n<li>移植使用的头文件：<code>FreeRTOS/Source/portable/[compiler]/[architecture]</code></li>\n<li>相关功能配置的文件：<code>FreeRTOSConfig.h</code></li>\n</ul>\n<p><strong>头文件的作用：</strong></p>\n<table>\n<colgroup>\n<col style=\"width: 23%\">\n<col style=\"width: 76%\">\n</colgroup>\n<thead>\n<tr class=\"header\">\n<th>头文件</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td><code>FreeRTOSConfig.h</code></td>\n<td>FreeRTOS\n的配置文件，相关算法的选择。特定功能函数的开关，使用什么函数就编译什么函数</td>\n</tr>\n<tr class=\"even\">\n<td><code>FreeRTOS.h</code></td>\n<td>使用 FreeRTOS 的 API 函数时必须包含该头文件。在\n<code>FreeRTOS.h</code>\n文件之后，再包含其它头文件，如：<code>task.h</code>\n、<code>queue.h</code> 等</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"内存管理\">内存管理</h3>\n<p>FreeRTOS 的内存管理文件位于\n<code>FreeRTOS/Source/portable/MemMang</code> 文件夹中，它放在\n<code>portable</code> 文件夹下，表示可以提供自己的函数。文件中有 5\n个源代码文件，对应 5 中内存管理的方法。</p>\n<table>\n<colgroup>\n<col style=\"width: 12%\">\n<col style=\"width: 50%\">\n<col style=\"width: 37%\">\n</colgroup>\n<thead>\n<tr class=\"header\">\n<th>文件</th>\n<th>优点</th>\n<th>缺点</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>heap_1.c</td>\n<td>分配简单，时间确定</td>\n<td>只分配，不回收</td>\n</tr>\n<tr class=\"even\">\n<td>heap_2.c</td>\n<td>动态分配、最佳匹配</td>\n<td>碎片，时间不定</td>\n</tr>\n<tr class=\"odd\">\n<td>heap_3.c</td>\n<td>调用标准库函数</td>\n<td>速度慢，时间不定</td>\n</tr>\n<tr class=\"even\">\n<td>heap_4.c</td>\n<td>相邻空闲内存可合并</td>\n<td>可解决碎片问题，时间不定</td>\n</tr>\n<tr class=\"odd\">\n<td>heap_5.c</td>\n<td>再 heap_4 基础上支持分割的内存块</td>\n<td>可解决碎片问题，时间不定</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"数据类型和编程规范\">数据类型和编程规范</h3>\n<h4 id=\"数据类型\">数据类型</h4>\n<p>每个移植版本都含有自己的 <code>pormacro.h</code> 头文件，里面定义了 2\n个数据类型：</p>\n<ul>\n<li>TickType_t:\n<ul>\n<li>FreeRTOS 配置了一个周期性时钟中断：Tick Interrupt</li>\n<li>每次发生一次中断，中断次数累加，这被称为 tick count</li>\n<li>tick count 这个变量的类型就是 TickType_t</li>\n<li>TickType_t 可以是 16 位的，也可以是 32 位的</li>\n<li><code>FreeRTOSConfig.h</code> 中定义 configUSE_16_BIT_TICKS\n时，TickType_t 就是 uint16_t</li>\n<li>否则 TickType_t 就是 uint32_t</li>\n<li>对于 32 位结构，建议把 TickType_t 配置为 uint32_t</li>\n</ul></li>\n<li>BaseType_t:\n<ul>\n<li>这是该架构最高效的数据类型</li>\n<li>32 位架构中， 为 uint32_t 类型</li>\n<li>16 位架构中，为 uint16_t 类型</li>\n<li>8 位架构中，为 uint8_t 类型</li>\n<li>BaseType_t 通常用作简单的返回值的类型，还有逻辑值，如\n<code>pdTRUE/pdFALSE</code></li>\n</ul></li>\n</ul>\n<h4 id=\"变量名\">变量名</h4>\n<ul>\n<li><em>uint32_t</em> 类型变量以 <em>ul</em> 为前缀，其中 \"u\" 表示\n\"unsigned\"，\"l\" 表示 \"long\"</li>\n<li><em>uint16_t</em> 类型变量以 <em>us</em> 为前缀，其中 \"u\" 表示\n\"unsigned\"，\"s\" 表示 \"short\"</li>\n<li><em>uint8_t</em> 类型变量以 <em>uc</em> 为前缀，其中 \"u\" 表示\n\"unsigned\"，\"c\" 表示 \"char\"</li>\n<li>非 stdint 类型的变量 以 <em>x</em> 为前缀，例如：BaseType_t 和\nTickType_t</li>\n<li>非 stdint 类型的 unsigned 变量附加前缀 <em>u</em>。例如：UBaseType_t\n类型变量 以 <em>ux</em> 为前缀</li>\n<li><em>size_t</em> 类型变量也带有 <em>x</em> 前缀</li>\n<li>枚举变量以 <em>e</em> 为前缀</li>\n<li>指针以附加 <em>p</em> 为前缀，例如：指向 uint16_t 的指针以\n<em>pus</em> 为前缀</li>\n<li>根据 MISRA 指南，未限定标准 <em>char</em> 类型仅包含 ASCII\n字符，并以 <em>c</em> 为前缀</li>\n<li>根据 MISRA 指南，<em>char</em> 类型变量仅可包含指向 ASCII\n字符串的指针，并以 <em>pc</em> 为前缀</li>\n</ul>\n<h4 id=\"函数\">函数</h4>\n<ul>\n<li>文件作用域静态（私有）函数以 <em>prv</em> 为前缀</li>\n<li>根据变量定义的相关规定，API 函数以其返回类型为前缀，并未\n<em>void</em> 添加前缀 <em>v</em></li>\n<li>API 函数名称以定义 API 函数文件的名称开头。例如，在\n<code>tasks.c</code> 中定义 v<u>Task</u>Delete，并且具有 void\n返回类型</li>\n</ul>\n<h4 id=\"宏\">宏</h4>\n<ul>\n<li>宏以定义宏的文件为前缀。前缀为小写。例如，在\n<code>FreeRTOSConfig.h</code> 中定义 <u>config</u>USE_PREEMPTION</li>\n<li>除前缀外，所有宏均使用大写字母书写，并使用下划线来分隔单词</li>\n</ul>\n<h2 id=\"任务-task\">任务 Task</h2>\n<p>使用 RTOS\n的实时应用程序可以被构建为一组独立的任务。每个任务在自己的上下文中执行，不依赖于系统内的其它任务或\nRTOS 调度器本身。在任何时间点，应用程序中只能执行一个任务，实时 RTOS\n调度器负责决定所要执行的任务。因此，RTOS\n调度器可以在应用程序执行时重复启停每个任务（将任务调入或调出）。由于任务不了解\nRTOS 调度器活动，因此实时 RTOS\n调度器负责确保任务调入时的处理器上下文（寄存器值、堆栈内容等）与任务调出时的处理器上下文完全相同。为实现这一点，每个任务都分配了自己的栈。</p>\n<h3 id=\"任务的状态\">任务的状态</h3>\n<p>任务可以运行在以下 4 种状态之一：</p>\n<ul>\n<li><p><strong>运行</strong>状态</p>\n<p>当任务被执行时，它将处于运行状态。任务将占用处理器。如何处理器只有一个内核，那么同一时间只能有一个任务被处理器执行，即只有一个任务能处于运行状态。</p></li>\n<li><p><strong>就绪</strong>状态</p>\n<p>处于就绪状态的任务能够被处理器执行，它们没有处于阻塞或挂起状态，但是由于具有同等优先级或更高优先级的任务正在被执行，无法占用处理器，需要等待被执行。</p></li>\n<li><p><strong>阻塞</strong>状态</p>\n<p>如果任务正在等待时间或外部事件，则该任务被认为处于阻塞状态。任务可以被延时函数阻塞，抑或是等待队列、信号量、事件组或通知等。处于阻塞状态的任务通常有一个“超时”期，超时后任务将被解除阻塞，即使该任务所等待的事件没有发生。</p>\n<p>阻塞状态下的任务不使用任何处理时间，不能进入运行状态</p></li>\n<li><p><strong>挂起</strong>状态</p>\n<p>处于挂起状态的任务不能被选择进入运行状态，但是挂起状态不存在超时。任务只能被别通过\n<code>vTaskSuspend()</code> 和 <code>vTaskResume()</code> API\n调用时，才会进入或退出挂起状态。</p></li>\n</ul>\n<p><img src=\"/img/FreeRTOS/task status.png\" style=\"zoom:50%;\"></p>\n<h3 id=\"任务优先级\">任务优先级</h3>\n<p>每个任务都具有一个优先级，优先级的大小在 0 到\n(<code>configMAX_PRIORITIES</code> -1)\n之间，<code>configMAX_PRRIORITIES</code> 在\n<code>FreeRTOSConfig.h</code> 文件中被定义。</p>\n<p>如果正在使用的端口实现了端口优化的任务选择机制，该机制使用“前导零计数”类指令（用于单个指令中的任务选择）且在\n<code>FreeRTOSConfig.h</code> 中将\n<code>configUSE_PORT_OPTIMISED_TASK_SELECTION</code> 设置为 1， 则\n<code>configMAX_PRIORITIES</code> 不得大于\n32。在所有其它情况下，<code>configMAX_PRIORITIES</code>\n可以设置任何合理范围内的值，但是考虑到 RAM\n使用效率，应保持在实际需求的最小值。</p>\n<p>低优先级数字表示低优先任务。<strong>空闲任务</strong>的优先级为零(<code>tskIDLE_PRIORIEY</code>)。</p>\n<p>FreeRTOS\n的调度器会确保处于运行状态的任务是当前可运行任务中最高优先级的。</p>\n<p>任意数量的任务可使用相同的优先级。如果\n<code>configUSE_TIME_SLICING</code> 未定义，或者\n<code>configUSE_TIME_SLICING</code> 设置为\n1，则相同优先级的就绪状态任务将使用时间片轮询调度方案共享可用的处理时间。</p>\n<h3 id=\"任务调度\">任务调度</h3>\n<h4 id=\"默认的-rtos-调度策略单核\">默认的 RTOS 调度策略（单核）</h4>\n<p>FreeRTOS\n默认使用固定优先级的<strong>抢占式</strong>调度策略，对同等优先级的任务执行时间片轮询调度：</p>\n<ul>\n<li>“固定优先级”\n是指调度器不会永久更改任务优先级，尽管它可能会有因为<strong>优先级继承</strong>而暂时提高任务的优先级。</li>\n<li>“抢占式调度” 是指调度器始终运行优先级最高且可运行的 RTOS\n任务，无论任务何时能够运行。例如，如果中断服务程序 (ISR)\n更改了优先级最高且可运行的任务，调度器会停止当前正在运行的低优先级任务，并启动高优先级任务——即使这发生在同一个时间片内。此时，称为高优先级任务“抢占”了低优先级的任务。</li>\n<li>“轮询调度” 是指具有相同优先级的任务轮流进入运行状态。</li>\n<li>“时间片” 是指调度器会在每个 tick\n中断上在同等优先级的任务之间进行切换，tick\n中断之间的时间构成一个时间片。tick 中断是 RTOS\n用来衡量时间的周期性中断。</li>\n</ul>\n<p><strong>使用优先排序的抢占式调度器，避免任务饥饿</strong></p>\n<p>如果总是运行优先级最高的任务，可能会造成这样的后果，永远不会进入“阻塞”或“挂起”状态的高优先级任务让所有任意执行时长的低优先级任务永久饥饿。<em>这就是为什么通常最好创建事件驱动型任务的原因之一</em>。例如，如果一个高优先级的正在等待一个事件，那么它就不应该处于事件的循环（轮询）中，因为如果处于轮询中，它会一直运行，永远不进入“阻塞”或“挂起”状态。反之，该任务应进入“阻塞”状态来等大事件。可以使用众多的\nFreeRTOS\n任务间通信将事件发送给任务。接收到事件后，优先级更高的任务会自动解除“阻塞”状态。<strong>高优先级任务处于“阻塞”状态时，低优先级任务会运行。</strong></p>\n<p><strong>配置 RTOS 调度策略</strong></p>\n<p>以下 <code>FreeRTOSConfig.h</code> 配置更改默认的调度行为：</p>\n<ul>\n<li><p><code>configUSE_PREEMPTION</code></p>\n<p>如果 <code>configUSE_PREEMPTION</code> 设置为\n0，则关闭“抢占”，只有当运行状态的任务进入“阻塞”或“挂起”状态，或运行状态任务调用\n<code>taskYIELD()</code>，或中断服务程序(ISR)手动请求上下文切换时，才会发生上下文切换。</p></li>\n<li><p><code>configUSE_TIME_SLICING</code> 设置为\n0，则表示时间片已关闭。因此调度器不会在每个 tick\n中断上在同等优先级的任务之间切换。</p></li>\n</ul>\n<h4 id=\"freertos-amp-调度策略\">FreeRTOS AMP 调度策略</h4>\n<p>使用 FreeRTOS 的非对称多处理(AMP)\n是指多核设备的每个核心都单独运行自己的 FreeRTOS\n实例。这些核心并不都需要具有相同的架构，但如果 FreeRTOS\n实例之间需要进行通信，则需要共享一些内存。</p>\n<p>每个核心都会运行自己的 FreeRTOS\n实例，因此任何给定核心上的调度算法与单核系统调度算法完全相同。可以使用<em>流缓冲区或消息缓冲区</em>作为核间通信原语。</p>\n<h4 id=\"freertos-smp-调度策略\">FreeRTOS SMP 调度策略</h4>\n<p>使用 FreeRTOS 的对称多处理(SMP) 是指一个 FreeRTOS\n实例可以跨多个处理器核心调度 RTOS 任务。由于只有一个FreeRTOS\n实例在运行，一次只能使用 FreeRTOS\n的一个端口，因此每个核心必须具有相同的处理器架构并共用相同的内存空间。</p>\n<p>FreeRTOS SMP 调度策略使用与单核调度策略相同的算法，但与单核和 AMP\n场景不同的是，SMP\n在任何给定时间都会导致多个任务处于运行状态（每个核心上都有一个运行状态的任务）这意味着，只有缺乏可运行的高优先级任务时，才会运行低优先级任务的假设不再成立。</p>\n<p><strong>配置 SMP RTSO 调度策略</strong></p>\n<p>以下配置选项有助于移动下述代码：将为单核或 AMP RTOS\n配置编写的代码移动到 SMP RTOS\n配置中，且这些代码依赖于该假设——如果有一个运行的高优先级任务，那么低优先级任务不会运行：</p>\n<ul>\n<li><p><code>configRUN_MULTIPLE_PRIORITIES</code></p>\n<p>如果将 <code>configRUN_MULTIPLE_PRIORITIES</code> 设置为\n0，则调度器只会同时运行具有相同优先级的多个任务。这可能会修复基于”一次只运行一个任务“这一假设编写的代码，但这就享受到\nSMP 配置带来的一些好处。</p></li>\n<li><p><code>configUSE_CORE_AFFINITY</code></p></li>\n</ul>\n<p>如果将 <code>configUSE_CORE_AFFINITY</code> 设置为 1， 则\n<code>vTaskCoreAffinitySet()</code> API\n函数可用于定义某个任务可以在哪些核心上运行以及不可以在那个核心上运行。</p>\n<h3 id=\"任务的实现\">任务的实现</h3>\n<p>任务是以 C 函数来实现的。它们唯一的特殊之处在于它们的原型，必须返回\n<code>void</code> 并接受一个 <code>void</code>\n指针参数。函数原型如下：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">void ATaskFunction(void *pvParameters);</code></pre>\n<p>每个任务本身就是一个小程序。通常会处于一个无限循环中永远运行，且不会退出。任务函数不允许实现返回，即不允许包含\n<code>return</code> 语句。如果想要删除掉任务，需要使用\n<code>vTaskDelete( NULL );</code>\n函数。同一个函数可以创建多个任务，每个任务都是独立运行的实例，具有自己的栈和任务本身定义的任何自动变量的副本。</p>\n<h4 id=\"创建任务\">创建任务</h4>\n<p>FreeRTOS 使用 <code>xTaskCreate()</code> API 函数创建任务。</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">BaseType_t xTaskCreate(TaskFunction_t pvTaskCode,\n                       const char* const pcName,\n                       uint16_t usStackDepth,\n                       void *pvParameters,\n                       UBaseType_t uxPriority,\n                       TaskHandle_t *pxCreatedTask)</code></pre>\n<table>\n<colgroup>\n<col style=\"width: 17%\">\n<col style=\"width: 82%\">\n</colgroup>\n<thead>\n<tr class=\"header\">\n<th style=\"text-align: left;\">Paramter Name</th>\n<th style=\"text-align: left;\">Description</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td style=\"text-align: left;\">pvTaskCode</td>\n<td style=\"text-align: left;\">pvTaskCode\n参数只是一个指针，指向实现任务的函数（就是函数名）</td>\n</tr>\n<tr class=\"even\">\n<td style=\"text-align: left;\">pcName</td>\n<td style=\"text-align: left;\">任务的描述性名称。FreeRTOS\n不会使用它，仅仅是调试时的辅助工具，有利于辨识。<br><code>configMAX_TASK_NAME_LEN</code>\n定义名称的最大长度，包括 NULL 终止符，超出的名称将会被截断。</td>\n</tr>\n<tr class=\"odd\">\n<td style=\"text-align: left;\">usStackDepth</td>\n<td style=\"text-align: left;\">指定任务栈的深度，即栈可容纳的字数(word)，不是字节(byte)。<br>如果栈的宽度是\n32-bit，深度是 100，那么栈空间就是 100 * 4 bytes。<br>栈空间不能超过\nuint16_t 类型的最大值。<br>分配的栈大小只能通过大致估算得到。</td>\n</tr>\n<tr class=\"even\">\n<td style=\"text-align: left;\">pvParameters</td>\n<td style=\"text-align: left;\">任务函数接受指向 void (void *)\n的指针类型的形参。<br>分配给 pvParameters 的值将传递给任务函数。</td>\n</tr>\n<tr class=\"odd\">\n<td style=\"text-align: left;\">uxPriority</td>\n<td style=\"text-align: left;\">定义任务的优先级。<br>优先级可以从 0\n(最低优先级) 分配到 <code>configMAX_PRIORITIES</code> -\n1(最高优先级)。</td>\n</tr>\n<tr class=\"even\">\n<td style=\"text-align: left;\">pxCreatedTask</td>\n<td style=\"text-align: left;\">向正在创建的任务传递句柄。<br>这个句柄用于在\nAPI 调用中引用任务。</td>\n</tr>\n<tr class=\"odd\">\n<td style=\"text-align: left;\">返回值</td>\n<td style=\"text-align: left;\">成功：pdPASS；<br>失败：errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY(失败原因只有内存<br>不足)</td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"example-1-创建两个任务\">Example 1 创建两个任务</h5>\n<p>任务一：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">void task1_task(void *pvParameters){\n    UBaseTpye_t msticks = 0;\n    msticks = pdMS_TO_TICKS(500);\n    while(1){\n        printf(\"task1 entry\\r\\n\");\n        GPIO_SetBits(GPIOA, GPIO_Pin_0);\n        vTaskDelay(msticks);\n        GPIO_ResetBits(GPIOA, GPIO_Pin_0);\n        vTaskDelay(msticks);\n    }\n}</code></pre>\n<p>任务二：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">void task2_task(void *pvParameters){\n    UBaseType_t msticks = 0;\n    msticks = pdMS_TO_TICKS(1000);\n    while(1){\n        printf(\"task2 entry\\r\\n\");\n        GPIO_ResetBits(GPIOA, GPIO_Pin_1);\n        vTaskDelay(msticks);\n        GPIO_SetBits(GPIOA, GPIO_Pin_1);\n        vTaskDelay(msticks);\n    }\n}</code></pre>\n<p>创建任务：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">#define TASK1_TASK_PRIO     5\n#define TASK1_STK_SIZE      256\n#define TASK2_TASK_PRIO     5\n#define TASK2_STK_SIZE      256\n/* create two task */\nxTaskCreate((TaskFunction_t )task2_task,\n            (const char*    )\"task2\",\n            (uint16_t       )TASK2_STK_SIZE,\n            (void*          )NULL,\n            (UBaseType_t    )TASK2_TASK_PRIO,\n            (TaskHandle_t*  )&amp;Task2Task_Handler);\n\nxTaskCreate((TaskFunction_t )task1_task,\n            (const char*    )\"task1\",\n            (uint16_t       )TASK1_STK_SIZE,\n            (void*          )NULL,\n            (UBaseType_t    )TASK1_TASK_PRIO,\n            (TaskHandle_t*  )&amp;Task1Task_Handler);\n/* Start the scheduler so the tasks start executing. */\nvTaskStartScheduler();</code></pre>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>实验使用沁恒 CH32F203C8T6 开发板</p></blockquote>\n<p>实验结果：</p>\n<p><img src=\"/img/FreeRTOS/task create.png\" style=\"zoom:100%;\"></p>\n<p>task1 和 task2 两个任务看似是在同时执行，但是 MCU\n只有一个处理核心，不可能同时执行两个任务。实际是，MCU\n快速交替执行这两个任务，由于这两个任务具有相同的优先级，所以它们在一个处理器核心上共享时间。</p>\n<p><img src=\"/img/FreeRTOS/task alternate.png\" style=\"zoom:100%;\"></p>\n<p>在任务调度器启动前，从 main()\n函数中创建两个任务。还可以从一个任务中创建另一个任务。</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">void vTask1(void *pvParameters){\n    const char *pcTaskName = \"Task 1 is running\\r\\n\";\n    volatile uint32_t ul; \n    xTaskCreate(vTask2, \"Task2\", 1000, NULL, 1, NULL);\n    for(;;){\n        vPrintString(pcTaskName);\n        for(ul = 0; ul &lt; mainDELAY_LOOP_COUNT; ul++){\n            \n        }\n    }\n}</code></pre>\n<h5 id=\"example-2-使用任务参数\">Example 2 使用任务参数</h5>\n<p>使用同一函数创建不同任务，并在创建任务时传入不同的参数，以此区别两个独立的任务。</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">void vTaskFunction(void *pvParameters){\n    const char *pcTaskText = pvParameters;\n    UBaseType_t msticks = 0;\n    msticks = pdMS_TO_TICKS(100);\n    while (1){\n        printf(pcTaskText);\n        vTaskDelay(msticks);\n    } \n}</code></pre>\n<p><code>pcTaskText</code> 变量接受创建任务时传入的\n<code>pvParameters</code> 参数，不同的任务可以有不同的\npvParameters。</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">static const char *pcTextForTask1 = \"Task 1 \\r\\n\";\nstatic const char *pcTextForTask2 = \"Task 2 \\r\\n\";\n\n/* 创建两个任务 */\nxTaskCreate(vTaskFunction, \"Task 1\", TASK1_STK_SIZE, (void *)pcTextForTask1, TASK1_TASK_PRIO, &amp;Task1Task_Handler);\nxTaskCreate(vTaskFunction, \"Task 2\", TASK2_STK_SIZE, (void *)pcTextForTask2, TASK2_TASK_PRIO, &amp;Task2Task_Handler);</code></pre>\n<p>实验结果：</p>\n<p><img src=\"/img/FreeRTOS/task param.png\" style=\"zoom:100%;\"></p>\n<h4 id=\"任务优先级-1\">任务优先级</h4>\n<p><code>uxPriority</code> 参数是在 <code>xTaskCreate()</code> API\n函数创建任务时，为任务分配的初始优先级。在任务开始调度之后，可以使用\n<code>vTaskPrioritySet()</code> API 函数为任务更改优先级。</p>\n<p>最大的任务优先级由 <code>FreeRTOSConfig.h</code> 文件中的\n<code>configMAX_PRIORITIES</code> 常量配置。数字越高，则由优先级越高。0\n为最低优先级，<code>configMAX_PRIORITIES</code> - 1\n为最高优先级。同一优先级的任务数量不受限制。</p>\n<p>FreeRTOS\n调度器可以使用两种方法中的一种来决定哪个任务将处于运行状态。<code>configMAX_PRIORITIES</code>\n可以设置的最大值取决于所使用的方法：</p>\n<ol type=\"1\">\n<li>Generic Method</li>\n</ol>\n<p>通用方法是用 C 语言实现的，可以在所有的 FreeRTOS 架构端口上使用。</p>\n<p>当使用通用方法时，<code>configMAX_PRIORITIES</code>\n可设置的最大值不受限制。但应当将其限制在必要情况的最小值，以节省片上资源。其值越高消耗的\nRAM 就越多。</p>\n<p>设置 Generic Method:</p>\n<ul>\n<li><code>configUSE_PORT_OPTIMISED_TASK_SELECTION</code> 置 0</li>\n<li><code>configUSE_PORT_OPTIMISED_TASK_SELECTION</code> 未定义</li>\n<li>Generic 是为使用中的 FreeRTOS 端口提供的唯一方法。</li>\n</ul>\n<ol start=\"2\" type=\"1\">\n<li>Architecture Optimized Method</li>\n</ol>\n<p>架构优化方法使用的汇编代码较少，且速度比通用方法快。<code>configMAX_PRIORITIES</code>\n设置不影响最坏情况下的执行时间。如果使用了架构优化方法，则\n<code>configMAX_PRIORITIES</code> 不能大于\n32。同样，应该尽可能的小。</p>\n<p>设置 Architecture Optimized Method:</p>\n<ul>\n<li><code>configUSE_PORT_OPTIMISED_TASK_SELECTION</code> 置 1</li>\n</ul>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>并非所有的FreeRTOS端口都提供了架构优化的方法</p></blockquote>\n<p>FreeRTOS\n调度器将始终确保能够运行的最高优先级任务是被选择进入运行状态的任务。当多个具有相同优先级的任务能够运行时，调度器将依次将每个任务转换为运行状态和退出运行状态。</p>\n<h4 id=\"tick-中断\">Tick 中断</h4>\n<p>调度算法使用“时间片”功能使得两个优先级相同任务能够连续运行。每个任务在自己的时间片中运行，一个时间片开始时，任务进入运行状态，一个时间片结束时，任务退出运行状态。</p>\n<p>为了能够选择下一个要运行的任务，调度器必须在每个时间片结束时执行。这个时间片就是一个周期性中断，称为\nTick 中断。时间片的长度是由 Tick 中断的频率决定的，该频率由\n<code>configTICK_RATE_HZ</code> 常量配置。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>如果将 <code>configTICK_RATE_HZ</code> 设置为 100\n(Hz)，那么时间片就是 10 ms。两次 Tick 中断之间的时间称为 “Tick\n周期”。一个时间片等于一个 Tick 周期。</p></blockquote>\n<p><code>configTICK_RATE_HZ</code>\n的最佳值取决于正在开发的应用程序，尽管典型值为100。</p>\n<p><img src=\"/img/FreeRTOS/tick interrupt.png\" style=\"zoom:100%;\"></p>\n<p><code>pdMS_TO_TICKS()</code> 宏将以毫秒为单位指定的时间转换为以 ticks\n为单位指定的时间。可用的分辨率取决于定义的 tick 频率，<strong>如果 tick\n频率高于1KHz( <code>configTICK_RATE_HZ</code> 大于 1000)，则不能使用\n<code>pdMS_TO_TICKS()</code>。</strong></p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">TickType_t xTimeInTicks = pdMS_TO_TICKS(200);</code></pre>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>不建议在应用程序中直接指定以刻度为单位的时间，而是使用\npdMS_TO_TICKS()\n宏来指定以毫秒为单位的时间，这样做可以确保即使刻度频率发生变化，应用程序中指定的时间也不会改变。</p></blockquote>\n<p><strong>tick count</strong> 值是自调度器启动以来发生的 tick\n中断的总数，假设 tick\n计数没有溢出。用户应用程序在指定延迟时间时不必考虑溢出，因为时间一致性是由\nFreeRTOS 内部管理的。</p>\n<h5 id=\"example-3-任务优先级\">Example 3 任务优先级</h5>\n<p>调度器将始终保证能够运行的最高优先级的任务是被选择进入运行状态的任务。以下将创建一个优先级为\n1 的任务和一个优先级为 2 的任务：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">xTaskCreate(vTaskFunction, \"Task 1\", 256, (void *)pcTextForTask1, 1, &amp;Task1Task_Handler);\nxTaskCreate(vTaskFunction, \"Task 2\", 256, (void *)pcTextForTask2, 2, &amp;Task2Task_Handler);</code></pre>\n<p>实验结果：</p>\n<p><img src=\"/img/FreeRTOS/task priority.png\" style=\"zoom:100%;\"></p>\n<p>因为任务 2 的优先级比任务 1 的高，只要任务 2\n是可运行的状态，系统将一直运行任务 2。任务 1 将永远得不到运行，称任务 1\n处于 “饥饿” 状态。</p>\n<h4 id=\"其它任务状态\">其它任务状态</h4>\n<p>如果一个任务不需要等待任何事情的发生，总是能处于运行状态，那么这种类型的任务的用处是十分有限的。这种任务只能以最低的优先级运行，因为如果它们处于高优先级，那么低优先级的任务将得不到运行，始终处于\n“饥饿” 状态。</p>\n<p>任务如果想要有用，那么它们必须为事件所驱动。事件驱动的任务只有在触发它的事件发生之后才能被执行，且在事件发生之前不能处于\nrunning\n状态。调度器始终选择能够运行的最高优先级任务。高优先级任务无法运行意味着调度器无法选择它们，而必须选择能够运行的低优先级任务。因此，使用事件驱动任务意味着可以在不同的优先级下创建任务，而不会使优先级最高的任务耗尽所有优先级较低的处理时间任务。</p>\n<h5 id=\"阻塞状态-the-blocked-state\">阻塞状态 (The Blocked State)</h5>\n<p>等待事件的任务被称为 “阻塞” 状态，这是 Not Running\n状态的一个子状态。</p>\n<p>任务等待事件的种类：</p>\n<ul>\n<li>事件(与时间相关)的时间 ——\n这个时间可以是一段延时，或某个绝对时间。例如延时 10 ms。</li>\n<li>同步事件 —— 事件源于另一个任务或中断。</li>\n</ul>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>FreeRTOS 的队列(queues)、二进制信号量(binary\nsemaphores)、计数信号量(counting\nsemaphores)、互斥锁(mutexes)、递归互斥锁(recursive\nmutexes)、事件组(event groups)和任务通知(task\nnotifications)都可以用来创建同步事件。</p></blockquote>\n<p>任务阻塞可以设置超时时间，如果在规定时间内事件已发生，或超过规定时间未发生，任务将离开阻塞状态。</p>\n<h5 id=\"挂起状态the-suspended-state\">挂起状态(The Suspended State)</h5>\n<p>挂起是 Not Running\n的一个子状态。处于挂起状态的任务无法被调度器调度。进入挂起状态的唯一方法是调用\n<code>vTaskSuspend()</code> API 函数。调用 <code>xTaskResume()</code> 或\n<code>vTaskResumeFromISR()</code> API\n函数将恢复任务调度。大多数应用不使用挂起状态。</p>\n<h5 id=\"就绪状态the-ready-state\">就绪状态(The Ready State)</h5>\n<p>处于 Not Running\n状态但未被阻塞或挂起的任务称为处于“就绪”状态。它们能够运行，因此“准备好”运行，但当前不处于运行状态。</p>\n<h5 id=\"example-4-使用阻塞状态创建延时\">Example 4\n使用阻塞状态创建延时</h5>\n<p>任何形式的轮询最重要的是效率低下。在轮询期间，任务实际上没有任何工作要做，但它仍然使用最大的处理时间，因此浪费了处理器周期。调用\n<code>vTaskDelay()</code> API 函数来是任务进入阻塞状态，\n避免轮询空循环，大大提升了处理器的效率。<strong>注意，只有当\n<code>INCLUDE_vTaskDelay</code> 设置为 1 时，<code>vTaskDelay()</code>\nAPI 函数才可用。</strong></p>\n<p><code>vTaskDelay()</code> 将调用任务置于阻塞状态，用于固定数量的 tick\n中断。任务在处于阻塞状态时不使用任何处理时间，因此任务仅在有实际工作要完成时使用处理时间。</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">void vTaskDelay( TickType_t xTicksToDelay );</code></pre>\n<table>\n<thead>\n<tr class=\"header\">\n<th>Paramter Name</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>xTicksToDelay</td>\n<td>任务保持阻塞状态所持续的 tick 中断数。</td>\n</tr>\n</tbody>\n</table>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">void vTaskFunction(void *pvParameters){\n    const char *pcTaskText = pvParameters;\n    TickType_t msticks = 0;\n    msticks = pdMS_TO_TICKS(500);\n    while (1){\n        printf(pcTaskText);\n        /* 延时 500 ms */\n        vTaskDelay(msticks);\n    } \n}</code></pre>\n<p>实验结果：</p>\n<p><img src=\"/img/FreeRTOS/task blocked.png\" style=\"zoom:100%;\"></p>\n<p>因为 <code>vTaskDelay()</code> 函数阻塞了任务 2，使得较低优先级的任务\n1 能够被运行。</p>\n<h5 id=\"vtaskdelayuntil-api-函数\"><code>vTaskDelayUntil()</code> API\n函数</h5>\n<p><code>vTaskDelay()</code> 阻塞的时常是一个相对的时间，从调用\n<code>vTaskDelay()</code> 函数开始进入阻塞状态，阻塞的时长为\nxTicksToDelay 参数所指定的 tick\n中断数。但是，<code>vTaskDelayUntil()</code>\n函数的参数指定任务从阻塞到就绪状态确切的 tick 计数值(tick count\nvalue)。当任务需要按照固定周期执行时，需要调用\n<code>vTaskDelayUntil()</code> API\n函数，因为任务解除阻塞状态的时间是绝对的，而不是相对于函数被调用的时间。</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">void vTaskDelayUntil( TickType_t * pxPreviousWakeTime, TickType_t xTimeIncrement );</code></pre>\n<table>\n<colgroup>\n<col style=\"width: 23%\">\n<col style=\"width: 76%\">\n</colgroup>\n<thead>\n<tr class=\"header\">\n<th>Parameter Name</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>pxPreviousWakeTime</td>\n<td>保存任务最后离开阻塞状态的时间，此时间作为参考点，以计算下次离开阻塞状态的时间。<br>它将在\nAPI 函数中自动更新，但必须在第一次使用它之前将其初始化为当前的 tick\n计数。</td>\n</tr>\n<tr class=\"even\">\n<td>xTimeIncrement</td>\n<td>任务固定执行的频率，也就是阻塞的时间长度。<br>可用\n<code>pdMS_TO_TICKS()</code> 宏将毫秒转称 tick 数值。</td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"example-5-使用-vtaskdelayuntil-阻塞\">Example 5 使用\n<code>vTaskDelayUntil()</code> 阻塞</h5>\n<p>创建两个任务 task1_task 和 task2_task，任务 1 的优先级为 2， 任务 2\n的优先级为 1。PA0 端口为 1 时， 表示任务 1 正在执行，为 0 时，表示任务 2\n正在执行。分别用 <code>vTaskDelay()</code> 和\n<code>vTaskDelayUntil()</code> 对任务 1 进行阻塞。</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">/* 任务 1 */\nvoid task1_task(void *pvParameters)\n{\n\tTickType_t xLastWakeTime;\n    int i;\n    /*初始的 Tick Count*/\n    xLastWakeTime = xTaskGetTickCount();\n    while(1)\n    {\n        GPIO_SetBits(GPIOA, GPIO_Pin_0);\n        for(i = 0; i &lt; 5; i++){\n            printf(\"Task1 is runnig\\r\\n\");\n        }\n\n#if 1\n        vTaskDelay(pdMS_TO_TICKS(50));\n#else \n        vTaskDelayUntil(&amp;xLastWakeTime, pdMS_TO_TICKS(50));\n#endif\n    }\n}\n/* 任务 2 */\nvoid task2_task(void *pvParameters)\n{\t\n    while(1)\n    {\n        GPIO_ResetBits(GPIOA, GPIO_Pin_0);\n        printf(\"Task 2 is running\\r\\n\");\n    }\n}\n/* 主函数 */\nint main(void)\n{\n    USART_Printf_Init(115200);\n    printf(\"SystemClk:%d\\r\\n\",SystemCoreClock);\n    printf(\"FreeRTOS Kernel Version:%s\\r\\n\",tskKERNEL_VERSION_NUMBER);\n    GPIO_Toggle_INIT();\n    xTaskCreate(task1_task, \"Task 1\", 256, NULL, 2, &amp;Task1Task_Handler);\n    xTaskCreate(task2_task, \"Task 2\", 256, NULL, 1, &amp;Task2Task_Handler);\n    vTaskStartScheduler();\n    while(1)\n    {\n        printf(\"shouldn't run at here!!\\n\");\n    }\n}</code></pre>\n<p>逻辑分析仪分析 PA0 端口电平变换：</p>\n<p><img src=\"/img/FreeRTOS/task%20delay1.png\"></p>\n<p><img src=\"/img/FreeRTOS/task%20delay2.png\"></p>\n<h4 id=\"空闲任务及其钩子函数\">空闲任务及其钩子函数</h4>\n<h5 id=\"空闲任务\">空闲任务</h5>\n<p>当创建的任务均处于阻塞状态，但是必须始终至少有一个任务可以进入\nRunning 状态。为了确保这一点，调度程序在调用\n<code>vTaskaStartScheduler()</code> 时，会自动创建一个 Idle\n任务。空闲任务只在循环中执行很少的操作，因此它并不妨碍其它任务的执行。</p>\n<p>空闲任务具有尽可能低的优先级(0\n优先级)，以确保它永远不会阻止更高优先级的任务进入运行状态。如果一定要创建与空闲任务同优先级的任务，可以通过配置\n<code>configIDLE_SHOULD_YILED</code>\n来防止空闲任务占用过多的处理时间。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>如果程序使用 <code>vTaskDelete()</code> API 函数，那么必须确保 Idle\n任务有机会得到运行。因为 Idle 任务负责在任务被删除之后清理内核资源。</p></blockquote>\n<h5 id=\"空闲任务的钩子函数\">空闲任务的钩子函数</h5>\n<p>可以通过使用空闲钩子(或空闲回调)函数将特定于应用程序的功能直接添加到空闲任务中，该函数在空闲任务循环的每次迭代中由空闲任务自动调用一次。</p>\n<p>空闲任务钩子函数的用法：</p>\n<ul>\n<li>执行低优先级、后台或连续处理功能</li>\n<li>测量空闲处理的时间。(空闲任务只有在所有高优先级应用程序任务没有工作可执行时才会运行;因此，测量分配给空闲任务的处理时间可以清楚地表明有多少处理时间是空闲的。)</li>\n<li>将处理器置于低功耗模式，当没有应用程序处理要执行时，提供一种简单而自动的省电方法</li>\n</ul>\n<p><strong>对空闲任务钩子函数实现的限制</strong>：</p>\n<ul>\n<li>空闲任务钩子函数绝不能试图阻塞或挂起。</li>\n<li>如果应用程序使用 <code>vTaskDelete()</code>\nAPI函数，那么空闲任务钩子必须要在合理的时间段内返回到其调用者。这是因为\nIdle 任务负责在任务被删除后清理内核资源。如果空闲任务永久地保留在 Idle\n钩子函数中，则不能进行清理。</li>\n</ul>\n<p><strong>空闲任务钩子函数必须具有以下的函数名和原型</strong>：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">void vApplicationIdleHook( void );</code></pre>\n<h5 id=\"example-6-创建空闲任务钩子函数\">Example 6\n创建空闲任务钩子函数</h5>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">volatile uint32_t ulIdleCycleCount = 0UL;\n/* 创建钩子函数 */\nvoid vApplicationIdleHook(void){\n    ulIdleCycleCount++ ;\n}</code></pre>\n<p>在 FreeRTOSConfig.h 中，将 <code>configUSE_IDLE_HOOK</code> 设置为\n1，空闲钩子函数才会被调用。</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">void vTaskFunction(void *pvParameters){\n    const char *pcTaskText = pvParameters;\n    while (1)\n    {\n        printf(pcTaskText);\n        printf(\"Idle Cycle Count = %d\", ulIdleCycleCount);\n        vTaskDelay(pdMS_TO_TICKS(1000));   \n    }  \n}</code></pre>\n<h4 id=\"更改任务优先级\">更改任务优先级</h4>\n<h5 id=\"vtaskpriorityset-api-函数\"><code>vTaskPrioritySet()</code> API\n函数</h5>\n<p><code>vTaskPrioritySet()</code> API\n函数用于在调度器启动后更改任何任务的优先级。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>需要将 <code>NCLUDE_vTaskPrioritySet</code> 设置为 1</p></blockquote>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">void vTaskPrioritySet( TaskHandle_t pxTask, UBaseType_t uxNewPriority );</code></pre>\n<table>\n<colgroup>\n<col style=\"width: 18%\">\n<col style=\"width: 81%\">\n</colgroup>\n<thead>\n<tr class=\"header\">\n<th>Parameter Name</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>pxTask</td>\n<td>任务句柄<br>任务可以通过传递 <code>NULL</code>\n代替有效的任务句柄来改变自己的优先级。</td>\n</tr>\n<tr class=\"even\">\n<td>uxNewPriority</td>\n<td>要设置的新的优先级</td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"xtaskpriorityget-api-函数\"><code>xTaskPriorityGet()</code> API\n函数</h5>\n<p><code>uxTaskPriorityGet()</code> API\n函数可以用来查询任务的优先级。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>需要将 <code>INCLUDE_uxTaskPriorityGet</code> 设置为 1</p></blockquote>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">UBaseType_t uxTaskPriorityGet( TaskHandle_t pxTask );</code></pre>\n<table>\n<colgroup>\n<col style=\"width: 18%\">\n<col style=\"width: 81%\">\n</colgroup>\n<thead>\n<tr class=\"header\">\n<th>Parameter Name</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>pxTask</td>\n<td>任务句柄<br>任务可以通过传递 <code>NULL</code>\n代替有效的任务句柄来查询自己的优先级。</td>\n</tr>\n<tr class=\"even\">\n<td>Returned value</td>\n<td>查询任务的优先级</td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"example-7-改变任务优先级\">Example 7 改变任务优先级</h5>\n<p>以不同的优先级创建两个任务，两个都不会进入阻塞状态。优先级相对较高的任务将被点调度器选择运行。</p>\n<ul>\n<li>任务 1\n以最高优先级创建，因此将会首先运行。先打印出两个字符串，在将任务 2\n的优先级提高到高于自己的优先级。</li>\n<li>在任务 2 中打印一条信息，再将自己的优先级设置到低于任务 1\n的优先级。</li>\n</ul>\n<p>任务 1：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">void vTask1(void *pvParameters){\n    UBaseType_t uxPriority;\n    uxPriority = uxTaskPriorityGet(NULL);\n    while (1)\n    {\n        printf(\"Task 1 is running\\r\\n\");\n        printf(\"About to raise the Task 2 priority\\r\\n\");\n        vTaskPrioritySet(xTask2Handle, (uxPriority + 1));\n    }   \n}</code></pre>\n<p>任务 2：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">void vTask2(void *pvParameters){\n    UBaseType_t uxPriority;\n    uxPriority = uxTaskPriorityGet(NULL);\n\n    while (1)\n    {\n        printf(\"Task 2 is running\\r\\n\");\n        printf(\"About to lower the Task 2 priority\\r\\n\");\n        vTaskPrioritySet(NULL, (uxPriority - 2));\n    }  \n}</code></pre>\n<p>创建任务：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">xTaskCreate(vTask1, \"Task 1\", 256, NULL, 2, &amp;xTask1Handle);\nxTaskCreate(vTask2, \"Task 2\", 256, NULL, 1, &amp;xTask2Handle);\nvTaskStartScheduler();</code></pre>\n<p>实验结果：</p>\n<p><img src=\"/img/FreeRTOS/task priority set.png\" style=\"zoom:100%;\"></p>\n<h4 id=\"删除任务\">删除任务</h4>\n<h5 id=\"vtaskdelete-api-函数\"><code>vTaskDelete()</code> API 函数</h5>\n<p>任务可以使用 <code>vTaskDelete()</code> API\n函数来删除自己或任何其他任务。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>需要将 <code>INCLUDE_vTaskDelete</code> 设置为 1</p></blockquote>\n<p>删除的任务不再存在，不能再进入“运行”状态。空闲任务负责释放分配给已删除的任务的内存。因此，重要的是，使用\n<code>vTaskDelete()</code> API\n函数的应用程序不要完全耗尽空闲任务的所有处理时间。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>当任务被删除时，只有内核自己分配给任务的内存才会被自动释放。任务实现分配的任何内存或其他资源必须显式释放。</p></blockquote>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">void vTaskDelete( TaskHandle_t pxTaskToDelete );</code></pre>\n<table>\n<colgroup>\n<col style=\"width: 18%\">\n<col style=\"width: 81%\">\n</colgroup>\n<thead>\n<tr class=\"header\">\n<th>Parameter Name</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>pxTaskToDelete</td>\n<td>待删除任务的句柄<br>任务可以通过传递NULL来代替有效的任务句柄来删除自己</td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"example-8-删除任务\">Example 8 删除任务</h5>\n<p>任务 1：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">TaskHandle_t xTask2Handle = NULL;\nvoid vTask1(void *pvParameters){\n    const TickType_t xDelay100ms = pdMS_TO_TICKS(100UL);\n    while(1){\n        printf(\"Task 1 is running\\r\\n\");\n        /* 创建任务 2 */\n        xTaskCreate(vTask2, \"Task 2\", 1000, NULL, 2 &amp;xTask2Handle);\n        /* 进入阻塞状态，使得 Idle 任务可以运行 */\n        vTaskDelay(xDelay100ms);\n    }\n}</code></pre>\n<p>任务 2：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">void vTask2(void *pvParameters){\n    printf(\"Task 2 is running and about to delete itself\\r\\n\");\n    /* 删除自身，传入 NULL 也可 */\n    vTaskDelete(xTask2Handle);\n}</code></pre>\n<p>主函数：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">int main(void){\n    xTaskCreate(vTask1, \"Task 1\", 1000, NULL, 1, NULL);\n    vTaskStartScheduler();\n    while(1);\n}</code></pre>\n<h4 id=\"调度算法\">调度算法</h4>\n<h5 id=\"配置调度算法\">配置调度算法</h5>\n<p>调度算法决定就绪状态中的哪个任务进入运行状态。可以使用\n<code>configUSE_PREEMPTION</code> 和<code>configUSE_TIME_SLICING</code>\n配置常量更改算法。第三个配置常量 <code>configUSE_TICKLESS_IDLE</code>\n也会影响调度算法，使用它可能导致在较长时间内完全关闭 Tick 中断。</p>\n<p>在所有可能的配置中，FreeRTOS\n调度器将确保共享优先级的任务依次被选择进入运行状态，即轮询调度。轮循调度算法不能保证同等优先级的任务之间的时间分配均等，只能保证同等优先级的任务依次进入运行状态。</p>\n<h5 id=\"带时间片的固定优先级抢占调度\">带时间片的固定优先级抢占调度</h5>\n<table>\n<thead>\n<tr class=\"header\">\n<th style=\"text-align: center;\">Constant</th>\n<th style=\"text-align: center;\">Value</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td style=\"text-align: center;\">configUSE_PREEMPTION</td>\n<td style=\"text-align: center;\">1</td>\n</tr>\n<tr class=\"even\">\n<td style=\"text-align: center;\">configUSE_TIME_SLICING</td>\n<td style=\"text-align: center;\">1</td>\n</tr>\n</tbody>\n</table>\n<p>以上配置称为“固定优先级抢占式时间片调度”的调度算法，这是大多数小型\nRTOS 应用程序使用的调度算法。</p>\n<p>调度策略的术语的解释：</p>\n<table>\n<colgroup>\n<col style=\"width: 18%\">\n<col style=\"width: 81%\">\n</colgroup>\n<thead>\n<tr class=\"header\">\n<th>Term</th>\n<th>Definition</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>Fixed Priority</td>\n<td>被称为 “固定优先级”\n的调度算法不会改变分配给被调度任务的优先级，但也不会阻止任务本身改变自己或其他任务的优先级。</td>\n</tr>\n<tr class=\"even\">\n<td>Pre-emptive</td>\n<td>抢占调度算法会在优先级高于“运行”的任务进入“就绪”状态时，立即对“运行”任务进行“抢占”。</td>\n</tr>\n<tr class=\"odd\">\n<td>Time Slicing</td>\n<td>时间片用于在具有相同优先级的任务之间共享处理时间，即使任务没有显式地放弃或进入阻塞状态。如果有与运行任务相同优先级的任务处于就绪状态，“时间片”调度算法将在每个时间片结束时选择一个新任务进入运行状态。一个时间片等于两个\nRTOS Tick中断之间的时间。</td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"不带时间片的固定优先级抢占调度\">不带时间片的固定优先级抢占调度</h5>\n<p>不使用时间片的优先级抢占调度与之前的任务选择和抢占算法相同，但不使用时间片在相同优先级的任务之间共享处理时间。</p>\n<table>\n<thead>\n<tr class=\"header\">\n<th style=\"text-align: center;\">Constant</th>\n<th style=\"text-align: center;\">Value</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td style=\"text-align: center;\">configUSE_PREEMPTION</td>\n<td style=\"text-align: center;\">1</td>\n</tr>\n<tr class=\"even\">\n<td style=\"text-align: center;\">configUSE_TIME_SLICING</td>\n<td style=\"text-align: center;\">0</td>\n</tr>\n</tbody>\n</table>\n<p>如果不使用时间片，则调度器只会在以下情况下选择一个新任务进入运行状态：</p>\n<ul>\n<li>高优先级的任务进入就绪状态。</li>\n<li>处于 “运行” 状态的任务进入 “阻塞” 或 “挂起” 状态。</li>\n</ul>\n<p>不使用时间片时，任务上下文切换比使用时间片时要少。因此，关闭时间片可以减少调度器的处理开销。然而，关闭时间片也会导致同等优先级的任务接收到的处理时间差异很大，由于这个原因，不使用时间切片运行调度器被认为是一种高级技术，只应该由有经验的用户使用。</p>\n<h5 id=\"合作调度\">合作调度</h5>\n<table>\n<thead>\n<tr class=\"header\">\n<th style=\"text-align: center;\">Constant</th>\n<th style=\"text-align: center;\">Value</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td style=\"text-align: center;\">configUSE_PREEMPTION</td>\n<td style=\"text-align: center;\">0</td>\n</tr>\n<tr class=\"even\">\n<td style=\"text-align: center;\">configUSE_TIME_SLICING</td>\n<td style=\"text-align: center;\">Any value</td>\n</tr>\n</tbody>\n</table>\n<p>当使用合作调度时，只有当运行状态任务进入阻塞状态，或者运行状态任务通过调用\n<code>taskYIELD()</code>\n(手动请求重新调度)时，才会发生上下文切换。任务永远不会被抢占，所以不能使用时间片。</p>\n","text":" FreeRTOS 是由 Real Time Engineers 公司独家拥有、开发和维护的。Real Time Engineers 公司已经与世界领先的芯片公司密切合作了十多年，为您提供屡获殊荣的商业级和完全免费的高质量软件。 FreeRTOS 非常适合使用微控制器或小型微处理...","link":"","photos":[],"count_time":{"symbolsCount":"20k","symbolsTime":"18 mins."},"categories":[{"name":"嵌入式","slug":"嵌入式","count":3,"path":"api/categories/嵌入式.json"}],"tags":[{"name":"FreeRTOS","slug":"FreeRTOS","count":3,"path":"api/tags/FreeRTOS.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#freertos-%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">FreeRTOS 的基本概念</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#freertos-%E7%9A%84%E6%A0%B8%E5%BF%83%E6%96%87%E4%BB%B6\"><span class=\"toc-text\">FreeRTOS 的核心文件</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%A7%BB%E6%A4%8D%E6%97%B6%E6%B6%89%E5%8F%8A%E7%9A%84%E6%96%87%E4%BB%B6\"><span class=\"toc-text\">移植时涉及的文件</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A4%B4%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95\"><span class=\"toc-text\">头文件目录</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86\"><span class=\"toc-text\">内存管理</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83\"><span class=\"toc-text\">数据类型和编程规范</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">数据类型</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%8F%98%E9%87%8F%E5%90%8D\"><span class=\"toc-text\">变量名</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">函数</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%AE%8F\"><span class=\"toc-text\">宏</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BB%BB%E5%8A%A1-task\"><span class=\"toc-text\">任务 Task</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%BB%E5%8A%A1%E7%9A%84%E7%8A%B6%E6%80%81\"><span class=\"toc-text\">任务的状态</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%BB%E5%8A%A1%E4%BC%98%E5%85%88%E7%BA%A7\"><span class=\"toc-text\">任务优先级</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6\"><span class=\"toc-text\">任务调度</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E9%BB%98%E8%AE%A4%E7%9A%84-rtos-%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5%E5%8D%95%E6%A0%B8\"><span class=\"toc-text\">默认的 RTOS 调度策略（单核）</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#freertos-amp-%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5\"><span class=\"toc-text\">FreeRTOS AMP 调度策略</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#freertos-smp-%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5\"><span class=\"toc-text\">FreeRTOS SMP 调度策略</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">任务的实现</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%88%9B%E5%BB%BA%E4%BB%BB%E5%8A%A1\"><span class=\"toc-text\">创建任务</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#example-1-%E5%88%9B%E5%BB%BA%E4%B8%A4%E4%B8%AA%E4%BB%BB%E5%8A%A1\"><span class=\"toc-text\">Example 1 创建两个任务</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#example-2-%E4%BD%BF%E7%94%A8%E4%BB%BB%E5%8A%A1%E5%8F%82%E6%95%B0\"><span class=\"toc-text\">Example 2 使用任务参数</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BB%BB%E5%8A%A1%E4%BC%98%E5%85%88%E7%BA%A7-1\"><span class=\"toc-text\">任务优先级</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#tick-%E4%B8%AD%E6%96%AD\"><span class=\"toc-text\">Tick 中断</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#example-3-%E4%BB%BB%E5%8A%A1%E4%BC%98%E5%85%88%E7%BA%A7\"><span class=\"toc-text\">Example 3 任务优先级</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%85%B6%E5%AE%83%E4%BB%BB%E5%8A%A1%E7%8A%B6%E6%80%81\"><span class=\"toc-text\">其它任务状态</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E9%98%BB%E5%A1%9E%E7%8A%B6%E6%80%81-the-blocked-state\"><span class=\"toc-text\">阻塞状态 (The Blocked State)</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E6%8C%82%E8%B5%B7%E7%8A%B6%E6%80%81the-suspended-state\"><span class=\"toc-text\">挂起状态(The Suspended State)</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%B0%B1%E7%BB%AA%E7%8A%B6%E6%80%81the-ready-state\"><span class=\"toc-text\">就绪状态(The Ready State)</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#example-4-%E4%BD%BF%E7%94%A8%E9%98%BB%E5%A1%9E%E7%8A%B6%E6%80%81%E5%88%9B%E5%BB%BA%E5%BB%B6%E6%97%B6\"><span class=\"toc-text\">Example 4\n使用阻塞状态创建延时</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#vtaskdelayuntil-api-%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">vTaskDelayUntil() API\n函数</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#example-5-%E4%BD%BF%E7%94%A8-vtaskdelayuntil-%E9%98%BB%E5%A1%9E\"><span class=\"toc-text\">Example 5 使用\nvTaskDelayUntil() 阻塞</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%A9%BA%E9%97%B2%E4%BB%BB%E5%8A%A1%E5%8F%8A%E5%85%B6%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">空闲任务及其钩子函数</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E7%A9%BA%E9%97%B2%E4%BB%BB%E5%8A%A1\"><span class=\"toc-text\">空闲任务</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E7%A9%BA%E9%97%B2%E4%BB%BB%E5%8A%A1%E7%9A%84%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">空闲任务的钩子函数</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#example-6-%E5%88%9B%E5%BB%BA%E7%A9%BA%E9%97%B2%E4%BB%BB%E5%8A%A1%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">Example 6\n创建空闲任务钩子函数</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%9B%B4%E6%94%B9%E4%BB%BB%E5%8A%A1%E4%BC%98%E5%85%88%E7%BA%A7\"><span class=\"toc-text\">更改任务优先级</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#vtaskpriorityset-api-%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">vTaskPrioritySet() API\n函数</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#xtaskpriorityget-api-%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">xTaskPriorityGet() API\n函数</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#example-7-%E6%94%B9%E5%8F%98%E4%BB%BB%E5%8A%A1%E4%BC%98%E5%85%88%E7%BA%A7\"><span class=\"toc-text\">Example 7 改变任务优先级</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%88%A0%E9%99%A4%E4%BB%BB%E5%8A%A1\"><span class=\"toc-text\">删除任务</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#vtaskdelete-api-%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">vTaskDelete() API 函数</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#example-8-%E5%88%A0%E9%99%A4%E4%BB%BB%E5%8A%A1\"><span class=\"toc-text\">Example 8 删除任务</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">调度算法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E9%85%8D%E7%BD%AE%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">配置调度算法</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%B8%A6%E6%97%B6%E9%97%B4%E7%89%87%E7%9A%84%E5%9B%BA%E5%AE%9A%E4%BC%98%E5%85%88%E7%BA%A7%E6%8A%A2%E5%8D%A0%E8%B0%83%E5%BA%A6\"><span class=\"toc-text\">带时间片的固定优先级抢占调度</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E4%B8%8D%E5%B8%A6%E6%97%B6%E9%97%B4%E7%89%87%E7%9A%84%E5%9B%BA%E5%AE%9A%E4%BC%98%E5%85%88%E7%BA%A7%E6%8A%A2%E5%8D%A0%E8%B0%83%E5%BA%A6\"><span class=\"toc-text\">不带时间片的固定优先级抢占调度</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%90%88%E4%BD%9C%E8%B0%83%E5%BA%A6\"><span class=\"toc-text\">合作调度</span></a></li></ol></li></ol></li></ol></li></ol>","author":{"name":"爱慢跑的乌龟","slug":"blog-author","avatar":"/img/avatar1.jpg","link":"/","description":"求知若饥，虚心若愚！","socials":{"github":"https://github.com/ansonxu1998","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"FreeRTOS 的队列 (Queue)","uid":"b5bbb50a4ed24d8a8d9fcbeb2df5e6ea","slug":"FreeRTOS/Queue","date":"2023-05-05T12:57:00.000Z","updated":"2023-05-06T11:27:20.463Z","comments":true,"path":"api/articles/FreeRTOS/Queue.json","keywords":null,"cover":"/img/FreeRTOS/logo.jpg","text":"队列提供一种任务到任务、任务到中断和中断到任务之间的通信机制。 队列的特点 数据存储 队列可保存有限数量的固定大小的数据项。一个队列可以容纳的最大数据量称为它的长度。在创建队列时需要指定每个数据项的长度和大小。队列通常使用先进先出(FIFO)缓冲区，数据在队列末尾被被写入并仓队列...","link":"","photos":[],"count_time":{"symbolsCount":"19k","symbolsTime":"17 mins."},"categories":[{"name":"嵌入式","slug":"嵌入式","count":3,"path":"api/categories/嵌入式.json"}],"tags":[{"name":"FreeRTOS","slug":"FreeRTOS","count":3,"path":"api/tags/FreeRTOS.json"}],"author":{"name":"爱慢跑的乌龟","slug":"blog-author","avatar":"/img/avatar1.jpg","link":"/","description":"求知若饥，虚心若愚！","socials":{"github":"https://github.com/ansonxu1998","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"链表 linked list","uid":"0d8865dd6f5b4fb80b5a9df16b916aeb","slug":"DSAA/链表","date":"2023-04-14T12:00:00.000Z","updated":"2023-04-15T02:49:14.057Z","comments":true,"path":"api/articles/DSAA/链表.json","keywords":null,"cover":"/img/DSAA/linked list 1.png","text":"链表 linked list 什么是链表 链表是数据元素的线性集合，其顺序不是由它们在内存中的物理位置给出的。每个元素都指向下一个元素。它是一种数据结构，由一组节点组成，这些节点共同表示一个序列。在其最基本的形式中，每个节点都包含：数据和指向序列中下一个节点的指针（链接）。这种结...","link":"","photos":[],"count_time":{"symbolsCount":"15k","symbolsTime":"14 mins."},"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","count":1,"path":"api/categories/数据结构与算法.json"}],"tags":[{"name":"计算机","slug":"计算机","count":1,"path":"api/tags/计算机.json"}],"author":{"name":"爱慢跑的乌龟","slug":"blog-author","avatar":"/img/avatar1.jpg","link":"/","description":"求知若饥，虚心若愚！","socials":{"github":"https://github.com/ansonxu1998","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}