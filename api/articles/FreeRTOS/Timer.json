{"title":"FreeRTOS 的定时器 (Timer)","uid":"0de178335a5288a6c84f26e77dfbea47","slug":"FreeRTOS/Timer","date":"2023-05-07T09:24:00.000Z","updated":"2023-05-07T09:36:40.877Z","comments":true,"path":"api/articles/FreeRTOS/Timer.json","keywords":null,"cover":"/img/FreeRTOS/logo.jpg","content":"<p>软件定时器用于在将来一个设定的时间或以固定频率定期的执行函数。软件定时器所执行的函数被称为软件定时器的<strong>回调函数</strong>。</p>\n<p>软件定时器由 FreeRTOS\n内核实现，并受其控制。它不需要硬件支持，也与硬件定时器或硬件计数器无关。软件计时器不使用任何处理时间，除非软件计时器回调函数正在实际执行。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>软件定时器的功能是可选的，配置软件定时器功能：</p>\n<ul>\n<li>引入软件定时器的头文件 <code>timer.c</code></li>\n<li>配置 <code>configUSE_TIMERS</code> 为 <code>1</code></li>\n</ul></blockquote>\n<h2 id=\"软件定时器的回调函数\">软件定时器的回调函数</h2>\n<p>软件定时器的回调函数实现为 C\n函数。唯一的特殊之处在于它的原型，它的返回类型必须是\n<code>void</code>，并将一个软件定时器的句柄作为其唯一的参数：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">void ATimerCallback(TimerHandle_t xTimer);</code></pre>\n<p>软件定时器回调函数从头到尾执行，并以正常方式退出。它应该尽可能的短，并且不能进入阻塞状态。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>当 FreeRTOS\n的调度启动时，软件定时器回调函数在自动创建的任务上下文中执行。因此，软件定时器回调函数绝不能调用会导致调用任务进入阻塞状态的\nFreeRTOS API 函数。调用 <code>xQueueReceive()</code>\n等函数是可以的，但前提是函数的 xTicksToWait 参数必须设置为 0。调用\n<code>vTaskDelay()</code> 等函数是不行的，因为调用\n<code>vTaskDelay()</code> 将始终将调用任务进入阻塞状态。</p></blockquote>\n<h2 id=\"软件定时器的属性和状态\">软件定时器的属性和状态</h2>\n<h3 id=\"软件定时器的周期\">软件定时器的周期</h3>\n<p>软件定时器的“周期”是软件定时器启动和软件计时器回调函数执行之间的时间。</p>\n<h3 id=\"单次定时器和自动重装载定时器\">单次定时器和自动重装载定时器</h3>\n<p>软件定时器有两种类型:</p>\n<ul>\n<li>One-shot timers\n<ul>\n<li>一旦启动，一次性定时器将只执行一次回调函数。一次性定时器可以手动重启，但不会自行重启。</li>\n</ul></li>\n<li>Auto-reload timers\n<ul>\n<li>一旦启动，自动重装载定时器将在每次过期时重新启动自己，从而周期性地执行其回调函数。</li>\n</ul></li>\n</ul>\n<h3 id=\"软件定时器的状态\">软件定时器的状态</h3>\n<ul>\n<li>Dormant\n<ul>\n<li>休眠软件定时器可以被它的句柄引用，但是没有运行，所以它的回调函数不会执行。</li>\n</ul></li>\n<li>Running\n<ul>\n<li>正在运行的软件计时器将在自软件计时器进入“正在运行”状态以来经过与其时间段相等的时间或自上次重置软件计时器以来执行其回调函数。</li>\n</ul></li>\n</ul>\n<p>自动加载软件定时器的状态转换：</p>\n<p><img src=\"/img/FreeRTOS/timer%20state.png\"></p>\n<p>一次性软件定时器的状态转换：</p>\n<p><img src=\"/img/FreeRTOS/timer%20state%202.png\"></p>\n<p>自动加载定时器执行回调函数后进入 Running\n状态，一次性定时器执行回调函数后进入休眠状态。</p>\n<p><code>xTimerDelete()</code> API\n函数的作用是删除定时器。定时器可以在任何时候删除。</p>\n<h2 id=\"软件定时器的上下文\">软件定时器的上下文</h2>\n<h3 id=\"rtos-守护进程定时器服务任务\">RTOS 守护进程(定时器服务)任务</h3>\n<p>所有的软定时器回调函数都在同一个 RTOS 守护进程（或\n“定时器服务”）任务的上下文中执行。</p>\n<p>守护进程任务是一个标准的 FreeRTOS\n任务，在调度程序启动时自动创建。它的优先级和栈大小分别由\n<code>configTIMER_TASK_PRIORITY</code> 和\n<code>configTIMER_TASK_STACK_DEPTH</code> 常数设置。</p>\n<p>软件定时器回调函数不得调用会导致调用任务进入阻塞状态的 FreeRTOS API\n函数，因为这样做会导致守护程序任务进入阻塞状态。</p>\n<h3 id=\"定时器命令队列\">定时器命令队列</h3>\n<p>软件定时器 API 函数将命令从调用任务通过一个名为 timer command queue\n的队列发送到守护任务。命令包括 start a timer、stop a timer 和 reset a\ntimer。</p>\n<p><img src=\"/img/FreeRTOS/timer%20command%20queue.png\"></p>\n<p>timer command queue 是一个标准的 FreeRTOS\n队列，它在调度程序启动时自动创建。定时器命令队列的长度由\n<code>configTIMER_QUEUE_LENGTH</code> 常数设置。</p>\n<h3 id=\"守护进程任务调度\">守护进程任务调度</h3>\n<p>守护进程任务和其他 FreeRTOS\n任务一样被调度，只有当它是能够运行的最高优先级任务时，它才会处理命令或执行计时器回调函数。</p>\n<p>当 Daemon task 的有优先级<strong>低于</strong>调用\n<code>xTimerStart()</code> API 函数的任务的优先级时：</p>\n<p><img src=\"/img/FreeRTOS/timer%20daemon%20task%201.png\"></p>\n<p>任务 1 调用 <code>xTimerStart()</code> API\n函数。<code>xTimerStart()</code>\n向定时器命令队列发送命令，使守护进程任务离开阻塞状态。由于任务 1\n的优先级高于守护任务的优先级，所以守护任务不会抢占任务 1。</p>\n<p>当任务 1 调用 API\n函数进入阻塞状态。守护任务则是处于就绪状态的最高优先级任务，因此调度器选择守护任务作为进入运行状态的任务。然后，守护进程任务开始处理任务\n1 发送到计时器命令队列的命令。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>启动状态的软件定时器过期的时间是从 start a timer\n命令发送到定时器命令队列的时间开始计算的，而不是从守护任务从定时器队列接收\nstart a timer 命令的时间开始计算的。</p></blockquote>\n<p>当 Daemon task 的有优先级<strong>高于</strong>调用\n<code>xTimerStart()</code> API 函数的任务的优先级时：</p>\n<p><img src=\"/img/FreeRTOS/timer%20daemon%20task%202.png\"></p>\n<p>任务 1 调用 <code>xTimerStart()</code> API\n函数。<code>xTimerStart()</code>\n向定时器命令队列发送命令，使守护进程任务离开阻塞状态。守护进程任务的优先级高于任务\n1 的优先级，因此调度器选择守护进程任务作为要进入的任务运行状态。</p>\n<p>任务 1 在完成执行 <code>xTimerStart()</code>\n函数之前被守护进程任务抢占，现在处于Ready状态。守护任务开始处理任务 1\n发送给定时器命令队列的命令。</p>\n<p>发送到 timer\n命令队列的命令包含一个时间戳。时间戳用于说明应用程序任务发送命令与守护进程任务处理同一命令之间的任何时间间隔。例如，如果发送\nstart a timer 命令来启动一个周期为 10 个 ticks\n的定时器，则<strong>使用时间戳来确保正在启动的定时器在命令发送后10个\nticks 过期，而不是在命令被守护任务处理后10个 ticks 过期。</strong></p>\n<h2 id=\"创建并启动一个软件定时器\">创建并启动一个软件定时器</h2>\n<h3 id=\"xtimercreate-api-函数\"><code>xTimerCreate()</code> API 函数</h3>\n<p>软件定时器由 TimerHandle_t\n类型的变量引用。<code>xTimerCreate()</code>\n用于创建一个软件定时器，并返回一个 TimerHandle_t\n来引用它所创建的软件定时器。软件定时器在休眠状态下创建。</p>\n<p>软件定时器可以调度器启动之前创建，也可以在调度器启动之后创建。</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">TimerHandle_t xTimerCreate(const char * const pcTimerName,\n                           TickType_t xTimerPeriodInTicks,\n                           UBaseType_t uxAutoReload,\n                           void * pvTimerID,\n                           TimerCallbackFunction_t pxCallbackFunction);</code></pre>\n<table>\n<colgroup>\n<col style=\"width: 24%\">\n<col style=\"width: 75%\">\n</colgroup>\n<tbody>\n<tr class=\"odd\">\n<td>pcTimerName</td>\n<td>定时器的描述名称，便于识别</td>\n</tr>\n<tr class=\"even\">\n<td>xTimerPeriodInTicks</td>\n<td>定时器的周期，单位是 Tick。可以是 <code>pdMS_TO_TICKS()</code>\n宏函数</td>\n</tr>\n<tr class=\"odd\">\n<td>uxAutoReload</td>\n<td>pdTRUE/pdFALSE 是否自动重装载</td>\n</tr>\n<tr class=\"even\">\n<td>pvTimerID</td>\n<td>每个软件定时器都有一个 ID 值</td>\n</tr>\n<tr class=\"odd\">\n<td>pxCallbackFunction</td>\n<td>软件计时器回调函数</td>\n</tr>\n<tr class=\"even\">\n<td>Returned value</td>\n<td>创建失败返回 NULL，成功则返回定时器句柄</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"xtimerstart-api-函数\"><code>xTimerStart()</code> API 函数</h3>\n<p><code>xTimerStart()</code>\n用于启动处于休眠状态的软件定时器，或重置(重新启动)处于运行状态的软件定时器。<code>xTimerStop()</code>\n用于停止处于运行状态的软件定时器。停止软件定时器相当于将定时器转换为休眠状态。</p>\n<p>可以在调度器启动之前调用\n<code>xTimerStart()</code>，但是当这样做时，软件计时器直到调度器启动时才真正启动。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>中断中应当使用 <code>TimerStartFromISR()</code> API 函数</p></blockquote>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">BaseType_t xTimerStart( TimerHandle_t xTimer, TickType_t xTicksToWait );</code></pre>\n<table>\n<colgroup>\n<col style=\"width: 18%\">\n<col style=\"width: 81%\">\n</colgroup>\n<thead>\n<tr class=\"header\">\n<th>Parameter Name</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>xTimer</td>\n<td>软件定时器句柄</td>\n</tr>\n<tr class=\"even\">\n<td>xTicksToWait</td>\n<td>如果队列已经满了，调用任务应该保持在阻塞状态以等待定时器命令队列上的空间变得可用的最大时间。</td>\n</tr>\n<tr class=\"odd\">\n<td>Returned value</td>\n<td>pdPASS/pdFALSE</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"example-13-创建一个一次性的和一个自动重装载的寄存器\">Example 13\n创建一个一次性的和一个自动重装载的寄存器</h3>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">#define mainONE_SHOT_TIMER_PERIOD pdMS_TO_TICKS( 3333 )\n#define mainAUTO_RELOAD_TIMER_PERIOD pdMS_TO_TICKS( 500 )\nint main(void)\n{ \n    TimerHandle_t xAutoReloadTimer, xOneShotTimer;\n\tBaseType_t xTimer1Started, xTimer2Started;\n    \n    USART_Printf_Init(115200);\n    printf(\"SystemClk:%d\\r\\n\",SystemCoreClock);\n    printf(\"FreeRTOS Kernel Version:%s\\r\\n\",tskKERNEL_VERSION_NUMBER);\n\n    GPIO_Toggle_INIT();\n    /* 创建一个一次性定时器 */\n    xOneShotTimer = xTimerCreate(\"OneShot\",\n   \t\t\t\t\t\t\t\t mainONE_SHOT_TIMER_PERIOD,\n   \t\t\t\t\t\t\t\t pdFALSE,\n    \t\t\t\t\t\t\t 0,\n    \t\t\t\t\t\t\t prvOneShotTimerCallback);\t\n    /* 创建一个自动重装载定时器 */\n    xAutoReloadTimer = xTimerCreate(\"AutoReload\",\n                                    mainAUTO_RELOAD_TIMER_PERIOD,\n                                    pdTRUE,\n                                    0,\n                                    prvAutoReloadTimerCallback);\n    /* 检查软件定时器是否创建成功 */\n    if((xOneShotTimer != NULL) &amp;&amp; (xAutoReloadTimer != NULL))\n    {\n        xTimer1Started = xTimerStart(xOneShotTimer, 0);\n        xTimer2Started = xTimerStart(xAutoReloadTimer, 0);\n        if((xTimer1Started == pdPASS) &amp;&amp; (xTimer2Started == pdPASS))\n        {\n            /* Start the scheduler. */\n            vTaskStartScheduler();\n        }\n    }\n    while(1);\n}</code></pre>\n<p>定时器回调函数：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">static void prvOneShotTimerCallback(TimerHandle_t xTimer)\n{\n    TickType_t xTimeNow;\n    /* 获得当前 Tick 计数器 */\n    xTimeNow = xTaskGetTickCount();\n    printf(\"One-shot timer callback executing %d\", xTimeNow);\n    /* File scope variable. */\n    ulCallCount++;\n}</code></pre>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">static void prvAutoReloadTimerCallback(TimerHandle_t xTimer)\n{\n    TickType_t xTimeNow;\n    /* 获得当前 Tick 计数器 */\n    xTimeNow = xTaskGetTickCount();\n\tprintf(\"Auto-reload timer callback executing %d\", xTimeNow);\n    ulCallCount++;\n}</code></pre>\n<p>实验结果：</p>\n<p><img src=\"/img/FreeRTOS/timer%20example%2013.png\"></p>\n<h2 id=\"定时器-id\">定时器 ID</h2>\n<p>每个软件定时器都有一个 ID，它是一个标签值。该 ID 存储在 (void *)\n中，因此可以直接存储整数值，指向任何其他对象，或用作函数指针。在创建软件定时器时为该\nID 分配一个初始值，之后可以通过 <code>vTimerSetTimerID()</code> API\n函数更新该 ID，并通过 <code>pvTimerGetTimerID()</code> API 函数查询该\nID。</p>\n<p>与其他软件定时器 API 函数不同，<code>vTimerSetTimerID()</code> 和\n<code>pvTimerGetTimerID()</code>\n直接访问软件定时器，它们不向定时器命令队列发送命令。</p>\n<h3 id=\"vtimersettimerid-api-函数\"><code>vTimerSetTimerID()</code> API\n函数</h3>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">void vTimerSetTimerID(const TimerHandle_t xTimer, void *pvNewID);</code></pre>\n<table>\n<thead>\n<tr class=\"header\">\n<th>Parameter Name</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>xTimer</td>\n<td>软件定时器句柄</td>\n</tr>\n<tr class=\"even\">\n<td>pvNewID</td>\n<td>设置软件定时器 ID 的值。</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"pvtimergettimerid-api-函数\"><code>pvTimerGetTimerID()</code> API\n函数</h3>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">void *pvTimerGetTimerID( TimerHandle_t xTimer );</code></pre>\n<table>\n<thead>\n<tr class=\"header\">\n<th>Parameter Name</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>xTimer</td>\n<td>软件定时器句柄</td>\n</tr>\n<tr class=\"even\">\n<td>Returned value</td>\n<td>软件定时器的 ID 值</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"example-14-使用回调函数参数和软件定时器-id\">Example 14\n使用回调函数参数和软件定时器 ID</h3>\n<p>同一个回调函数可以分配给多个软件定时器。完成后，使用回调函数参数来确定哪个软件计时器过期了。</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">/* Create the one shot timer software timer */\nxOneShotTimer = xTimerCreate(\"OneShot\",\n\t\t\t\t\t\t\t mainONE_SHOT_TIMER_PERIOD,\n\t\t\t\t\t\t\t pdFALSE,\n\t\t\t\t\t\t\t 0,\n                             prvTimerCallback);\n/* Create the auto-reload software timer*/\nxAutoReloadTimer = xTimerCreate(\"AutoReload\",\n\t\t\t\t\t\t\t\tmainAUTO_RELOAD_TIMER_PERIOD,\n\t\t\t\t\t\t\t\tpdTRUE,\n                                0,\n                                prvTimerCallback );</code></pre>\n<p><code>prvTimerCallback()</code>\n将在其中一个计时器到期时执行。<code>prvTimerCallback()</code>\n使用函数的参数来确定调用它是因为一次性定时器过期，还是因为自动加载定时器过期。</p>\n<p><code>prvTimerCallback()</code> 还演示了如何使用软件定时器 ID\n作为定时器特定的存储，每个软件定时器都在自己的 ID\n中保存过期次数的计数，自动重新加载计时器使用该计数在第五次执行时停止自己。</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">static void prvTimerCallback(TimerHandle_t xTimer)\n{\n    TickType_t xTimeNow;\n    uint32_t ulExecutionCount;\n    /* 获得定时器 ID */\n    ulExecutionCount = (uint32_t) pvTimerGetTimerID(xTimer);\n    ulExecutionCount++;\n    vTimerSetTimerID(xTimer, (void *)ulExecutionCount);\n    /* 获得当前 Tick 计数 */\n    xTimeNow = xTaskGetTickCount();\n    /* 判断是哪个定时器到期 */\n    if(xTimer == xOneShotTimer)\n    {\n    \tprintf(\"One-shot timer callback executing %d\\r\\n\", xTimeNow);\n    }\n    else\n    {\n    \tprintf(\"Auto-reload timer callback executing %d\\r\\b\", xTimeNow);\n        if(ulExecutionCount == 5)\n        {\n            /* 自动装载 5 次后，停止定时器 */\n            xTimerStop( xTimer, 0 );\n        }\n    }\n}</code></pre>\n<p>实验结果：</p>\n<p><img src=\"/img/FreeRTOS/timer%20example%2014.png\"></p>\n<h2 id=\"更改一个定时器的周期\">更改一个定时器的周期</h2>\n<h3 id=\"xtimerchangeperiod-api-函数\"><code>xTimerChangePeriod()</code>\nAPI 函数</h3>\n<p>通过 <code>xTimerChangePeriod()</code>\n函数修改软件定时器的周期。如果使用 <code>xTimerChangePeriod()</code>\n来更改<strong>已经运行</strong>的定时器的周期，则定时器将使用新的周期值来<strong>重新计算其到期时间</strong>。重新计算的过期时间是相对于\n<code>xTimerChangePeriod()</code>\n被调用的时间，而不是相对于定时器最初启动的时间。</p>\n<p>如果 <code>xTimerChangePeriod()</code>\n用于更改处于<strong>休眠状态</strong>(未运行的计时器)的定时器的周期，则定时器将计算到期时间，并转换到运行状态(计时器将开始运行)。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>中断中应当使用 <code>xTimerChangePeriodFromISR()</code> API 函数</p></blockquote>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">BaseType_t xTimerChangePeriod(TimerHandle_t xTimer,\n                              TickType_t xNewTimerPeriodInTicks,\n                              TickType_t xTicksToWait );</code></pre>\n<table>\n<thead>\n<tr class=\"header\">\n<th>Parameter Name</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>xTimer</td>\n<td>定时器句柄</td>\n</tr>\n<tr class=\"even\">\n<td>xTimerPeriodInTicks</td>\n<td>新的定时器周期</td>\n</tr>\n<tr class=\"odd\">\n<td>xTicksToWait</td>\n<td>写入定时器命令队列的阻塞时间</td>\n</tr>\n<tr class=\"even\">\n<td>Returned value</td>\n<td>pdPASS/pdFALSE</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"重置软件定时器\">重置软件定时器</h2>\n<p>重置软件定时器是指重新启动定时器，定时器的过期时间被重新计算为相对于定时器重置的时间，而不是定时器最初启动的时间。</p>\n<h3 id=\"xtimerreset-api-函数\"><code>xTimerReset()</code> API 函数</h3>\n<p>使用 <code>xTimerReset()</code> API\n函数重置计时器。<code>xTimerReset()</code>\n也可用于启动处于休眠状态的计时器。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>中断中应该使用 <code>xTimerResetFromISR()</code> API 函数</p></blockquote>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">BaseType_t xTimerReset( TimerHandle_t xTimer, TickType_t xTicksToWait );</code></pre>\n<table>\n<thead>\n<tr class=\"header\">\n<th>Parameter Name</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>xTimer</td>\n<td>定时器句柄</td>\n</tr>\n<tr class=\"even\">\n<td>xTicksToWait</td>\n<td>写入定时器命令队列的阻塞时间</td>\n</tr>\n<tr class=\"odd\">\n<td>Returned value</td>\n<td>pdPASS/pdFALSE</td>\n</tr>\n</tbody>\n</table>\n","text":"软件定时器用于在将来一个设定的时间或以固定频率定期的执行函数。软件定时器所执行的函数被称为软件定时器的回调函数。 软件定时器由 FreeRTOS 内核实现，并受其控制。它不需要硬件支持，也与硬件定时器或硬件计数器无关。软件计时器不使用任何处理时间，除非软件计时器回调函数正在实际执...","link":"","photos":[],"count_time":{"symbolsCount":"8.4k","symbolsTime":"8 mins."},"categories":[{"name":"嵌入式","slug":"嵌入式","count":3,"path":"api/categories/嵌入式.json"}],"tags":[{"name":"FreeRTOS","slug":"FreeRTOS","count":3,"path":"api/tags/FreeRTOS.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%BD%AF%E4%BB%B6%E5%AE%9A%E6%97%B6%E5%99%A8%E7%9A%84%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">软件定时器的回调函数</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%BD%AF%E4%BB%B6%E5%AE%9A%E6%97%B6%E5%99%A8%E7%9A%84%E5%B1%9E%E6%80%A7%E5%92%8C%E7%8A%B6%E6%80%81\"><span class=\"toc-text\">软件定时器的属性和状态</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BD%AF%E4%BB%B6%E5%AE%9A%E6%97%B6%E5%99%A8%E7%9A%84%E5%91%A8%E6%9C%9F\"><span class=\"toc-text\">软件定时器的周期</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8D%95%E6%AC%A1%E5%AE%9A%E6%97%B6%E5%99%A8%E5%92%8C%E8%87%AA%E5%8A%A8%E9%87%8D%E8%A3%85%E8%BD%BD%E5%AE%9A%E6%97%B6%E5%99%A8\"><span class=\"toc-text\">单次定时器和自动重装载定时器</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BD%AF%E4%BB%B6%E5%AE%9A%E6%97%B6%E5%99%A8%E7%9A%84%E7%8A%B6%E6%80%81\"><span class=\"toc-text\">软件定时器的状态</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%BD%AF%E4%BB%B6%E5%AE%9A%E6%97%B6%E5%99%A8%E7%9A%84%E4%B8%8A%E4%B8%8B%E6%96%87\"><span class=\"toc-text\">软件定时器的上下文</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#rtos-%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B%E5%AE%9A%E6%97%B6%E5%99%A8%E6%9C%8D%E5%8A%A1%E4%BB%BB%E5%8A%A1\"><span class=\"toc-text\">RTOS 守护进程(定时器服务)任务</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AE%9A%E6%97%B6%E5%99%A8%E5%91%BD%E4%BB%A4%E9%98%9F%E5%88%97\"><span class=\"toc-text\">定时器命令队列</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6\"><span class=\"toc-text\">守护进程任务调度</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%88%9B%E5%BB%BA%E5%B9%B6%E5%90%AF%E5%8A%A8%E4%B8%80%E4%B8%AA%E8%BD%AF%E4%BB%B6%E5%AE%9A%E6%97%B6%E5%99%A8\"><span class=\"toc-text\">创建并启动一个软件定时器</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#xtimercreate-api-%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">xTimerCreate() API 函数</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#xtimerstart-api-%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">xTimerStart() API 函数</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#example-13-%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E4%B8%80%E6%AC%A1%E6%80%A7%E7%9A%84%E5%92%8C%E4%B8%80%E4%B8%AA%E8%87%AA%E5%8A%A8%E9%87%8D%E8%A3%85%E8%BD%BD%E7%9A%84%E5%AF%84%E5%AD%98%E5%99%A8\"><span class=\"toc-text\">Example 13\n创建一个一次性的和一个自动重装载的寄存器</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%9A%E6%97%B6%E5%99%A8-id\"><span class=\"toc-text\">定时器 ID</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#vtimersettimerid-api-%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">vTimerSetTimerID() API\n函数</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#pvtimergettimerid-api-%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">pvTimerGetTimerID() API\n函数</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#example-14-%E4%BD%BF%E7%94%A8%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E5%92%8C%E8%BD%AF%E4%BB%B6%E5%AE%9A%E6%97%B6%E5%99%A8-id\"><span class=\"toc-text\">Example 14\n使用回调函数参数和软件定时器 ID</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%9B%B4%E6%94%B9%E4%B8%80%E4%B8%AA%E5%AE%9A%E6%97%B6%E5%99%A8%E7%9A%84%E5%91%A8%E6%9C%9F\"><span class=\"toc-text\">更改一个定时器的周期</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#xtimerchangeperiod-api-%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">xTimerChangePeriod()\nAPI 函数</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%87%8D%E7%BD%AE%E8%BD%AF%E4%BB%B6%E5%AE%9A%E6%97%B6%E5%99%A8\"><span class=\"toc-text\">重置软件定时器</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#xtimerreset-api-%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">xTimerReset() API 函数</span></a></li></ol></li></ol>","author":{"name":"爱慢跑的乌龟","slug":"blog-author","avatar":"/img/avatar1.jpg","link":"/","description":"求知若饥，虚心若愚！","socials":{"github":"https://github.com/ansonxu1998","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Simulink 编译动态链接库","uid":"72c8bb50db339fd6a5c5fe75ad80519f","slug":"Simulink/Simulink 编译动态链接库","date":"2023-06-05T13:20:00.000Z","updated":"2023-08-30T01:32:54.945Z","comments":true,"path":"api/articles/Simulink/Simulink 编译动态链接库.json","keywords":null,"cover":"/img/bg/Simulink.png","text":"一、创建输入输出变量 将变量设置为全局变量： 右击信号线，选择 Properties Current &#x3D; Simulink.Signal; Current.CoderInfo.StorageClass &#x3D; &quot;ExportedGlobal&quot;;...","link":"","photos":[],"count_time":{"symbolsCount":"7.9k","symbolsTime":"7 mins."},"categories":[{"name":"Simulink","slug":"Simulink","count":1,"path":"api/categories/Simulink.json"}],"tags":[{"name":"代码生成","slug":"代码生成","count":1,"path":"api/tags/代码生成.json"}],"author":{"name":"爱慢跑的乌龟","slug":"blog-author","avatar":"/img/avatar1.jpg","link":"/","description":"求知若饥，虚心若愚！","socials":{"github":"https://github.com/ansonxu1998","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"FreeRTOS 的队列 (Queue)","uid":"b5bbb50a4ed24d8a8d9fcbeb2df5e6ea","slug":"FreeRTOS/Queue","date":"2023-05-05T12:57:00.000Z","updated":"2023-05-06T11:27:20.463Z","comments":true,"path":"api/articles/FreeRTOS/Queue.json","keywords":null,"cover":"/img/FreeRTOS/logo.jpg","text":"队列提供一种任务到任务、任务到中断和中断到任务之间的通信机制。 队列的特点 数据存储 队列可保存有限数量的固定大小的数据项。一个队列可以容纳的最大数据量称为它的长度。在创建队列时需要指定每个数据项的长度和大小。队列通常使用先进先出(FIFO)缓冲区，数据在队列末尾被被写入并仓队列...","link":"","photos":[],"count_time":{"symbolsCount":"19k","symbolsTime":"17 mins."},"categories":[{"name":"嵌入式","slug":"嵌入式","count":3,"path":"api/categories/嵌入式.json"}],"tags":[{"name":"FreeRTOS","slug":"FreeRTOS","count":3,"path":"api/tags/FreeRTOS.json"}],"author":{"name":"爱慢跑的乌龟","slug":"blog-author","avatar":"/img/avatar1.jpg","link":"/","description":"求知若饥，虚心若愚！","socials":{"github":"https://github.com/ansonxu1998","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}