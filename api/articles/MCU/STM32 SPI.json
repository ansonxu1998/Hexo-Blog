{"title":"STM32 SPI 通信","uid":"f421a58a89600265fb1eeb9a03b677f4","slug":"MCU/STM32 SPI","date":"2022-10-16T02:19:00.000Z","updated":"2023-09-01T02:28:29.548Z","comments":true,"path":"api/articles/MCU/STM32 SPI.json","keywords":null,"cover":"/img/STM32-GPIO/STM32-logo.jpg","content":"<h2 id=\"spi-通信原理及特点\">SPI 通信原理及特点</h2>\n<p>SPI，Serial Peripheral interface，串行外围设备接口。是 Motorola 首先在其 MC68HCXX 系列处理器上定义的。SPI 接口主要应用在 EEPROM、FLASH、实时时钟、AD 转换器，还有数字信号处理器和数字信号解码器之间。</p>\n<p>SPI 的优点：</p>\n<ul>\n<li>一主多从</li>\n<li>同步通信</li>\n<li>高速全双工，可达几十 Mbps</li>\n</ul>\n<h2 id=\"spi-通讯协议时序\">SPI 通讯协议时序</h2>\n<ul>\n<li>SCK：时钟信号</li>\n<li>MISO：主收从发</li>\n<li>MOSI：主发从收</li>\n<li>NSS：片选信号</li>\n</ul>\n<p>SPI 通讯有 4 种时序模式，由 SPI 控制寄存器 SPI_CR1 中的 CPOL 和 CPHA 位控制。</p>\n<ul>\n<li><strong>CPOL(Clock Polority) 时钟极性</strong></li>\n<li><strong>CPHA(Clock Phase) 时钟相位</strong></li>\n</ul>\n<p><img src=\"/img/2023-8-31/timing%20sequence.gif\" /></p>\n<ul>\n<li>CPOL=0：时钟低电平总线空闲</li>\n<li>CPOL=1：时钟高电平总线空闲</li>\n<li>CPHA=0：第一个跳变沿</li>\n<li>CPHA=1：第二个跳变沿</li>\n</ul>\n<p>SPI 的 4 种时序模式：</p>\n<table>\n<thead>\n<tr class=\"header\">\n<th style=\"text-align: center;\">SPI 时序模式</th>\n<th style=\"text-align: center;\">CPOL</th>\n<th style=\"text-align: center;\">CPHA</th>\n<th style=\"text-align: center;\">空闲时钟电平</th>\n<th style=\"text-align: center;\">采样时刻</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td style=\"text-align: center;\">模式 0</td>\n<td style=\"text-align: center;\">0</td>\n<td style=\"text-align: center;\">0</td>\n<td style=\"text-align: center;\">低电平</td>\n<td style=\"text-align: center;\">第 1 个跳变沿</td>\n</tr>\n<tr class=\"even\">\n<td style=\"text-align: center;\">模式 1</td>\n<td style=\"text-align: center;\">0</td>\n<td style=\"text-align: center;\">1</td>\n<td style=\"text-align: center;\">低电平</td>\n<td style=\"text-align: center;\">第 2 个跳变沿</td>\n</tr>\n<tr class=\"odd\">\n<td style=\"text-align: center;\">模式 2</td>\n<td style=\"text-align: center;\">1</td>\n<td style=\"text-align: center;\">0</td>\n<td style=\"text-align: center;\">高电平</td>\n<td style=\"text-align: center;\">第 1 个跳变沿</td>\n</tr>\n<tr class=\"even\">\n<td style=\"text-align: center;\">模式 3</td>\n<td style=\"text-align: center;\">1</td>\n<td style=\"text-align: center;\">1</td>\n<td style=\"text-align: center;\">高电平</td>\n<td style=\"text-align: center;\">第 2 个跳变沿</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"stm32-spi-总线\">STM32 SPI 总线</h2>\n<p>主要功能：</p>\n<ul>\n<li>支持 8bit 或 16bit 的数据帧格式，可设置 MSB/LSB 先行</li>\n<li>支持主、从机模式</li>\n<li>片选信号的管理模式可选硬件或软件</li>\n<li>硬件 CRC 校验功能</li>\n<li>支持中断、DMA</li>\n<li>支持 Motorola 模式和 TI 模式</li>\n<li>支持半双工模式（单线单向、单线双向）</li>\n</ul>\n<p><strong>中断</strong></p>\n<table>\n<thead>\n<tr class=\"header\">\n<th>Interrupt event</th>\n<th>Event flag</th>\n<th>Enable Control bit</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>Transmit buffer empty flag</td>\n<td>TXE</td>\n<td>TXEIE</td>\n</tr>\n<tr class=\"even\">\n<td>Receive buffer not empty flag</td>\n<td>RXNE</td>\n<td>RXNEIE</td>\n</tr>\n<tr class=\"odd\">\n<td>Master Mode fault event</td>\n<td>MODF</td>\n<td>ERRIE</td>\n</tr>\n<tr class=\"even\">\n<td>Overrun error</td>\n<td>OVR</td>\n<td>ERRIE</td>\n</tr>\n<tr class=\"odd\">\n<td>CRC error flag</td>\n<td>CRCERR</td>\n<td>ERRIE</td>\n</tr>\n<tr class=\"even\">\n<td>TI frame format error</td>\n<td>FRE</td>\n<td>ERRIE</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"stm32cubemx软件配置\">STM32CubeMX软件配置</h2>\n<p>Step 1：RCC 时钟、SW调试口</p>\n<p>Step 2：SPIx 选择、I/O 管脚选择</p>\n<p>Step 3：SPI 参数、中断、DMA</p>\n<p><img src=\"/img/2023-8-31/cubemx.png\" /></p>\n<h2 id=\"hal-库函数分析\">HAL 库函数分析</h2>\n<p><strong>查询模式（阻塞模式）</strong></p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">HAL_SPI_Transmit(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size, uint32_t Timeout);\n\nHAL_SPI_Receive(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size, uint32_t Timeout);\n\nHAL_SPI_TransmitReceive(SPI_HandleTypeDef *hspi, uint8_t *pTxData, uint8_t *pRxData, uint16_t Size, uint32_t Timeout);</code></pre>\n<p><strong>中断模式</strong></p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">HAL_SPI_Transmit_IT(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size);\n\nHAL_SPI_Receive_IT(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size);\n\nHAL_SPI_TransmitReceive_IT(SPI_HandleTypeDef *hspi, uint8_t *pTxData, uint8_t *pRxData, uint16_t Size);</code></pre>\n<p><strong>DMA 模式</strong></p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">HAL_SPI_Transmit_DMA(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size);\n\nHAL_SPI_Receive_DMA(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size);\n\nHAL_SIP_TransmitReceive_DMA(SPI_HandleTypeDef *hspi, uint8_t *pTxData, uint8_t *pRxData, uint16_t Size);</code></pre>\n<h2 id=\"stm32-hal-库-spi-通讯\">STM32 HAL 库 SPI 通讯</h2>\n<h3 id=\"串行-flash-芯片-w25q128\">串行 FLash 芯片 W25Q128</h3>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>如何看 Datasheet?</p>\n<p>1、主要特点</p>\n<p>2、电气特性</p>\n<p>3、管脚定义</p>\n<p>4、通讯时序</p>\n<p>5、应用说明</p></blockquote>\n<p>W25Q28 的驱动程序</p>\n<ol type=\"1\">\n<li>判断芯片存在</li>\n<li>读数据（查询/DMA）</li>\n<li>写使能、写禁止</li>\n<li>写数据（是否核查）</li>\n<li>扇区擦除、块擦除、芯片擦除</li>\n</ol>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;* File: W25Q128.h *&#x2F;\n#ifndef __W25Q128_H\n#define __W25Q128_H\n\n#ifedf __cplusplus\nextern &quot;C&quot; &#123;\n#endif\n#include &quot;main.h&quot;\n\n    \n&#x2F;&#x2F; W25X系列&#x2F;Q系列芯片列表\n&#x2F;&#x2F; W25Q80\tID\t0XEF13\n&#x2F;&#x2F; W25Q16\tID\t0XEF14\n&#x2F;&#x2F; W25Q32\tID\t0XEF15\n&#x2F;&#x2F; W25Q64\tID\t0XEF16\n&#x2F;&#x2F; W25Q128\tID\t0XEF17\n&#x2F;&#x2F; W25Q256\tID\t0XEF18\n\n#define W25Q80 0XEF13\n#define W25Q16 0XEF14\n#define W25Q32 0XEF15\n#define W25Q64 0XEF16\n#define W25Q128 0XEF17\n#define W25Q256 0XEF18\n\n#define NumByteOfPage  \t\t256\n#define\tNumPageOfSector  \t16\n#define NumSectorOfBlock\t16\n#define NumBlockOfChip\t\t256\n\n#define NumByteOfSector\tNumByteOfPage * NumPageOfSector\n#define NumByteOfBlock\tNumByteOfSector * NumSectorOfBlock\n#define FLACH_SZIE \t\tNumByteOfBlock * NumBlockOfChip\n\n#define W25Q128_CS_0\tHAL_GPIO_WritePin(SPI1_CS_GPIO_Port, SPI1_CS_Pin, GPIO_PIN_RESET)\n#define W25Q128_CS_1\tHAL_GPIO_WritePin(SPI1_CS_GPIO_Port, SPI1_CS_Pin, GPIO_PIN_SET)\n\n&#x2F;* 指令表 *&#x2F;\n#define\tW25X_WriteEnable \t\t0x06\n#define\tW25X_WriteDisable\t\t0x04\n#define\tW25X_ReadStatusReg1 \t0x05\n#define\tW25X_ReadStatusReg2\t\t0x35\n#define\tW25X_ReadStatusReg3\t\t0x15\n#define\tW25X_WriteStatusReg1\t0x01\n#define W25X_WriteStatusReg2\t0x31\n#define\tW25X_WriteStatusReg3\t0x11\n#define W25X_ReadData  \t\t    0x03\n#define W25X_FastReadData\t\t0x0B\n#define W25X_FastReadDual\t\t0x3B\n#define\tW25X_PageProgram\t\t0x02\n#define W25X_BlockErase\t\t\t0xD8\n#define W25X_SectorErase\t\t0x20\n#define W25X_ChipErase\t\t\t0xC7\n#define W25X_PowerDown\t\t\t0xB9\n#define W25X_ReleasePowerDown\t 0xAB\n#define W25X_DeviceID\t\t\t0xAC\n#define W25X_ManufactDeviceID\t 0x90\n#define W25X_JedecDeviceID\t\t 0x9F\n#define W25X_Enable4ByteAddr\t 0xB7\n#define W25X_Exit4ByteAddr\t\t 0xE9\n\nuint8_t W25QXX_Init(void);\nuint16_t W25QXX_ReadID(void);\t\t    &#x2F;&#x2F; 读取 FLASH ID\nuint8_t W25QXX_ReadSR(uint8_t regno);\t&#x2F;&#x2F; 读取寄存器器\nvoid W25QXX_4ByteAddr_Enable(void);\t\t&#x2F;&#x2F; 使能 4 字节地址模式\nvoid W25QXX_Write_SR(uint8_t regno, uint_8 sr); &#x2F;&#x2F; 写状态寄存器\nvoid W25QXX_Write_Enable(void);\t\t\t&#x2F;&#x2F; 写使能\nvoid W25QXX_Write_Enable(void);\t\t\t&#x2F;&#x2F; 写保护\nvoid W25QXX_Write_NoChech(uint8_t *pBuffer, uint32_t WriteAdd, uint16_t NumByteToWrite); \nvoid W25QXX_Read(uint8_t *pBuffer, uint32_t ReadAddr, uint16_t NumByteToWrite);&#x2F;&#x2F; 读取 flash\nvoid W25QXX_Read_DMA(uint8_t *pBuffer, uint32_t ReadAddr, uint16_t NumByteToRead);&#x2F;&#x2F; 读取 flsh\nvoid W25QXX_Write(uint8_t *pBuffer, uint32_t WriteAddr, uint16_t NumByteToWrite);&#x2F;&#x2F; 写入 flash\nvoid W25QXX_Erase_Chip(void);\t\t&#x2F;&#x2F; 整片擦除\nvoid W25QXX_Erase_Sector(uint32_t Dst_Addr);\t&#x2F;&#x2F; 扇区擦除\nvoid W25QXX_Erase_Block(uint32_t Dst_Addr);\t&#x2F;&#x2F; \t块擦除\nvoid W25QXX_Wait_Busy(void);\t\t&#x2F;&#x2F; 等待空闲\nvoid W25QXX_PowerDown(void);\t\t&#x2F;&#x2F; 进入掉电模式\nvoid W25QXX_WAKEUP(void);\t\t\t&#x2F;&#x2F; 唤醒\n\n#ifdef __cplusplus\n&#125;\n#endif &#x2F;* __W25Q128_H *&#x2F; \n</code></pre>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><code>extern \"C\"</code> 的主要作用就是为了能够正确实现 C++ 代码调用其他 C 语言代码。加上 <code>extern \"C\"</code> 后，会指示编译器这部分代码按 C 语言进行编译，而不是 C++的。由于 C++ 支持函数重载，因此编译器编译函数的过程中会将函数的参数类型也加到编译后的代码中，而不仅仅是函数名；而 C 语言并不支持函数重载，因此编译 C 语言代码的函数时不会带上函数的参数类型，一般只包括函数名。</p>\n<p>通过 <code>extern \"C\"</code>，告诉 g++ 编译器，不要对这些函数进行 <em>Name mangling</em>，按照 C 编译器的方式取生成符号表符号。</p></blockquote>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><code>__cplusplus</code> 和 <code>c_plusplus</code> 这两个宏有定义，说明使用的c++的编译器。</p></blockquote>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;* File W25Q128.c *&#x2F;\n#include &quot;W25Q128.h&quot;\n\nextern SPI_HandleTypeDef hspi1;\n\nuint16_t W25QXX_TYPE;\nuint8_t SPI1_RX_BUF[4096];\n\n&#x2F;&#x2F; 初始化 SPI FLASH 的 IO 口\nuint8_t W25QXX_Init(void)&#123;\n    W25Q128_CS_1;\t\t&#x2F;&#x2F; SPI FLASH 不选中\n    W25QXX_TYPE &#x3D; W25QXX_ReadID(); &#x2F;&#x2F; 读取 FLASH ID\n    if(W25QXX_TYPE &#x3D;&#x3D; W25Q128)&#123;\n        return 1;\n    &#125;else&#123;\n        return 0;\n    &#125;\n&#125;\n\n&#x2F;&#x2F; 读取 W25QXX 的状态寄存器\nuint8_t W25QXX_ReadSR(uint8_t regno)&#123;\n    uint8_t cmd[2];\n    uint8_t temp[2];\n    switch(regno)&#123;\n        case 1:\n            cmd[0] &#x3D; W25X_ReadStatusReg1;\n            break;\n        case 2:\n            cmd[0] &#x3D; W25X_ReadStatusReg2;\n        case 3:\n            cmd[0] &#x3D; W25X_ReadStatusReg3;\n        default:\n            cmd[0] &#x3D; W25X_ReadStatusReg1;\n            break;\n    &#125;\n    W25Q128_CS_0;\n    &#x2F;&#x2F; Poll mode\n    &#x2F;&#x2F; 发送指令和接收简单数据推荐使用查询模式\n    HAL_SPI_TransmitReceive(&amp;hspi1, cmd, temp, 2, 10); &#x2F;&#x2F; 发送读转台寄存器命令\n    W25Q128_CS_1;\n    return temp[1];\n&#125;\n\n&#x2F;&#x2F; 写 W25QXX 状态寄存器\nvoid W25QXX_Write_SR(uint8_t regno, uint8_t sr)&#123;\n    uint8_t cmd[2];\n    switch(regno)&#123;\n        case 1: \n            cmd[0] &#x3D; W25X_WriteStatusReg1;\n        case 2:\n            cmd[0] &#x3D; W25X_WriteStatusReg2;\n        case 3:\n            cmd[0] &#x3D; W25X_WriteStatusReg3;\n        default:\n            cmd[0] &#x3D; W25X_WriteStatusReg1;\n    &#125;\n    cmd[1] &#x3D; sr;\n    W25Q128_CS_0;\n    HAL_SPI_Transmit(&amp;hspi1, cmd, 2, 10);\n    W25Q128_CS_1;\n&#125;\n\n&#x2F;&#x2F; W25QXX 写使能\n&#x2F;&#x2F; 将 WEL 置位\nvoid W25QXX_Write_Enable(void)&#123;\n    uint8_t cmd &#x3D; W25X_WriteEnable;\n    W25Q128_CS_0;\n    HAL_SPI_Transmit(&amp;hspi1, &amp;cmd, 1, 10);\n    W25Q128_CS_1;\n&#125;\n\n&#x2F;&#x2F; W25QXX 写禁止\n&#x2F;&#x2F; 将 WEL 清零\nvoid W25QXX_Write_Disable(void)&#123;\n    uint8_t cmd &#x3D; W25X_WriteDisable;\n    W25Q128_CS_0;\n    HAL_SPI_Transmit(&amp;hspi1, &amp;cmd, 1, 10);\n    W25Q128_CS_1;\n&#125;\n\n&#x2F;&#x2F; 等待空闲\nvoid W25QXX_Wait_Busy(void)&#123;\n    while((W25QXX_ReadSR(1)&amp;0x01) &#x3D;&#x3D; 0x01); &#x2F;&#x2F; 等待 BUSY 位清空\n&#125;\n\n&#x2F;&#x2F; 进入掉电模式\nvoid W25QXX_PowerDown(void)&#123;\n    uint8_t cmd &#x3D; W25X_PowerDown;\n    W25Q128_CS_0;\n    HAL_SPI_Transmit(&amp;hspi1, &amp;cmd, 1, 10);\n    W25Q128_CS_1;\n    HAL_Delay(1);\n&#125;\n\n&#x2F;&#x2F; 唤醒\nvoid W25QXX_WAKEUP(void)&#123;\n    uint8_t cmd &#x3D; W25X_ReleasePowerDown;\n    W25Q128_CS_0;\n    HAL_SPI_Transmit(&amp;hspi1, &amp;cmd, 1, 10);\n    W25Q128_CS_1;\n    HAL_Delay(1);\n&#125;</code></pre>\n","text":"SPI 通信原理及特点 SPI，Serial Peripheral interface，串行外围设备接口。是 Motorola 首先在其 MC68HCXX 系列处理器上定义的。SPI 接口主要应用在 EEPROM、FLASH、实时时钟、AD 转换器，还有数字信号处理器和数字信号解...","link":"","photos":[],"count_time":{"symbolsCount":"7.9k","symbolsTime":"7 mins."},"categories":[{"name":"单片机","slug":"单片机","count":8,"path":"api/categories/单片机.json"}],"tags":[{"name":"STM32","slug":"STM32","count":8,"path":"api/tags/STM32.json"},{"name":"SPI","slug":"SPI","count":1,"path":"api/tags/SPI.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#spi-%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E5%8F%8A%E7%89%B9%E7%82%B9\"><span class=\"toc-text\">SPI 通信原理及特点</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#spi-%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE%E6%97%B6%E5%BA%8F\"><span class=\"toc-text\">SPI 通讯协议时序</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#stm32-spi-%E6%80%BB%E7%BA%BF\"><span class=\"toc-text\">STM32 SPI 总线</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#stm32cubemx%E8%BD%AF%E4%BB%B6%E9%85%8D%E7%BD%AE\"><span class=\"toc-text\">STM32CubeMX软件配置</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#hal-%E5%BA%93%E5%87%BD%E6%95%B0%E5%88%86%E6%9E%90\"><span class=\"toc-text\">HAL 库函数分析</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#stm32-hal-%E5%BA%93-spi-%E9%80%9A%E8%AE%AF\"><span class=\"toc-text\">STM32 HAL 库 SPI 通讯</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%B2%E8%A1%8C-flash-%E8%8A%AF%E7%89%87-w25q128\"><span class=\"toc-text\">串行 FLash 芯片 W25Q128</span></a></li></ol></li></ol>","author":{"name":"爱慢跑的乌龟","slug":"blog-author","avatar":"/img/avatar1.jpg","link":"/","description":"求知若饥，虚心若愚！","socials":{"github":"https://github.com/ansonxu1998","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"STM32 I2C 通信","uid":"736e2225b7c206e1f84f77a4e032b64a","slug":"MCU/STM32-I2C","date":"2022-10-18T02:21:00.000Z","updated":"2023-09-01T02:28:29.812Z","comments":true,"path":"api/articles/MCU/STM32-I2C.json","keywords":null,"cover":"/img/STM32-GPIO/STM32-logo.jpg","text":"I2C 总线介绍 I2C 的定义 Inter-intergrated Circuit 的缩写，最初由 PHILIPS 公司推出。用于短距离设备之间的低速串行通信，如处理器和外围器件的通线。只需要 2 根信号线，具有总线时钟同步和仲裁机制，允许多主机通信。传输速率在标准模式下可达 ...","link":"","photos":[],"count_time":{"symbolsCount":"1.4k","symbolsTime":"1 mins."},"categories":[{"name":"单片机","slug":"单片机","count":8,"path":"api/categories/单片机.json"}],"tags":[{"name":"STM32","slug":"STM32","count":8,"path":"api/tags/STM32.json"},{"name":"I2C","slug":"I2C","count":1,"path":"api/tags/I2C.json"}],"author":{"name":"爱慢跑的乌龟","slug":"blog-author","avatar":"/img/avatar1.jpg","link":"/","description":"求知若饥，虚心若愚！","socials":{"github":"https://github.com/ansonxu1998","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"STM32-通用定时器","uid":"3d33cea6f7241857ab27348fe640e83f","slug":"MCU/STM32-通用定时器","date":"2022-10-15T02:18:00.000Z","updated":"2023-09-01T02:28:30.404Z","comments":true,"path":"api/articles/MCU/STM32-通用定时器.json","keywords":null,"cover":"/img/STM32-GPIO/STM32-logo.jpg","text":"通用定时器功能概述 通用定时器功能 输入捕获(Input Capture) 输出比较(Output Compare) 生成 PWM 波 测量 PWM 周期和占空比 定时器同步 定时器串联 结构框图 时序： 预分频系数由 1 修改到 2 时，并不会立即生效，而是要等到下一个 UEV...","link":"","photos":[],"count_time":{"symbolsCount":"3.9k","symbolsTime":"4 mins."},"categories":[{"name":"单片机","slug":"单片机","count":8,"path":"api/categories/单片机.json"}],"tags":[{"name":"STM32","slug":"STM32","count":8,"path":"api/tags/STM32.json"},{"name":"通用定时器","slug":"通用定时器","count":1,"path":"api/tags/通用定时器.json"}],"author":{"name":"爱慢跑的乌龟","slug":"blog-author","avatar":"/img/avatar1.jpg","link":"/","description":"求知若饥，虚心若愚！","socials":{"github":"https://github.com/ansonxu1998","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}