{"title":"棋盘格角点检测","uid":"1eaff4e22fb5fa029043d1942e6ee81c","slug":"Digital-Image/X-Corner","date":"2022-06-29T07:11:00.000Z","updated":"2022-06-29T07:41:49.503Z","comments":true,"path":"api/articles/Digital-Image/X-Corner.json","keywords":null,"cover":[],"content":"<h2\nid=\"a-new-sub-pixel-detector-for-x-corners-in-camera-calibration-targets\">A\nNew Sub-Pixel Detector for X-Corners in Camera Calibration Targets</h2>\n<blockquote>\n<p>基于海塞矩阵的方法</p>\n</blockquote>\n<p>一个标准的 X-Corners 如下图所示：</p>\n<p><img src=\"/img/X-Corners/2a.png\" /></p>\n<p>其表达式为： <span class=\"math display\">\\[\nf(x,y)=\\begin{cases}\n0,&amp;xy\\le0\\\\\n1,&amp;xy&gt;0\n\\end{cases}\n\\]</span>\n由于实际的图像中存在噪点，所以需要对图像进行低通滤波，这里使用高斯算子：\n<span class=\"math display\">\\[\ng(x,y)=\\frac{1}{2\\pi\\sigma^2}e^{-\\frac{x^2+y^2}{2\\sigma^2}}\n\\]</span> 高斯算子平滑的 X-Corner 的强度分布模型： <span\nclass=\"math display\">\\[\nr(x,y)=g(x,y)\\otimes f(x,y)=\\Phi(x)\\Phi(y)+\\Phi(-x)\\Phi(-y)\\quad (2)\n\\]</span> 其中，<span\nclass=\"math inline\">\\(\\Phi(x)=\\frac{1}{\\sqrt{2\\pi}\\sigma}\\int_{-\\infty}^xe^{-\\frac{t^2}{2\\sigma^2}}dt\\)</span>.</p>\n<p>对于 X-Corner，我们可以使用由图像函数的 Hessian\n矩阵的特征值推导出的新形状算子。</p>\n<p>Hessian\n矩阵的特征值对应曲面的最小和最大二阶导数，它们的相关特征向量是二阶导数极值的方向，并且相互正交.\n将图像函数中一个像素的邻域视为一个表面块，Hessian 矩阵表示为 <span\nclass=\"math display\">\\[\n\\mathbf{H}=\\begin{bmatrix}\nr_{xx}&amp;r_{xy}\\\\\nr_{xy}&amp;r_{yy}\n\\end{bmatrix}\n\\]</span> <span class=\"math inline\">\\(r_{xx},r_{xy},r_{yy}\\)</span>\n是图像函数 <span class=\"math inline\">\\(r(x,y)\\)</span> 的二阶偏导数.\nHessian 矩阵的两个特征值为: <span class=\"math display\">\\[\n\\lambda_1=\\frac{1}{2}(r_{xx}+r_{yy}+D),\\lambda_2=\\frac{1}{2}(r_{xx}+r_{yy}-D).\n\\]</span> 对应的归一化特征向量是： <span class=\"math display\">\\[\n\\begin{align*}\n&amp;\\mathbf{n}_1=\\begin{bmatrix}\\sqrt{\\frac{1}{2}\\left(1-\\frac{f_{yy}-f_{xx}}{D}\\right)}&amp;\\sqrt{\\frac{1}{2}\\left(1+\\frac{f_{yy}-f_{xx}}{D}\\right)}\\end{bmatrix}^T\n\\\\\n&amp;\\mathbf{n}_2=\\begin{bmatrix}\\sqrt{\\frac{1}{2}\\left(1+\\frac{f_{yy}-f_{xx}}{D}\\right)}&amp;-\\sqrt{\\frac{1}{2}\\left(1-\\frac{f_{yy}-f_{xx}}{D}\\right)}\\end{bmatrix}^T\n\\end{align*}\n\\]</span></p>\n<p>其中，<span\nclass=\"math inline\">\\(D=\\sqrt{(r_{xx}-r_{yy})^2+4r_{xy}^2}\\)</span>.</p>\n<p>对于方程（2）中的 X-Corner，对应的 Hessian 矩阵的最大特征值 <span\nclass=\"math inline\">\\(\\lambda_1\\)</span> 是正的，最小特征值 <span\nclass=\"math inline\">\\(\\lambda_2\\)</span>\n是负的，因此我们可以得到一个新的简单算子来检测x角点的像素位置： <span\nclass=\"math display\">\\[\nS=\\lambda_1\\cdot\\lambda_2=r_{xx}r_{yy}-r_{xy}^2.\n\\]</span> 待检测角是 <span class=\"math inline\">\\(S\\)</span>\n的局部负极值点. 基于这个约束，我们可以确定 X-Corner 的像素位置 <span\nclass=\"math inline\">\\((x_0,y_0)\\)</span>.</p>\n<p><strong>亚像素检测：</strong></p>\n<p>很明显，X-Corner 真正的亚像素位置必须位于 <span\nclass=\"math inline\">\\((x_0,y_0)\\)</span> 附近。我们假设它的实际位置是\n<span class=\"math inline\">\\((x_0+s,y_0+t)\\)</span>. <span\nclass=\"math inline\">\\((s,t)\\in[-0.5,0.5]\\times[-0.5,0.5]\\)</span>.\n对于每个\nX-Corner，我们可以使用第二个泰勒多项式来描述它周围的局部强度分布： <span\nclass=\"math display\">\\[\nr(x_0+s,y_0+t)=r+\\begin{pmatrix}s&amp;t\\end{pmatrix}\\begin{pmatrix}r_x\\\\r_y\\end{pmatrix}\n+\\frac{1}{2}\\begin{pmatrix}s&amp;t\\end{pmatrix}\\begin{pmatrix}r_{xx}&amp;r_{xy}\\\\r_{xy}&amp;r_{yy}\\end{pmatrix}\\begin{pmatrix}s\\\\t\\end{pmatrix}\n\\quad (3)\n\\]</span> <span class=\"math inline\">\\(r\\)</span> 是图像函数 <span\nclass=\"math inline\">\\(r(x,y)\\)</span> 在点 <span\nclass=\"math inline\">\\((x_0,y_0)\\)</span> 的值. <span\nclass=\"math inline\">\\(r_x,r_y\\)</span> 是 <span\nclass=\"math inline\">\\(r(x,y)\\)</span> 在点 <span\nclass=\"math inline\">\\((x_0,y_0)\\)</span> 的一阶偏导，<span\nclass=\"math inline\">\\(r_{xx},r_{xy},r_{yy}\\)</span> 是 <span\nclass=\"math inline\">\\(r(x,y)\\)</span> 在点 <span\nclass=\"math inline\">\\((x_0,y_0)\\)</span> 的二阶偏导.</p>\n<p>如上所述，X-Corner 就是强度剖面的鞍点. 我们可以将 式（3）沿 <span\nclass=\"math inline\">\\(s\\)</span> 和 <span\nclass=\"math inline\">\\(t\\)</span> 的一阶导数设为0： <span\nclass=\"math display\">\\[\n\\begin{cases}\nr_{xx}s+r_{xy}t+r_x=0\\\\\nr_{xy}s+r_{yy}t+r_y=0\n\\end{cases}\n\\]</span> 然后我们就可以得到亚像素的位置 <span\nclass=\"math inline\">\\((x_0+s,y_0+t)\\)</span>： <span\nclass=\"math display\">\\[\ns=\\frac{r_yr_{xy}-r_xr_{yy}}{r_{xx}r_{yy}-r_{xy}^2},t=\\frac{r_xr_{xy}-r_yr_{xx}}{r_{xx}r_{yy}-r_{xy}^2}.\n\\]</span> <strong>Detection of X-corners in Discrete\nSpace</strong>：</p>\n<p>对于离散图像，只需要做一个修改，即在离散空间中实现卷积。这里我们选择标准高斯核作为卷积掩码：\n<span class=\"math display\">\\[\ng(m,n)=\\frac{1}{2\\pi\\sigma^2}e^{-\\frac{m^2+n^2}{2\\sigma^2}}\n\\]</span> 掩码的维度为 <span\nclass=\"math inline\">\\((2N+1)\\times(2N+1)\\)</span>，其中 <span\nclass=\"math inline\">\\(N\\)</span> 为 <span\nclass=\"math inline\">\\(4[\\sigma]\\)</span>.\n然后将离散图像与相应的微分核进行卷积，得到离散图像的偏导数。</p>\n<h3 id=\"图像求导问题\">图像求导问题</h3>\n<h4 id=\"一阶导数\">一阶导数</h4>\n<p>导数的的定义： <span class=\"math display\">\\[\nf&#39;(x)=\\lim\\limits_{\\Delta x\\rightarrow0}\\frac{f(x+\\Delta\nx)-f(x)}{\\Delta x}\\qquad (1)\n\\]</span> 由于图像的像素是离散的，所以通常采用差分的形式，取 $x=1\n$，在图像中 <span class=\"math inline\">\\((x,y)\\)</span> 处的方向导数为：\n<span class=\"math display\">\\[\n\\frac{\\partial f}{\\partial x}=f(x+1,y)-f(x,y) \\qquad (2)\n\\]</span></p>\n<p>关于差分： <span class=\"math display\">\\[\n\\begin{align*}\n&amp;向前差分：f&#39;(x)\\approx\\frac{f(x+h)-f(x)}{h}\\\\\n&amp;向后差分：f&#39;(x)\\approx\\frac{f(x)-f(x-h)}{h} \\\\\n&amp;中心差分：f&#39;(x)\\approx\\frac{f(x+0.5h)-f(x-0.5)}{h}\n\\end{align*}\n\\]</span></p>\n<p>Sobel 算子计算梯度的方式略有不同.</p>\n<p><img src=\"/img/X-Corners/sobel.png\" /></p>\n<p>根据式（2）计算 <span class=\"math inline\">\\(P\\)</span>\n点处的方向导数为： <span class=\"math display\">\\[\nP&#39;_x=D-P,\\quad P&#39;_y = F-P\n\\]</span> <img src=\"/img/X-Corners/diff.png\" /></p>\n<p>对于 sobel 算子为： <span class=\"math display\">\\[\n\\begin{align*}\nP&#39;_x=2*D+C+E-2*H-A-G,\\\\\nP&#39;_y=2*F+G+E-2*B-A-C.\n\\end{align*}\n\\]</span> <img src=\"/img/X-Corners/sobel1.png\" /></p>\n<p>使用 sobel 算子计算 <span class=\"math inline\">\\(P\\)</span>\n点的梯度有： <span class=\"math display\">\\[\ngrad(f)=\\vert P&#39;_x\\vert+\\vert P&#39;_y\\vert\n\\]</span> 对角线方向导数有： <span class=\"math display\">\\[\n\\begin{align*}\nP&#39;_{xy} = 2*G+H+F-2*C-B-D\\\\\nP&#39;_{yx} = 2*E+F+D-2*A-H-B\n\\end{align*}\n\\]</span> <img src=\"/img/X-Corners/sobel2.png\" /></p>\n<h4 id=\"二阶导数\">二阶导数</h4>\n<p>数学定义为： <span class=\"math display\">\\[\nf&#39;&#39;(x)=\\lim\\limits_{\\Delta x\\rightarrow0}\\frac{f&#39;(x+\\Delta\nx)-f&#39;(x)}{\\Delta x} \\qquad (3)\n\\]</span> 向前差分： <span class=\"math display\">\\[\n\\frac{\\partial^2f(x,y)}{\\partial\nx^2}=f&#39;_x(x+1,y)-f&#39;_x(x,y)\\qquad (4)\n\\]</span> 由 <span\nclass=\"math inline\">\\(f&#39;_x(x,y)=f(x+1,y)-f(x,y)\\)</span>，<span\nclass=\"math inline\">\\(f&#39;_x(x+1,y)=f(x+2,y)-f(x+1,y)\\)</span> 得：\n<span class=\"math display\">\\[\n\\begin{align*}\n\\frac{\\partial^2f(x,y)}{\\partial\nx^2}&amp;=f(x+2,y)-f(x+1,y)-f(x+1,y)+f(x,y)\\\\\n&amp;=f(x+2,y)-2f(x+1,y)+f(x,y)\n\\end{align*}\n\\]</span> 向后差分： <span class=\"math display\">\\[\n\\begin{align*}\nf&#39;&#39;_{xx}(x,y)&amp;=f&#39;_x(x,y)-f&#39;_x(x-1,y)\\\\\n&amp;=f(x+1,y)-f(x,y)-f(x,y)-f(x-1,y)\\\\\n&amp;=f(x+1,y)-2f(x,y)-f(x-1,y)\n\\end{align*}\n\\]</span> 同理： <span class=\"math display\">\\[\nf&#39;&#39;_{yy}(x,y)=f(x,y+1)-2f(x,y)-f(x,y-1)\n\\]</span> 对于 <span\nclass=\"math inline\">\\(\\frac{\\partial^2f(x,y)}{\\partial x\\partial\ny}\\)</span> ，向后差分: <span class=\"math display\">\\[\n\\begin{align*}\n\\frac{\\partial^2f(x,y)}{\\partial x\\partial\ny}&amp;=\\frac{f&#39;_x(x,y)}{\\partial y}\\\\\n&amp;=f&#39;_x(x,y)-f&#39;_x(x,y-1)\\\\\n&amp;=f(x+1,y)-f(x,y)-[f(x+1,y-1)-f(x,y-1)]\\\\\n&amp;=f(x+1,y)-f(x+1,y-1)-f(x,y)+f(x,y-1)\n\\end{align*}\n\\]</span> 向后差分： <span class=\"math display\">\\[\n\\begin{align*}\n\\frac{\\partial^2f(x,y)}{\\partial x\\partial\ny}&amp;=\\frac{f&#39;_x(x,y)}{\\partial y}\\\\\n&amp;=f&#39;_x(x,y+1)-f&#39;_x(x,y)\\\\\n&amp;=f(x+1,y+1)-f(x,y+1)-[f(x+1,y)-f(x,y)]\\\\\n&amp;=f(x+1,y+1)-f(x,y+1)+f(x,y)-f(x+1,y)\n\\end{align*}\n\\]</span></p>\n<p><img src=\"/img/X-Corners/2-order-diff.png\" /></p>\n<h4 id=\"hessian-矩阵\">Hessian 矩阵</h4>\n<p><span class=\"math display\">\\[\n\\mathbf{Hessian} = \\begin{bmatrix}\nf&#39;&#39;_{xx}&amp;f&#39;&#39;_{xy}\\\\\nf&#39;&#39;_{yx}&amp;f&#39;&#39;_{yy}\n\\end{bmatrix}\n\\]</span></p>\n<p>二元函数泰勒公式的近似表达式： <span class=\"math display\">\\[\nf(x,y)=f(x_0,y_0)+\\begin{pmatrix}dx&amp;dy\\end{pmatrix}\\begin{pmatrix}f&#39;_x\\\\f&#39;_y\\end{pmatrix}+\\frac{1}{2}\\begin{pmatrix}dx&amp;dy\\end{pmatrix}\\begin{pmatrix}f&#39;&#39;_{xx}&amp;f&#39;&#39;_{xy}\\\\f&#39;&#39;_{yx}&amp;f&#39;&#39;_{yy}\\end{pmatrix}\\begin{pmatrix}dx\\\\dy\\end{pmatrix}\n\\]</span> 其极值情况可由 <span\nclass=\"math inline\">\\(\\mathbf{Hessian}\\)</span> 矩阵来判定，令 <span\nclass=\"math inline\">\\(\\Delta\n\\mathbf{x}=\\begin{pmatrix}dx&amp;dy\\end{pmatrix}\\)</span>，<span\nclass=\"math inline\">\\(\\mathbf{H}=\\begin{pmatrix}f&#39;&#39;_{xx}&amp;f&#39;&#39;_{xy}\\\\f&#39;&#39;_{yx}&amp;f&#39;&#39;_{yy}\\end{pmatrix}\\)</span>.\n当 <span class=\"math inline\">\\((f&#39;_x,f&#39;_y)=0\\)</span>\n时，如果对于任意向量 <span\nclass=\"math inline\">\\(\\Delta\\mathbf{x}\\)</span>，都有 <span\nclass=\"math inline\">\\(\\Delta\\mathbf{x}\\mathbf{H}\\Delta\\mathbf{x}^T\\)</span>\n为正，那么 <span class=\"math inline\">\\(\\mathbf{H}\\)</span>\n为正定矩阵，函数具有局部极小值. 如果对于任意向量 <span\nclass=\"math inline\">\\(\\Delta\\mathbf{x}\\)</span>，都有 <span\nclass=\"math inline\">\\(\\Delta\\mathbf{x}\\mathbf{H}\\Delta\\mathbf{x}^T\\)</span>\n为负，那么 <span class=\"math inline\">\\(\\mathbf{H}\\)</span>\n为负定矩阵，函数具有局部极大值.</p>\n<p><font color='pink'>当 Hessian\n矩阵同时具有正负特征值时，该点为鞍点.</font></p>\n","text":"A New Sub-Pixel Detector for X-Corners in Camera Calibration Targets 基于海塞矩阵的方法 一个标准的 X-Corners 如下图所示： 其表达式为： \\[ f(x,y)=\\begin{cases} 0,&amp;...","link":"","photos":[],"count_time":{"symbolsCount":"5.6k","symbolsTime":"5 mins."},"categories":[{"name":"图像处理","slug":"图像处理","count":1,"path":"api/categories/图像处理.json"}],"tags":[{"name":"相机标定","slug":"相机标定","count":1,"path":"api/tags/相机标定.json"},{"name":"角点检测","slug":"角点检测","count":1,"path":"api/tags/角点检测.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#a-new-sub-pixel-detector-for-x-corners-in-camera-calibration-targets\"><span class=\"toc-text\">A\nNew Sub-Pixel Detector for X-Corners in Camera Calibration Targets</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9B%BE%E5%83%8F%E6%B1%82%E5%AF%BC%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">图像求导问题</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%B8%80%E9%98%B6%E5%AF%BC%E6%95%B0\"><span class=\"toc-text\">一阶导数</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E9%98%B6%E5%AF%BC%E6%95%B0\"><span class=\"toc-text\">二阶导数</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#hessian-%E7%9F%A9%E9%98%B5\"><span class=\"toc-text\">Hessian 矩阵</span></a></li></ol></li></ol></li></ol>","author":{"name":"爱慢跑的乌龟","slug":"blog-author","avatar":"/img/avatar1.jpg","link":"/","description":"求知若饥，虚心若愚！","socials":{"github":"https://github.com/ansonxu1998","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Docker实战案例","uid":"7d5686ce3c9c17768b418785872c4c2b","slug":"Linux/Docker实战案例","date":"2022-06-30T07:13:00.000Z","updated":"2022-06-30T07:26:16.697Z","comments":true,"path":"api/articles/Linux/Docker实战案例.json","keywords":null,"cover":null,"text":"操作系统 BusyBox BusyBox 是一个集成了一百多个最常用 Linux 命令和工具（如cat、echo、grep、mount、telnet等）的精简工具箱，它只有几MB的大小，很方便进行各种快速验证，被誉为“Linux系统的瑞士军刀”。BusyBox 可运行于多款 PO...","link":"","photos":[],"count_time":{"symbolsCount":"17k","symbolsTime":"15 mins."},"categories":[{"name":"《Docker技术入门与实践》","slug":"《Docker技术入门与实践》","count":2,"path":"api/categories/《Docker技术入门与实践》.json"}],"tags":[{"name":"Docker","slug":"Docker","count":2,"path":"api/tags/Docker.json"}],"author":{"name":"爱慢跑的乌龟","slug":"blog-author","avatar":"/img/avatar1.jpg","link":"/","description":"求知若饥，虚心若愚！","socials":{"github":"https://github.com/ansonxu1998","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Docker 基础入门","uid":"e8df40174e1c8fdb0eda4ca741803291","slug":"Linux/Docker基础入门","date":"2022-06-24T06:44:00.000Z","updated":"2022-06-30T07:27:59.663Z","comments":true,"path":"api/articles/Linux/Docker基础入门.json","keywords":null,"cover":null,"text":"核心概念与安装配置 Docker 的三大核心概念： 镜像(Image) 容器(Container) 仓库(Repository) 核心概念 Docker 镜像 Docker 镜像可以将其理解为一个只读的模板。它是 docker 容器的基础。用户可以从网络上下载已经配置好的镜像，并...","link":"","photos":[],"count_time":{"symbolsCount":"16k","symbolsTime":"14 mins."},"categories":[{"name":"《Docker技术入门与实践》","slug":"《Docker技术入门与实践》","count":2,"path":"api/categories/《Docker技术入门与实践》.json"}],"tags":[{"name":"Docker","slug":"Docker","count":2,"path":"api/tags/Docker.json"}],"author":{"name":"爱慢跑的乌龟","slug":"blog-author","avatar":"/img/avatar1.jpg","link":"/","description":"求知若饥，虚心若愚！","socials":{"github":"https://github.com/ansonxu1998","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}