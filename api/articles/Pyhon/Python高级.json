{"title":"Python 高级应用","uid":"b3283c8479bedbfcba4845761e4e6510","slug":"Pyhon/Python高级","date":"2022-09-28T07:00:00.000Z","updated":"2023-08-19T06:41:45.390Z","comments":true,"path":"api/articles/Pyhon/Python高级.json","keywords":null,"cover":"/img/python/logo.png","content":"<h2 id=\"语法糖\">语法糖</h2>\n<p>语法糖(Syntactic suger)，也译为语法糖衣，是由英国计算机科学家Peter J.Landin发明的一个术语，指计算机语言中添加某种语法，这种语法对语言的功能并没有影响，但是更方便程序员使用。通常来说使用语法糖能够增加程序的可读性，从而减少代码出错的机会。就相当于汉语中的成语。用更简练的语言表达叫复杂的含义。在得到广泛流传的情况下，可以提升交流效率。</p>\n<hr />\n<p>1.对一个list排序，先按元素的一个属性排序，再按另一个属性排序。<br />\n如：一个学校的人站成一行，需要年级从小到大，并且每个年级中从矮到高排序。 <pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">[P1, P2, P3,...Pn].sort(key&#x3D;lambda x: (x.grade, X.height))</code></pre></p>\n<p>把需要排序的属性拿出来作为一个tuple，主要的放前面，次要的放后面。因为Python在比较tuple大小的时候正是按字典序进行的。如果需要对更多属性排序，继续添加进tuple即可。<br />\n扩展：<br />\n假设有一个list： <pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">list &#x3D; [1, -2, 10, -12, -4, -5, 9, 2]</code></pre></p>\n<p>依然是排序，目标是将正的放在前面，负的放在后面，并且分别按绝对值从小到大。即输出： <pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">[1, 2, 9, 10, -2, -4, -5, -12]</code></pre></p>\n<p>最简单的方法是： <pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">list.sort(key&#x3D;lambda x: (x&lt;0, abs(x)))</code></pre> -------- 2.对于列表形如list_1 = [[1, 2], [3, 4, 5], [6, 7], [8], [9]]转化成列表list_2 = [1, 2, 3, 4, 5, 6, 7, 8, 9]的问题。<br />\n(1) 一般方法<br />\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">list_1 &#x3D; [[1, 2], [3, 4, 5], [6, 7], [8], [9]]\nlist_2 &#x3D; []\nfor _ in list_1:\n\tlist_2 +&#x3D; _\nprint(list_2)</code></pre></p>\n<ol start=\"2\" type=\"1\">\n<li><p>更pythonic的方法，列表推导 <pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">list_1 &#x3D; [[1, 2], [3, 4, 5], [6, 7], [8], [9]]\n[i for k in list_1 for i in k]</code></pre></p></li>\n<li><p>抽象用法 <pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">list_1 &#x3D; [[1, 2], [3, 4, 5], [6, 7], [8], [9]]\nsum(list_1, [])</code></pre></p></li>\n</ol>\n<h2 id=\"装饰器\">装饰器</h2>\n<p>1.函数闭包(function closure) + 函数式语言(函数是一等公民，可作为变量使用)中的术语 + 函数闭包：一个函数，其参数和返回值都是函数 + 用于增强函数功能 + 面向切面编程(AOP) <pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\"># 闭包本质是一个函数\n# 闭包函数的传入参数和返回参数也是函数\n# 闭包函数的返回函数是对传入函数进行增强后的结果\ndef count_time_wrapper(func):\n\t&quot;&quot;&quot;\n\t闭包，用于增强函数func：给函数增强计时功能\n\t&quot;&quot;&quot;\n\tdef improved_func():\n\t\tstart_time &#x3D; time.clock()\n\t\tfunc()\n\t\tend_time &#x3D; time.clock()\n\t\tprint(&quot;it takes &#123;&#125; s to find all the odds&quot;.format(end_time - start_time))\n\treturn improved_func</code></pre> 闭包函数是显式增强</p>\n<table style=\"width:12%;\">\n<colgroup>\n<col style=\"width: 12%\" />\n</colgroup>\n<thead>\n<tr class=\"header\">\n<th>2.函数语法糖(Syntactic sugar) + 指计算机语言中添加的某种语法，这种语法<strong>对语言的功能没有影响</strong> ，但是<strong>方便程序员使用</strong>。 + 语法糖<strong>没有增加新功能</strong> ，只是一种更方便的写法。 + 语法糖<strong>可以完全等价地转换为</strong> 为原本非语法糖。 + 装饰器在第一次调用被装饰函数时进行增强 + 增强时机-&gt;在第一次调用之前 + 增强次数-&gt;只增强一次，之后为增强后的函数 Python装饰器是函数闭包的语法糖 <pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">def count_time_wrapper(func):\n\t&quot;&quot;&quot;\n\t闭包，用于增强函数func：给函数增加计时功能\n\t&quot;&quot;&quot;\n\tdef improved_func():\n\t\tstart_time &#x3D; time.clock()\n\t\tfunc()\n\t\tend_time &#x3D; time.clock()\n\t\tprint(&quot;it takes &#123;&#125; s to find all the odds.&quot;.format(end_time - start_time))\n\treturn improved_func\n\t\n@count_time_wrapper\ndef print_odds():\n\tfor i in range(100):\n\t\tif i % 2 &#x3D;&#x3D; 1:\n\t\t\tprint(i)\n\t\t\t\n&lt;++&gt;&#96;&#96;&#96;\n\n对于有返回值和参数的函数，调用闭包增强：\n\n​&#96;&#96;&#96;python\ndef count_time_wrapper(func):\n\t&quot;&quot;&quot;\n\t闭包，用于增强函数func：给函数增加计时功能\n\t&quot;&quot;&quot;\n\tdef improved_func(*args, **kwargs):\n\t\tstart_time &#x3D; time.clock()\n\t\tret &#x3D; func(*args, **kwargs)\n\t\tend_time &#x3D; time.clock()\n\t\tprint(&quot;it takes &#123;&#125; s to find all the odds.&quot;.format(end_time - start_time))\n\t\treturn ret\n\treturn improved_func\t\n\t\n@count_time_wrapper\ndef print_odds(lim):\n\tcnt &#x3D; 0 \n\tfor i in range(lim):\n\t\tif i % 2 &#x3D;&#x3D; 1:\n\t\t\tcnt +&#x3D; 1\n\treturn cnt\t\t</code></pre></th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>日志打印器： <pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\"># 装饰函数\ndef logger(func):\n\tdef wrapper(*args, **kw):\n\t\tprint(&#39;准备计算：&#123;&#125;函数了：&#39;.format(func.__name__))\n\t\tfunc(*args, **kw)\n\t\tprint(&#39;计算结束&#39;)\n\treturn wrapper\n\n@logger\ndef add(x, y):\n\tprint(&#39;&#123;&#125; + &#123;&#125; &#x3D; &#123;&#125;&#39;.format(x, y, x+y))\n\nadd(100, 50)</code></pre></td>\n</tr>\n<tr class=\"even\">\n<td>时间计时器： <pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">def timer(func):\n\tdef wrapper(*args, **kw):\n\t\tt1 &#x3D; time.time()\n\t\t# 业务函数\n\t\tfunc(*args, **kw)\n\t\tt2 &#x3D; time.time()\n\t\tcost_time &#x3D; t2 - t1\n\t\tprint(&#39;花费时间：&#123;&#125; s.&#39;.format(cost_time))\n\treturn wrapper\n\n@timer\ndef want_sleep(sleep_time):\n\ttime.sleep(sleep_time)\n\nwant_sleep(10)</code></pre></td>\n</tr>\n</tbody>\n</table>\n<p>进阶用法：带参数的函数装饰器<br />\n例子：<br />\n我们要执行一下两个函数时候，分别根据来说出一段打招呼的话<br />\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">def american():\n\tprint(&quot;I come from America&quot;)\n\ndef chinese():\n\tprint(&quot;我来自中国。&quot;)</code></pre></p>\n<p>添加装饰器： <pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">@say_hello(&quot;china&quot;)\ndef american():\n\tprint(&quot;我来自中国&quot;)\n\n@say_hello(&quot;america&quot;)\ndef chinese():\n\tprint(&quot;I come from America.&quot;)\n\t\ndef say_hello(contry):\n\tdef wrapper(func):\n\t\tdef deco(*args, **kw):\n\t\t\tif contry &#x3D;&#x3D; &quot;china&quot;:\n\t\t\t\tprint(&quot;你好！&quot;)\n\t\t\telif contry &#x3D;&#x3D; &quot;america&quot;:\n\t\t\t\tprint(&quot;hello&quot;)\n\t\t\telif:\n\t\t\t\treturn\n\t\t\tfunc(*args, **kw)\n\t\treturn deco\n\treturn wrapper</code></pre></p>\n<p><strong>需要一个外层函数来接受装饰器函数的参数</strong></p>\n<table style=\"width:12%;\">\n<colgroup>\n<col style=\"width: 12%\" />\n</colgroup>\n<thead>\n<tr class=\"header\">\n<th>高阶用法：不带参数的类装饰器 基于类装饰器的实现，必须实现<code>__call__</code> 和<code>__init__</code> 两个内置函数。 <code>__init__</code> :接收被装饰函数 <code>__call__</code> :实现装饰逻辑。 <pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">class logger(object):\n\tdef __inint__(self, func):\n\t\tself.func &#x3D; func\n\t\n\tdef __call__(self, *args, **kw):\n\t\tprint(&quot;[INFO]:the function &#123;func&#125;() is running...&quot;.format(func &#x3D; self.func.__name__))\n\t\treturn self.func(*args, **kw)\n\n@logger\ndef say(something):\n\tprint(&#39;say &#123;&#125;!&#39;.format(something))\n\nsay(&#39;hello&#39;)</code></pre></th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>带参数的类装饰器 上述例子只能打印<code>INFO</code> 级别的日志，正常情况下，我们还需要打印<code>DEBUG</code> <code>WARNING</code> 等级别的日志。 这就需要给类装饰器传入参数，给这个函数指定级别。 <strong>带参数和不带参数的类装饰器有很大的不同。</strong> <code>__init__</code> ：不再接收被装饰函数，而是接收传入参数。 <code>__call__</code> ：接收被装饰函数，实现装饰逻辑。 <pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">class logger(object):\n\tdef __init__(self, level&#x3D;&#39;INFO&#39;):\n\t\tself.level &#x3D; level\n\t\n\tdef __call__(self, func):\n\t\tdef wrapper(*args, **kw):\n\t\t\tprint(&quot;[&#123;level&#125;]:the function &#123;func&#125;() is running...&quot;.format(level&#x3D;self.level, func&#x3D;func.__name__))\n\t\t\tfunc(*args, **kw)\n\t\treturn wrapper\n\n\n@logger(level&#x3D;&#39;WARNING&#39;)\ndef say(something):\n\tprint(&#39;say &#123;&#125;!&#39;.format(something))\n\nsay(&#39;hello&#39;)</code></pre></td>\n</tr>\n</tbody>\n</table>\n<p>使用偏函数与类实现装饰器<br />\n绝大多数装饰器都是基于函数和闭包实现的，但这并非制造装饰器的唯一方式。<br />\nPython对某个对象是否通过装饰器(<code>@decorator</code> )形式使用只有一个要求：<strong>decorator必须是一个“可被调用(callable)的对象。</strong><br />\n函数是callable对象，类也是callable对象，只要实现了<code>__call__</code> 函数，还有比较少的人使用的偏函数也是callable对象。<br />\n如下：DelayFunc是一个实现了<code>__call__</code> 的类，delay返回一个偏函数，在这里delay就可以作为一个装饰器。 <pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">import time\nimport functools\n\nclass DelayFunc:\n\tdef __init__(self, duration, func):\n\t\tself.duration &#x3D; duration\n\t\tself.func &#x3D; func\n\t\t\n\tdef __call__(self, *args, **kw):\n\t\tprint(f&#39;Wait for &#123;self.duration&#125; seconds...&#39;)\n\t\ttime.sleep(self.duration)\n\t\treturn self.func(*args, **kw)\n\t\n\tdef eager_call(self, *args, **kw):\n\t\tprint(&#39;Call without delay&#39;)\n\t\treturn self.func(*args, **kw)\n\ndef delay(duration):\n\t&quot;&quot;&quot;\n\t装饰器：推迟某个函数的执行。  \n\t同时提供.eager_call 方法立即执行\n\t&quot;&quot;&quot;\n\t# 此处为了避免定义额外函数\n\t# 直接使用functools.partial 帮助构造 DelayFunc实例\n\treturn functools.partial(DelayFunc, duration)\n\n@delay(duration&#x3D;2)\ndef add(a, b):\n\treturn a+b</code></pre> -------- 装饰类的装饰器<br />\n用Python写单例模式的时候，常用的有三种写法。其中一种，是用装饰器来实现。<br />\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">instances &#x3D; []\n\ndef singleton(cls):\n\tdef get_instance(*args, **kw):\n\t\tcls_mane &#x3D; cls.__name__\n\t\tprint(&#39;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;1&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#39;)\n\t\tif not cls_name in instances:\n\t\t\tprint(&#39;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;2&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#39;)\n\t\t\tinstance &#x3D; cls(*args, **kw)\n\t\t\tinstances[cls_name] &#x3D; instance\n\t\treturn instances[cls_name]\n\treturn get_instance\n\n@singleton\nclass User:\n\t_instance &#x3D; None\n\t\n\tdef __init__(self, name):\n\t\tprint(&#39;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;3&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#39;)\n\t\tself.name &#x3D; name</code></pre></p>\n<table style=\"width:12%;\">\n<colgroup>\n<col style=\"width: 12%\" />\n</colgroup>\n<tbody>\n<tr class=\"odd\">\n<td>wraps装饰器 在functools标准库中提供了一个wraps装饰器 <pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">def wrapper(func):\n\tdef innner_function():\n\t\tpass\n\treturn inner_function\n\n@wrapeer\ndef wrapped():\n\tpass\n\nprint(wrapped.__name__)\n# inner_function</code></pre></td>\n</tr>\n<tr class=\"even\">\n<td>上边执行<code>func</code> 和下边<code>decorator(func)</code> 是等价的，所以上面<code>func.__name__</code> 是等价于下面<code>decorator</code> 的，当然名字是<code>inner_function</code> <pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">def wrapper(func):\n\tdef inner_function():\n\t\tpass\n\treturn inner_function\n\ndef wrapped():\n\tpass\n\nprint(wrapper(wrapped).__name__)\n# inner_function</code></pre></td>\n</tr>\n<tr class=\"odd\">\n<td>为了避免这种情况的产生，使用functools.wraps装饰器，它的作用是<strong>将被装饰的函数(wrapped)</strong> 的一些属性赋值给<strong>修饰器函数(wrapper)</strong> ，最终让属性显示更符合我们的直觉。 <pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">from functools import update_wrapper\nWRAPPER_ASSIGNMENTS &#x3D; (&#39;__moudle__&#39;, &#39;__name__&#39;, &#39;__qualname__&#39;, &#39;__doc__&#39;, &#39;__annotations__&#39;)\n\ndef wrapper(func):\n\tdef inner_function():\n\t\tpass\n\tupdate_wrapper(inner_function, func, assigned&#x3D;WRAPPER_ASSIGNMENTS)\\\n\treturn inner_function\n\n@wrapper\ndef wrapped():\n\tpass\n\nprint(wrapped.__name__)</code></pre></td>\n</tr>\n</tbody>\n</table>\n<p>内置装饰器：property<br />\n它通常存在于类中，可以将一个函数定义成一个属性，属性的值就是该函数return的内容。<br />\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">class Student(object):\n\tdef __init__(self, name, age&#x3D;None):\n\t\tself.name &#x3D; name\n\t\tself.age - age\n\n# 实例化\nXiaoMing &#x3D; Student(&quot;小明&quot;)\n\n# 添加属性\nXiaoMing.age &#x3D; 25\n\n# 查询属性\nXiaoMing.age\n\n# 删除属性\ndel XiaoMing.age</code></pre></p>\n<p>这样做会直接将属性暴露出去，不能限制属性值的合法性。<br />\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">class Student(object):\n\tdef __init__(self, name):\n\t\tself.name &#x3D; name\n\t\tself.name &#x3D; None\n\t\n\tdef set_age(self, age):\n\t\tif not isinstance(age, int):\n\t\t\traise ValueError(&quot;输入不合法：年龄必须是数值&quot;)\n\t\tif not 0 &lt; age &lt; 100:\n\t\t\traise ValueError(&quot;输入不合法：年龄范围必须0-100&quot;)\n\t\tself._age &#x3D; age\n\t\n\tdef get_age(self):\n\t\treturn self._age\n\t\n\tdef del_age(self):\n\t\tself._age &#x3D; None\n\nXiaoMing &#x3D; Student(&quot;小明&quot;)\n\n# 添加属性\nXiaoMing.set_age(25)\n\n# 查询属性\nXiaoMing.get_age()\n\n# 删除属性\nXiaoMing.del_age()\n</code></pre> 上面的代码设计虽然可以变量的定义，但是可以发现不管是获取还是赋值（通过函数）都和我们平时见到的不一样。 按照我们思维习惯应该是这样的:<br />\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\"># 赋值\nXiaoMing.age &#x3D; 24\n\n# 获取\nXiaoMing.age</code></pre></p>\n<p>这样的设计可以通过下面的代码来实现：<br />\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">class Student(object):\n    def __init__(self, name):\n        self.name &#x3D; name\n        self.name &#x3D; None\n\n    @property\n    def age(self):\n        return self._age\n\n    @age.setter\n    def age(self, value):\n        if not isinstance(value, int):\n            raise ValueError(&#39;输入不合法：年龄必须为数值!&#39;)\n        if not 0 &lt; value &lt; 100:\n            raise ValueError(&#39;输入不合法：年龄范围必须0-100&#39;)\n        self._age&#x3D;value\n\n    @age.deleter\n    def age(self):\n        del self._age\n\nXiaoMing &#x3D; Student(&quot;小明&quot;)\n\n# 设置属性\nXiaoMing.age &#x3D; 25\n\n# 查询属性\nXiaoMing.age\n\n# 删除属性\ndel XiaoMing.age</code></pre></p>\n<h2 id=\"typing\">typing</h2>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>Python 运行时不强制执行函数和变量类型的注解，但这些注解可用于类型检测器、IDE、静态检查器等第三方工具。</p></blockquote>\n<p>此模块为类型提示提供运行时支持。最基本的支持包括 <code>Any</code>、<code>Union</code>、<code>Callable</code>、<code>TypeVar</code> 和 <code>Generic</code> 类型。有关完整的规范，请参阅<a href=\"https://www.python.org/dev/peps/pep-0484\"><strong>PEP 484</strong></a>。有关类型提示的简化介绍，请参见<a href=\"https://www.python.org/dev/peps/pep-0483\"><strong>PEP 483</strong></a>。</p>\n<p>类型注解方式：</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">def greeting(name: str) --&gt; str:\n    return &#39;Hello&#39; + name</code></pre>\n<p><code>greeting</code> 函数中，参数 <code>name</code> 的类型是 str, 返回类型也是 str。</p>\n<h3 id=\"类型别名\">类型别名</h3>\n<p>把类型赋给别名，就可以定义类型的别名。本例中 <code>Vector</code> 和 <code>list[float]</code> 相同，可互换：</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">Vector &#x3D; list[float]\ndef scale(scalar: float, vector: Vector) -&gt; Vector:\n    return [scalar * num for num in vector]\n\nnew_vector &#x3D; scale(2.0, [1.0, -4.2, 5.4])</code></pre>\n<p>类型别名适用于简化类型签名。例如：</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">from collections.abc import  Sequence\n\nConnectionOptions &#x3D; dict[str, str]\nAddress &#x3D; tuple[str, int]\nServer &#x3D; tuple[Address, ConnectionOptions]\n\ndef broadcast_message(message: str, servers: Sequence[Server]) -&gt; None:</code></pre>\n<h3 id=\"newtype\">NewType</h3>\n<p>使用 <code>NewType</code> 辅助类来创建不同的类型</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">from typing import NewType\n\nUserID &#x3D; NewType(&#39;UserId&#39;, int)\nsome_id &#x3D; UserId(524213)</code></pre>\n<p>静态类型检查器把新类型当作原始类型的子类，这种方式适用于捕捉逻辑错误。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>注意，这些检查只由静态类型检查器强制执行。在运行时，语句 <code>Derived = NewType('Derived', Base)</code> 将产生一个 <code>Derived</code> 类，该类立即返回你传递给它的任何参数。 这意味着语句 <code>Derived(some_value)</code> 不会创建一个新的类，也不会引入超出常规函数调用的很多开销。</p></blockquote>\n<h3 id=\"可调对象callable\">可调对象(Callable)</h3>\n<p>预期特定签名回调函数的框架可以用<code>Callable[[Arg1Type, Arg2Type], ReturnType]</code> 实现类型提示。</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">from collections.abc import Callable\n\ndef feeder(get_next_item: Callable[[], str]) -&gt; None:\n    # Body\ndef async_query(on_success: Callable[[int, Exception], None]，\n               on_error:Callable[[int, Exception], None]) -&gt; None:\n    # Body</code></pre>\n<p>无需指定调用签名，用省略号字面量替换类型提示里的参数列表：<code>Callable[..., ReturnType]</code>，就可以声明可调对象的返回类型。</p>\n<p>以其他可调用对象为参数的可调用对象可以使用 <code>ParamSpec</code> 来表明其参数类型是相互依赖的。此外，如果该可调用对象增加或删除了其他可调用对象的参数，可以使用 <code>Concatenate</code> 操作符。它们分别采取<code>Callable[ParamSpecVariable, ReturnType]</code> 和 <code>Callable[Concatenate[Arg1Type, Arg2Type, ..., ParamSpecVariable], ReturnType]</code> 的形式</p>\n","text":"语法糖 语法糖(Syntactic suger)，也译为语法糖衣，是由英国计算机科学家Peter J.Landin发明的一个术语，指计算机语言中添加某种语法，这种语法对语言的功能并没有影响，但是更方便程序员使用。通常来说使用语法糖能够增加程序的可读性，从而减少代码出错的机会。就相...","link":"","photos":[],"count_time":{"symbolsCount":"11k","symbolsTime":"10 mins."},"categories":[{"name":"Python","slug":"Python","count":5,"path":"api/categories/Python.json"}],"tags":[{"name":"Python tips","slug":"Python-tips","count":5,"path":"api/tags/Python-tips.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%AF%AD%E6%B3%95%E7%B3%96\"><span class=\"toc-text\">语法糖</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%A3%85%E9%A5%B0%E5%99%A8\"><span class=\"toc-text\">装饰器</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#typing\"><span class=\"toc-text\">typing</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D\"><span class=\"toc-text\">类型别名</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#newtype\"><span class=\"toc-text\">NewType</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8F%AF%E8%B0%83%E5%AF%B9%E8%B1%A1callable\"><span class=\"toc-text\">可调对象(Callable)</span></a></li></ol></li></ol>","author":{"name":"爱慢跑的乌龟","slug":"blog-author","avatar":"/img/avatar1.jpg","link":"/","description":"求知若饥，虚心若愚！","socials":{"github":"https://github.com/ansonxu1998","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Amesim 与 Simulink 的联合仿真","uid":"51d61b1e82665e319117cf3815ca2bc7","slug":"Amesim/Amesim与Simulink联合仿真","date":"2022-09-28T07:12:00.000Z","updated":"2023-04-15T03:27:40.237Z","comments":true,"path":"api/articles/Amesim/Amesim与Simulink联合仿真.json","keywords":null,"cover":"/img/Amesim/AMESim.png","text":"Amesim 与 Simulink 的联合仿真 环境配置 软件版本为：Matlab 2020b 和 Amesim 2021.1，编译器使用 MinGW-w64 附件安装： 首先需要在 Matlab 中安装附件 MATLAB Support for MinGW-w64 C/C++ ...","link":"","photos":[],"count_time":{"symbolsCount":"4k","symbolsTime":"4 mins."},"categories":[{"name":"Amesim","slug":"Amesim","count":1,"path":"api/categories/Amesim.json"}],"tags":[{"name":"Amesim","slug":"Amesim","count":1,"path":"api/tags/Amesim.json"},{"name":"Simulink","slug":"Simulink","count":1,"path":"api/tags/Simulink.json"}],"author":{"name":"爱慢跑的乌龟","slug":"blog-author","avatar":"/img/avatar1.jpg","link":"/","description":"求知若饥，虚心若愚！","socials":{"github":"https://github.com/ansonxu1998","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Python 的深拷贝和浅拷贝","uid":"5badb916fa8f30fce64229fc7b4b0982","slug":"Pyhon/深拷贝与浅拷贝","date":"2022-09-27T11:01:00.000Z","updated":"2023-05-05T08:22:12.120Z","comments":true,"path":"api/articles/Pyhon/深拷贝与浅拷贝.json","keywords":null,"cover":"/img/python/logo.png","text":"Python 的深拷贝和浅拷贝 a &#x3D; [1, 2, 3, [1, 2, 3, [4, 5]]] b &#x3D; a 当使用赋值运算符 =，a 和 b 两个变量指向的同一个地址： a &#x3D; [1, 2, 3, [1, 2, 3, [4, 5]]] c &#x3...","link":"","photos":[],"count_time":{"symbolsCount":431,"symbolsTime":"1 mins."},"categories":[{"name":"Python","slug":"Python","count":5,"path":"api/categories/Python.json"}],"tags":[{"name":"Python tips","slug":"Python-tips","count":5,"path":"api/tags/Python-tips.json"}],"author":{"name":"爱慢跑的乌龟","slug":"blog-author","avatar":"/img/avatar1.jpg","link":"/","description":"求知若饥，虚心若愚！","socials":{"github":"https://github.com/ansonxu1998","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}