[{"id":"01ed63026d9bc8723f828c17bac96fdf","title":"FreeRTOS 的任务 (Task)","content":"FreeRTOS 的任务 (Task)\n\nFreeRTOS 是由 Real Time Engineers 公司独家拥有、开发和维护的。Real\nTime Engineers\n公司已经与世界领先的芯片公司密切合作了十多年，为您提供屡获殊荣的商业级和完全免费的高质量软件。\nFreeRTOS\n非常适合使用微控制器或小型微处理器的深度嵌入式实时应用程序。这种类型的应用程序通常包括硬实时和软实时需求的混合。\n\n\n\n\n\n\n\n\n\n\nFreeRTOS 的官网\n官方文档下载地址\nFreeRTOS 的基本概念\nFreeRTOS 的核心文件\n最核心的文件有两个：\n\nFreeRTOS/Source/task.c\nFreeRTOS/Source/list.c\n\n\n\n\n核心文件\n作用\n\n\n\n\ntask.c\n必需，用于实现任务操作\n\n\nlist.c\n必需，用于实现列表\n\n\nqueue.c\n必需，队列用于实现任务间的数据传递\n\n\ntimer.c\n可选，实现软件定时器\n\n\nevent_groups.c\n可选，提供事件组功能\n\n\ncroutine.c\n可选，弃用\n\n\n\n移植时涉及的文件\nFreeRTOS 移植时需要使用的文件位于\nFreeRTOS/Source/portable/[compiler]/[architecture]\n目录中。例如：RVDS/ARM_CM3，表示 cortex M3 架构在 RVDS 或\nKeil 工具上的移植文件，内有 2 个文件：\n\nport.c\nportmacro.h\n\n头文件目录\nFreeRTOS 需要 3 个头文件目录：\n\nFreeRTOS 核心代码的头文件：FreeRTOS/Source/include\n移植使用的头文件：FreeRTOS/Source/portable/[compiler]/[architecture]\n相关功能配置的文件：FreeRTOSConfig.h\n\n头文件的作用：\n\n\n\n\n\n\n\n头文件\n作用\n\n\n\n\nFreeRTOSConfig.h\nFreeRTOS\n的配置文件，相关算法的选择。特定功能函数的开关，使用什么函数就编译什么函数\n\n\nFreeRTOS.h\n使用 FreeRTOS 的 API 函数时必须包含该头文件。在\nFreeRTOS.h\n文件之后，再包含其它头文件，如：task.h\n、queue.h 等\n\n\n\n内存管理\nFreeRTOS 的内存管理文件位于\nFreeRTOS/Source/portable/MemMang 文件夹中，它放在\nportable 文件夹下，表示可以提供自己的函数。文件中有 5\n个源代码文件，对应 5 中内存管理的方法。\n\n\n\n\n\n\n\n\n文件\n优点\n缺点\n\n\n\n\nheap_1.c\n分配简单，时间确定\n只分配，不回收\n\n\nheap_2.c\n动态分配、最佳匹配\n碎片，时间不定\n\n\nheap_3.c\n调用标准库函数\n速度慢，时间不定\n\n\nheap_4.c\n相邻空闲内存可合并\n可解决碎片问题，时间不定\n\n\nheap_5.c\n再 heap_4 基础上支持分割的内存块\n可解决碎片问题，时间不定\n\n\n\n数据类型和编程规范\n数据类型\n每个移植版本都含有自己的 pormacro.h 头文件，里面定义了 2\n个数据类型：\n\nTickType_t:\n\nFreeRTOS 配置了一个周期性时钟中断：Tick Interrupt\n每次发生一次中断，中断次数累加，这被称为 tick count\ntick count 这个变量的类型就是 TickType_t\nTickType_t 可以是 16 位的，也可以是 32 位的\nFreeRTOSConfig.h 中定义 configUSE_16_BIT_TICKS\n时，TickType_t 就是 uint16_t\n否则 TickType_t 就是 uint32_t\n对于 32 位结构，建议把 TickType_t 配置为 uint32_t\n\nBaseType_t:\n\n这是该架构最高效的数据类型\n32 位架构中， 为 uint32_t 类型\n16 位架构中，为 uint16_t 类型\n8 位架构中，为 uint8_t 类型\nBaseType_t 通常用作简单的返回值的类型，还有逻辑值，如\npdTRUE/pdFALSE\n\n\n变量名\n\nuint32_t 类型变量以 ul 为前缀，其中 \"u\" 表示\n\"unsigned\"，\"l\" 表示 \"long\"\nuint16_t 类型变量以 us 为前缀，其中 \"u\" 表示\n\"unsigned\"，\"s\" 表示 \"short\"\nuint8_t 类型变量以 uc 为前缀，其中 \"u\" 表示\n\"unsigned\"，\"c\" 表示 \"char\"\n非 stdint 类型的变量 以 x 为前缀，例如：BaseType_t 和\nTickType_t\n非 stdint 类型的 unsigned 变量附加前缀 u。例如：UBaseType_t\n类型变量 以 ux 为前缀\nsize_t 类型变量也带有 x 前缀\n枚举变量以 e 为前缀\n指针以附加 p 为前缀，例如：指向 uint16_t 的指针以\npus 为前缀\n根据 MISRA 指南，未限定标准 char 类型仅包含 ASCII\n字符，并以 c 为前缀\n根据 MISRA 指南，char 类型变量仅可包含指向 ASCII\n字符串的指针，并以 pc 为前缀\n\n函数\n\n文件作用域静态（私有）函数以 prv 为前缀\n根据变量定义的相关规定，API 函数以其返回类型为前缀，并未\nvoid 添加前缀 v\nAPI 函数名称以定义 API 函数文件的名称开头。例如，在\ntasks.c 中定义 vTaskDelete，并且具有 void\n返回类型\n\n宏\n\n宏以定义宏的文件为前缀。前缀为小写。例如，在\nFreeRTOSConfig.h 中定义 configUSE_PREEMPTION\n除前缀外，所有宏均使用大写字母书写，并使用下划线来分隔单词\n\n任务 Task\n使用 RTOS\n的实时应用程序可以被构建为一组独立的任务。每个任务在自己的上下文中执行，不依赖于系统内的其它任务或\nRTOS 调度器本身。在任何时间点，应用程序中只能执行一个任务，实时 RTOS\n调度器负责决定所要执行的任务。因此，RTOS\n调度器可以在应用程序执行时重复启停每个任务（将任务调入或调出）。由于任务不了解\nRTOS 调度器活动，因此实时 RTOS\n调度器负责确保任务调入时的处理器上下文（寄存器值、堆栈内容等）与任务调出时的处理器上下文完全相同。为实现这一点，每个任务都分配了自己的栈。\n任务的状态\n任务可以运行在以下 4 种状态之一：\n\n运行状态\n当任务被执行时，它将处于运行状态。任务将占用处理器。如何处理器只有一个内核，那么同一时间只能有一个任务被处理器执行，即只有一个任务能处于运行状态。\n就绪状态\n处于就绪状态的任务能够被处理器执行，它们没有处于阻塞或挂起状态，但是由于具有同等优先级或更高优先级的任务正在被执行，无法占用处理器，需要等待被执行。\n阻塞状态\n如果任务正在等待时间或外部事件，则该任务被认为处于阻塞状态。任务可以被延时函数阻塞，抑或是等待队列、信号量、事件组或通知等。处于阻塞状态的任务通常有一个“超时”期，超时后任务将被解除阻塞，即使该任务所等待的事件没有发生。\n阻塞状态下的任务不使用任何处理时间，不能进入运行状态\n挂起状态\n处于挂起状态的任务不能被选择进入运行状态，但是挂起状态不存在超时。任务只能被别通过\nvTaskSuspend() 和 vTaskResume() API\n调用时，才会进入或退出挂起状态。\n\n\n任务优先级\n每个任务都具有一个优先级，优先级的大小在 0 到\n(configMAX_PRIORITIES -1)\n之间，configMAX_PRRIORITIES 在\nFreeRTOSConfig.h 文件中被定义。\n如果正在使用的端口实现了端口优化的任务选择机制，该机制使用“前导零计数”类指令（用于单个指令中的任务选择）且在\nFreeRTOSConfig.h 中将\nconfigUSE_PORT_OPTIMISED_TASK_SELECTION 设置为 1， 则\nconfigMAX_PRIORITIES 不得大于\n32。在所有其它情况下，configMAX_PRIORITIES\n可以设置任何合理范围内的值，但是考虑到 RAM\n使用效率，应保持在实际需求的最小值。\n低优先级数字表示低优先任务。空闲任务的优先级为零(tskIDLE_PRIORIEY)。\nFreeRTOS\n的调度器会确保处于运行状态的任务是当前可运行任务中最高优先级的。\n任意数量的任务可使用相同的优先级。如果\nconfigUSE_TIME_SLICING 未定义，或者\nconfigUSE_TIME_SLICING 设置为\n1，则相同优先级的就绪状态任务将使用时间片轮询调度方案共享可用的处理时间。\n任务调度\n默认的 RTOS 调度策略（单核）\nFreeRTOS\n默认使用固定优先级的抢占式调度策略，对同等优先级的任务执行时间片轮询调度：\n\n“固定优先级”\n是指调度器不会永久更改任务优先级，尽管它可能会有因为优先级继承而暂时提高任务的优先级。\n“抢占式调度” 是指调度器始终运行优先级最高且可运行的 RTOS\n任务，无论任务何时能够运行。例如，如果中断服务程序 (ISR)\n更改了优先级最高且可运行的任务，调度器会停止当前正在运行的低优先级任务，并启动高优先级任务——即使这发生在同一个时间片内。此时，称为高优先级任务“抢占”了低优先级的任务。\n“轮询调度” 是指具有相同优先级的任务轮流进入运行状态。\n“时间片” 是指调度器会在每个 tick\n中断上在同等优先级的任务之间进行切换，tick\n中断之间的时间构成一个时间片。tick 中断是 RTOS\n用来衡量时间的周期性中断。\n\n使用优先排序的抢占式调度器，避免任务饥饿\n如果总是运行优先级最高的任务，可能会造成这样的后果，永远不会进入“阻塞”或“挂起”状态的高优先级任务让所有任意执行时长的低优先级任务永久饥饿。这就是为什么通常最好创建事件驱动型任务的原因之一。例如，如果一个高优先级的正在等待一个事件，那么它就不应该处于事件的循环（轮询）中，因为如果处于轮询中，它会一直运行，永远不进入“阻塞”或“挂起”状态。反之，该任务应进入“阻塞”状态来等大事件。可以使用众多的\nFreeRTOS\n任务间通信将事件发送给任务。接收到事件后，优先级更高的任务会自动解除“阻塞”状态。高优先级任务处于“阻塞”状态时，低优先级任务会运行。\n配置 RTOS 调度策略\n以下 FreeRTOSConfig.h 配置更改默认的调度行为：\n\nconfigUSE_PREEMPTION\n如果 configUSE_PREEMPTION 设置为\n0，则关闭“抢占”，只有当运行状态的任务进入“阻塞”或“挂起”状态，或运行状态任务调用\ntaskYIELD()，或中断服务程序(ISR)手动请求上下文切换时，才会发生上下文切换。\nconfigUSE_TIME_SLICING 设置为\n0，则表示时间片已关闭。因此调度器不会在每个 tick\n中断上在同等优先级的任务之间切换。\n\nFreeRTOS AMP 调度策略\n使用 FreeRTOS 的非对称多处理(AMP)\n是指多核设备的每个核心都单独运行自己的 FreeRTOS\n实例。这些核心并不都需要具有相同的架构，但如果 FreeRTOS\n实例之间需要进行通信，则需要共享一些内存。\n每个核心都会运行自己的 FreeRTOS\n实例，因此任何给定核心上的调度算法与单核系统调度算法完全相同。可以使用流缓冲区或消息缓冲区作为核间通信原语。\nFreeRTOS SMP 调度策略\n使用 FreeRTOS 的对称多处理(SMP) 是指一个 FreeRTOS\n实例可以跨多个处理器核心调度 RTOS 任务。由于只有一个FreeRTOS\n实例在运行，一次只能使用 FreeRTOS\n的一个端口，因此每个核心必须具有相同的处理器架构并共用相同的内存空间。\nFreeRTOS SMP 调度策略使用与单核调度策略相同的算法，但与单核和 AMP\n场景不同的是，SMP\n在任何给定时间都会导致多个任务处于运行状态（每个核心上都有一个运行状态的任务）这意味着，只有缺乏可运行的高优先级任务时，才会运行低优先级任务的假设不再成立。\n配置 SMP RTSO 调度策略\n以下配置选项有助于移动下述代码：将为单核或 AMP RTOS\n配置编写的代码移动到 SMP RTOS\n配置中，且这些代码依赖于该假设——如果有一个运行的高优先级任务，那么低优先级任务不会运行：\n\nconfigRUN_MULTIPLE_PRIORITIES\n如果将 configRUN_MULTIPLE_PRIORITIES 设置为\n0，则调度器只会同时运行具有相同优先级的多个任务。这可能会修复基于”一次只运行一个任务“这一假设编写的代码，但这就享受到\nSMP 配置带来的一些好处。\nconfigUSE_CORE_AFFINITY\n\n如果将 configUSE_CORE_AFFINITY 设置为 1， 则\nvTaskCoreAffinitySet() API\n函数可用于定义某个任务可以在哪些核心上运行以及不可以在那个核心上运行。\n任务的实现\n任务是以 C 函数来实现的。它们唯一的特殊之处在于它们的原型，必须返回\nvoid 并接受一个 void\n指针参数。函数原型如下：\nvoid ATaskFunction(void *pvParameters);\n每个任务本身就是一个小程序。通常会处于一个无限循环中永远运行，且不会退出。任务函数不允许实现返回，即不允许包含\nreturn 语句。如果想要删除掉任务，需要使用\nvTaskDelete( NULL );\n函数。同一个函数可以创建多个任务，每个任务都是独立运行的实例，具有自己的栈和任务本身定义的任何自动变量的副本。\n创建任务\nFreeRTOS 使用 xTaskCreate() API 函数创建任务。\nBaseType_t xTaskCreate(TaskFunction_t pvTaskCode,\n                       const char* const pcName,\n                       uint16_t usStackDepth,\n                       void *pvParameters,\n                       UBaseType_t uxPriority,\n                       TaskHandle_t *pxCreatedTask)\n\n\n\n\n\n\n\nParamter Name\nDescription\n\n\n\n\npvTaskCode\npvTaskCode\n参数只是一个指针，指向实现任务的函数（就是函数名）\n\n\npcName\n任务的描述性名称。FreeRTOS\n不会使用它，仅仅是调试时的辅助工具，有利于辨识。configMAX_TASK_NAME_LEN\n定义名称的最大长度，包括 NULL 终止符，超出的名称将会被截断。\n\n\nusStackDepth\n指定任务栈的深度，即栈可容纳的字数(word)，不是字节(byte)。如果栈的宽度是\n32-bit，深度是 100，那么栈空间就是 100 * 4 bytes。栈空间不能超过\nuint16_t 类型的最大值。分配的栈大小只能通过大致估算得到。\n\n\npvParameters\n任务函数接受指向 void (void *)\n的指针类型的形参。分配给 pvParameters 的值将传递给任务函数。\n\n\nuxPriority\n定义任务的优先级。优先级可以从 0\n(最低优先级) 分配到 configMAX_PRIORITIES -\n1(最高优先级)。\n\n\npxCreatedTask\n向正在创建的任务传递句柄。这个句柄用于在\nAPI 调用中引用任务。\n\n\n返回值\n成功：pdPASS；失败：errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY(失败原因只有内存不足)\n\n\n\nExample 1 创建两个任务\n任务一：\nvoid task1_task(void *pvParameters){\n    UBaseTpye_t msticks = 0;\n    msticks = pdMS_TO_TICKS(500);\n    while(1){\n        printf(\"task1 entry\\r\\n\");\n        GPIO_SetBits(GPIOA, GPIO_Pin_0);\n        vTaskDelay(msticks);\n        GPIO_ResetBits(GPIOA, GPIO_Pin_0);\n        vTaskDelay(msticks);\n    }\n}\n任务二：\nvoid task2_task(void *pvParameters){\n    UBaseType_t msticks = 0;\n    msticks = pdMS_TO_TICKS(1000);\n    while(1){\n        printf(\"task2 entry\\r\\n\");\n        GPIO_ResetBits(GPIOA, GPIO_Pin_1);\n        vTaskDelay(msticks);\n        GPIO_SetBits(GPIOA, GPIO_Pin_1);\n        vTaskDelay(msticks);\n    }\n}\n创建任务：\n#define TASK1_TASK_PRIO     5\n#define TASK1_STK_SIZE      256\n#define TASK2_TASK_PRIO     5\n#define TASK2_STK_SIZE      256\n/* create two task */\nxTaskCreate((TaskFunction_t )task2_task,\n            (const char*    )\"task2\",\n            (uint16_t       )TASK2_STK_SIZE,\n            (void*          )NULL,\n            (UBaseType_t    )TASK2_TASK_PRIO,\n            (TaskHandle_t*  )&amp;Task2Task_Handler);\n\nxTaskCreate((TaskFunction_t )task1_task,\n            (const char*    )\"task1\",\n            (uint16_t       )TASK1_STK_SIZE,\n            (void*          )NULL,\n            (UBaseType_t    )TASK1_TASK_PRIO,\n            (TaskHandle_t*  )&amp;Task1Task_Handler);\n/* Start the scheduler so the tasks start executing. */\nvTaskStartScheduler();\n\n\n\n\n\n\n\n\n\n实验使用沁恒 CH32F203C8T6 开发板\n实验结果：\n\ntask1 和 task2 两个任务看似是在同时执行，但是 MCU\n只有一个处理核心，不可能同时执行两个任务。实际是，MCU\n快速交替执行这两个任务，由于这两个任务具有相同的优先级，所以它们在一个处理器核心上共享时间。\n\n在任务调度器启动前，从 main()\n函数中创建两个任务。还可以从一个任务中创建另一个任务。\nvoid vTask1(void *pvParameters){\n    const char *pcTaskName = \"Task 1 is running\\r\\n\";\n    volatile uint32_t ul; \n    xTaskCreate(vTask2, \"Task2\", 1000, NULL, 1, NULL);\n    for(;;){\n        vPrintString(pcTaskName);\n        for(ul = 0; ul &lt; mainDELAY_LOOP_COUNT; ul++){\n            \n        }\n    }\n}\nExample 2 使用任务参数\n使用同一函数创建不同任务，并在创建任务时传入不同的参数，以此区别两个独立的任务。\nvoid vTaskFunction(void *pvParameters){\n    const char *pcTaskText = pvParameters;\n    UBaseType_t msticks = 0;\n    msticks = pdMS_TO_TICKS(100);\n    while (1){\n        printf(pcTaskText);\n        vTaskDelay(msticks);\n    } \n}\npcTaskText 变量接受创建任务时传入的\npvParameters 参数，不同的任务可以有不同的\npvParameters。\nstatic const char *pcTextForTask1 = \"Task 1 \\r\\n\";\nstatic const char *pcTextForTask2 = \"Task 2 \\r\\n\";\n\n/* 创建两个任务 */\nxTaskCreate(vTaskFunction, \"Task 1\", TASK1_STK_SIZE, (void *)pcTextForTask1, TASK1_TASK_PRIO, &amp;Task1Task_Handler);\nxTaskCreate(vTaskFunction, \"Task 2\", TASK2_STK_SIZE, (void *)pcTextForTask2, TASK2_TASK_PRIO, &amp;Task2Task_Handler);\n实验结果：\n\n任务优先级\nuxPriority 参数是在 xTaskCreate() API\n函数创建任务时，为任务分配的初始优先级。在任务开始调度之后，可以使用\nvTaskPrioritySet() API 函数为任务更改优先级。\n最大的任务优先级由 FreeRTOSConfig.h 文件中的\nconfigMAX_PRIORITIES 常量配置。数字越高，则由优先级越高。0\n为最低优先级，configMAX_PRIORITIES - 1\n为最高优先级。同一优先级的任务数量不受限制。\nFreeRTOS\n调度器可以使用两种方法中的一种来决定哪个任务将处于运行状态。configMAX_PRIORITIES\n可以设置的最大值取决于所使用的方法：\n\nGeneric Method\n\n通用方法是用 C 语言实现的，可以在所有的 FreeRTOS 架构端口上使用。\n当使用通用方法时，configMAX_PRIORITIES\n可设置的最大值不受限制。但应当将其限制在必要情况的最小值，以节省片上资源。其值越高消耗的\nRAM 就越多。\n设置 Generic Method:\n\nconfigUSE_PORT_OPTIMISED_TASK_SELECTION 置 0\nconfigUSE_PORT_OPTIMISED_TASK_SELECTION 未定义\nGeneric 是为使用中的 FreeRTOS 端口提供的唯一方法。\n\n\nArchitecture Optimized Method\n\n架构优化方法使用的汇编代码较少，且速度比通用方法快。configMAX_PRIORITIES\n设置不影响最坏情况下的执行时间。如果使用了架构优化方法，则\nconfigMAX_PRIORITIES 不能大于\n32。同样，应该尽可能的小。\n设置 Architecture Optimized Method:\n\nconfigUSE_PORT_OPTIMISED_TASK_SELECTION 置 1\n\n\n\n\n\n\n\n\n\n\n并非所有的FreeRTOS端口都提供了架构优化的方法\nFreeRTOS\n调度器将始终确保能够运行的最高优先级任务是被选择进入运行状态的任务。当多个具有相同优先级的任务能够运行时，调度器将依次将每个任务转换为运行状态和退出运行状态。\nTick 中断\n调度算法使用“时间片”功能使得两个优先级相同任务能够连续运行。每个任务在自己的时间片中运行，一个时间片开始时，任务进入运行状态，一个时间片结束时，任务退出运行状态。\n为了能够选择下一个要运行的任务，调度器必须在每个时间片结束时执行。这个时间片就是一个周期性中断，称为\nTick 中断。时间片的长度是由 Tick 中断的频率决定的，该频率由\nconfigTICK_RATE_HZ 常量配置。\n\n\n\n\n\n\n\n\n\n如果将 configTICK_RATE_HZ 设置为 100\n(Hz)，那么时间片就是 10 ms。两次 Tick 中断之间的时间称为 “Tick\n周期”。一个时间片等于一个 Tick 周期。\nconfigTICK_RATE_HZ\n的最佳值取决于正在开发的应用程序，尽管典型值为100。\n\npdMS_TO_TICKS() 宏将以毫秒为单位指定的时间转换为以 ticks\n为单位指定的时间。可用的分辨率取决于定义的 tick 频率，如果 tick\n频率高于1KHz( configTICK_RATE_HZ 大于 1000)，则不能使用\npdMS_TO_TICKS()。\nTickType_t xTimeInTicks = pdMS_TO_TICKS(200);\n\n\n\n\n\n\n\n\n\n不建议在应用程序中直接指定以刻度为单位的时间，而是使用\npdMS_TO_TICKS()\n宏来指定以毫秒为单位的时间，这样做可以确保即使刻度频率发生变化，应用程序中指定的时间也不会改变。\ntick count 值是自调度器启动以来发生的 tick\n中断的总数，假设 tick\n计数没有溢出。用户应用程序在指定延迟时间时不必考虑溢出，因为时间一致性是由\nFreeRTOS 内部管理的。\nExample 3 任务优先级\n调度器将始终保证能够运行的最高优先级的任务是被选择进入运行状态的任务。以下将创建一个优先级为\n1 的任务和一个优先级为 2 的任务：\nxTaskCreate(vTaskFunction, \"Task 1\", 256, (void *)pcTextForTask1, 1, &amp;Task1Task_Handler);\nxTaskCreate(vTaskFunction, \"Task 2\", 256, (void *)pcTextForTask2, 2, &amp;Task2Task_Handler);\n实验结果：\n\n因为任务 2 的优先级比任务 1 的高，只要任务 2\n是可运行的状态，系统将一直运行任务 2。任务 1 将永远得不到运行，称任务 1\n处于 “饥饿” 状态。\n其它任务状态\n如果一个任务不需要等待任何事情的发生，总是能处于运行状态，那么这种类型的任务的用处是十分有限的。这种任务只能以最低的优先级运行，因为如果它们处于高优先级，那么低优先级的任务将得不到运行，始终处于\n“饥饿” 状态。\n任务如果想要有用，那么它们必须为事件所驱动。事件驱动的任务只有在触发它的事件发生之后才能被执行，且在事件发生之前不能处于\nrunning\n状态。调度器始终选择能够运行的最高优先级任务。高优先级任务无法运行意味着调度器无法选择它们，而必须选择能够运行的低优先级任务。因此，使用事件驱动任务意味着可以在不同的优先级下创建任务，而不会使优先级最高的任务耗尽所有优先级较低的处理时间任务。\n阻塞状态 (The Blocked State)\n等待事件的任务被称为 “阻塞” 状态，这是 Not Running\n状态的一个子状态。\n任务等待事件的种类：\n\n事件(与时间相关)的时间 ——\n这个时间可以是一段延时，或某个绝对时间。例如延时 10 ms。\n同步事件 —— 事件源于另一个任务或中断。\n\n\n\n\n\n\n\n\n\n\nFreeRTOS 的队列(queues)、二进制信号量(binary\nsemaphores)、计数信号量(counting\nsemaphores)、互斥锁(mutexes)、递归互斥锁(recursive\nmutexes)、事件组(event groups)和任务通知(task\nnotifications)都可以用来创建同步事件。\n任务阻塞可以设置超时时间，如果在规定时间内事件已发生，或超过规定时间未发生，任务将离开阻塞状态。\n挂起状态(The Suspended State)\n挂起是 Not Running\n的一个子状态。处于挂起状态的任务无法被调度器调度。进入挂起状态的唯一方法是调用\nvTaskSuspend() API 函数。调用 xTaskResume() 或\nvTaskResumeFromISR() API\n函数将恢复任务调度。大多数应用不使用挂起状态。\n就绪状态(The Ready State)\n处于 Not Running\n状态但未被阻塞或挂起的任务称为处于“就绪”状态。它们能够运行，因此“准备好”运行，但当前不处于运行状态。\nExample 4\n使用阻塞状态创建延时\n任何形式的轮询最重要的是效率低下。在轮询期间，任务实际上没有任何工作要做，但它仍然使用最大的处理时间，因此浪费了处理器周期。调用\nvTaskDelay() API 函数来是任务进入阻塞状态，\n避免轮询空循环，大大提升了处理器的效率。注意，只有当\nINCLUDE_vTaskDelay 设置为 1 时，vTaskDelay()\nAPI 函数才可用。\nvTaskDelay() 将调用任务置于阻塞状态，用于固定数量的 tick\n中断。任务在处于阻塞状态时不使用任何处理时间，因此任务仅在有实际工作要完成时使用处理时间。\nvoid vTaskDelay( TickType_t xTicksToDelay );\n\n\n\nParamter Name\nDescription\n\n\n\n\nxTicksToDelay\n任务保持阻塞状态所持续的 tick 中断数。\n\n\n\nvoid vTaskFunction(void *pvParameters){\n    const char *pcTaskText = pvParameters;\n    TickType_t msticks = 0;\n    msticks = pdMS_TO_TICKS(500);\n    while (1){\n        printf(pcTaskText);\n        /* 延时 500 ms */\n        vTaskDelay(msticks);\n    } \n}\n实验结果：\n\n因为 vTaskDelay() 函数阻塞了任务 2，使得较低优先级的任务\n1 能够被运行。\nvTaskDelayUntil() API\n函数\nvTaskDelay() 阻塞的时常是一个相对的时间，从调用\nvTaskDelay() 函数开始进入阻塞状态，阻塞的时长为\nxTicksToDelay 参数所指定的 tick\n中断数。但是，vTaskDelayUntil()\n函数的参数指定任务从阻塞到就绪状态确切的 tick 计数值(tick count\nvalue)。当任务需要按照固定周期执行时，需要调用\nvTaskDelayUntil() API\n函数，因为任务解除阻塞状态的时间是绝对的，而不是相对于函数被调用的时间。\nvoid vTaskDelayUntil( TickType_t * pxPreviousWakeTime, TickType_t xTimeIncrement );\n\n\n\n\n\n\n\nParameter Name\nDescription\n\n\n\n\npxPreviousWakeTime\n保存任务最后离开阻塞状态的时间，此时间作为参考点，以计算下次离开阻塞状态的时间。它将在\nAPI 函数中自动更新，但必须在第一次使用它之前将其初始化为当前的 tick\n计数。\n\n\nxTimeIncrement\n任务固定执行的频率，也就是阻塞的时间长度。可用\npdMS_TO_TICKS() 宏将毫秒转称 tick 数值。\n\n\n\nExample 5 使用\nvTaskDelayUntil() 阻塞\n创建两个任务 task1_task 和 task2_task，任务 1 的优先级为 2， 任务 2\n的优先级为 1。PA0 端口为 1 时， 表示任务 1 正在执行，为 0 时，表示任务 2\n正在执行。分别用 vTaskDelay() 和\nvTaskDelayUntil() 对任务 1 进行阻塞。\n/* 任务 1 */\nvoid task1_task(void *pvParameters)\n{\n\tTickType_t xLastWakeTime;\n    int i;\n    /*初始的 Tick Count*/\n    xLastWakeTime = xTaskGetTickCount();\n    while(1)\n    {\n        GPIO_SetBits(GPIOA, GPIO_Pin_0);\n        for(i = 0; i &lt; 5; i++){\n            printf(\"Task1 is runnig\\r\\n\");\n        }\n\n#if 1\n        vTaskDelay(pdMS_TO_TICKS(50));\n#else \n        vTaskDelayUntil(&amp;xLastWakeTime, pdMS_TO_TICKS(50));\n#endif\n    }\n}\n/* 任务 2 */\nvoid task2_task(void *pvParameters)\n{\t\n    while(1)\n    {\n        GPIO_ResetBits(GPIOA, GPIO_Pin_0);\n        printf(\"Task 2 is running\\r\\n\");\n    }\n}\n/* 主函数 */\nint main(void)\n{\n    USART_Printf_Init(115200);\n    printf(\"SystemClk:%d\\r\\n\",SystemCoreClock);\n    printf(\"FreeRTOS Kernel Version:%s\\r\\n\",tskKERNEL_VERSION_NUMBER);\n    GPIO_Toggle_INIT();\n    xTaskCreate(task1_task, \"Task 1\", 256, NULL, 2, &amp;Task1Task_Handler);\n    xTaskCreate(task2_task, \"Task 2\", 256, NULL, 1, &amp;Task2Task_Handler);\n    vTaskStartScheduler();\n    while(1)\n    {\n        printf(\"shouldn't run at here!!\\n\");\n    }\n}\n逻辑分析仪分析 PA0 端口电平变换：\n\n\n空闲任务及其钩子函数\n空闲任务\n当创建的任务均处于阻塞状态，但是必须始终至少有一个任务可以进入\nRunning 状态。为了确保这一点，调度程序在调用\nvTaskaStartScheduler() 时，会自动创建一个 Idle\n任务。空闲任务只在循环中执行很少的操作，因此它并不妨碍其它任务的执行。\n空闲任务具有尽可能低的优先级(0\n优先级)，以确保它永远不会阻止更高优先级的任务进入运行状态。如果一定要创建与空闲任务同优先级的任务，可以通过配置\nconfigIDLE_SHOULD_YILED\n来防止空闲任务占用过多的处理时间。\n\n\n\n\n\n\n\n\n\n如果程序使用 vTaskDelete() API 函数，那么必须确保 Idle\n任务有机会得到运行。因为 Idle 任务负责在任务被删除之后清理内核资源。\n空闲任务的钩子函数\n可以通过使用空闲钩子(或空闲回调)函数将特定于应用程序的功能直接添加到空闲任务中，该函数在空闲任务循环的每次迭代中由空闲任务自动调用一次。\n空闲任务钩子函数的用法：\n\n执行低优先级、后台或连续处理功能\n测量空闲处理的时间。(空闲任务只有在所有高优先级应用程序任务没有工作可执行时才会运行;因此，测量分配给空闲任务的处理时间可以清楚地表明有多少处理时间是空闲的。)\n将处理器置于低功耗模式，当没有应用程序处理要执行时，提供一种简单而自动的省电方法\n\n对空闲任务钩子函数实现的限制：\n\n空闲任务钩子函数绝不能试图阻塞或挂起。\n如果应用程序使用 vTaskDelete()\nAPI函数，那么空闲任务钩子必须要在合理的时间段内返回到其调用者。这是因为\nIdle 任务负责在任务被删除后清理内核资源。如果空闲任务永久地保留在 Idle\n钩子函数中，则不能进行清理。\n\n空闲任务钩子函数必须具有以下的函数名和原型：\nvoid vApplicationIdleHook( void );\nExample 6\n创建空闲任务钩子函数\nvolatile uint32_t ulIdleCycleCount = 0UL;\n/* 创建钩子函数 */\nvoid vApplicationIdleHook(void){\n    ulIdleCycleCount++ ;\n}\n在 FreeRTOSConfig.h 中，将 configUSE_IDLE_HOOK 设置为\n1，空闲钩子函数才会被调用。\nvoid vTaskFunction(void *pvParameters){\n    const char *pcTaskText = pvParameters;\n    while (1)\n    {\n        printf(pcTaskText);\n        printf(\"Idle Cycle Count = %d\", ulIdleCycleCount);\n        vTaskDelay(pdMS_TO_TICKS(1000));   \n    }  \n}\n更改任务优先级\nvTaskPrioritySet() API\n函数\nvTaskPrioritySet() API\n函数用于在调度器启动后更改任何任务的优先级。\n\n\n\n\n\n\n\n\n\n需要将 NCLUDE_vTaskPrioritySet 设置为 1\nvoid vTaskPrioritySet( TaskHandle_t pxTask, UBaseType_t uxNewPriority );\n\n\n\n\n\n\n\nParameter Name\nDescription\n\n\n\n\npxTask\n任务句柄任务可以通过传递 NULL\n代替有效的任务句柄来改变自己的优先级。\n\n\nuxNewPriority\n要设置的新的优先级\n\n\n\nxTaskPriorityGet() API\n函数\nuxTaskPriorityGet() API\n函数可以用来查询任务的优先级。\n\n\n\n\n\n\n\n\n\n需要将 INCLUDE_uxTaskPriorityGet 设置为 1\nUBaseType_t uxTaskPriorityGet( TaskHandle_t pxTask );\n\n\n\n\n\n\n\nParameter Name\nDescription\n\n\n\n\npxTask\n任务句柄任务可以通过传递 NULL\n代替有效的任务句柄来查询自己的优先级。\n\n\nReturned value\n查询任务的优先级\n\n\n\nExample 7 改变任务优先级\n以不同的优先级创建两个任务，两个都不会进入阻塞状态。优先级相对较高的任务将被点调度器选择运行。\n\n任务 1\n以最高优先级创建，因此将会首先运行。先打印出两个字符串，在将任务 2\n的优先级提高到高于自己的优先级。\n在任务 2 中打印一条信息，再将自己的优先级设置到低于任务 1\n的优先级。\n\n任务 1：\nvoid vTask1(void *pvParameters){\n    UBaseType_t uxPriority;\n    uxPriority = uxTaskPriorityGet(NULL);\n    while (1)\n    {\n        printf(\"Task 1 is running\\r\\n\");\n        printf(\"About to raise the Task 2 priority\\r\\n\");\n        vTaskPrioritySet(xTask2Handle, (uxPriority + 1));\n    }   \n}\n任务 2：\nvoid vTask2(void *pvParameters){\n    UBaseType_t uxPriority;\n    uxPriority = uxTaskPriorityGet(NULL);\n\n    while (1)\n    {\n        printf(\"Task 2 is running\\r\\n\");\n        printf(\"About to lower the Task 2 priority\\r\\n\");\n        vTaskPrioritySet(NULL, (uxPriority - 2));\n    }  \n}\n创建任务：\nxTaskCreate(vTask1, \"Task 1\", 256, NULL, 2, &amp;xTask1Handle);\nxTaskCreate(vTask2, \"Task 2\", 256, NULL, 1, &amp;xTask2Handle);\nvTaskStartScheduler();\n实验结果：\n\n删除任务\nvTaskDelete() API 函数\n任务可以使用 vTaskDelete() API\n函数来删除自己或任何其他任务。\n\n\n\n\n\n\n\n\n\n需要将 INCLUDE_vTaskDelete 设置为 1\n删除的任务不再存在，不能再进入“运行”状态。空闲任务负责释放分配给已删除的任务的内存。因此，重要的是，使用\nvTaskDelete() API\n函数的应用程序不要完全耗尽空闲任务的所有处理时间。\n\n\n\n\n\n\n\n\n\n当任务被删除时，只有内核自己分配给任务的内存才会被自动释放。任务实现分配的任何内存或其他资源必须显式释放。\nvoid vTaskDelete( TaskHandle_t pxTaskToDelete );\n\n\n\n\n\n\n\nParameter Name\nDescription\n\n\n\n\npxTaskToDelete\n待删除任务的句柄任务可以通过传递NULL来代替有效的任务句柄来删除自己\n\n\n\nExample 8 删除任务\n任务 1：\nTaskHandle_t xTask2Handle = NULL;\nvoid vTask1(void *pvParameters){\n    const TickType_t xDelay100ms = pdMS_TO_TICKS(100UL);\n    while(1){\n        printf(\"Task 1 is running\\r\\n\");\n        /* 创建任务 2 */\n        xTaskCreate(vTask2, \"Task 2\", 1000, NULL, 2 &amp;xTask2Handle);\n        /* 进入阻塞状态，使得 Idle 任务可以运行 */\n        vTaskDelay(xDelay100ms);\n    }\n}\n任务 2：\nvoid vTask2(void *pvParameters){\n    printf(\"Task 2 is running and about to delete itself\\r\\n\");\n    /* 删除自身，传入 NULL 也可 */\n    vTaskDelete(xTask2Handle);\n}\n主函数：\nint main(void){\n    xTaskCreate(vTask1, \"Task 1\", 1000, NULL, 1, NULL);\n    vTaskStartScheduler();\n    while(1);\n}\n调度算法\n配置调度算法\n调度算法决定就绪状态中的哪个任务进入运行状态。可以使用\nconfigUSE_PREEMPTION 和configUSE_TIME_SLICING\n配置常量更改算法。第三个配置常量 configUSE_TICKLESS_IDLE\n也会影响调度算法，使用它可能导致在较长时间内完全关闭 Tick 中断。\n在所有可能的配置中，FreeRTOS\n调度器将确保共享优先级的任务依次被选择进入运行状态，即轮询调度。轮循调度算法不能保证同等优先级的任务之间的时间分配均等，只能保证同等优先级的任务依次进入运行状态。\n带时间片的固定优先级抢占调度\n\n\n\nConstant\nValue\n\n\n\n\nconfigUSE_PREEMPTION\n1\n\n\nconfigUSE_TIME_SLICING\n1\n\n\n\n以上配置称为“固定优先级抢占式时间片调度”的调度算法，这是大多数小型\nRTOS 应用程序使用的调度算法。\n调度策略的术语的解释：\n\n\n\n\n\n\n\nTerm\nDefinition\n\n\n\n\nFixed Priority\n被称为 “固定优先级”\n的调度算法不会改变分配给被调度任务的优先级，但也不会阻止任务本身改变自己或其他任务的优先级。\n\n\nPre-emptive\n抢占调度算法会在优先级高于“运行”的任务进入“就绪”状态时，立即对“运行”任务进行“抢占”。\n\n\nTime Slicing\n时间片用于在具有相同优先级的任务之间共享处理时间，即使任务没有显式地放弃或进入阻塞状态。如果有与运行任务相同优先级的任务处于就绪状态，“时间片”调度算法将在每个时间片结束时选择一个新任务进入运行状态。一个时间片等于两个\nRTOS Tick中断之间的时间。\n\n\n\n不带时间片的固定优先级抢占调度\n不使用时间片的优先级抢占调度与之前的任务选择和抢占算法相同，但不使用时间片在相同优先级的任务之间共享处理时间。\n\n\n\nConstant\nValue\n\n\n\n\nconfigUSE_PREEMPTION\n1\n\n\nconfigUSE_TIME_SLICING\n0\n\n\n\n如果不使用时间片，则调度器只会在以下情况下选择一个新任务进入运行状态：\n\n高优先级的任务进入就绪状态。\n处于 “运行” 状态的任务进入 “阻塞” 或 “挂起” 状态。\n\n不使用时间片时，任务上下文切换比使用时间片时要少。因此，关闭时间片可以减少调度器的处理开销。然而，关闭时间片也会导致同等优先级的任务接收到的处理时间差异很大，由于这个原因，不使用时间切片运行调度器被认为是一种高级技术，只应该由有经验的用户使用。\n合作调度\n\n\n\nConstant\nValue\n\n\n\n\nconfigUSE_PREEMPTION\n0\n\n\nconfigUSE_TIME_SLICING\nAny value\n\n\n\n当使用合作调度时，只有当运行状态任务进入阻塞状态，或者运行状态任务通过调用\ntaskYIELD()\n(手动请求重新调度)时，才会发生上下文切换。任务永远不会被抢占，所以不能使用时间片。\n","slug":"FreeRTOS/Task","date":"2023-04-23T09:13:00.000Z","categories_index":"嵌入式","tags_index":"FreeRTOS","author_index":"爱慢跑的乌龟"},{"id":"0d8865dd6f5b4fb80b5a9df16b916aeb","title":"链表 linked list","content":"链表 linked list\n什么是链表\n链表是数据元素的线性集合，其顺序不是由它们在内存中的物理位置给出的。每个元素都指向下一个元素。它是一种数据结构，由一组节点组成，这些节点共同表示一个序列。在其最基本的形式中，每个节点都包含：数据和指向序列中下一个节点的指针（链接）。这种结构允许在迭代期间从序列中的任何位置有效地插入或删除元素。链表的一个缺点是访问时间是线性的(difficult\nto\npipeline)。更快的访问（例如随机访问）是不行的。与链表相比，数组具有更好的缓存局部性(cache\nlocality)。\n链表是最简单和最常见的数据结构之一。它们可用于实现其它几种常见的抽象数据类型，包括列表、栈(Stack)、队列、关联数组和\nS 表达式，尽管直接实现这些数据结构而不使用链表作为基础并不罕见。\n链表相对于传统数组的主要优点是，可以轻松插入或删除列表中的元素，而无需重新分配或重组整个结构，因为数据项不需要连续存储在内存或磁盘上，而在运行时重组数组是一项成本更高的操作。链表允许在列表中的任意位置\n插入和删除节点，并且允许在列表遍历期间将链接保留在内存中添加或删除的链接之前，以恒定数量的操作来执行次操作。\n但是，由于简单链表本身不允许随机访问数据或任何形式的有效索引，因此许多基本操作（例如获取列表的最后一个节点、查找包含给定基准的节点或定位应插入新节点的位置）可能需要遍历大部分或全部列表元素。\n\n\n\n\n\n\n\n\n\n\n链表的每条记录通常称为“元素”(element)\n或节点(node)。包含下一个节点地址的字段通常称为“下一个链接”或“下一个指针”。其余称为“数据”。\n为什么要使用链表？\n数组(Arrays)可以用来存储相似类型的线性数据，但数组有以下的限制：\n\n数组的大小是固定的：因此使用数组时必须先预设元素数量的上限。此外，通常情况下，无论是否使用，都需要分配数组上限大小的内存。\n插入一个元素或删除一个数组中的已有元素花费很大：必须为新元素创建空间，为了创建这个空间，现有的数组元素必须移动。\n\nExample：\n在一个系统中，如果我们在一个数组\nid[] = [1000, 1010, 1050, 2000, 2040] 中维护一个有序的 ID\n列表。此时，想要插入一个新的 ID\n1005，那么为了维持排序的顺序，我们必须移动 1000 之后的所有元素。\n链表相对于数组的优点\n\n动态数组\n易于插入和删除\n在开头插入一个元素是一个常数时间操作，需要 O(1)\n时间，而在数组的开头插入一个元素需要 O(n) 时间，其中 n\n是数组中元素的数量。\n\n链表的缺点\n\n不能随机访问。必须从第一个节点开始按顺序访问节点。因此，不能用它的默认实现对链表进行有效的二分搜索。\n对于列表中的每个元素，指针都需要额外的内存空间。\n不是缓存友好(cache-friendly)。由于数组元素是连续位置，因此存在引用的局部性，这在链表中是不存在的。\n遍历和更改指针需要花费大量的时间。\n反向遍历单链表是不可能的。\n链表不可能像在数组中那样通过索引直接访问元素。\n所搜一个元素的代价很高，需要 O(n) 时间复杂度。\n链表的排序是十分复杂的，同时花费巨大。\n\n链表的种类\n\n简单链表 (Simple Linked List) -\n只能在一个方向上移动或遍历链表。每个节点的 next\n指针指向其它节点，最后一个节点的 next 指针指向\nNULL。它也被称为“单链表”。\n双链表 (Doubly Linked List) -\n在这种类型的链表中看，可以在两个方向（向前和向后）移动或遍历链表。\n循环链表 (Circular Linked List) - 链表的最后一个节点的\nnext 指针指向第一个节点。\n双向循环链表 (Doubly Circular Linked List) -\n这是一种更复杂的链表类型，它包含指向列表中下一个节点和上一个节点的指针。双链表和循环双向链表的区别，与单链表和循环链表的区别一样的。循环双向链表在第一个节点的前一个字段中不包含\nNULL。\nHeader Linked List - 它在列表的开头包含一个标题节点。\n\n链表的基本操作\n\nDeletion\nInsertion\nSearch\nDisplay\n\n单链表的简单实现\nC\n&#x2F;&#x2F; A linked list node\nstruct Node&#123;\n    int data;\n    struct Node* next;\n&#125;\nC++\nclass Node&#123;\npublic:\n    int data;\n    Node* next;\n&#125;\nPython\n# Node class\nclass Node:\n    # Function to initialize the node object\n    def __init__(self, data):\n        self.data &#x3D; data\t# Assign data\n        self.next &#x3D; Node\n遍历链表\nC\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nstruct Node&#123;\n    int data;\n    struct Node* next;\n&#125;;\n\nvoid printList(struct Node* n)&#123;\n    while(n !&#x3D; NULL)&#123;\n        printf(&quot;%d&quot;, n-&gt;data);\n        n &#x3D; n-&gt;next;\n    &#125;\n&#125;\n\nint main()&#123;\n    struct Node* head &#x3D; NULL;\n    struct Node* second &#x3D; NULL;\n    struct Node* third &#x3D; NULL;\n    \n    &#x2F;&#x2F; allocate 3 nodes in the heap\n    head &#x3D; (struct Node*)malloc(sizeof(struct Node));\n    second &#x3D; (struct Node*)malloc(sizeof(struct Node));\n    third &#x3D; (struct Node*)malloc(sizeof(struct Node));\n    \n    head-&gt;data &#x3D; 1;\n    head-&gt;next &#x3D; second;\n    \n    seconde-&gt;data &#x3D; 2;\n    seconde-&gt;next &#x3D; third;\n    \n    third-&gt;data &#x3D; 3;\n    third-&gt;next &#x3D; NULL;\n    \n    prinfList(head);\n    \n    return 0;\n&#125;\nC++\nusing namespace std;\n\nclass Node&#123;\npublic:\n    int data;\n    Node* next;\n&#125;;\n\nvoid printList(Node* n)&#123;\n    while(n !&#x3D; NULL)&#123;\n        cout &lt;&lt; n-&gt;data &lt;&lt; &quot; &quot;;\n        n &#x3D; n-&gt;next;\n    &#125;\n&#125;\n\nint main()&#123;\n    Node* head &#x3D; NULL;\n    Node* second &#x3D; NULL;\n    Node* third &#x3D; NULL;\n    \n    &#x2F;&#x2F; allocate 3 nodes in the heap\n    head &#x3D; new Node();\n    second &#x3D; new Node();\n    third &#x3D; new Node();\n    \n    head-&gt;data &#x3D; 1;\n    head-&gt;next &#x3D; second;\n    \n    second-&gt;data &#x3D; 2;\n    second-&gt;next &#x3D; third;\n    \n    third-&gt;data &#x3D; 3;\n    third-&gt;next &#x3D; NULL;\n    \n    printList(head);\n    \n    return 0;\n&#125;\nPython\nclass Node:\n    def __init__(self, data):\n        self.data &#x3D; data\n        self.next &#x3D; None\n        \nclass LinkedList:\n    def __init__(self):\n        self.head &#x3D; None\n       \n    def printList(self):\n        temp &#x3D; self.head\n        while(temp):\n            print(temp.data)\n            temp &#x3D; temp.next\n            \nif __name__ &#x3D;&#x3D; &quot;__main__&quot;:\n    llist &#x3D; LinkedList()\n    \n    llist.head &#x3D; Node(1)\n    second &#x3D; Node(2)\n    third &#x3D; Node(3)\n    \n    llist.head.next &#x3D; second\n    second.next &#x3D; third\n    \n    llist.printList()\n链表的应用\n\n链表可以用来实现其它的数据结构，如堆栈和队列\n链表可以用来实现哈希表\n链表可以用来实现图\n\n链表的操作：Traverse,\nInsert and Delete\n\nTraversal - 访问链表的每一个元素\nInsertion - 添加一个新的元素到链表中\nDeletion - 删除一个已有元素\nSearch - 在链表中找到一个节点\nSort - 对链表的节点进行排序\n\n遍历一个链表\nstruct node *temp &#x3D; head;\nprintf(&quot;\\n\\nList elements are - \\n&quot;);\nwhile(temp !&#x3D; NULL)&#123;\n    printf(&quot;%d ---&gt;&quot;, temp-&gt;data);\n    temp &#x3D; temp-&gt;next;\n&#125;\n插入一个元素到链表中\n\n在开头插入\n\n\n为新节点分配内存\n存入数据\n新节点的 next 指向 head\n更改 head 指向最新创建的节点\n\nstruct node *newNode;\nnewNode &#x3D; malloc(sizeof(struct node));\nnewNode-&gt;data &#x3D; 4;\nnewNode-&gt;next &#x3D; head;\nhead &#x3D; newNode;\n\n在末尾插入\n\n\n为新节点分配内存\n存入数据\n遍历到最后一个节点\n更改最后一个节点的 next 指向最新的节点\n\nstruct node *newNode;\nnewNode &#x3D; malloc(sizeof(struct node));\nnewNode-&gt;data &#x3D; 4;\nnewNode-&gt;next &#x3D; NULL;\n\nstruct node *temp &#x3D; head;\nwhile(temp-&gt;next !&#x3D; NULL)&#123;\n    temp &#x3D; temp-&gt;next;\n&#125;\ntemp-&gt;next &#x3D; newNode\n\n在中间插入\n\n\n为新节点分配内存\n存入数据\n遍历到新节点存入位置之前的节点\n更改 next 指针\n\nstruct node *newNode;\nnewNode &#x3D; malloc(sizeof(struct node));\nnewNode-&gt;data &#x3D; 4;\n\nstruct node *temp &#x3D; head;\nfor(int i &#x3D; 2; i &lt; position; i++)&#123;\n    if(temp-&gt;next !&#x3D; NULL)&#123;\n        temp &#x3D; temp-&gt;next;\n    &#125;\n&#125;\nnewNode-&gt;next &#x3D; temp-&gt;next;\ntemp-&gt;next &#x3D; newNode;\n从链表中删除一个节点\n\n删除头节点\n\n\n将 head 指向第二个节点\n\nhead &#x3D; head-&gt;next;\n\n删除末尾的节点\n\n\n遍历到倒数第二个元素\n将它的 next 指针指向 NULL\n\nstruct node* temp &#x3D; head;\nwhile(temp-&gt;next-&gt;next !&#x3D; NULL)&#123;\n    temp &#x3D; temp-&gt;next;\n&#125;\ntemp-&gt;next &#x3D; NULL;\n\n删除中间的节点\n\n\n遍历到要删除节点之前的节点\n更改其 next 指针， 将要删除的节点从链表中排除\n\nfor(int i &#x3D; 2; i &lt; position; i++)&#123;\n    if(temp-&gt;next !&#x3D; NULL)&#123;\n        temp &#x3D; temp-&gt;next;\n    &#125;\n&#125;\ntemp-&gt;next &#x3D; temp-&gt;next-&gt;next;\n在链表中搜索一个元素\n\n将 head 作为 current 节点\n运行一个循环，直到 current 节点是\nNULL，因为最后一个节点指向 NULL\n在每次迭代中，检测节点是否等于 item。如果与\nitem 匹配，则返回 true，否则返回\nfalse。\n\nbool searchNode(struct Node** head_ref, int key)&#123;\n    struct Node* current &#x3D; *head_ref;\n    \n    while(current !&#x3D; NULL)&#123;\n        if(current-&gt;data &#x3D;&#x3D; key) return true;\n        current &#x3D; current-&gt;next;\n    &#125;\n    return false;\n&#125;\n链表元素排序\n冒泡排序：\n\n将 head 作为 current 节点，并创建一个\nindex 节点备用。\n如果 head 是空，则返回。\n否则，运行一个循环直到以后一个节点。\n在每次迭代中依次执行 5-6 步。\n存储 current 的下一个节点在 index\n中。\n检查 current\n节点的数据是否大于下一个节点的。如果是，则交换 current 和\nindex。\n\nvoid sortLinkedList(struct Node** head_ref)&#123;\n    struct Node *current &#x3D; *head_ref, *index &#x3D; NULL;\n    int temp;\n    \n    if(head_ref &#x3D;&#x3D; NULL)&#123;\n        return;\n    &#125;else&#123;\n        while(current !&#x3D; NULL)&#123;\n            &#x2F;&#x2F; index points to the node next to current\n            index &#x3D; current-&gt;next;\n            \n            while(index !&#x3D; NULL)&#123;\n                if(current-&gt;data &gt; index-&gt;data)&#123;\n                    temp &#x3D; current-&gt;data;\n                    current-&gt;data &#x3D; index-&gt;data;\n                    index-&gt;data &#x3D; temp;\n                &#125;\n                index &#x3D; index-&gt;next;\n            &#125;\n            current &#x3D; current-&gt;next;\n        &#125;\n    &#125;\n&#125;\nPython\n# Linked list operations in Python\n\n# create a node\nclass Node:\n    def __init__(self, data):\n        self.data &#x3D; data\n        self.next &#x3D; None\n\nclass LinkedList:\n    def __init__(self):\n        self.head &#x3D; None\n        \n    # Insert at the begining\n    def insertAtBegining(self, new_data):\n        new_node &#x3D; Node(new_data)\n        \n        new_node.next &#x3D; self.head\n        self.head &#x3D; new_node\n    \n    # Insert after a node\n    def insertAfter(self, prev_node, new_data):\n        if prev_node is None:\n            print(&quot;The given previous node must inLinkedList.&quot;)\n            return\n        new_node &#x3D; Node(new_data)\n        new_node.next &#x3D; prev_node.next\n        prev_node.next &#x3D; new_node\n    # Insert at the end\n    def insertAtEnd(self, new_data):\n        new_node &#x3D; Node(new_data)\n        \n        if self.head is None:\n            self.head &#x3D; new_node\n            return\n        \n        last &#x3D; self.head\n        while(last.next):\n            last &#x3D; last.next\n        \n        last.next &#x3D; new_node\n        \n    # Deleting a node\n    def deleteNode(self, position):\n        if self.head is None:\n            return\n        \n        temp &#x3D; self.head\n        \n        if position &#x3D;&#x3D; 0:\n            self.head &#x3D; temp.next\n            temp &#x3D; None\n            return\n        \n        # Find the key to be deleted\n        for i in range(position - 1):\n            temp &#x3D; temp.next\n            if temp is None:\n                break\n        \n        # If the key is not present\n        if temp is None:\n            return \n        \n        if temp.next is None:\n            return\n        \n        next &#x3D; temp.next.next\n        temp.next &#x3D; None\n        temp.next &#x3D; next\n    \n    # Search an element\n    def search(self, key):\n        current &#x3D; self.head\n        \n        while current is not None:\n            if current.data &#x3D;&#x3D; key:\n                return True\n            \n            current &#x3D; current.next\n        \n        return False\n    \n    # Sort the linked list\n    def sortLinkedList(self, head):\n        current &#x3D; head\n        index &#x3D; Node(None)\n        \n        if head is None:\n            return\n        else:\n            while current is not None:\n                # index points to the node next to current \n                index &#x3D; current.next\n                \n                while index is not None:\n                    if current.data &gt; index.data:\n                        current.data, index.data &#x3D; index.data, current.data\n                    index &#x3D; index.next\n                current &#x3D; current.next\n\n    # Print the linked list\n    def printList(self):\n        temp &#x3D; self.head\n        while(temp):\n            print(str(temp.data) + &quot; &quot;, end&#x3D;&quot;&quot;)\n            temp &#x3D; temp.next\n\nif __name__ &#x3D;&#x3D; &#39;__main__&#39;:\n    llist &#x3D; LinkedList()\n    llist.insertAtEnd(1)\n    llist.insertAtBeginning(2)\n    llist.insertAtBeginning(3)\n    llist.insertAtEnd(4)\n    llist.inserAfter(llist.head.next, 5)\n    \n    print(&quot;linked list: &quot;)\n    llist.printList()\n    \n    print(&quot;\\nAfter deleting an element:&quot;)\n    llist.deleteNode(3)\n    llist.printList()\n    \n    print()\n    item_to_find &#x3D; 3\n    if llist.search(item_to_find):\n        print(str(item_to_find) + &quot;is found&quot;)\n    else:\n        print(str(item_to_find) + &quot;is not found&quot;)\n        \n    llist.sortLinkedList(llist.head)\n    print(&quot;Sorted List: &quot;)\n    llist.printList()\nC\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nstruct Node&#123;\n    int data;\n    struct Node* next;\n&#125;;\n\n&#x2F;&#x2F; Insert at the beginning\nvoid insertAtBeginning(struct Node** head_ref, int new_data)&#123;\n    &#x2F;&#x2F; Allocate memory to a node\n    struct Node* new_node &#x3D; (struct Node*)malloc(sizeof(struct Node));\n    \n    &#x2F;&#x2F; insert the data\n    new_node-&gt;data &#x3D; new_data;\n    new_node-&gt;next &#x3D; (*head_ref);\n    \n    &#x2F;&#x2F; Move head to new node\n    (*head_ref) &#x3D; new_node;\n&#125;\n\n&#x2F;&#x2F; Insert a node after a node\nvoid insertAfter(struct Node* prev_node, int new_data)&#123;\n    if(prev_node &#x3D;&#x3D; NULL)&#123;\n        printf(&quot;the given previous node cannot be NULL&quot;);\n        return;\n    &#125;\n    struct Node* new_node &#x3D; (struct Node*)malloc(sizeof(struct Node));\n    new_node-&gt;data &#x3D; new_data;\n    new_node-&gt;next &#x3D; prev_node-&gt;next;\n    prev_node-&gt;next &#x3D; new_node;\n&#125;\n\n&#x2F;&#x2F; Insert the end\nvoid insertAtEnd(struct Node** head_ref, int new_data)&#123;\n    struct Node* new_node &#x3D; (struct Node*)malloc(sizeof(struct Node));\n    struct Node* last &#x3D; *head_ref;\n    \n    new_node-&gt;data &#x3D; new_data;\n    new_node-&gt;next &#x3D; NULL;\n    \n    if(*head_ref &#x3D;&#x3D; NULL)&#123;\n        *head_ref &#x3D; new_node;\n        return;\n    &#125;\n    while(last-&gt;next !&#x3D; NULL) last &#x3D; last-&gt;next;\n    last-&gt;next &#x3D; new_node;\n    return;\n&#125;\n\n&#x2F;&#x2F; Delete a node\nvoid deleteNode(struct Node** head_ref, int key)&#123;\n    struct Node *temp &#x3D; *head_ref, *prev;\n    \n    if(temp !&#x3D; NULL &amp;&amp; temp-&gt;data &#x3D;&#x3D; key)&#123;\n        *head_ref &#x3D; temp-&gt;next;\n        free(temp);\n        return;\n    &#125;\n    &#x2F;&#x2F; Find the key to be deleted\n    while(temp !&#x3D; NULL &amp;&amp; temp-&gt;data !&#x3D; key)&#123;\n        prev &#x3D; temp;\n        temp &#x3D; temp-&gt;next;\n    &#125;\n    \n    &#x2F;&#x2F; If the key is not present\n    if(temp &#x3D;&#x3D; NULL) return;\n    \n    &#x2F;&#x2F; Remove the node\n    prev-&gt;next &#x3D; temp-&gt;next;\n    free(temp);\n&#125;\n\n&#x2F;&#x2F; Search a node\nint searchNode(struct Node** head_ref, int key)&#123;\n    struct Node* current &#x3D; *head_ref;\n    \n    while(current !&#x3D; NULL)&#123;\n        if (current-&gt;data &#x3D;&#x3D; key) return 1;\n        current &#x3D; current-&gt;next;\n    &#125;\n    return 0;\n&#125;\n\n&#x2F;&#x2F; Sort the linked list\nvoid sortLinkedList(struct Node** head_ref)&#123;\n    struct Node* current &#x3D; *head_ref, *index &#x3D; NULL;\n    int temp;\n    if(head_ref &#x3D;&#x3D; NULL)&#123;\n        return;\n    &#125;else&#123;\n        while(current !&#x3D; NULL)&#123;\n            index &#x3D; current-&gt;next;\n            \n            while(index !&#x3D; NULL)&#123;\n                if(current-&gt;data &gt; index-&gt;data)&#123;\n                    temp &#x3D; current-&gt;data;\n                    current-&gt;data &#x3D; index-&gt;data;\n                    index-&gt;data &#x3D; temp;\n                &#125;\n                index &#x3D; index-&gt;next;\n           &#125;\n            current &#x3D; current-&gt;next;\n        &#125;\n    &#125;\n&#125;\n\n&#x2F;&#x2F; Print the linked list\nvoid printList(struct Node* node)&#123;\n    while(node !&#x3D; NULL)&#123;\n        printf(&quot; %d &quot;, node-&gt;data);\n        node &#x3D; node-&gt;next;\n    &#125;\n&#125;\n\nint main()&#123;\n    struct Node* head &#x3D; NULL;\n    \n    insertAtEnd(&amp;head, 1);\n    insertAtBeginning(&amp;head, 2);\n    insertAtBeginning(&amp;head, 3);\n    insertAtEnd(&amp;head, 4);\n    insertAfter(head-&gt;next, 5);\n    \n    printf(&quot;Linked list: &quot;);\n    printList(head);\n    \n    printf(&quot;\\nAfter deleting an element: &quot;);\n    deleteNode(&amp;head, 3);\n    printList(head);\n    \n    int item_to_find &#x3D; 3;\n    if(searchNode(&amp;head, item_to_find))&#123;\n        printf(&quot;\\n%d is found&quot;, item_to_find);\n    &#125;else&#123;\n        printf(&quot;\\n%d is not found&quot;, item_to_find);\n    &#125;\n    \n    sortLinkedList(&amp;head);\n    printf(&quot;\\nSorted List: &quot;);\n    printList(head);\n&#125;\n\n","slug":"DSAA/链表","date":"2023-04-14T12:00:00.000Z","categories_index":"数据结构与算法","tags_index":"计算机","author_index":"爱慢跑的乌龟"},{"id":"386d227c4f88ed4186d8b0b65da86630","title":"CAN 总线协议","content":"CAN 总线协议\nController Area Network (CAN bus)\n是一种车辆总线标准，允许为控制器和设备在没有主机的情况下与彼此的应用程序进行通信（没有主从关系）。它是一种基于消息的协议，最初设计用于汽车内的多路复用电线以节省铜线，但它也可以许多其他情况。对于每个设备，帧中的数据是串行传输的，但如果多个设备同时传输，最高优先级的设备可以继续传输，而其他设备则推出。帧被所有设备接受，包括发送设备。\nCAN 总线的历史\n1983-1991: CAN 总线的诞生和发展\nCAN 总线最初是由德国博世公司（Bosch），在 1983 年开发，并于 1986\n年首次发布。CAN\n总线最初用于汽车电子系统的通信，并逐渐得到其他领域的广泛应用。在这一时期，CAN\n总线标准得到了进一步完善和发展，包括 CAN 2.0A 和 CAN 2.0B\n等版本的发布。\n1991-2000年: CAN\n总线的普及和标准化\nCAN\n总线在这一时期得到了广泛的应用和推广，成为汽车电子系统、工业控制和自动化领域的主流通信协议。CAN\n总线标准也到了进一步的标准化和完善，包括 ISO 11898 等标准的发布。\n2000年至今: CAN\n总线的进一步发展和应用扩展\n2012 年，博世发布了CAN FD1.0，即 CAN with Flexible\nData-Rate。该规范使用不同的帧格式，允许不同的数据长度，并在仲裁决定后可选择切换到更快的比特率。CAN\nFD 与现有的 CAN 2.0 网络兼容，因此新的 CAN FD 设备可以与现有的 CAN\n设备在同一网络中共存。截至 2018 年，博世积极扩展 CAN 标准。\nCAN 总线的标准\n1. CAN 2.0A 和 2.0B\nCAN 2.0A 和 2.0B 是最基本的 CAN 标准，定义了 CAN\n总线上数据的帧格式、速率、物理层等特性，能够支持最高 1 Mbps\n的数据传输速率。其中，CAN 2.0A 标准采用 11\n位标识符（ID）进行帧的识别和过滤，而 CAN 2.0B 标准则采用 29\n位标识符进行帧的识别和过滤。\n2. ISO 11898-2\nISO 11898-2 是 CAN 总线的物理层规范，主要定义了 CAN\n总线在电气特性方面的规范，包括电压、电流、传输速率、传输距离等。此规范还定义了两根差分信号线（CAN_H\n和 CAN_L）以及地线的连接方式，以保证 CAN 总线的抗干扰能力和可靠性。\n3. ISO 11898-3\nISO 11898-3 是高速 CAN 总线的物理层规范，定义了在高速传输模式下 CAN\n总线的电气特性和信号波形。在该标准下，CAN 总线的最高传输速率可以达到 1\nMbps，传输距离可以达到 40 米。\n4. ISO 11898-4\nISO 11898-4 是低速 CAN 总线的物理层规范，定义了在低速传输模式下 CAN\n总线的电气特性和信号波形。在该标准下，CAN 总线的最高传输速率为 125\nKbps，传输距离可以达到 500 米。\n5. SAE J1939\nSAE J1939 是一种 CAN\n总线协议，主要用于商用车辆和重型机械设备的通信。它定义了 CAN\n总线上的数据格式、物理层、协议等方面的规范，能够实现多节点、高速、实时的数据交换。\n6. DeviceNet\nDeviceNet 是一种 CAN\n总线协议，主要用于工业自动化领域的设备通信。它定义了 CAN\n总线上的数据格式、物理层、协议等方面的规范，能够实现设备的控制和信息交换。'\n物理层标准\nISO 11898-2\n\n\n\n\n\n\n\n\n\nHigh-speed medium access unit:\n定义了 CAN\n的高速物理介质附件(HS-PMA)，广泛用于汽车行业的串行通信协议，支持分布式实时控制和多路传输。\nHS-PMA\n包括一个传输和一个接受实体。它应能够使连接的物理介质，即两线电缆，相对于公共接地偏压。发送单元在\nCAN_H 和 CAN_L 两根信号线上施加差分电压，以表示逻辑信号 0\n(dominant)，不施加差分电压时，表示逻辑信号 1\n(recessive)，这些信号将被连接在完全相同介质的其他节点所接收。这两个信号是物理介质相关子层的接口。\nHS-PMA 应当提供一个 AUI 给物理编码子层。它包括 TXD 和 RXD 信号以及\nGND。TXD 信号接受来自物理编码子层的 bit 流，并传输给 MDI。RXD 信号将来自\nMDI 的 bit 流发送给物理编码子层。\n\n\n\n\n\n\n\n\n\nAUI: attachment unit interface 附件单元接口\nMDI: media dependent interface 介质相关接口\n由一个或多个 HS-PMA\n组成的应用至少应支持正常功率运行模式。实现低功耗模式是可选的。\n\n\n\n\n\n\n\n\nOperating mode\nBus biasing behaviour\nTransmitter behavior\n\n\n\n\nNormal\nBus biasing active\nDominant or recessive\n\n\nLow-power\nBus biasing active or inactive\nRecessive\n\n\n\nHS-PMA 测试回路\nHS-PMA 输出 CAN 信号是由 CAN_H 和 CAN_L 实现的，TXD\n是传输数据输入，RXD\n是接收数据输出。下图展示的外围电路定义所有必需电压电流参数的测量条件。 表示 HS-PMA\n在网络中使用时的有效阻性负载（总线负载），代表可选的分立终端电容器。\n\n\nHS-PMA test circuit\n\n\n\n\n\n\n\n\n\n\n differential\nvoltage between CAN_H and CAN_L wires\n single ended\nvoltage on CAN_H wire\n single ended\nvoltage on CAN_L wire\n capacitive load\non RXD\n\n发送特性\n\n为了达到可接受的低射频发射水平，发送端应满足下表所要求的驱动信号对称性：\n\n发送端的最大输出电流的限制如下：\n\n表5详细说明了总线偏置激活时的隐性输出特性：\n\n表6详细说明了总线偏置未激活时的隐性输出特性：\n\nHS-PMA 可以限制显性传输的持续时间，防止 TXD\n因为故障持续输出显性，从而干扰其他节点的通信。HS-PMA\n应该在表7中指定的限制范围内实现超时：\n\n\n\n\n\n\n\n\n\n\n\n的最小值与最小的比特率之间存在一定的关系。 的最小值为 0.8\nms，bit 流大于或等于 21.6 kbit/s 时，可以容纳 17 个连续的显性位；当 bit\n流大于或等于 45.8 kbit/s 时，可以容纳 36 个连续的显性位。值 17 表明 PMA\n尝试发送一个显性位，并且每次在接收数据输入时都看到一个隐性电平。当前五次尝试的最后一位有位错误时，值\n36 反映连续 6 个错误帧。\n接收特性\n当 HS-PMA\n处于低功耗模式，并且总线偏置被激活时，隐性和显性状态的差分输入电压范围如表\n8 所示：\n\n当 HS-PMA\n处于低功耗模式，并且总线偏置未被激活时，隐性和显性状态的差分输入电压范围如表\n9 所示：\n\n接收机的输入阻抗\n\nHS-PMA 应该具有表 10 给出的输入阻抗：\n\n同时，内部阻抗应当满足表 11 的需求：\n\n发送和接收的时序特性\n时序参数应在 HS-PMA 的 RXD 输出和 TXD 输入以及 CAN_H 和 CAN_L\n之间的差压上测量。\n图 5 展示了如何测量信号轨迹中的时序：\n\nHS-PMA 的循环延时要求：\n\n\n\n\n\n\n\n\n\n\n从 TXD 输入端的信号边沿到 RXD\n输出端的下一个具有相同极性的信号边沿的时间跨度，需要考虑两个信号边沿的最大延迟。\n\n\n， 和  的最大额定值\n表 15 反映了静态电压的上下限，可以连接到 CAN_H 和 CAN_L\n而不造成损坏，而 \n则保持在其自身的最大额定值范围内。\n\nCAN_H 和 CAN_L 的最大漏电流\n没有供电的 HS-PMA 不应干扰连接到同一媒介的其他 HS-PMA\n的通信，最大漏电流的要求如表 16 所示：\n\n低功耗模式的唤醒\n当由一个或多个 HS-PMA 组成的网络实现低功耗模式时，HS-PMA\n应能够发出唤醒事件信号。表17列出了定义的 HS-PMA 类型所需的唤醒机制：\n\n当一个 HS-PMA 有多个唤醒机制时，这写唤醒机制必须可配置。\n基本的唤醒：\n当接收到一个持续时间至少为 \n的显性状态，就能够触发一个唤醒事件。\n唤醒模式唤醒：\n当连续接收到两个持续时间至少为 \n的显性状态，并被一个持续时间至少为 \n的隐性状态隔开时，将发生唤醒事件。\n选择唤醒：\n一旦检测到一个唤醒帧 (WUF)，将触发唤醒事件。在 CBFF 或 CEFF 中解码\nCAN 帧并接受为 WUF 是由 HS-PMA\n完成的。如果启用，在正常和低功耗模式下都可以解码 CAN 帧。\n在偏置反应时间  过去后，可以忽略\nCBFF 和 CEFF 中最多 4 帧(当比特率高于 500 kbit/s 时最多 8\n帧)，并且不能忽略 CBFF 和 CEFF 中的任何后续帧。\n在错误通信的情况下，HS-PMA\n应在内部错误计数器溢出时或溢出后发出唤醒信号。\n\n正常模式到低功耗模式转换时的行为\n\n如果在模式更改之前启用了选择性唤醒，并且 HS-PMA\n不再忽略帧，则在模式转换期间也应支持 CAN\n数据和远程帧的解码，这些模式转换启用了帧检测 IP。 如果接收到的帧是有效的\nWUF，则收发器应指示唤醒。 如果启用，CAN\n数据的解码应在正常和低功耗模式下实现。\n\n位解码\n\n当 CAN_H 和 CAN_L\n之间的差分电压时序符合以下两种信号之一时，接收到的经典 CAN\n帧应被正确解码:\n\nbit 流由信号形状A的多个实例组成 (用于处理振铃);\nbit 流可以由信号形状 B1\n的多个实例和信号形状B2的一个实例组装而成(以处理发送方时钟容差和仲裁损失)。\n\n\n\n唤醒帧\n\n如果满足以下所有条件，一个有效的典型 CAN 将被认为是一个有效的\nWUF：\n\n当 DLC 匹配未禁用时，接收到的帧是典型 CAN 数据帧。当 DLC\n匹配被禁用时，帧也可能是远程帧。\n接收到的典型 CAN 帧的 ID 与相关 bit 位的配置 ID (在HS-PMA中)\n完全匹配。相关 bit 的位置是由一个 ID 掩码给出的。\n接收到的典型 CAN 数据帧的 DLC 与配置的 DLC 完全匹配。这个 DLC\n匹配条件可以通过 HS-PMA 实现中的配置禁用。\n当 DLC 大于 0 且启用 DLC\n匹配时，接收到的帧的数据字段在对应于配置的数据掩码中的设置的 bit\n位置上至少设置了一位。\n收到正确的循环冗余校验 (CRC)，包括隐性 CRC 分隔符，并且在确认 (ACK)\n之前未检测到错误。图7描述了被认为是“不关心”的 bit。\n\n\n\n\n\n\n\n\n\n\nDLC: data length code\n\n\n帧错误计数机制\n\n在激活选择唤醒功能和  结束时，错误\nCAN 帧的计数器应设置为零。计数器的初始值为零。当检测到位填充、CRC 或 CRC\n分隔符形式错误时，该计数器将加1。如果已经接收到一个典型 CAN\n帧，并且计数器不为零，那么计数器将减1。在 CRC\n定界符和间歇字段结束之间的显性位不应增加帧错误计数器。\n在此计数器的每次递增或递减时，HS-PMA 中的解码器单元应等待 \n个隐性位，然后考虑一个显性位作为帧的开始。图8描述了在接收到典型 CAN\n帧和出现错误场景时，强制开始帧 (SOF) 检测的位置。\n\n当计数器达到阈值时，应立即或在下一次接收 WUP\n时进行唤醒。默认阈值是32，其他值可能是可配置的。\n在偏置反应时间  结束后开始的连续 4\n个(比特率&gt; 500 kbit/s时最多 8 个)的典型 CAN\n数据和远程帧可能被忽略(失败时错误计数器没有增加)或被判断为错误(即使没有错误，错误计数器也会增加)。\n接收带有非标称保留位 (SRR, r0)的 CEFF\n帧不会导致错误计数器的增加。\n\n唤醒帧 ID\n\n支持 CAN-ID 掩码机制，以在比较中排除 ID 位。支持 11 位和 29 位的\nCAN-ID 和 ID 掩码。用户选择 WUF 是否必须出现在 CBFF 或 CEFF 中。IDE\n位不是 ID 掩码的一部分。在任何情况下都要进行判别。\n除 \"don't care\" 外，所有被掩码的 ID 位都与配置的 ID\n位完全匹配。如果掩码 ID 位配置为 \"don't care\"，则 “1” 和 “0”\n都将被接受。\n\n\n唤醒帧 DLC\n\n如果启用了 DLC 匹配条件，则只有当接收帧的 DLC 与配置的 DLC\n完全匹配时，典型 CAN 帧才能是有效的 WUF。\n如果 DLC 匹配条件被禁用，则 DLC 和数据字段不被计算，当标识符匹配且\nCRC 正确时，典型 CAN 帧已经是有效的 WUF。\n\n唤醒帧的数据域\n\n如果启用了 DLC 匹配条件，则只有在接收到的 WUF\n的数据字段中至少有一个逻辑 1 位与配置的 WUF 中的数据字段的逻辑 1\n位匹配时，典型 CAN 帧才能是有效的 WUF。\n如果 DLC 匹配条件被禁用，则 DLC 和数据字段不被计算，当标识符匹配且\nCRC 正确时，典型 CAN 帧已经是有效的 WUF。\n\n使用该机制，只需一个唤醒帧就可以唤醒 64 个独立的 ECU 组。\n总线偏置 (Bus biasing)\n当 HS-PMA\n具有低功耗模式和选择性唤醒时，需要自动电压偏置。对于所有其他\nHS-PMA，应实现正常偏置或自动电压偏置。\n\n正常偏置\n\n正常偏置意味着总线偏置在正常模式下激活，在低功率模式下不激活。\n\n自动电压偏置\n\n自动电压偏置是指在正常模式下总线偏置是激活的，在低功耗模式下由 CAN_H\n和 CAN_L 之间的电压差控制。下面的状态机说明了这种机制。\n\n图 11 中的状态机定义了所有操作模式的总线偏置行为。进入状态 1\n时，可选定时器 \n复位并重新启动；当进入状态 3 或 4 时，定时器 \n复位并重新启动。\n表 20 指定了总线偏置控制时间，图 12 为偏置反应时间。\n\n\n数据链路层协议\nCAN 的特点\n（1） 多主控制\n当总线处于空闲状态时，所有的节点都可向总线发送消息。最先访问总线的节点可获得总线的发送权。当有多个节点同时向总线发送消息时，发送高优先级\nID 消息的节点可获得总线的发送权。\n（2）消息的发送\n在 CAN\n协议中，所有的消息都以统一的格式发送。总线处于空闲状态时，总线上的所有节点都可以向总线发送消息。当有多个节点同时向总线发送消息时，根据标识符\n（Identifier, ID) 决定优先级。ID\n并不是标识消息发送的目的地址，而是表示访问总线的消息的优先级。两个以上的节点同时开始发送消息时，对各个消息\nID\n的每个位进行逐个仲裁比较。仲裁获胜（被判定为优先级最高）的节点继续发送消息，仲裁失利的节点则立刻停止发送而进行接收工作。\n（3）系统的柔软性\n与总线相连的节点没有类似于“地址”的信息。因此在总线上增加节点时，连接在总线上的其它节点的软硬件及应用层都不需要做任何改变。\n（4）通信速度\n根据整个网络的规模，可设定合适的通信速度。在同一网络的中，所有的节点必须设定为统一的速度。即使有一个节点的通信速度与其它节点不同，该节点也将会输出错误信号，妨碍整个网络的通信。不同的网络则可以设置不同的通信速度。\n（5）远程数据请求\n可通过发送 “遥控帧” 请求其它节点发送数据。\n（6）错误检测功能·错误通知功能·错误恢复功能\n所有节点都可以检测错误（错误检测功能）。检测出错误的节点会立即通知其它所有节点（错误通知功能）。正在发送消息的节点一旦检测出错误，会强制结束当前的发送。强制结束发送的节点会不断重新发送此消息直到成功为止（错误恢复功能）。\n（7）故障封闭\nCAN\n可以判断出错误的类型是总线上暂时的数据错误（如外部噪声）还是持续的数据错误（如节点内部故障、驱动器故障、断线等）。由此功能，当总线上发生持续数据错误时，可将引起此故障的节点从总线上隔离出去。\n（8）连接\nCAN\n总线是可同时连接多个节点的总线。可连接的节点总数在理论上是没有限制的。但实际应用的过程中，可连接的节点数受总线上的时间延迟及电气负载的限制。降低通信速度，可连接的节点数增加；提高通信速度，则可连接的节点数减少。\nCAN 的错误\n错误的种类\n节点始终处于3 种状态之一。\n（1）主动错误状态\n主动错误状态是可以正常参加总线通信的状态。处于主动错误状态的节点检测出错误时，输出主动错误标志。\n（2）被动错误状态\n被动错误状态是易引起错误的状态。处于被动错误状态的节点虽然能够参加总线通信，但是为了不妨碍其它节点通信，接收时不能积极地发送错误通知。处于被动错误状态的节点即使检测出错误，而其它处于主动错误状态的节点如果没有发现错误，整个总线也被认为是没有错误的。处于被动错误状态的节点检测出错误时，输出被动错误标志。\n处于被动错误状态的节点在发送结束后不能立刻再次开始发送。在开始下次发送前，在间隔帧期间内必须插入\n“延迟传送”（8 个隐性位）\n（3）总线关闭态\n总线关闭态是不能参加总线上通信的状态。消息的接受和发送都是禁止的。\n\n\n\n\n\n\n\n\n\n这些状态依靠发送错误的计数和接收错误的计数来管理的，根据计数值决定进入那种状态。错误状态和计数值的关系如下：\n\n\n错误计算值\n发送错误计数值和接收错误计数值根据一定的条件发送变化。错误计数值的变动条件如下表所示。一次数据的接收和发送可能同时满足多个条件。错误计数器在错误标志的第一个位出现的时间点上开始计数。\n\n\n\n\n\n\n\n\n接受和发送错误计数值的变动条件\n发送错误计数值 (TEC)\n接收错误计数值 (REC)\n\n\n\n\n接收节点检测出错误时。例外：接收单元在发送错误标志或过载标志中检测出“位错误”时，接收错误计数值不增加。\n——\n+1\n\n\n接收节点在发送完错误标志后检测到的第一个位为显性电平时。\n——\n+8\n\n\n发送节点在输出错误标志时。\n+8\n——\n\n\n发送节点在发送主动错误标志或过载标志时，检测出位错误。\n+8\n——\n\n\n接收节点在发送主动错误标志或过载标志时，检测出位错误。\n——\n+8\n\n\n各节点从主动错误标志、过载标志的最开始检测出连续\n14 个位的显性位时。之后，每检测出连续的 8 个位的显性位时。\n发送时 +8\n接收时 +8\n\n\n检测出在被动错误标志后追加的连续 8\n个位的显性位时。\n发送时 +8\n接收时 +8\n\n\n发送单元正常发送数据结束时（返回 ACK\n且到帧结束也未检测出错误时）。\n-1 (TEC=0 时 )\n——\n\n\n接收单元正常接收数据结束时（到 CRC\n未检测出错误且正常返回 ACK 时）。\n——\n设\n\n\n处于总线关闭态的单元，检测到 128 次连续 11\n个位的隐性位。\nTEC=0\nREC=0\n\n\n\nCAN 协议\n帧的种类\n通信是通过以下 5 种类型的帧进行的。\n\n数据帧\n遥控帧\n错误帧\n过载帧\n帧间隔\n\n数据帧和遥控帧有标准格式和扩展格式两种格式。标准格式有11\n个位的标识符 (ID)，扩展格式有 29 个位的 ID。\n\n\n\n帧\n帧用途\n\n\n\n\n数据帧\n用于发送节点向接收节点传送数据的帧。\n\n\n遥控帧\n用于接收节点向具有相同 ID 的发送节点请求数据的帧。\n\n\n错误帧\n用于当检测出错误时向其它节点通知错误的帧。\n\n\n过载帧\n用于接收节点通知其尚未做好接收准备的帧。\n\n\n帧间隔\n用于将数据帧及遥控帧与前面的帧分离开来的帧。\n\n\n\n数据帧\n数据帧由 7 个段构成：\n\n帧起始：表示数据帧开始的段。\n仲裁段：表示该帧优先级的段。\n控制段：表示数据的字节数及保留位的段。\n数据段：数据的内容，可发送 0～8 个字节的数据。\nCRC 段：检查帧的传输错误的段。\nACK 段：表示确认正常接收的段。\n帧结束：表示数据帧结束的段。\n\n\n(1) 帧起始（标准、扩展格式相同）\n表示帧开始的段，1\n个位显性位。只有在总线空闲期间节点才能够发送 SOF.\n(2) 仲裁段\n表示数据优先级的段。\n标准帧有 11 位 ID，扩展帧有 29 位 ID。\nRTR 位：用于区分数据帧和遥控帧\n\n0：数据帧\n1：遥控帧\n\nIDE 位：用于区分标准帧和扩展帧\n\n0：标准帧\n1：扩展帧\n\nSSR 位：表明该位置代替了标准帧中的 RTR（无实际意义，SSR永远置 1）\n\n\n\n\n\n\n\n\n\n标准帧的 ID 有 11 个位。从 ID28 到 ID18 被依次发送。禁止高7\n位都为隐性。（禁止设定：ID=1111111XXXX）\n扩展帧的 ID 有 29 个位。基本 ID 从 ID28 到 ID18，扩展 ID 由 ID17 到\nID0 表示。基本 ID 和标准帧的 ID 相同。禁止高 7\n位都为隐性。（禁止设定：基本 ID=1111111XXXX）\n(3) 控制段\n控制段由 6\n个位构成，表示数据段的字节数。标准帧和扩展帧的构成有所不同。\n\n\n\n\n\n\n\n\n\n\n保留位（r0、r1）\n保留位必须全部以显性电平发送。但接收方可以接收显性、隐性及其任意组合的电平。\n数据长度码（DLC）\n数据长度码与数据的字节数的对应关系如下表所示。数据的字节数必须为 0～8\n字节。但接收方对 DLC = 9～15 的情况并不视为错误。\n\n\n(4) 数据场（标准帧和扩展帧相同）\n\n具有 0-8 个字节长度，由 DLC 确定\n包含 CAN 数据帧发送的内容\n\n(5) CRC 段（标准/扩展格式相同）\nCRC 段是检查帧传输错误的帧。由15 个位的 CRC 顺序和 1 个位的 CRC\n界定符（用于分隔的位）构成。\n\n\n\n\n\n\n\n\n\nCRC 顺序是根据多项式生成的 CRC 值，CRC\n的计算范围包括帧起始、仲裁段、控制段、数据段。\n接收方以同样的算法计算 CRC 值并进行比较，不一致时会通报错误。\n(6) ACK 段 ACK 段用来确认是否正常接收。由 ACK 槽\n(ACK Slot)和 ACK 界定符 2 个位构成。\n\n\n\n\n\n\n\n\n\n\n发送节点的ACK 段 发送节点在 ACK 段发送 2 个位的隐性位。\n接收节点的 ACK 段 接收到正确消息的节点在 ACK 槽(ACK\nSlot)发送显性位，通知发送节点正常接收结束。这称作“发送ACK”或者“返回ACK”。\n\n(7) 帧结束 帧结束是表示该该帧的结束的段。由 7\n个位的隐性位构成。\n遥控帧\n接收节点向发送节点请求发送数据所用的帧。遥控帧由 6\n个段组成。遥控帧没有数据帧的数据段。\n\n帧起始（SOF）：表示帧开始的段。\n仲裁段：表示该帧优先级的段。可请求具有相同 ID 的数据帧。\n控制段：表示数据的字节数及保留位的段。\nCRC 段：检查帧的传输错误的段。\nACK 段：表示确认正常接收的段。\n帧结束：表示遥控帧结束的段。\n\n\n\n\n\n\n\n\n\n\n\n遥控帧和数据帧\n\n数据帧和遥控帧的不同\n\n遥控帧的 RTR 位为隐性位，没有数据段\n没有数据的数据帧和遥控帧可通过 RTR 位来区分\n\n遥控帧没有数据段，数据长度码该如何表示？\n\n遥控帧的数据长度码以所请求数据帧的数据长度码表示。\n\n没有数据段的数据帧有何用途？\n\n可用于各节点的定期连接确认/应答、或仲裁段本身带有实质性信息的情况下。\n\n\n错误帧\n用于在接收和发送消息时检测出错误通知错误的帧。错误帧由错误标志和错误界定符构成。\n(1) 错误标志\n错误标志包括主动错误标志和被动错误标志两种。\n\n主动错误标志：6 个位的显性位。\n被动错误标志：6 个位的隐性位。\n\n(2) 错误界定符 错误界定符由 8\n个位的隐性位构成。\n\n\n\n\n\n\n\n\n\n\n\n主动错误标志：处于主动错误状态的节点检测出错误时输出的错误标志。\n被动错误标志：处于被动错误状态的节点检测出错误时输出的错误标志。\n\n过载帧\n过载帧是用于接收节点通知其尚未完成接收准备的帧。过载帧由过载标志和过载界定符构成。\n(1) 过载标志\n6 个位的显性位。\n过载标志的构成与主动错误标志的构成相同。\n(2) 过载界定符\n8 个位的隐性位。\n过载界定符的构成与错误界定符的构成相同。\n\n帧间隔\n帧间隔是用于分隔数据帧和遥控帧的帧。数据帧和遥控帧可通过插入帧间隔将本帧与前面的任何帧（数据帧、遥控帧、错误帧、过载帧）分开。\n过载帧和错误帧前不能插入帧间隔。\n\n(1) 间隔\n3 个位的隐性位。\n(2) 总线空闲\n隐性电平，无长度限制（0\n亦可）。本状态下，可视为总线空闲，要发送的节点可开始访问总线。\n(3) 延迟传送（发送暂时停止）\n8\n个位的隐性位。只在处于被动错误状态的节点刚发送一个消息后的帧间隔中包含的段。\n优先级仲裁\n在总线空闲态，最先开始发送消息的节点获得发送权。\n多个节点同时开始发送时，各发送节点从仲裁段的第一位开始进行仲裁。连续输出显性电平最多的节点可继续发送。\n\n(1) 数据帧何遥控帧的优先级\n具有相同 ID\n的数据帧和遥控帧在总线上竞争时，仲裁段的最后一位（RTR）为显性位的数据帧具有优先权，可继续发送。\n(2) 标准帧和扩展帧的优先级\n标准格式 ID 与具有相同 ID\n的遥控帧或者扩展格式的数据帧在总线上竞争时，标准格式的 RTR\n位为显性位的具有优先权，可继续发送。\n位填充\n位填充是为防止突发错误而设定的功能。当连续输出 5\n个相同极性的数据时，插入一个反极性的数据。\n\n(1) 发送节点的工作\n在发送数据帧和遥控帧时，SOF～CRC 段间的数据，输出 5\n个相同极性的电平，插入一个反极性的电平。\n(2) 接收节点的工作\n在接收数据帧和遥控帧时，SOF～CRC 段间的数据，如果接收连续 5\n个极性相同的位，则删除下一位，再继续接收。如果受到连续 6\n个相同极性的电平，将被视为错误并发送错误帧。\n错误的种类\n错误共有 5 种。多种错误可能同时发生。\n\n位错误\n填充错误\nCRC 错误\n格式错误\nACK 错误\n\n\n(1) 位错误\n\n位错误由向总线上输出数据帧、遥控帧、错误帧、过载帧的节点和输出 ACK\n的节点、输出错误的节点来检测。\n在仲裁段输出隐性电平，但检测出显性电平时，将被视为仲裁失利，而不是位错误。\n在仲裁段作为填充位输出隐性电平时，但检测出显性电平时，将不视为位错误，而是填充错误。\n发送单元在 ACK\n段输出隐性电平，但检测到显性电平时，将被判断为其它节点的 ACK\n应答，而非位错误。\n输出被动错误标志（6\n个位隐性位）但检测出显性电平时，将遵从错误标志的结束条件，等待检测出连续相同6\n个位的值（显性或隐性），并不视为位错误。\n\n(2) 格式错误\n\n即使接收节点检测出 EOF（7 个位的隐性位）的最后一位（第8\n个位）为显性电平，也不视为格式错误。\n即使接收节点检测出数据长度码 (DLC) 中 9∼15\n的值时，也不视为格式错误。\n\n错误帧的输出\n检测出满足错误条件的节点输出错误标志通报错误。\n处于主动错误状态的节点输出的错误标志为主动错误标志；处于被动错误状态的节点输出的错误标志为被动错误标志。\n发送节点发送完错误帧后，将再次发送数据帧或遥控帧。\n\n位时序\n由发送节点在非同步的情况下发送的每秒钟的位数称为位速率。一个位可分为\n4 段。\n\n同步段（SS）\n传播时间段（PTS）\n相位缓冲段1（PBS1）\n相位缓冲段2（PBS2）\n\n这些段又由可称为 Time Quantum（以下称为 Tq）的最小时间单位构成。\n1 位分为 4 个段，每个段又由若干个 Tq\n构成，这称为位时序。\n1 位由多少个 Tq 构成、每个段又由多少个 Tq\n构成等，可以任意设定位时序。通过设定位时序，多个节点可同时采样，也可任意设定采样点。\n\n\n\n\n\n\n\n\n\n\n\n采样点就是读取总线电平，并将读到的电平作为位值的点。\n同步方法\nCAN 协议的通信方法为 NRZ（Non-Return to\nZero）方式。各个位的开头或者结尾都没有附加同步信号。发送节点以与位时序同步的方式开始发送数据。另外，接收节点根据总线上电平的变化进行同步并进行接收工作。\n但是，发送节点和接收节点存在的时钟频率误差及传输路径上的（电缆、驱动器等）相位延迟会引起同步偏差。因此接收节点通过硬件同步或者再同步的方法调整时序进行接收。\n硬件同步\n接收节点在总线空闲状态检测出帧起始时进行的同步调整。\n在检测出边沿的地方不考虑 SJW 的值而认为是 SS 段。\n\n\n\n\n\n\n\n\n\nSJW: reSynchronization Jump Width 再同步补偿宽度\n\n再同步\n在接收过程中检测出总线上的电平变化时进行的同步调整。\n每当检测出边沿时，根据 SJW 值通过加长 PBS1 段，或缩短 PBS2\n段，以调整同步。但如果发生了超出 SJW 值的误差时，最大调整量不能超过 SJW\n值。\n\n调整同步的规则\n\n1 个位中只进行一次同步调整。\n只有当上次采样点的总线值和边沿后的总线值不同时，该边沿才能用于调整同步。\n在总线空闲且存在隐性电平到显性电平的边沿时，则一定要进行硬件同步。\n在总线非空闲时检测到的隐性电平到显性电平的边沿如果满足条件 (1) 和\n(2)，将进行再同步。但还要满足下面条件。\n发送节点观测到自身输出的显性电平有延迟时不进行再同步。\n发送节点在帧起始到仲裁段有多个单元同时发送的情况下，对延迟边沿不进行再同步。\n\n","slug":"Communication Protocol/CAN 总线","date":"2023-04-01T09:02:00.000Z","categories_index":"通信协议","tags_index":"CAN 总线","author_index":"爱慢跑的乌龟"},{"id":"5446d073459d8b66ad572b884caef029","title":"E96 系列电阻标称阻值","content":"E96系列电阻标称阻值\n\n\n\n\n\n\n","slug":"Electronic/E96系列电阻标称阻值","date":"2023-03-21T03:10:00.000Z","categories_index":"电子技术","tags_index":"阻值表","author_index":"爱慢跑的乌龟"},{"id":"f2d866e3599035768285c02ebfff1255","title":"STM32 定时器产生 PWM 波","content":"STM32 定时器产生 PWM 波\n对于 PWM\n波来说最重要的两个参数就是频率和占空比。频率是周期的倒数，占空比是指脉宽时间占周期的比例。微控制器产生\nPWM 波的原理是，定时器重复的从 0 计数到 ARR，设定比较值\nCCRx。当定时器的计数值向上计数到与 CCRx\n的值相等时，对应波形输出管脚电平翻转，当定时器计数值到 ARR\n时，输出管脚的电平再次发生翻转。定时器的一个计时周期对应一个 PWM\n周期，脉宽（高电平的宽度）需要根据输出管脚的初始电平不同，或者为 0~CCRx\n这一段，或者为 CCRx~ARR 这一段。改变 CCRx 的值即可实现脉宽的控制。PWM\n频率和占空比的影响因素有：\n\nARR：决定 PWM 周期（在系统时钟频率固定的情况下）\nCCRx：决定 PWM 占空比（高低电平所占整个周期比例）\n\n\nSTM32 的 TIM1 ~ TIM8 定时器，除了\nTIM6 和 TIM7 外的其他定时器都可以用来产生\nPWM 输出。高级定时器 TIM1 和\nTIM8 可以同时产生 7 路的 PWM\n输出。而通用定时器可以同时产生 4 路\nPWM。\n以通用定时器为例，这些定时器有 4\n个输出通道，每个通道都有一个捕获/比较寄存器，将寄存器，将寄存器值和计数器值比较，通过比较结果输出高低电平，实现\nPWM 信号输出。\n每个定时器只有一个计数器，但每个通道都有自己的捕获/比较寄存器，因此对于一个定时器来说，4\n路输出的 PWM\n频率（周期）是相同的，而不同通道的占空比可以是不同的。\n\n对 GPIO 和 TIM3 进行初始化：\nvoid TIM_Config(void){\n    GPIO_InitTypeDef GPIO_InitStructure;\n    \n    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE); // GPIOB 时钟打开\n    RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE); // TIM3 时钟打开\n    \n    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1;\n    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP; // 复用推挽输出\n    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; // 输出 50MHz\n    GPIO_Init(GPIOB, &amp;GPIO_InitStructure);\n}\n定时器 TIM3 配置：\nvoid TIM_Init(uint16_t arr, uint16_t duty){\n    TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure;\n    TIM_OCInitTypeDef TIM_OCInitStructure;\n    \n    TIM_DeInit(TIM3);\n    TIM_TimeBaseStructure.TIM_Period = arr - 1;\t// 自动重装载寄存器的值\n    TIM_TimeBaseStructure.TIM_Prescaler = 1; // 时钟预分频数\n    TIM_TimeBaseStructure.TIM_ClockDivsion = 0x0; // 采样分频\n    TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;\n    TIM_TimeBaseInit(TIM3, &amp;TIM_TimeBaseStructure);\n    \n    TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1; // TIM 的 PWM1 模式\n    TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;\n    TIM_OCInitStructure.TIM_Pulse = duty; // 设置占空比\n    TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High; // TIM 输出比较极性高\n   \tTIM_OC4Init(TIM3, &amp;TIM_OCInitStructure);\n    \n    TIM_OC4PreloadConfig(TIM3, TIM_OCPreload_Enable); // 使能定时器 TIM3 在 CCR3 上的预装在寄存器\n    TIM_ARRPreloadConfig(TIM3, ENABLE); // 使能定时器 TIM3 在 ARR 上的预装载寄存器\n    TIM_Cmd(TIM3, ENABLE); // 使能定时器3\n}\n计数模式：\n\nCubeMX 配置计时器：\n\n定时器的开关函数：\nHAL_TIM_Base_Start_IT(&amp;htim2); // 开启定时器及溢出中断\nHAL_TIM_Base_Stop_IT(&amp;htim2); // 关闭定时器及溢出中断\nHAL_TIM_Base_Strat(&amp;htim2); // 开启定时器（不开启中断）\nHAL_TIM_Base_Stop(&amp;htim2); // 关闭定时器\nPWM 配置：\n\n\n\n\nPrescaler 预分频系数：等待多少个时钟周期增加一次计数\nCounter Model 计数模式：向上、向下或者中间对齐等\nCounter Period 计数周期：重新开始计数前所要计数的最大数量\nInternal Clock Division 内部时钟分频：另一种时钟分频方法\nauto-reload-preload\n自动重装载：当计数达到最大时，重新启动计数器\n\n\n\n\n\n\n\n\n\n\nCalculate the PWM frequency\n\nSystem Clock is 72 MHz: We can \"count\" 72-million times each\nsecond\n8-bit resolution(0-255): Each cycle is 256 \"counts\"\n\n\nPWM frequency = 218250 Hz\n\n\nMode 模式：PWM1 、PWM2\n\n\n\n模式\n计数器 CNT 计数方式\n说明\n\n\n\n\nPWM1\n递增\nCNT&lt;CCR，通道 CH 为有效，否则为无效\n\n\n\n递减\nCNT&gt;CCR，通道 CH 为无效，否则为有效\n\n\nPWM2\n递增\nCNT&lt;CCR，通道 CH 为无效，否则为有效\n\n\n\n递减\nCNT&gt;CCR，通道 CH 为有效，否则为无效\n\n\n\nPulse 占空比：Counter Periode 之间的一个数\n\nHAL 库代码：\n#include \"stm32f1xx_hal.h\"\n\nTIM_HandleTypeDef htim2;\n\nvoid SystemClock_Config(void);\nvoid Error_Handler(void);\n\nvoid PWM_Init(void)\n{\n    TIM_OC_InitTypeDef sConfigOC;\n\n    htim2.Instance = TIM2;\n    htim2.Init.Prescaler = 7199;\n    htim2.Init.CounterMode = TIM_COUNTERMODE_UP;\n    htim2.Init.Period = 999;\n    htim2.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;\n    if (HAL_TIM_PWM_Init(&amp;htim2) != HAL_OK)\n    {\n        Error_Handler();\n    }\n\n    sConfigOC.OCMode = TIM_OCMODE_PWM1;\n    sConfigOC.Pulse = 499;\n    sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;\n    sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;\n    if (HAL_TIM_PWM_ConfigChannel(&amp;htim2, &amp;sConfigOC, TIM_CHANNEL_1) != HAL_OK)\n    {\n        Error_Handler();\n    }\n\n    HAL_TIM_MspPostInit(&amp;htim2);\n}\n\nint main(void)\n{\n    HAL_Init();\n    SystemClock_Config();\n\n    __HAL_RCC_GPIOA_CLK_ENABLE();\n    GPIO_InitTypeDef GPIO_InitStruct;\n    GPIO_InitStruct.Pin = GPIO_PIN_0;\n    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;\n    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;\n    HAL_GPIO_Init(GPIOA, &amp;GPIO_InitStruct);\n\n    PWM_Init();\n\n    HAL_TIM_PWM_Start(&amp;htim2, TIM_CHANNEL_1);\n\n    while (1)\n    {\n    }\n}\n修改频率:\n可以通过修改预分频器（Prescaler）和计数周期（Period）的值来改变 PWM\n信号的频率。\n例如，假设你希望生成 1 kHz 的 PWM 信号：\nhtim2.Init.Prescaler = 71;\nhtim2.Init.Period = 999;\n","slug":"MCU/STM32-PWM","date":"2023-02-13T10:57:00.000Z","categories_index":"单片机","tags_index":"STM32,PWM","author_index":"爱慢跑的乌龟"},{"id":"927bf395dd3f4c1ed23a8c2f2923f289","title":"脉冲宽度调制 PWM","content":"脉冲宽度调制 PWM\n\n\n\n\n\n\n\n\n\n脉宽调制(PWM)\n或脉冲持续时间调制(PDM)是一种通过有效地将电信号分成离散部分来降低电信号传输的平均功率的方法。馈送到负载的电压（和电流）的平均值通过快速打开和关闭电源与负载之间的开关来控制。同关断周期相比，开关开启的时间越长，提供给负载的总功率就越高。PWM\n特别适用于运行惯性负载，例如电机看，这些负载不容易受到这种离散开关的影响，因为它们的惯性导致它们反应缓慢。PWM\n开关频率必须足够高，以不影响负载，也就是说，负载感知到的合成波形必须尽可能平滑。\n占空比 Duty cycle\n占空比是指“开启”时间与固定间隔时间（周期）的比例；低占空比对应于低功率，因为电源大部分时间都是关闭的。占空比以百分比表示，100%表示完全开启。当数字信号在一半时间打开，另一半时间关闭时，数字信号的占空比为\n50%，类似于“方波”。\n\n\n占空比 Duty cycle\n\n原理 Principle\n脉宽调制使用矩形脉冲波，调制其脉冲宽度，导致波形平均值发生变化。如果我们考虑一个脉冲波形，其周期为 、最小值为 、最大值为  以及占空比 ，则其波形的平均值为：  因为  是脉冲波，当\n 时，其值为 ；当  时，其值为 ，上式可写为：  其中，，。因此，信号的平均值直接取决于占空比 。\n生成 PWM\n信号的最简单方法时交叉方法，它只需要一个锯齿波或三角波和一个比较器。当参考信号（红色正弦波）的值大于调制波形（蓝色）时，PWM\n信号（洋红色）处于高电平状态，否则处于电平状态。\n\n\nSPWM\n\nSimulink 生成 SPWM波\n\n正弦波\n\n它是基频(逆变器输出电压所需的频率)上的参考信号。\n\n锯齿波\n\n它是高频载波。\n\n参考波与载波相比较\n当 参考波 &gt; 载波，输出为高；当 参考波 &lt; 载波，输出为低。\n\n\n三个正弦波信号发生器，频率均为 ，相位相差\n120°。一个锯齿波信号发生器，其频率为 1000 Hz，相位是 180°。\n\n正弦波与锯齿波信号比较，生成 SPWM 信号：\n\n","slug":"Control/脉冲宽度调制 PWM","date":"2023-02-12T07:48:00.000Z","categories_index":"自动控制","tags_index":"PWM","author_index":"爱慢跑的乌龟"},{"id":"d97c1a68285e6aac869410b1223c6673","title":"矩阵的导数运算(1)","content":"矩阵的导数运算 (1)\n标量方程对向量的导数：\n定义： \n\n - 标量 []\n\n- 向量 []\n\n\n\n\n\n\n\n\n\n\n求导结果的行数与分母相同，称为分母布局(Denominator\nLayout)\n\n\n\n\n\n\n\n\n\n\n行数和分子相同，称为分子布局(Numerator Layout)\n例\n\n\n\n\n\n\n\n\n\n，\n\n分母布局\n\n分子布局\n向量方程对向量的导数\n\n\n 分母布局\n常用特例\n若 ,\n, 则 \n\n若 ,\n , 则 .\n当 A 为对称矩阵时，, \n\n\n\n\n\n\n\n\n\n : 二次型\n","slug":"Math/矩阵的导数运算1","date":"2023-02-10T08:37:00.000Z","categories_index":"数学","tags_index":"矩阵求导","author_index":"爱慢跑的乌龟"},{"id":"c3a5445bafc67228b7830b43d89f077b","title":"STM32 GPIO","content":"STM32 GPIO\nGPIO 功能描述\nGPIO 的寄存器包括：\n\n2 个 32-bit 配置寄存器 GPIOx_CRL GPIO_CRH\n2 个 32-bit 数据寄存器 GPIOx_IDR GPIOx_ODR\n1 个 32-bit 置位/复位寄存器 GPIOx_BSRR\n1 个 16-bit 复位寄存器 GPIOx_BRR\n1 个 32-bit 锁定寄存器 GPIOx_LCKR\n\nGPIO 的每个端口可以通过软件配置以下几种模式：\n\nInput floating\nInput pull-up\nInput-pull-down\nAnalog\nOutput open-drain\nOutput push-pull\nAlternate function push-pull\nAlternate function open-drain\n\nI/O 端口位的基本结构：\n\n模式配置：\n\n\n\n\nMODE[1:0]\nMeaning\n\n\n\n\n00\nReserved\n\n\n01\nMaximum output speed 10 MHz\n\n\n10\nMaximum output speed 2 MHz\n\n\n11\nMaximum output speed 50 MHz\n\n\n\n通用 I/O\n在复位期间和复位后，复用功能不激活，I/O\n端口配置位浮动输入模式(CNFx[1:0] = 01b，MODEx[1:0] = 00b)。\n当配置为输出时，写入输出数据寄存器(GPIOx_ODR)的值在 I/O\n引脚上输出。可以在推挽模式或开漏模式(N-MOS 被激活)下使用输出驱动器。\n输入数据寄存器(GPIOx_IDR)在每个 APB2 时钟周期时捕获每个 I/O\n引脚上的数据。\n所有的 GPIO\n引脚都有一个内部弱上拉或弱下拉，当配置为输入模式时，可以选择激活或不激活。\n原子位置位或重置\n在对 GPIOx_ODR 进行按位操作时，软件不需要禁用中断：可以在单原子 APB2\n写访问中只修改一个或几个位。这是通过将置位/复位寄存器(GPIOx_BSRR)的位置\n1，来选择要选择要修改的位来实现。未选择的位不会修改。\n复用功能(AF)\n在使用默认的复用功能之前，有必要对端口位配置寄存器进行编程。\n\n对于复用功能输入，端口必须配置为输入模式（浮动、上拉或下拉），输入引脚必须外部驱动。\n对于复用功能输出，端口必须配置为复用功能输出模式（推挽或开漏）。\n对于双向复用功能，端口必须配置为复用功能输出模式（推挽或开漏）。在这种情况下，输入驱动程序配置浮动输入模式。\n\n如果端口位配置为复用功能输出，则断开输出寄存器并将引脚连接到片上外设的输出信号。\n如果软件将 GPIO\n引脚配置为复用功能输出，但是外设未激活，则不指定其输出。\nI/O 复用功能的软件重映射\n为了优化不同设备包的外设 I/O\n功能数量，可以将一些复用功能映射到其它的引脚上。这是通过软件实现的，通过编程相应的寄存器(AFIO)。\nGPIO 锁定机制\n锁定机制允许 IO 配置被冻结。当 LOCK\n序列被应用于端口时，在下一次重置前，不可能再修改端口位的值。\n输入配置\n当 I/O 口被配置为输入模式时：\n\n输出缓存区被禁用\n施密特触发器输入被激活\n弱上拉电阻和弱下拉电阻激活与否取决于输入模式配置（浮动、上拉或下拉）\n每个 ABP2 时钟周期，I/O 引脚上的数据被采样到输入数据寄存器中\n对输入数据寄存器进行访问以获得 I/O 状态。\n\n\n输出配置\n当 I/O 口被配置为输出模式时：\n\n输出缓冲区被激活\n\n开漏模式: 输出寄存器中的 “0” 激活 N-MOS，而输出寄存器中的 “1” 在\nHi-Z 中离开端口(P-MOS从未激活)\n推挽模式: 输出寄存器中的 “0” 激活 N-MOS，而输出寄存器中的 “1”\n激活P-MOS\n\n施密特输入触发器被激活\n弱上拉和下拉电阻被禁用\n每个 APB2 时钟周期，I/O 引脚上的数据被采样到输入数据寄存器中\n通过读输入寄存器以获得开漏模式下的\nI/O 状态\n通过读输出寄存器以获得推挽模式下最后写入的值\n\n\n复用功能配置\n当 I/O 配置为复用功能时：\n\n输出缓存区在开漏或推挽模式下启用\n输出缓存区由来自外设的信号驱动\n施密特触发输入被激活\n弱上拉和下拉电阻被禁用\n每个 APB2 时钟周期，I/O 引脚上的数据被采样到输入数据寄存器中\n通过读输入寄存器以获得开漏模式下的\nI/O 状态\n通过读输出寄存器以获得推挽模式下最后写入的值\n\n\n模拟量配置\n当 I/O 配置为模拟量时：\n\n输出缓冲区被禁用\n施密特触发输入被停用，为 I/O\n引脚的每个模拟值提供零消耗。施密特触发器的输出被强制为恒定值(0)\n弱上拉和下拉电阻被禁用\n对输入数据寄存器的读访问获得值 “0”\n\n\nGPIO 寄存器\n外设寄存器必须通过 words (32位)来访问。\n端口配置寄存器 低 (GPIOx_CRL)\nAddress offset: 0x00\nReset value: 0x4444 4444\n\n端口配置寄存器 高 (GPIOx_CRH)\nAddress offset: 0x04\nReset value: 0x4444 4444\n\nMODEy[1:0]: Port (A..G) 配置位(y=0..15)\n\n00 - Input mode (reset state)\n01 - Output mode，max speed 10 MHz\n10 - Output mode，max speed 2 MHz\n11 - Output mode，max speed 50 MHz\n\nCNFy[1:0]: Port (A..G) 配置位(y=0..15)\nIn input mode (MODE[1:0]=00):\n\n00 - Analog mode\n01 - Floating inpurt (reset state)\n10 - Input with pull-up / pull-down\n11 - Reserved\n\nIn output mode (MODE[1:0]&gt;00):\n\n00 - General purpose output push-pull\n01 - General purpose output Open-drain\n10 - Alternate function output Push-pull\n11 - Alternate function output Open-drain\n\n端口输入寄存器 (GPIOx_IDR)\nAddress offset: 0x08h\nReset value: 0x0000 XXXX\n\nIDRy: Port (A..G) 输入数据(y=0..15)\n这些位是只读的，只能在 Word 模式下访问。它们包含相应 I/O\n端口的输入值。\n端口输出寄存器 (GPIOx_ODR)\nAddress offset: 0x0C\nReset value: 0x0000 0000\n\nODRy: Port (A..G) 输出数据(y=0..15)\n这些位可以通过软件读写，并且只能在 Word 模式下访问。\n端口位置位/复位寄存器\n(GPIOx_BSRR)\nAddress offset: 0x10\nReset value: 0x0000 0000\n\nBRy: Port (A..G) Reset bit y (y= 0 .. 15)\n这些位是只写的，只能在 Word 模式下访问\n\n0 - 对相应的 ODRx 位没有任何操作\n1 - 重置相应的 ODRx 位\n\nBSy: Port (A..G) Set bit y (y= 0 .. 15)\n这些位是只写的，只能在 Word 模式下访问\n\n0 - 对相应的 ODRx 位没有任何操作\n1 - 设置相应的 ODRx 位\n\n端口位复位寄存器 (GPIOx_BRR)\nAddress offset: 0x14\nReset value: 0x0000 0000\n\nBRy: Port (A..G) Reset bit y (y= 0 .. 15)\n这些位是只写的，只能在Word模式下访问。\n\n0 - 对相应的 ODRx 位没有任何操作\n1 - 重置相应的 ODRx 位\n\n端口配置锁寄存器 (GPIOx_LCKR)\n当一个正确的写序列被应用到第 16\n位(LCKK)时，该寄存器用于锁定端口的配置。Bits[15:0] 用于锁定 GPIO\n的配置。在写序列期间，LCKR[15:0] 的值不能改变。如果 LOCK\n序列已经应用于端口位，则在下一次复位之前，不能再修改端口位的值。\n每个锁位冻结相应的 4 位控制寄存器 (CRL, CRH)。\nAddress offset: 0x18\nReset value: 0x0000 0000\n\nLCKK[16]: Lock key\n这个位可以随时读取。它只能使用 Lock Key Writing Sequence\n进行修改。\n\n0 - 端口配置锁密钥未激活\n1 - 端口配置锁键激活。GPIOx_LCKR\n寄存器被锁定，直到下一次复位。\n\nLCKy: Port (A..G) Lock bit y (y= 0..15)\n这些位是可读写的，但只有当 LCKK 位为 0 时才能写入\n\n0 - 端口配置未锁定\n1 - 端口配置已锁定\n\nAFIO 寄存器\n\n\n\n\n\n\n\n\n\n要读/写 AFIO_EVCR、AFIO_MAPR 和 AFIO_EXTICRX 寄存器，必须首先使能\nAFIO 时钟。\n事件控制寄存器 (AFIO_EVCR)\nAddress offset: 0x00\nReset value: 0x0000 0000\n\nEVOE: 事件输出使能\n由软件设置或清除。置位时，EVENTOUT Cortex® 输出连接到由\nPORT[2:0] 和 PIN[3:0] 位选择的 I/O。\nPORT[2:0]: 端口选择\n通过软件设置和清除。选择用于输出 Cortex® EVENTOUT 信号的端口。\n\n\n\n\n\n\n\n\n\nEVENTOUT信号输出能力不扩展到 PF 和 PG 端口\n\n000 - PA\n001 - PB\n010 - PC\n011 - PD\n100 - PE\n\nPIN[3:0]: 引脚选择 (A..E)\n通过软件设置和清除。选择用于输出 Cortex® EVENTOUT 信号的引脚。\n\n0000 - Px0\n0001 - Px1\n...\n1111 - Px15\n\n复用功能重映射和调试\nI/O 配置寄存器 (AFIO_MAPR)\nAddress offset: 0x04\nReset value: 0x0000 0000\n\n外部中断配置寄存器 1\n(AFIO_EXTICR1)\nAddress offset: 0x08\nReset value: 0x0000\n\nEXTIx[3:0]: EXIT (0..3) 配置\n这些位由软件写入以选择 EXTIx 外部中断的输入引脚。\n\n0000 - PA[x] pin\n0001 - PB[x] pin\n0010 - PC[x] pin\n0011 - PD[x] pin\n0100 - PE[x] pin\n0101 - PF[x] pin\n0110 - PG[x] pin\n\n外部中断配置寄存器 2\n(AFIO_EXTICR2)\nAddress offset: 0x0C\nReset value: 0x0000\n\nEXTIx[3:0]: EXIT (4..7) 配置\n这些位由软件写入以选择 EXTIx 外部中断的输入引脚。\n\n0000 - PA[x] pin\n0001 - PB[x] pin\n0010 - PC[x] pin\n0011 - PD[x] pin\n0100 - PE[x] pin\n0101 - PF[x] pin\n0110 - PG[x] pin\n\n外部中断配置寄存器 3\n(AFIO_EXTICR3)\nAddress offset: 0x10\nReset value: 0x0000\n\nEXTIx[3:0]: EXIT (8..11) 配置\n这些位由软件写入以选择 EXTIx 外部中断的输入引脚。\n\n0000 - PA[x] pin\n0001 - PB[x] pin\n0010 - PC[x] pin\n0011 - PD[x] pin\n0100 - PE[x] pin\n0101 - PF[x] pin\n0110 - PG[x] pin\n\n外部中断配置寄存器 4\n(AFIO_EXTICR4)\nAddress offset: 0x14\nReset value: 0x0000\n\nEXTIx[3:0]: EXIT (12..15) 配置\n这些位由软件写入以选择 EXTIx 外部中断的输入引脚。\n\n0000 - PA[x] pin\n0001 - PB[x] pin\n0010 - PC[x] pin\n0011 - PD[x] pin\n0100 - PE[x] pin\n0101 - PF[x] pin\n0110 - PG[x] pin\n\n复用功能重映射和调试\nI/O 配置寄存器 2 (AFIO_MAPR2)\nAddress offset: 0x1C\nReset value: 0x0000 0000\n\n","slug":"MCU/STM32-GPIO","date":"2022-10-11T07:47:00.000Z","categories_index":"单片机","tags_index":"STM32 GPIO","author_index":"爱慢跑的乌龟"},{"id":"51d61b1e82665e319117cf3815ca2bc7","title":"Amesim 与 Simulink 的联合仿真","content":"Amesim 与 Simulink\n的联合仿真\n环境配置\n软件版本为：Matlab 2020b 和\nAmesim 2021.1，编译器使用 MinGW-w64\n附件安装：\n首先需要在 Matlab 中安装附件\nMATLAB Support for MinGW-w64 C/C++ Compiler\n\n\n点击进入安装即可。\n安装完成后，在命令行输入：\n\nmex -setup\nmex -setup C++\n\n\n环境变量配置（关键）\n路径： 此电脑 - 属性 - 高级系统设置 - 高级 - 环境变量 -\n系统变量\n\n\n\n\n\n\n\n变量名\n变量值\n\n\n\n\nAME\nD:\\tool\\Simcenter\\2021.1\\Amesim\n\n\nGCC_HOME\nD:\\Program Files\\Polyspace\\R2020b\\extern\\lib\\win64\\mingw64\n\n\nMATLAB\nD:\\Program Files\\Polyspace\\R2020b\n\n\nMW_MINGW64_LOC\nC:\\ProgramData\\MATLAB\\SupportPackages\\R2020b\\3P.instrset\\mingw_w64.instrset\n\n\n\nPath：\n\n\nAmesim 编译器选择\n路径： Tools - Preference - Compliation - Active\ncomplier\n\n联合仿真接口使用\n路径：Interfaces - Create interface block...\n\n\n完成 Amesim 草图之后，编译模型，编译细节如下：\n\n点击 Run simulation：\n\n再点击 Simulink，系统将会自动打开 Matlab 并启动\nSimulink。\n在 Simulink Libaray 的 User-Defined Functions 中找到\nS-Function 模块：\n\nS-Function 模块的参数设置：\n\nSimulink interface\n两个接口\nSimcenter Amesim-Simulink 和 Simulink-Simcenter Amesim 接口可以结合\nSimcenter Amesim 和 Simulink 模型执行仿真。\n由于涉及两个软件包，接口提供了两个主要选项：将 Simcenter Amesim 模型导入\nSimulink，或将 Simulink 模型导入 Simcenter Amesim。\n通过 Simcenter Amesim-Simulink 界面，用户可以选择这两种方法。\n除了这两种方法之外，还可以将 Simcenter Amesim 求解器（带有 Simcenter\nAmesim 模型）导出到 Simulink。\n这有时称为协同仿真，因为我们使用两个软件包中的求解器，它们一起执行仿真。\n如何选择我需要的接口？\n这个问题没有单一的答案。答案取决于很多事情。有些 Simcenter Amesim\n系统很难或不可能使用 Simulink\n求解器求解。如果是这种情况，那么用户需要选择协同仿真。这意味着将同时使用\nSimcenter Amesim 和 Simulink 求解器，并且每个人都将负责自己的部分。\n有时 Simulink 系统非常复杂，将其导入 Simcenter Amesim\n可能不是最佳解决方案，因为它会强制使用 Simulink\n固定步长求解器，这有时并不合适。\n除了技术原因之外，还必须考虑模型的用途。如果主要目的是测试/开发\nSimcenter Amesim 模型，则将 Simulink 模型导入 Simcenter Amesim\n可能是最佳策略。如果主要目的是使用在 Simcenter Amesim 中编写的物理模型在\nSimulink 中测试/开发控制器，那么在 Simulink\n中工作显然是一个更好的主意。\n在许多情况下，一个人开发 Simulink 模型，另一个人开发 Simcenter Amesim\n模型。负责整合模型的人显然更喜欢在“他的”环境中工作。\n有一些明显的“规则”：如果 Simulink 模型很小，而 Simcenter Amesim\n模型很大，则可以将 Simulink 模型放入 Simcenter Amesim。如果需要访问\nSimcenter Amesim 中的独特功能，您还可以将 Simulink 模型放入 Simcenter\nAmesim。如果您需要使用 MATLAB® /Simulink 中的特殊功能，您可以将\nSimcenter Amesim 模型放入 Simulink。\nSupported Simulink Interface\nmodes\n\n\n\n\n\n\n\nEnvisaged interface mode\nSupported\n\n\n\n\n1.1 Co-simulation in Simcenter Amesim: Simcenter\nAmesim as Master (Simulink as Slave)\n\n(SL2AMECosim)\n\n\n2.1 Co-simulation in Simulink: Simcenter Amesim as\nSlave (Simulink as Master)\n\n(AME2SLCosim)\n\n\n2.2 Model Exchange: Export of Simcenter Amesim\nmodel into Simulink\n (AME2SL)\n\n\n\n\n对于 SL2AMECosim，请注意，一旦将\nSimulink 模型导入 Simcenter\nAmesim，就不再需要 Simulink\n来运行仿真（也不需要 Simulink 许可证）。\n在 SL2AMECosim 中，嵌入式 Simulink\n求解器始终为固定步长类型。 支持 Simulink\n模型引用。\n对于 Simulink（AME2SL 或\nAME2SLCosim）中的模型交换或联合仿真，Simcenter\nAmesim 模型（带或不带求解器）导出为\nS-Function\n此模式符合黑盒选项。\n\n\n\n\nmultiple Simulink interfaces\n\n如果 Simcenter Amesim 是目标环境，则接口模块是完全独立的（Simcenter\nAmesim 将其视为标准子模型）。 因此，在同一个 Simcenter Amesim\n草图上混合不同块类型或设置的可能性在理论上是不受限制的。\n可以在单个 Simcenter Amesim 系统中使用多个 Simulink\n模型（反之亦然），但不能在单个 Simcenter Amesim 系统中多次使用同一个\nSimulink 模型（反之亦然）。\n目标环境中使用的块与独立系统一样多。\n\n\n\n\n\n\n\n\nCapability\nSupported interface modes for blocks\n\n\n\n\nUse  Simulink\nblocks in Simcenter Amesim\nCo-simulation (SL2AMECosim): Simcenter\nAmesim as Master (Simulink as Slave)\n\n\nUse  Simulink\nblocks with different solver types (variable/fixed-step) or solver\nsettings in Simcenter Amesim\nCo-simulation (SL2AMECosim): Simcenter\nAmesim as Master (Simulink as Slave)\n\n\nUse  Simcenter\nAmesim blocks in Simulink\nCo-simulation (AME2SLCosim): Simcenter\nAmesim as Slave (Simulink as Master)\n\n\n\nModel Exchange (AME2SL): Export of\nSimcenter Amesim model into\nSimulink\n\n\n\nBoth Co-simulation (AME2SLCosim): Simcenter\nAmesim as Slave (Simulink as Master) and Model\nExchange (AME2SL): Export of Simcenter\nAmesim model into Simulink\n\n\nUse  Simcenter\nAmesim blocks with different solver types (variable/fixed-step)\nor solver settings in Simulink\nCo-simulation (AME2SLCosim): Simcenter\nAmesim as Slave (Simulink as Master)\n\n\n\n\n在 SL2AMECosim\n中，求解器类型始终为固定步长，但设置（例如步长）可以不同\n其中一些模型交换块可以是黑盒类型。\n\n依赖\n编译器：\n\nThe Simcenter Amesim to Simulink\ninterface for Simcenter Amesim 2021.1 has been\nextensively tested using MATLAB/Simulink R2015b and\nR2020b. All releases between these two versions should work.\n","slug":"Amesim/Amesim与Simulink联合仿真","date":"2022-09-28T07:12:00.000Z","categories_index":"Amesim","tags_index":"Amesim,Simulink","author_index":"爱慢跑的乌龟"},{"id":"5badb916fa8f30fce64229fc7b4b0982","title":"Python 的深拷贝和浅拷贝","content":"Python 的深拷贝和浅拷贝\na &#x3D; [1, 2, 3, [1, 2, 3, [4, 5]]]\nb &#x3D; a\n当使用赋值运算符 =，a 和 b\n两个变量指向的同一个地址：\n\na &#x3D; [1, 2, 3, [1, 2, 3, [4, 5]]]\nc &#x3D; a.cope()\n当列表具有多层时，copy()\n仅拷贝一层(浅拷贝)，而深层的列表依然指向原列表的地址：\n\n修改第一层列表的值并不会影响原有列表，但是修改深层列表的原有列表：\nc[3][0] &#x3D; 10\n\n若要完全拷贝(深拷贝)多层列表 a，则需要使用\ncopy 库中的 deepcopy() 函数实现：\nimport copy\nd &#x3D; copy.deepcopy(a)\n\n此时，对于 列表 d 的修改不会对原有列表 a 产生任何影响。\n\n\n\n\n\n\n\n\n\nPython\n中的拷贝仅对于可变量如列表、字典等，而不可变的量如常量、元组等，则没有拷贝的属性。\n","slug":"Pyhon/深拷贝与浅拷贝","date":"2022-09-27T11:01:00.000Z","categories_index":"Python","tags_index":"Python tips","author_index":"爱慢跑的乌龟"},{"id":"c1235f99efb341252757b2cde16e8265","title":"AD20 使用笔记","content":"AD20 使用笔记\n网格设置\nAltium Designer 20 一共有 3 种栅格：Grids、Gudies 和 Axes。\nGrids 是最常用的普通栅格。\nGrids 栅格的设置有：\n\nG 键设置栅格大小\n\n\n\nCtrl + G 设置栅格属性\n\n\n\n自定义区域栅格\n\n\n\n栅格捕捉开关：\n\nGuides\n栅格用于捕捉我们放置的向导线(参考线)或点，如果没有放置是不起作用的。\n矩阵区域内排列\nAlt + A\n\n交叉选择模式\nShift + Ctrl + X\n\nPCB 设计规则管理器\n\n规则约束共 10 大类：\n电气规则：包含间距、短路、开路等。\n信号线规则：线宽、过孔、差分线、扇孔等。\n贴片规则、阻焊规则、铺铜规则、测试点规则、生产部分规则、高速部分规则、放置器件的规则\n和 信号完整性分析的规则\n常用规则\n\n安全间距（最小线间距）（6 mil)\n\n一般最小间距为 3.5-6mil\n\n\n线宽（6 mil)\n\n电流与线宽之间的关系： \n\n -\n修正系数,一般覆铜线在内层时取 0.024，在外层时取 0.048;\n - 最大温升 [℃]\n - 铜线的截面积 []\n\n\n印制导线最大允许工作电流（导线厚 50um，允许温升 10 ℃）\n\n\n\n\n导线宽度（Mil）\n导线电流（A）\n\n\n\n\n10\n1\n\n\n15\n1.2\n\n\n20\n1.3\n\n\n25\n1.7\n\n\n30\n1.9\n\n\n50\n2.6\n\n\n75\n3.5\n\n\n100\n4.2\n\n\n200\n7.0\n\n\n250\n8.3\n\n\n\n\n添加 Net Classes：\n\n\n\n为网络分类添加独立的线宽规则：\n\n\n\n过孔（12 24 mil)\n\n\n显示网络飞线\n\n原理图库分部分绘制\n\n导出 Gerber 文件\n\nGerber 设置界面：\n\n\n\n\n\n生成NC钻孔文件:\n\n\n\n\n","slug":"Altium-Designer/AD20使用笔记","date":"2022-09-19T06:48:00.000Z","categories_index":"电子技术","tags_index":"Altium Designer","author_index":"爱慢跑的乌龟"},{"id":"0eaae2e7a8b8a57479711ca2360e5962","title":"立创 EAD 导出 AD 封装","content":"立创 EDA 导出 AD 封装\n\n导出 AD 库\n\n\n\n确认导出\n\n\n\n得到 AD 的 pcb 文件\n\n\n\n\n\n\n\n\n\n\n\n生成的是 pcb 文件，需要再 AD 中生成元件封装库\n\n生成元件封装库\n\n\n\n得到元件封装库\n\n\n导出 3D 模型文件\n\n导出 3D 模型\n\n\n\n选择导出\n\n\n\n使用 FreeCAD 打开文件，并删除 PCB 底板\n\n\n\n导出 STEP 文件\n\n\n\n选中模型\n\n\n\n选择导出\n\n\n\n保存\n\n","slug":"Altium-Designer/立创EAD导出AD封装","date":"2022-09-08T08:43:00.000Z","categories_index":"电子技术","tags_index":"Altium Designer,立创EDA","author_index":"爱慢跑的乌龟"},{"id":"7d5686ce3c9c17768b418785872c4c2b","title":"Docker实战案例","content":"操作系统\nBusyBox\nBusyBox 是一个集成了一百多个最常用 Linux\n命令和工具（如cat、echo、grep、mount、telnet等）的精简工具箱，它只有几MB的大小，很方便进行各种快速验证，被誉为“Linux系统的瑞士军刀”。BusyBox\n可运行于多款 POSIX\n环境的操作系统中，如Linux（包括Android）、Hurd、FreeBSD等。\n下载 busybox：latest 镜像：\n$ docker pull busybox:latest\nAlpine\nAlpine操作系统是一个面向安全的轻型 Linux 发行版。它不同于通常的 Linux\n发行版，Alpine 采用了musl libc 和 BusyBox\n以减小系统的体积和运行时资源消耗，但功能上比BusyBox又完善得多，因此得到开源社区越来越多的青睐。\nDebian/Ubuntu\nDebian 和 Ubuntu 都是目前较为流行的 Debian\n系的服务器操作系统，十分适合研发场景。Docker Hub\n上提供了官方镜像，国内各大容器云服务也基本都提供了相应的支持。\ndebian镜像很适合作为基础镜像，用于构建自定义镜像。\n当试图直接使用 apt-get 安装一个软件的时候，会提示\nE：Unable to locate package.\n这并非系统不支持 apt-get 命令。Docker镜像在制作时为了精简清除了 apt\n仓库信息，因此需要先执行 apt-get update\n命令来更新仓库信息。更新信息后即可成功通过 apt-get 命令来安装软件.\nCentOS/Fedora\nCentOS 和 Fedora 都是基于 Redhat 的常见 Linux 分支。CentOS\n是目前企业级服务器的常用操作系统；Fedora 则主要面向个人桌面用户。\nFedora 是由 Fedora Project 社区开发，红帽公司赞助的 Linux\n发行版。它的目标是创建一套新颖、多功能并且自由和开源的操作系统。\n为镜像添加SSH服务\n基于docker\ncommit命令创建容器\n\n准备工作\n\n使用 ubuntu: 14.04 镜像来创建一个容器：\n$ docker run -it ubuntu:14.04 &#x2F;bin&#x2F;bash\n更新 apt 缓存，并安装 openssh-server:\n# apt-get updata\n# apt-get install openshh-server -y\n\n配置 SSH 服务\n\n如果需要正常启动 SSH 服务，则目录 /var/run/sshd\n必须存在。手动创建它，并启动 SSH 服务：\nmkdir -p &#x2F;var&#x2F;run&#x2F;sshd\n&#x2F;usr&#x2F;sbin&#x2F;sshd -D &amp;\n查看容器的 22 端口，可见此端口已经处于监听状态：\nnetstat -tunlp\n修改 SSH 服务的安全登录配置，取消 pam 登录限制：\nsed -ri &#39;s&#x2F;session required pam_loginuid.so&#x2F;#session required pam_loginuid.so&#x2F;g&#39; &#x2F;etc&#x2F;pam.d&#x2F;sshd\n在 root 用户目录下创建 .ssh\n目录，并复制需要登录的公钥信息（一般为本地主机用户目录下的\n.ssh/id_rsa.pub 文件，可由 ssh-keygen-t rsa 命令生成）到 authorized_keys\n文件中：\nmkdir root&#x2F;.ssh\nvim &#x2F;root&#x2F;.ssh&#x2F;authorized_keys\n创建自动启动 SSH 服务的可执行文件 run.sh，并添加可执行权限：\nvim &#x2F;run.sh\nchmod +x run.sh\n其中，run.sh 脚本内容如下：\n#!&#x2F;bin&#x2F;bash\n&#x2F;usr&#x2F;sbin&#x2F;sshd -D\n退出容器：\nexit\n\n保存镜像\n\n将所退出的容器用 docker commit 命令保存为一个新的 sshd:\nubuntu镜像：\ndocker commit fc1 sshd:ubuntu\n\n使用镜像\n\n启动容器，并添加端口映射 10022 -&gt; 22：\ndocker run -p 10022:22 -d sshd:ubuntu &#x2F;run.sh\n使用 Dockerfile 创建\n\n创建工作目录\n\n创建一个 sshd_ubuntu 工作目录：\nmkdir sshd_ubuntu\n创建 Dockerfile 和 run.sh 文件：\ncd sshd_ubuntu&#x2F;\ntouch Dockerfile run.sh\n\n编写 run.sh 脚本和 authorized_keys 文件\n\nrun.sh 脚本：\n#!&#x2F;bin&#x2F;bash\n&#x2F;usr&#x2F;sbin&#x2F;sshd -D\n在宿主机上生成 SSH 密钥对，并创建 authorized_keys 文件：\nssh-keygen -t rsa\ncat ~&#x2F;.shh&#x2F;id_rsa.pub &gt; authorized_keys\n\n编写 Dockerfile\n\n# 设置继承镜像\nFROM ubuntu:14.04\n\n# 作者\nMAINTAINER docker_user (user@docker.com)\n\n# 开始运行更新命令\nRUN apt-get updata\n\n# 安装 ssh 服务\nRUN apt-get install -y openssh-server\nRUN mkdir -p &#x2F;var&#x2F;run&#x2F;sshd\nRUN mkdir -p &#x2F;root&#x2F;.ssh\n\n# 取消 pam 限制\nRUN sed -ri &#39;s&#x2F;session required pam_loginuid.so&#x2F;#session required pam_loginuid.so&#x2F;g&#39; &#x2F;etc&#x2F;pam.d&#x2F;sshd\n\n# 复制配置文件到相应位置，并赋予脚本可执行权限\nADD authorized_keys &#x2F;root&#x2F;.ssh&#x2F;authorized_key\nADD run.sh &#x2F;run.sh\nRUN chmod 755 &#x2F;run.sh\n\n# 开放端口\nEXPOSE 22\n\n# 设置自启动命令\nCMD [&quot;&#x2F;run.sh&quot;]\n\n创建镜像\n\n在 sshd_ubuntu 目录下， 使用 docker build\n命令来创建镜像。这里需要注意最后还有一个\n.，表示使用当前目录中的 Dockerfile：\ncd sshd_ubuntu\ndocker build -t sshd:Dockerfile .\n如果读者使用 Dockerfile 创建自定义镜像，那么需要注意的是 Docker\n会自动删除中间临时创建的层，还需要注意每一步的操作和编写的 Dockerfile\n中命令的对应关系。\nWeb 服务与应用\nApache\nApache 是一个高稳定性的、商业级别的开源 Web 服务器。目前 Apache\n已经是世界使用排名第一的 Web\n服务器软件。由于其良好的跨平台和安全性，Apache\n被广泛应用在多种平台和操作系统上。作为 Apache\n软件基金会支持的项目，它的开发者社区完善而高效。自1995年发布至今，一直以高标准进行维护与开发。Apache\n名称源自美国的西南部一个印第安人部落：阿帕奇族，它支持类 UNIX 和 Windows\n系统。\n\n使用官方镜像\n\n官方提供了名为 httpd 的 Apache 镜像，可以作为基础 Web 服务镜像。\nDockerfile文件：\nFROM httpd:2.4\nCOPY .&#x2F;public-html &#x2F;usr&#x2F;local&#x2F;apache2&#x2F;htdocs&#x2F;&lt;i\n创建项目目录 public-html，并在此目录下创建 index.html文件：\n&lt;!DOCTYPE html&gt;\n\t&lt;html&gt;\n        &lt;body&gt;\n            &lt;p&gt;\n                Hello, Docker!\n            &lt;&#x2F;p&gt;\n        &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n构建自定义镜像：\ndocker build -t apache2-image .\n运行镜像：\ndocker run -it --rm --name apache-container -p 80:80 apache2-image\n也可以不创建自定义镜像，直接通过映射目录方式运行 Apache 容器：\ndocker run -it --rm --name my-apache-app -p 80:80 -v &quot;$PWD&quot;:&#x2F;usr&#x2F;local&#x2F;apache2&#x2F;htdocs&#x2F; httpd:2.4\n\n使用自定义镜像\n\n创建一个 apache_ubuutu 工作目录，在其中创建 Dockerfile 文件、run.sh\n文件 和 sample 目录：\nmkdir apache_ubuntu &amp;&amp; cd apache_ubuntu\ntouch Dockerfile run.sh\nmkdir sample\nDockerfile 文件：\n# 设置 自己创建的 sshd 镜像\nFROM sshd:Dockerfile\n# 作者信息\nMAINTAINER docker_user (user@docker.com)\n# 设置环境变量，所有操作都是非交互式的\nENV DEBIAN_FRONTEND noninteractive\n# 安装\nRUN apt-get -yq install apache2 &amp;&amp; \\\n\trm -rf &#x2F;var&#x2F;lib&#x2F;apt&#x2F;lists&#x2F;*\nRUN echo &quot;Asia&#x2F;Shanghai&quot; &gt; &#x2F;etc&#x2F;timezone &amp;&amp;\\\n\tdpkg-reconfigure -f noninteractive tzdata\n# 添加用户的脚本，并设置权限，这会覆盖之前放在这个位置的脚本\nADD run.sh &#x2F;run.sh\nRUN chmod 755 &#x2F;*.sh\n# 添加一个示例的web站点，删掉默认安装在 apache 文件夹下面的文件，并将用户添加的示例用软链接链到&#x2F;var&#x2F;www&#x2F;html目录下面\nRUN mkdir -p &#x2F;var&#x2F;lock&#x2F;apache2 &amp;&amp; mkdir -p &#x2F;app &amp;&amp; rm -fr &#x2F;var&#x2F;www&#x2F;html &amp;&amp; ln -s &#x2F;app &#x2F;var&#x2F;www&#x2F;html\nCOPY sample&#x2F; &#x2F;app\n#设置 apache 相关的一些变量，在容器启动的时候可以使用 -e 参数替代\nENV APACHE_RUN_USER www-data\nENV APACHE_RUN_GROUP www-data\nENV APACHE_LOG_DIR &#x2F;var&#x2F;log&#x2F;apache2\nENV APACHE_PID_FILE &#x2F;var&#x2F;run&#x2F;apache2.pid\nENV APACHE_RUN_DIR &#x2F;var&#x2F;run&#x2F;apache2\nENV APACHE_LOCK_DIR &#x2F;var&#x2F;lock&#x2F;apache2\nENV APACHE_SERVERADMIN admin@localhost\nENV APACHE_SERVERNAME localhost\nENV APACHE_SERVERALIAS docker.localhost\nENV APACHE_DOCUMENTROOT &#x2F;var&#x2F;www\nEXPOSE 80\nWORKDIR &#x2F;app\nCMD [&quot;&#x2F;run.sh&quot;]\n此 sample 站点的内容为输出 Hello Docker！。然后在 sample 目录下创建\nindex.html 文件，内容如下：\n&lt;!DOCTYPE html&gt;\n    &lt;html&gt;\n        &lt;body&gt;\n            &lt;p&gt;Hello, Docker!&lt;&#x2F;p&gt;\n        &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\nrun.sh 脚本：\n$ cat run.sh\n#!&#x2F;bin&#x2F;bash\n&#x2F;usr&#x2F;sbin&#x2F;sshd &amp;\nexec apache2 -D FOREGROUND\n使用 docker build 命令创建 apache:ubuntu 镜像：\ndocker build -t apache:ubuntu\n\n\n\n\n\n\n\n\n\n在使用 Dockerfile\n创建镜像时，会继承父镜像的开放端口，但却不会继承启动命令。\nNginx\nNginx 是一款功能强大的开源反向代理服务器，支持\nHTTP、HTTPS、SMTP、POP3、IMAP 等协议。它也可以作为负载均衡器、HTTP\n缓存或 Web 服务器。Nginx\n一开始就专注于高并发和高性能的应用场景。它使用类 BSD 开源协议，支持\nLinux、BSD、Mac、Solaris、AIX 等类Unix系统，同时也有 Windows\n上的移植版本。\n\n使用官方镜像\n\n只用 docker run 直接运行官方 Nginx 镜像：\ndocker run -d -p 80:80 --name webserver nginx\n\n自定义 Web 页面\n\n创建 index.html 文件，并将 index.html 文件挂载至容器中：\ndocker run --name nginx-container -p 80:80 -v index.html:&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html:ro -d nignx\nTomcat\nTomcat 是由 Apache 软件基金会下属的 Jakarta 项目开发的一个 Servlet\n容器，按照 Sun Microsystems 提供的技术规范，实现了对 Servlet 和 Java\nServer Page（JSP）的支持。同时，它提供了作为 Web\n服务器的一些特有功能，如 Tomcat 管理和控制平台、安全域管理和 Tomcat\n阀等。由于 Tomcat 本身也内含了一个 HTTP 服务器，也可以当作一个单独的Web\n服务器来使用。\n搜索 Tomcat 相关镜像的个数：\ndocker search tomcat |wc -l\n\n准备工作\n\n创建 tomcat7.0_jdk1.6 文件夹，从 www.oracle.com 网站上下载 sun_jdk\n1.6 压缩包，解压为 jdk 目录。\n创建 Dockerfile 和 run.sh 文件：\nmkdir tomcat7.0_jdk1.6\ncd tomcat7.0_jdk1.6\ntouch Dockerfile run.sh\n下载Tomcat，可以到官方网站下载最新的版本，也可以直接使用下面链接中给出的版本：\nwget http:&#x2F;&#x2F;mirror.bit.edu.cn&#x2F;apache&#x2F;tomcat&#x2F;tomcat-7&#x2F;v7.0.56&#x2F;bin&#x2F;apache-tomcat-7.0.56.zip\n解压后，tomcat7.0_jdk1.6目录结构应如下所示（多余的压缩包文件已经被删除）：\nls\nDockerfile  apache-tomcat-7.0.56   jdk  run.sh\n\nDockerfile 文件和其他脚本文件\n\nDockerfile 文件：\nFROM sshd:Dockerfile\n#设置继承自用户创建的 sshd 镜像\n\n\nMAINTAINER docker_user (user@docker.com)\n#创建者的基本信息\n\n\n#设置环境变量，所有操作都是非交互式的\nENV DEBIAN_FRONTEND noninteractive\n\n#注意这里要更改系统的时区设置\nRUN echo &quot;Asia&#x2F;Shanghai&quot; &gt; &#x2F;etc&#x2F;timezone &amp;&amp; \\\n        dpkg-reconfigure -f noninteractive tzdata\n        \n#安装跟 tomcat 用户认证相关的软件\nRUN apt-get install -yq --no-install-recommends wget pwgen ca-certificates &amp;&amp; \\\n    apt-get clean &amp;&amp; \\\n    rm -rf &#x2F;var&#x2F;lib&#x2F;apt&#x2F;lists&#x2F;*\n    \n#设置 tomcat 的环境变量，若读者有其他的环境变量需要设置，也可以在这里添加。\nENV CATALINA_HOME &#x2F;tomcat\nENV JAVA_HOME &#x2F;jdk\n\n#复制 tomcat 和 jdk 文件到镜像中\nADD apache-tomcat-7.0.56 &#x2F;tomcat\nADD jdk &#x2F;jdk\nADD create_tomcat_admin_user.sh &#x2F;create_tomcat_admin_user.sh\nADD run.sh &#x2F;run.sh\nRUN chmod +x &#x2F;*.sh\nRUN chmod +x &#x2F;tomcat&#x2F;bin&#x2F;*.sh\nEXPOSE 8080\nCMD [&quot;&#x2F;run.sh&quot;]\n创建 tomcat 用户和密码脚本文件 create_tomcat_admin_user.sh\n文件，内容为：\n#!&#x2F;bin&#x2F;bash\nif [ -f &#x2F;.tomcat_admin_created ]; then\n    echo &quot;Tomcat &#39;admin&#39; user already created&quot;\n    exit 0\nfi\n#generate password\nPASS&#x3D;$&#123;TOMCAT_PASS:-$(pwgen -s 12 1)&#125;\n_word&#x3D;$( [ $&#123;TOMCAT_PASS&#125; ] &amp;&amp; echo &quot;preset&quot; || echo &quot;random&quot; )\necho &quot;&#x3D;&gt; Creating and admin user with a $&#123;_word&#125; password in Tomcat&quot;\nsed -i -r &#39;s&#x2F;&lt;\\&#x2F;tomcat-users&gt;&#x2F;&#x2F;&#39; $&#123;CATALINA_HOME&#125;&#x2F;conf&#x2F;tomcat-users.xml\necho &#39;&lt;role rolename&#x3D;&quot;manager-gui&quot;&#x2F;&gt;&#39; &gt;&gt; $&#123;CATALINA_HOME&#125;&#x2F;conf&#x2F;tomcat-users.xml\necho &#39;&lt;role rolename&#x3D;&quot;manager-script&quot;&#x2F;&gt;&#39; &gt;&gt; $&#123;CATALINA_HOME&#125;&#x2F;conf&#x2F;tomcat-users.xml\necho &#39;&lt;role rolename&#x3D;&quot;manager-jmx&quot;&#x2F;&gt;&#39; &gt;&gt; $&#123;CATALINA_HOME&#125;&#x2F;conf&#x2F;tomcat-users.xml\necho &#39;&lt;role rolename&#x3D;&quot;admin-gui&quot;&#x2F;&gt;&#39; &gt;&gt; $&#123;CATALINA_HOME&#125;&#x2F;conf&#x2F;tomcat-users.xml\necho &#39;&lt;role rolename&#x3D;&quot;admin-script&quot;&#x2F;&gt;&#39; &gt;&gt; $&#123;CATALINA_HOME&#125;&#x2F;conf&#x2F;tomcat-users.xml\necho &quot;&lt;user username&#x3D;\\&quot;admin\\&quot; password&#x3D;\\&quot;$&#123;PASS&#125;\\&quot; roles&#x3D;\\&quot;manager-gui,manager-\n    script,manager-jmx,admin-gui, admin-script\\&quot;&#x2F;&gt;&quot; &gt;&gt; $&#123;CATALINA_HOME&#125;&#x2F;conf&#x2F;\n    tomcat-users.xml\necho &#39;&lt;&#x2F;tomcat-users&gt;&#39; &gt;&gt; $&#123;CATALINA_HOME&#125;&#x2F;conf&#x2F;tomcat-users.xml\necho &quot;&#x3D;&gt; Done!&quot;\ntouch &#x2F;.tomcat_admin_created\necho &quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;\necho &quot;You can now configure to this Tomcat server using:&quot;\necho &quot;&quot;\necho &quot;    admin:$&#123;PASS&#125;&quot;\necho &quot;&quot;\necho &quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;\n编写 run.sh 脚本文件，内容为：\n#!&#x2F;bin&#x2F;bash\nif [ ! -f &#x2F;.tomcat_admin_created ]; then\n    &#x2F;create_tomcat_admin_user.sh\nfi\n&#x2F;usr&#x2F;sbin&#x2F;sshd -D &amp;\nexec $&#123;CATALINA_HOME&#125;&#x2F;bin&#x2F;catalina.sh run\n\n创建和测试镜像\n\n创建镜像 tomcat7.0：jdk1.6：\ndocker build -t tomcat7.0:jdk1.6 .\n启动一个 tomcat 容器进行测试：\ndocker run -d -P tomcat7.0:jdk1.6\n通过 docker logs 得到 tomcat 的密码：\ndocker logs 3cd\n&#x3D;&gt; Creating and admin user with a random password in Tomcat\n&#x3D;&gt; Done!\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\nYou can now configure to this Tomcat server using:\n    admin:aBwN0CNCPckw\nJetty\nJetty 是一个优秀的开源 Servlet\n容器，以其高效、小巧、可嵌入式等优点深得人心，它为基于 Java 的 Web\n内容（如 JSP 和 Servlet）提供运行环境。Jetty 基于 Java 语言编写，它的\nAPI 以一组 JAR 包的形式发布。开发人员可以将 Jetty\n容器实例化成一个对象，可以迅速为一些独立运行的 Java 应用提供 Web\n服务。\nDockerHub 官方提供了 Jetty 镜像，直接运行 docker run\n指令即可：\ndocker run -d jetty\nLAMP\nLAMP（Linux-Apache-MySQL-PHP）是目前流行的 Web\n工具栈，其中包括：Linux 操作系统，Apache 网络服务器，MySQL\n数据库，Perl、PHP 或者 Python\n编程语言。其组成工具均是成熟的开源软件，被大量网站所采用。和 Java/J2EE\n架构相比，LAMP 具有 Web\n资源丰富、轻量、快速开发等特点；和微软的.NET架构相比，LAMP更具有通用、跨平台、高性能、低价格的优势。因此\nLAMP 无论是在性能、质量还是价格方面都是企业搭建网站的首选平台。\n\n使用 linode/lamp 镜像\n\n直接运行镜像：\ndocker run -p 80:80 -t -i linode&#x2F;lamp &#x2F;bin&#x2F;bash\n在容器内部 shell 启动 apache 以及 mysql 服务：\nservice apache2 start\nservice mysql start\n\n使用 tutum/lamp 镜像\n\n直接运行镜像：\ndocker run -d -p 80:80 -p 3306:3306 tutum&#x2F;lamp\nCMS\n内容管理系统（Content Management\nSystem，CMS）指的是提供内容编辑服务的平台程序。CMS\n可以让不懂编程的用户方便又轻松地发布、更改和管理各类数字内容（主要以文本和图像为主）。\nWordPress\nWordPress 基于 PHP 和\nMySQL，架构设计简单明了，支持主题，插件和各种功能模块。更重要的是，WordPress\n拥有庞大的社区，在线资源非常丰富，并且在各大网络空间商和云平台中受到广泛的支持。根据2013年8月的统计数据，流量排名前一千万的网站中其使用率高达22%。\n\n使用官方镜像\n\n下载官方镜像：\ndocker pull wordpress\n创建并运行一个 wordpress 容器，并连接到 mysql 容器：\ndocker run --name some-wordpress --link some-mysql:mysql -d wordpress\n\n使用 Compose 搭建 WordPress 应用\n\n新建一个 docker-compose.yml 文件：\nwordpress:\n\timage: wordpress\n\tlinks: \n\t\t- db:mysql\n\tports:\n\t\t- 8080:80\ndb:\n\timage: mariadb\n\tenvironment:\n\t\tMYSQL_ROOT_PASSWORD: example\n然后执行：\ndocker-compose up\n\n\n\n\n\n\n\n\n\n如果提示没有 docker-compose 命令，可以通过 pip install docker-compose\n来在线安装。\nGhost\nGhost 是一个广受欢迎的开源博客平台，使用 JavaScript 编写，以 MIT\n协议发布。它的设计非常简约，使用起来体验优异，非常适合做内容发布，故而受到很多极客或技术工作者的喜爱。\n直接运行官方镜像：\ndocker run --name ghost-container -d ghost\n数据库应用\n主流的数据库类型主要包括关系型(SQL)和非关系型(NoSQL)两种。\n关系数据库是建立在关系模型基础上的数据库，借助于集合代数等数学概念和方法来处理数据库中的数据，支持复杂的事物处理和结构化查询。代表实现有\nMySQL、Oracle、PostGreSQL、MariaDB、SQLServer 等。\n非关系数据库是新兴的数据库技术，它放弃了传统关系型数据库的部分强一致性限制，带来性能上的提升，使其更适用于需要大规模并行处理的场景。非关系型数据库是关系型数据库的良好补充，代表产品有\nMongoDB、Redis、CouchDB 等。\nMySQL\nMySQL\n是全球最流行的开源的开源关系数据库软件之一，因为其高性能、成熟可靠和适应性而得到广泛应用。\n使用官方镜像启动一个 MySQL Server 实例：\ndocker run --name mysql1 -e MYSQL_ROOT_PASSWORD&#x3D;123 -d mysql:latest\nMySQL 服务的标准端口是 3306，用户可以通过 CLI\n工具对配置进行修改：\ndocker run -it --link some-mysql:mysql --rm mysql sh -c &#39;exec mysql -h&quot;$MYSQL_ PORT_3306_TCP_ADDR&quot; -P&quot;$MYSQL_PORT_3306_TCP_PORT&quot; -uroot -p&quot;$MYSQL_ENV_MYSQL_ROOT_PASSWORD&quot;&#39;\n\n系统与日志访问\n\n用户可以使用 docker exec 指令调用内部系统中的 bash\nshell，以访问容器内部系统：\ndocker exec -it some-mysql bash\nMySQL Server 日志可以使用 docker logs 指令查看：\ndocker logs some-mysql\n\n使用自定义配置文件\n\n如果用户希望使用自定义 MySQL 配置，则可以创建一个目录，内置 cnf\n配置文件，然后将其挂载至容器的 /etc/mysql/conf.d\n目录。比如，自定义配置文件为\n/my/custom/config-file.cnf，则可以使用以下指令：\ndocker run --name some-mysql -v &#x2F;my&#x2F;custom:&#x2F;etc&#x2F;mysql&#x2F;conf.d -e MYSQL_ROOT_PASSWORD&#x3D;my-secret-pw -d mysql:tag\n\n脱离cnf文件进行配置\n\n很多的配置选项可以通过标签（flags）传递至 mysqld\n进程。这样用户就可以脱离cnf配置文件，对容器进行弹性的定制。\ndocker run --name some-mysql -e MYSQL_ROOT_PASSWORD&#x3D;my-secret-pw -d mysql:tag --character-set-server&#x3D;utf8mb4 --collatioo-server&#x3D;utf8mb4_unicode_ci\nMongoDB\nMongoDB 是一款可扩展、高性能的开源文档数据库，是当今最流行的 NoSQL\n数据库软件之一。它采用 C++\n开发，支持复杂的数据类型和强大的查询语言，提供了关系数据库的绝大部分功能。\n使用官方镜像\n用户可以使用 docker run 指令直接运行官方 mongodb\n镜像：\ndocker run --name mongo-container -d mongo\n\n连接 mongodb 容器\n\n使用 --link 参数，连接新建的\nmongo-container 容器：\ndocker run -it --link mongo-container:db alpine sh\n\n直接使用 mongo cli 指令\n\n如果想直接在宿主机器上使用 mongodb 镜像，可以在\ndocker run 指令后面加入entrypoint\n指令，这样就可以非常方便的直接进入 mongo cli 了：\ndocker run -it --link mongo-container:db --entrypoint mongo mongo --host db\n使用自定义 Dockerfile\nDockerfile 文件：\n# 设置从用户之前创建的 sshd 镜像继承。\nFROM sshd\nMAINTAINER docker_user (user@docker.com)\nRUN apt-get update &amp;&amp; \\\n    apt-get install -y mongodb pwgen &amp;&amp; \\\n    apt-get clean &amp;&amp; \\\n    rm -rf &#x2F;var&#x2F;lib&#x2F;apt&#x2F;lists&#x2F;*\n    \n# 创建 mongodb 存放数据文件的文件夹\nRUN mkdir -p &#x2F;data&#x2F;db\nVOLUME &#x2F;data&#x2F;db\nENV AUTH yes\n\n# 添加脚本\nADD run.sh &#x2F;run.sh\nADD set_mongodb_password.sh &#x2F;set_mongodb_password.sh\nRUN chmod 755 .&#x2F;*.sh\nEXPOSE 27017\nEXPOSE 28017\nCMD [&quot;&#x2F;run.sh&quot;]\n新建 set_mongodb_password.sh\n脚本。此脚本主要负责配置数据库的用户名和密码：\n#!&#x2F;bin&#x2F;bash\n# 这个脚本主要是用来设置数据库的用户名和密码。\n# 判断是否已经设置过密码。\nif [ -f &#x2F;.mongodb_password_set ]; then\n        echo &quot;MongoDB password already set!&quot;\n        exit 0\nfi\n&#x2F;usr&#x2F;bin&#x2F;mongod --smallfiles --nojournal &amp;\nPASS&#x3D;$&#123;MONGODB_PASS:-$(pwgen -s 12 1)&#125;\n_word&#x3D;$( [ $&#123;MONGODB_PASS&#125; ] &amp;&amp; echo &quot;preset&quot; || echo &quot;random&quot; )\nRET&#x3D;1\nwhile [[ RET -ne 0 ]]; do\n    echo &quot;&#x3D;&gt; Waiting for confirmation of MongoDB service startup&quot;\n    sleep 5\n    mongo admin --eval &quot;help&quot; &gt;&#x2F;dev&#x2F;null 2&gt;&amp;1\n    RET&#x3D;$?\ndone\n\n# 通过 docker logs + id 可以看到下面的输出。\necho &quot;&#x3D;&gt; Creating an admin user with a $&#123;_word&#125; password in MongoDB&quot;\nmongo admin --eval &quot;db.addUser(&#123;user: &#39;admin&#39;, pwd: &#39;$PASS&#39;, roles: \n    [ &#39;userAdminAnyDatabase&#39;, &#39;dbAdminAnyDatabase&#39; ]&#125;);&quot;\nmongo admin --eval &quot;db.shutdownServer();&quot;\necho &quot;&#x3D;&gt; Done!&quot;\ntouch &#x2F;.mongodb_password_set\necho &quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;\necho &quot;You can now connect to this MongoDB server using:&quot;\necho &quot;&quot;\necho &quot;    mongo admin -u admin -p $PASS --host &lt;host&gt; --port &lt;port&gt;&quot;\necho &quot;&quot;\necho &quot;Please remember to change the above password as soon as possible!&quot;\necho &quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;\n\n新建 run.sh，此脚本是主要的 mongodb 启动脚本：\n#!&#x2F;bin&#x2F;bash\nif [ ! -f &#x2F;.mongodb_password_set ]; then\n        &#x2F;set_mongodb_password.sh\nfi\nif [ &quot;$AUTH&quot; &#x3D;&#x3D; &quot;yes&quot; ]; then\n\n# 这里读者可以自己设定 Mongodb 的启动参数。\n\texport mongodb&#x3D;&#39;&#x2F;usr&#x2F;bin&#x2F;mongod --nojournal --auth --httpinterface --rest&#39;\nelse\n\texport mongodb&#x3D;&#39;&#x2F;usr&#x2F;bin&#x2F;mongod --nojournal --httpinterface --rest&#39;\nfi\nif [ ! -f &#x2F;data&#x2F;db&#x2F;mongod.lock ]; then\n    eval $mongodb\nelse\n    export mongodb&#x3D;$mongodb&#39; --dbpath &#x2F;data&#x2F;db&#39;\n    rm &#x2F;data&#x2F;db&#x2F;mongod.lock\n    mongod --dbpath &#x2F;data&#x2F;db --repair &amp;&amp; eval $mongodb\nfi\n第二步，使用 docker build 指令构建镜像：\ndocker build -t mongodb-imaga .\n第三步，启动后台容器，并分别映射 27017 和 28017 端口到本地：\ndocker run -d -p 27017:27017 -p 28017:28017 mongodb\n通过 docker logs 来查看默认的 admin 帐户密码：\ndocker logs sa9\n    &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n        You can now connect to this MongoDB server using:\n            mongo admin -u admin -p 5elsT6KtjrqV --host &lt;host&gt; --port &lt;port&gt;\n        Please remember to change the above password as soon as possible!\n        &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\nRedis\nRedis\n是一个开源（BSD许可）的基于内存的数据结构存储系统，可以用作数据库、缓存和消息中间件。\n通过 docker run 指令可以直接启动一个 redis-container\n容器：\ndocker run --name redis-container -d redis\n\n连接redis容器\n\n用户可以使用 --link 参数，连接创建的 redis-container\n容器：\ndocker run -it --link redis-container:db alpine sh\n还可以使用 n c指令（即NetCat）检测 redis 服务的可用性：\nnc db 6379\n\n使用自定义配置\n\n可以通过数据卷实现自定义 redis 配置，如下所示：\ndocker run -v &#x2F;myredis&#x2F;conf&#x2F;redis.conf:&#x2F;usr&#x2F;local&#x2F;etc&#x2F;redis&#x2F;redis.conf --name \n    myredis redis redis-server &#x2F;usr&#x2F;local&#x2F;etc&#x2F;redis&#x2F;redis.conf\n","slug":"Linux/Docker实战案例","date":"2022-06-30T07:13:00.000Z","categories_index":"Docker","tags_index":"《Docker技术入门与实践》","author_index":"爱慢跑的乌龟"},{"id":"1eaff4e22fb5fa029043d1942e6ee81c","title":"棋盘格角点检测","content":"A\nNew Sub-Pixel Detector for X-Corners in Camera Calibration Targets\n\n\n\n\n\n\n\n\n\n基于海塞矩阵的方法\n一个标准的 X-Corners 如下图所示：\n\n其表达式为： \n由于实际的图像中存在噪点，所以需要对图像进行低通滤波，这里使用高斯算子：\n 高斯算子平滑的 X-Corner 的强度分布模型：  其中，.\n对于 X-Corner，我们可以使用由图像函数的 Hessian\n矩阵的特征值推导出的新形状算子。\nHessian\n矩阵的特征值对应曲面的最小和最大二阶导数，它们的相关特征向量是二阶导数极值的方向，并且相互正交.\n将图像函数中一个像素的邻域视为一个表面块，Hessian 矩阵表示为  \n是图像函数  的二阶偏导数.\nHessian 矩阵的两个特征值为:  对应的归一化特征向量是： \n其中，.\n对于方程（2）中的 X-Corner，对应的 Hessian 矩阵的最大特征值  是正的，最小特征值 \n是负的，因此我们可以得到一个新的简单算子来检测x角点的像素位置：  待检测角是 \n的局部负极值点. 基于这个约束，我们可以确定 X-Corner 的像素位置 .\n亚像素检测：\n很明显，X-Corner 真正的亚像素位置必须位于  附近。我们假设它的实际位置是\n. .\n对于每个\nX-Corner，我们可以使用第二个泰勒多项式来描述它周围的局部强度分布：   是图像函数  在点  的值.  是  在点  的一阶偏导， 是  在点  的二阶偏导.\n如上所述，X-Corner 就是强度剖面的鞍点. 我们可以将 式（3）沿  和  的一阶导数设为0：  然后我们就可以得到亚像素的位置 ：  Detection of X-corners in Discrete\nSpace：\n对于离散图像，只需要做一个修改，即在离散空间中实现卷积。这里我们选择标准高斯核作为卷积掩码：\n 掩码的维度为 ，其中  为 .\n然后将离散图像与相应的微分核进行卷积，得到离散图像的偏导数。\n图像求导问题\n一阶导数\n导数的的定义：  由于图像的像素是离散的，所以通常采用差分的形式，取 ，在图像中  处的方向导数为：\n\n关于差分： 向前差分：向后差分：中心差分：\nSobel 算子计算梯度的方式略有不同.\n\n根据式（2）计算 \n点处的方向导数为：  \n对于 sobel 算子为：  \n使用 sobel 算子计算 \n点的梯度有：  对角线方向导数有：  \n二阶导数\n数学定义为：  向前差分：  由 ， 得：\n 向后差分：  同理：  对于  ，向后差分:  向后差分： \n\nHessian 矩阵\n\n二元函数泰勒公式的近似表达式：  其极值情况可由  矩阵来判定，令 ，.\n当 \n时，如果对于任意向量 ，都有 \n为正，那么 \n为正定矩阵，函数具有局部极小值. 如果对于任意向量 ，都有 \n为负，那么 \n为负定矩阵，函数具有局部极大值.\n当 Hessian\n矩阵同时具有正负特征值时，该点为鞍点.\n","slug":"Digital-Image/X-Corner","date":"2022-06-29T07:11:00.000Z","categories_index":"图像处理","tags_index":"相机标定,角点检测","author_index":"爱慢跑的乌龟"},{"id":"e8df40174e1c8fdb0eda4ca741803291","title":"Docker 基础入门","content":"核心概念与安装配置\nDocker 的三大核心概念：\n\n镜像(Image)\n容器(Container)\n仓库(Repository)\n\n核心概念\nDocker 镜像\nDocker 镜像可以将其理解为一个只读的模板。它是 docker\n容器的基础。用户可以从网络上下载已经配置好的镜像，并直接使用。\nDocker 容器\nDocker\n容器类似于一个轻量级的沙箱，用于运行和隔离应用。容器是从镜像创建的应用运行实例。可以将其启动、开始、停止和删除。\n\n镜像自身是只读的。容器从镜像启动的时候，会在镜像的最上层创建一个可写层\n\nDocker 仓库\nDocker 仓库是 Docker 集中存放镜像文件的场所。\nDocker 仓库的类型：\n\n公开仓库(Public)\n私有仓库(Private)\n\nDocker 的安装\nUbuntu 环境下安装 Docker\n推荐至少使用 14.04 LTS 版本。\n为了让 Docker 使用 aufs 存储，推荐安装 linux-image-extra\n软件包：\n$ sudo apt-get install -y linux-image-extra-$(uname -r)\n添加镜像源：\n安装 apt-transport-https 包支持 HTTP 协议的源：\n$ sudo apt-get install -y apt-transport-https\n添加源的 gpg 密钥：\n$ sudo apt-key adv --keyserver hkp:&#x2F;&#x2F;p80.pool.sks-keyservers.net:80 --recv-keys \n    58118E89F3A912897C070ADBF76221572C52609D\n获取当前操作系统的代号：\n$ lsb_release -c\nCodename:       trusty\n接下来就可以添加Docker的官方apt软件源了。通过下面的命令创建\n/etc/apt/sources.list.d/docker.list\n文件，并写入源的地址内容。非 trusty\n版本的系统注意修改为自己对应的代号：\n$ sudo cat &lt;&lt;EOF &gt; &#x2F;etc&#x2F;apt&#x2F;sources.list.d&#x2F;docker.list\ndeb https:&#x2F;&#x2F;apt.dockerproject.org&#x2F;repo ubuntu-trusty main\nEOF\n更新 apt 软件包缓存：\n$ sudo apt-get update\n安装 Docker：\n$ sudo apt-get install -y docker-engine\n通过脚本自动化安装 Docker：\n$ sudo curl -sSL https:&#x2F;&#x2F;get.docker.com&#x2F; | sh\n启动 docker 服务：\n$ sudo systemctl start docker\nCentOS 环境下安装 Docker\n添加 yum 软件源：\n$ sudo tee &#x2F;etc&#x2F;yum.repos.d&#x2F;docker.repo &lt;&lt;-&#39;EOF&#39;\n[dockerrepo]\nname&#x3D;Docker Repository\nbaseurl&#x3D;https:&#x2F;&#x2F;yum.dockerproject.org&#x2F;repo&#x2F;main&#x2F;centos&#x2F;$releasever&#x2F;\nenabled&#x3D;1\ngpgcheck&#x3D;1\ngpgkey&#x3D;https:&#x2F;&#x2F;yum.dockerproject.org&#x2F;gpg\nEOF\n安装 docker：\n$ sudo yum update\n$ sudo yum install -y docker-engine\n使用脚本安装\n$ curl -fsSL https:&#x2F;&#x2F;get.docker.com&#x2F; | sh\n或者：\n$ wget -qO- https:&#x2F;&#x2F;get.docker.com&#x2F; | sh\n配置 Docker 服务\n将当前用户加入 docker 用户组：\n$ sudo usermod -aG docker USER_NAME\nDocker 服务的默认配置文件：/etc/default/docker\n可以通过修改 DOCKER_OPTS 来修改服务启动的参数。\nDocker 服务的管理脚本：/etc/init.d/docker\n查看版本信息：\n$ docker verison\nClient: Docker Engine - Community\n Version:           20.10.17\n API version:       1.41\n Go version:        go1.17.11\n Git commit:        100c701\n Built:             Mon Jun  6 23:02:56 2022\n OS&#x2F;Arch:           linux&#x2F;amd64\n Context:           default\n Experimental:      true\n\nServer: Docker Engine - Community\n Engine:\n  Version:          20.10.17\n  API version:      1.41 (minimum version 1.12)\n  Go version:       go1.17.11\n  Git commit:       a89b842\n  Built:            Mon Jun  6 23:01:02 2022\n  OS&#x2F;Arch:          linux&#x2F;amd64\n  Experimental:     false\n containerd:\n  Version:          1.6.6\n  GitCommit:        10c12954828e7c7c9b6e0ea9b0c02b01407d3ae1\n runc:\n  Version:          1.1.2\n  GitCommit:        v1.1.2-0-ga916309\n docker-init:\n  Version:          0.19.0\n  GitCommit:        de40ad0\n\nDocker 镜像\nDocker 运行容器前需要本地存在对应的镜像，若本地无镜像，Docker\n将从默认的镜像仓库下载，用户可以通过配置，使用自定义的镜像仓库。\n镜像获取\n使用 docker pull 命令从 Docker Hub\n镜像仓库下载镜像。\n命令格式：docker pull Image-Name[: TAG] (TAG\n通常是版本信息)\n没有指定 TAG，默认为 latest\n$ docker pull ubuntu\nUsing default tag: latest\nlatest: Pulling from library&#x2F;ubuntu\n405f018f9d1d: Pull complete\nDigest:sha256:b6b83d3c331794420340093eb706a6f152d9c1fa51b262d9bf34594887c2c7ac\nStatus: Downloaded newer image for ubuntu:latest\ndocker.io&#x2F;library&#x2F;ubuntu:latest\n镜像文件一般由若干层(layer)组成，每个层都有一个唯一的 ID\n(如：405f018f9d1d)。使用 docker pull\n命令下载时会获取并输出镜像的各层信息。当不同的镜像包括相同的层时，本地仅存储层的一份内容，减小了需要的存储空间。\n镜像名称之前应该加上仓库地址前缀，使用官方仓库时默认省略，即：docker pull ubuntu：14.04\n相当于\ndocker pull registry.hub.docker.com/ubuntu：14.04。\n若从非官方仓库下载镜像，则必须指定仓库地址前缀。\npull 子命令支持的选项：\n-a,--all-tags=true|false -\n是由获取仓库中所有镜像，默认为 否。\n查看镜像信息\n列出所有镜像\n命令：docker images\n$ docker images\nREPOSITORY   TAG       IMAGE ID       CREATED       SIZE\nubuntu       latest    27941809078c   2 weeks ago   77.8MB\n\nREPOSITORY - 来自于那个仓库\nTAG - 版本信息\nIMAGE ID - 唯一标识镜像\nCREATED - 镜像的最后更新时间\nSIZE - 镜像大小\n\nimages 子命令主要支持的选项：\n-a, --all&#x3D;true|false: 列出所有镜像（包含临时文件），默认为 否；\n--digests&#x3D;true|false: 列出镜像的数字摘要值，默认为 否；\n-f, --filter&#x3D;[]: 过滤列出镜像；\n--format&#x3D;&quot;TEMPLATE&quot;: 控制输出格式，.ID代表ID信息，.Repository代币哦仓库信息；\n--no-trunc&#x3D;true|false: 对输出结果中太长的部分是否进行截断，默认为 是；\n-q, --quiet&#x3D;true|false: 仅输出ID信息，默认为　否\n使用 man docker-images 查看更多命令选项。\n添加镜像标签\n使用 tag\n命令来为一个本地镜像添加新的标签，以方便使用：\n$ docker tag ubuntu:latest myubuntu:latest\n查看详细信息\n使用 inspect 命令获取镜像的详细信息：\n$ docker inspect ubuntu:14.04\n返回的消息为 JSON 格式的消息，如果只想获取其中一项，使用\n-f 参数来指定：\n$ docker inspect -f &#123;&#123;&quot;.Architecture&quot;&#125;&#125;\n查看镜像的历史\n使用 history 命令来查看镜像的历史：\n$ docker history ubuntu:14.04\n可以查看各个层的内容具体的创建信息。\n搜索镜像\n使用 docker search\n命令来搜索远程仓库中的镜像，默认使用官方仓库。\n支持的参数有 ：\n--no-trunc&#x3D;true|false: 输出信息不截断显示，默认为 否；\n-f, --filter&#x3D;[]: 基于条件过滤输出\n--limit&#x3D;25: 搜索结果的最大数量\n搜索所有自动创建的评价为1+的带nginx关键字的镜像：\n$ docker search --limit&#x3D;10 nginx\n删除镜像\n使用 docker rmi 命令来删除镜像：\n使用标签删除\n$ docker rmi ubuntu:latest\n\n\n\n\n\n\n\n\n\n当一个镜像拥有多个标签时，删除某一个标签并不会影响原来的镜像\n使用镜像 ID 删除\n当使用 ID 进行删除时，所有的镜像标签包括原始镜像本身都会被删除。\n\n\n\n\n\n\n\n\n\n若镜像创建的容器存在时，则该镜像文件将无法被删除\n如果需要强制删除，可以使用 -f 参数。\n创建镜像\n有三种方式创建镜像：\n\n基于已有镜像的容器创建\n基于本地模板导入\n基于 Dockerfile 创建\n\n基于已有镜像的容器创建\n使用 docker commit 命令来创建。\n主要选项包括：\n-a, --author&#x3D;&quot;&quot;: 作者信息\n-c, --change&#x3D;[]: 提交的执行 Dockerfile 指令\n-m, --message&#x3D;&quot;&quot;: 提交信息\n-p, --pause&#x3D;true: 提交时暂停容器的运行\n提交时使用容器的 ID 或名称来指定容器：\n$ docker commit -m &quot;Added a new file&quot; -a &quot;Anson&quot; a925cb40b3f0 test:0.1\n基于本地模板导入\n使用 docker inport 命令来创建。\n$ cat ubuntu-14.04-x86_64-minimal.tar.gz | docker import - ubuntu:14.04\n存出和载入镜像\n存出镜像\n使用 docker save 来存出镜像：\n$ docker save -o ubuntu_14.04.tar ubuntu:14.04\n载入镜像\n使用 docker load 来载入镜像：\n$ docker load --input ubuntu_14.04.tar\n或者：\n$ docker load &lt; ubuntu_14.04.tar\n上传镜像\n使用 docker push 命令来上传镜像到仓库，默认为官方 Docker\nHub仓库：\ndocker push NAME[:TAG] | [REGISTRY_HOST[:REGISTRY_PORT]/]NAME[:TAG]\n$ docker tag test:latest user&#x2F;test:latest\n$ docker push user&#x2F;test:latest\nDocker 容器\n容器是镜像运行的实例。镜像是静态的只读文件，而容器带有运行时需要的可写文件层。\n创建容器\n新建容器\n使用 docker create 命令来创建一个容器：\n$ docker create -it ubuntu:latest\n此时容器处于停止状态，可以使用 docker start\n命令来启动它。\n启动容器\n使用 docker start 命令来启动一个已经创建的容器：\n$ docker start af\naf\n新建并启动容器\n使用 docker run 命令来创建并执行。\n$ docker run ubuntu &#x2F;bin&#x2F;echo &#39;Hello world&#39;\nHello world\n启动一个 bash 终端：\n$ docker run -it ubuntu:14.04 &#x2F;bin&#x2F;bash\n\n-t - 让 Docker\n分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上\n-i - 让容器的标准输入保持打开\n\nCtrl + d 或 输入 exit 退出容器。\n守护态运行\n通过添加 -d 参数实现：\ndocker run -d ubuntu  &#x2F;bin&#x2F;sh -c &quot;while true; do echo hello world; sleep 1; done&quot;\n终止容器\n使用 docker stop 命令来终止一个运行中的容器。\ndocker stop[-t|--time[=10]][CONTAINER...]\n首先向容器发送 SIGTERM 信号，等待一段超时时间（默认为10秒）后，再发送\nSIGKILL信号来终止容器：\n$ docker stop ce5\nce5\ndocker kill 命令会直接发送 SIGKILL\n信号来强行终止容器。\n重新启动一个容器使用 docker restart 命令。\n进入容器\n进入容器的方法：\n\nattach\nexec\nnsenter\n...\n\nattach 命令\ndocker attach [--detach-keys[=[]]] [--no-stdin] [--sig-proxy[=true]] CONTAINER\n主要选项：\n--detach-keys&#x3D;&quot;&quot;: 重写用于退出容器的键序列\n--no-stdin[&#x3D;false]: 是否关闭标准输入\n--sig-proxy[&#x3D;true]: 代理进程接收到的所有信号\n\n\n\n\n\n\n\n\n\n\n当多个窗口同时使用 attach\n命令连接到同一个容器时，所有的窗口都会同步显示。当某个窗口阻塞时，其他窗口也无法执行操作了。\nexec 命令\n主要参数：\n-i, --interactive[&#x3D;false]: 使用标准输入接受用户命令\n--privileged[&#x3D;false]: 赋予命令拓展权限\n-t, --tty[&#x3D;false]: 分配 pseudo-TTY\n-u, --user&#x3D;&quot;&quot;: 用户名或 UID (format:[:])\n$ docker exec -it 55c0389b9d7c &#x2F;bin&#x2F;bash\nnsenter 工具\n\n找到容器进程的 PID，命令如下：\nPID&#x3D;$(docker inspect --format &quot;&#123;&#123;.State.Pid&#125;&#125;&quot; &lt;container&gt;)\n通过 PID 连接到容器\n$ nsenter --target $PID --mount --uts --ipc --net --pid\n\n例子：\n$ docker run -idt ubuntu\n243c32535da7d142fb0e6df616a3c3ada0b8ab417937c853a9e1c251f499f550\n$ docker ps\nCONTAINER ID   IMAGE   COMMAND   CREATED  STATUS   PORTS  NAMES\n243c32535da7  ubuntu:latest   &quot;&#x2F;bin&#x2F;bash&quot;  18 seconds ago  Up 17 seconds \n    nostalgic_hypatia\n$ PID&#x3D;$(docker-pid 243c32535da7)\n10981\n$ nsenter --target 10981 --mount --uts --ipc --net --pid\nroot@243c32535da7:&#x2F;#\n删除容器\n使用 docker rm 命令来删除容器。\n主要参数：\n-f, --force[&#x3D;false]: 强制删除正在运行的容器\n-l,\t--link[&#x3D;false]: 删除指定的链接，但保留容器\n-v, --volumes[&#x3D;false]: 删除容器挂载的数据卷\n导入和导出容器\n在需要将容器从一个系统迁移到另一个系统的情况下，可以使用 Docker\n的导入和导出功能。\n导出容器\n使用 docker export 命令来导出容器：\n$ docker export -o test_for_run.tar ce5\n$ docker export e81 &gt; test_for_stop.tar\n导入容器\n使用 docker import 命令来导入容器：\n$ docker import test_for_run.tar - test&#x2F;ubuntu:v1.0\n访问 Docker 仓库\n仓库（Repository）是集中存放镜像的地方，分公共仓库和私有仓库。\nDocker Hub公共镜像市场\nDocker官方维护了一个公共镜像仓库 https://hub.docker.com\n时速云镜像市场\n访问地址 https://hub.tenxcloud.com\n搭建本地私有仓库\n使用 registry\n镜像创建私有仓库\n使用 registry 镜像来简单搭建一套本地私有仓库环境：\n$ docker run -d -p 5000:5000 registry\n默认情况下，会将仓库创建在容器的 /tmp/registry\n目录下。使用参数 -v 将镜像文件存放在本地的指定路径。\n$ docker run -d -p 5000:5000 -v &#x2F;opt&#x2F;data&#x2F;registry:&#x2F;tmp&#x2F;registry registry\n\n管理私有仓库\n使用 docker tag 命令将这个镜像标记为\n10.0.2.2：5000/test\n$ docker tag ubuntu:14.04 10.0.2.2:5000&#x2F;test\n使用 docker push 上传标记的镜像：\n$ docker push 10.0.2.2:5000&#x2F;test\nDocker 数据管理\n生产环境中使用 Docker\n的过程中，往往需要对数据进行持久化，或者需要在多个容器之间进行数据共享，这必然涉及容器的数据管理操作。\n容器中管理数据主要有两种方式：\n\n数据卷(Data Volumes)：容器内数据直接映射到本地主机环境；\n数据卷容器(Data Volume Containers)：使用特定容器维护数据卷。\n\n数据卷\n数据卷的特性：\n\n数据卷可以在容器之间共享和重用，容器间传递数据将变得高效方便；\n对数据卷内数据的修改会立马生效，无论是容器内操作还是本地操作；\n对数据卷的更新不会影响镜像，解耦了应用和数据；\n卷会一直存在，直到没有容器使用，可以安全地卸载它。\n\n在容器内创建一个数据卷\n在 docker run 命令下，使用参数 -v\n在容器内创建一个数据卷。重复使用可创建多个。\n例：\n$ docker run -d -P --name web -v &#x2F;webapp training&#x2F;webapp python app.py\n挂载一个主机目录作为数据卷\n$ docker run -d -P --name web -v &#x2F;src&#x2F;webapp:&#x2F;opt&#x2F;webapp training&#x2F;webapp python app.py\n加载主机的 /src/webapp 目录到容器的\n/opt/webapp 目录\n注：本地目录的路径必须是绝对路径，如果目录不存在，Docker会自动创建。\nDocker 挂载数据卷的默认权限是读写（rw），用户也可以通过 ro\n指定为只读：\n$ docker run -d -P --name web -v &#x2F;src&#x2F;webapp:&#x2F;opt&#x2F;webapp:ro\ntraining&#x2F;webapp python app.py\n挂载一个本地主机文件作为数据卷\n-v\n也可以从主机挂载单个文件到容器中作为数据卷（不推荐）。\n$ docker run --rm -it -v ~&#x2F;.bash_history:&#x2F;.bash_history ubuntu &#x2F;bin&#x2F;bash\n数据卷容器\n如果用户需要在多个容器之间共享一些持续更新的数据，最简单的方式是使用数据卷容器。数据卷容器也是一个容器，但是它的目的是专门用来提供数据卷供其他容器挂载。\n\n创建一个数据卷容器 dbdata，并在其中创建一个数据卷挂载到\n/dbdata:\n$ docker run -it -v &#x2F;dbdata --name dbdata ubuntu\nroot@3ed94f279b6f:&#x2F;#\n然后，可以在其他容器中使用 --volumes-from 来挂载\ndbdata 容器中的数据卷，例如创建 db1 和 db2\n两个容器，并从dbdata容器挂载数据卷：\n$ docker run -it --volumes-from dbdata --name db1 ubuntu\n$ docker run -it --volumes-from dbdata --name db2 ubuntu\n\n\n\n\n\n\n\n\n\n\n使用 --volumes-from\n参数所挂载数据卷的容器自身并不需要保持在运行状态。\n如果删除了挂载的容器（包括dbdata、db1和db2），数据卷并不会被自动删除。如果要删除一个数据卷，必须在删除最后一个还挂载着它的容器时显式使用\ndocker rm-v 命令来指定同时删除关联的容器。\n利用数据卷容器来迁移数据\n\n备份\n\n备份 dbdata 数据卷容器内的数据卷：\n$ docker run --volumes-from dbdata -v $(pwd):&#x2F;backup --name worker ubuntu tar cvf &#x2F;backup&#x2F;backup.tar &#x2F;dbdata\n\n镜像：ubuntu\n容器：worker\n-v $(pwd):/backup：挂载本地的当前目录到 worker 容器的\n/backup 目录\n--volumes-from dbdata：让 worker 容器挂载 dbdata\n容器的数据卷\ntar cvf/backup/backup.tar /dbdata：将\n/dbdata 下内容备份为容器内的\n/backup/backup.tar\n\n\n恢复\n\n将数据恢复到一个容器：\n首先创建一个带有数据卷的容器 dbdata2：\n$ docker run -v &#x2F;dbdata --name dbdata2 ubuntu &#x2F;bin&#x2F;bash\n然后创建另一个新的容器，挂载dbdata2的容器，并使用untar解压备份文件到所挂载的容器卷中：\n$ docker run --volumes-from dbdata2 -v $(pwd):&#x2F;backup busybox tar xvf &#x2F;backup&#x2F;backup.tar\n端口映射与容器互联\n端口映射实现访问容器\n\n从外部访问容器应用\n\n在启动容器的时候，如果不指定对应的参数，在容器外部是无法通过网络来访问容器内的网络应用和服务的。\n当容器中运行一些网络应用，要让外部访问这些应用时，可以通过\n-P 或 -p 参数来指定端口映射。当使用\n-P 参数时，Docker会随机映射一个 49000~49900\n的端口到内部容器开放的网络端口：\ndocker run -d -P training&#x2F;webapp python app.py\n可以使用 docker logs 命令来查看应用的信息：\n$ docker logs -f nostalgic_morse\n-p可以指定要映射的端口，并且，在一个指定端口上只可以绑定一个容器。支持的格式有\nIP：HostPort：ContainerPort、\nIP：：ContainerPort、\nHostPort：ContainerPort。\n\n映射所有接口地址\n\n使用 HostPort：ContainerPort 格式将本地的 5000\n端口映射到容器的 5000 端口，可以执行：\n$ docker run -d -p 5000:5000 training&#x2F;webapp python app.py\n多次使用 -p 参数可以绑定多个端口。\n\n映射到指定地址的指定端口\n\n可以使用 IP：HostPort：ContainerPort\n格式指定映射使用一个特定地址，比如localhost 地址 127.0.0.1：\n$ docker run -d -p 127.0.0.1:5000:5000 training&#x2F;webapp python app.py\n\n映射到指定地址的任意端口\n\n使用 IP：：ContainerPort 绑定 localhost\n的任意端口到容器的 5000端 口，本地主机会自动分配一个端口：\n$ docker run -d -p 127.0.0.1::5000 training&#x2F;webapp python app.py\n还可以使用 upd 标记来指定 UDP 端口：\n$ docker run -d -p 127.0.0.1:5000:5000&#x2F;udp training&#x2F;webapp python app.py\n\n查看映射端口配置\n\n使用 docker port\n命令来查看当前映射的端口配置，也可以查看绑定的地址：\n$ docker port nostalgic_morse 5000\n127.0.0.1:49155\n互联机制实现便捷互访\n容器的互联（linking）是一种让多个容器中应用进行快速交互的方式。它会在源和接收容器之间创建连接关系，接收容器可以通过容器名快速访问到源容器，而不用指定具体的\nIP 地址。\n\n自定义容器命名\n\n使用 --name 参数可以为容器自定义命名：\n$ docker run -d -P --name web training&#x2F;webapp python app.py\n\n\n\n\n\n\n\n\n\n容器的名称是唯一的。\n\n容器互联\n\n使用 --link 参数可以让容器之间安全地进行交互。\n创建一个新的数据库容器：\n$ docker run -d --name db training&#x2F;postgres\n创建一个新的 web 容器，并将它连接到 db 容器：\n$ docker run -d -P --name web --link db:db training&#x2F;webapp python app.py\n--link 参数的格式为\n--link name: alias，其中 name 是要连接的容器名称，alias\n是这个连接的别名。\nweb 容器连接到 db 容器，这允许web容器访问db容器的信息。\nDocker通过两种方式为容器公开连接信息：\n\n更新环境变量\n更新 /etc/hosts 文件\n\n使用 Dockerfile 创建镜像\nDockerfile 是一个文本格式的配置文件，用户可以使用 Dockerfile\n来快速创建自定义的镜像。\n基本结构\nDockerfile 由一行行命令语句组成，并且支持以 #\n开头的注释行。\n一般而言，Dockerfile分为四部分：\n\n基础镜像信息\n维护者信息\n镜像操作指令\n容器启动时执行指令\n\n指令说明\n指令的一般格式为 INSTRUCTION arguments\n\n\n\n\n\n\n\n指令\n说明\n\n\n\n\nFROM\n指定所创建镜像的基础镜像\n\n\nMAINTAINER\n指定维护者信息\n\n\nRUN\n运行命令\n\n\nCMD\n指定启动容器时默认执行的命令\n\n\nLABEL\n指定生成镜像的元数据标签信息\n\n\nEXPOSE\n声明镜像内服务所监听的端口\n\n\nENV\n指定环境变量\n\n\nADD\n复制指定的  路径下的内容到容器的  路径下， 可以为\nURL；如果为 tar 文件，会自动解压到  路径下\n\n\nCPOY\n复制本地主机的  路径下的内容到镜像中的 \n路径下；一般情况下推荐使用 COPY，而不是 ADD\n\n\nENTERPOINT\n指定镜像的默认入口\n\n\nVOLUME\n创建数据卷挂载点\n\n\nUSER\n指定运行容器时的用户名或 UID\n\n\nWORKDIR\n配置工作目录\n\n\nARG\n指定镜像使用的参数\n\n\nONBUILD\n配置当所创建的镜像为其他镜像的基础镜像时，所执行的创建操作指令\n\n\nSTOPSIGNAL\n容器退出的信号值\n\n\nHEALTHCHECK\n如何进行健康检查\n\n\nSHELL\n指定使用 shell 时的默认 shell 类型\n\n\n\nFROM\n指定所创建镜像的基础镜像，如果本地不存在，则默认会去 Docker Hub\n下载指定镜像。\n格式：FROM &lt;image&gt; or\nFROM &lt;imgae&gt;: &lt;tag&gt; or\nFROM &lt;image&gt;@&lt;digest&gt;\n 任何 Dockerfile 中的第一条指令必须为 FROM\n指令。并且，如果在同一个Dockerfile中创建多个镜像，可以使用多个FROM指令（每个镜像一次）。\nMAINTAINER\n指定维护者信息。\n格式：MAINTAINER &lt;name&gt;\nRUN\n运行指定命令。\n格式：RUN &lt;command&gt; or\nRUN [\"executable\", \"param1\", \"param2\"]\n注：必须使用双引号\n前者默认将在 shell 终端中运行命令，即/bin/sh-c；后者则使用 exec\n执行，不会启动shell环境。\nCMD\n指定启动容器时默认执行的命令。\n格式：\n\nCMD [\"executable\", \"param1\", \"param2\"] 使用 exec\n执行\nCMD command param1 param2 在 /bin/sh\n中执行\nCMD [\"param1\", \"param2\"] 提供给 ENTERPOINT\n的默认参数\n\n每个Dockerfile只能有一条 CMD\n命令。如果指定了多条命令，只有最后一条会被执行。\nLABEL\n用来指定生成镜像的元数据标签信息。\n格式：LABEL &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; ...\nEXPOSE\n声明镜像内服务所监听的端口。\n格式：EXPOSE &lt;port&gt; [&lt;port&gt; ...]\nEXPOSE 22 80 8443\n注意，该指令只是起到声明作用，并不会自动完成端口映射。\nENV\n指定环境变量，在镜像生成过程中会被后续 RUN\n指令使用，在镜像启动的容器中也会存在。\n格式：ENV &lt;key&gt;&lt;value&gt; or\nENV &lt;key&gt;=value\nENV PG_MAJOR 9.3\nENV PG_VERSION 9.3.4\nRUN curl -SL http:&#x2F;&#x2F;example.com&#x2F;postgres-$PG_VERSION.tar.xz | tar -xJC &#x2F;usr&#x2F;src&#x2F;\n    postgress &amp;&amp; …\n\n\nENV PATH &#x2F;usr&#x2F;local&#x2F;postgres-$PG_MAJOR&#x2F;bin:$PATH\nADD\n该命令将复制指定的路径下的内容到容器中的路径下。\n格式：ADD &lt;src&gt; &lt;dest&gt;\n路径支持正则格式。\nCOPY\n格式：COPY &lt;src&gt; &lt;dest&gt;\nENTRYPOINT\n指定镜像的默认入口命令，该入口命令会在启动容器时作为根命令执行，所有传入值作为该命令的参数。\n格式：\n\nENTRYPOINT [\"executable\", \"param1\", \"param2\"] exec\n调用执行\nENTRYPOINT command param1, param2 shell 中执行\n\n每个Dockerfile中只能有一个ENTRYPOINT，当指定多个时，只有最后一个有效。\nVOLUME\n创建一个数据卷挂载点。\n格式：VOLUME [\"/data\"]\nUSER\n指定运行容器时的用户名或UID，后续的RUN等指令也会使用指定的用户身份。\n格式：USER daemon\nWORKDIR\n为后续的 RUN、CMD 和 ENTRYPOINT 指令配置工作目录。\n格式：WORKDIR /path/to/workdir\n可以使用多个 WORKDIR\n指令，后续命令如果参数是相对路径，则会基于之前命令指定的路径。\nARG\n指定一些镜像内使用的参数，这些参数在执行 docker build\n命令时才以 --build-arg&lt;varname&gt;=&lt;value&gt;\n格式传入。\n格式：ARG &lt;name&gt;[=&lt;default value&gt;]\nONBUILD\n配置当所创建的镜像作为其他镜像的基础镜像时，所执行的创建操作指令。\n格式：ONBUILD[INSTRUCTION]\nSTOPSIGNAL\n指定所创建镜像启动的容器接收退出的信号值。例如：\nSTOPSIGNAL signal\nHEALTHCHECK\n配置所启动容器如何进行健康检查（如何判断健康与否），自Docker\n1.12开始支持。\n格式：\n\nHEALTHCHECK [OPTIONS] CMD command：根据所执行命令返回值是否为0来判断；\nHEALTHCHECK NONE：禁止基础镜像中的健康检查。\n\nOPTIONS：\n\n--interval=DURATION（默认为：30s）：过多久检查一次；\n--timeout=DURATION（默认为：30s）：每次检查等待结果的超时；\n--retries=N（默认为：3）：如果失败了，重试几次才最终确定失败。\n\nSHELL\n指定其他命令使用 shell 时的默认 shell 类型。\n创建镜像\n编写完成 Dockerfile 之后，可以通过 docker build\n命令来创建镜像。\n\n如果使用非内容路径下的 Dockerfile，可以通过 -f\n选项来指定其路径。\n要指定生成镜像的标签信息，可以使用 -t 选项。\n\n格式：docker build [OPTION] Path 读取指定路径下的\nDockerfile，并将该路径下的所有内容发送到 Docker\n服务端，由服务端创建镜像。\n例如，指定 Dockerfile 所在路径为\n/tmp/docker_builder/，并且希望生成镜像标签为build_repo/first_image，可以使用下面的命令：\n$ docker build -t build_repo&#x2F;first_image &#x2F;tmp&#x2F;docker_builder&#x2F;\n使用 .dockerignore 文件\n可以通过 .dockerignore 文件（每一行添加一条匹配模式）来让 Docker\n忽略匹配模式路径下的目录和文件。\n","slug":"Linux/Docker基础入门","date":"2022-06-24T06:44:00.000Z","categories_index":"Docker","tags_index":"《Docker技术入门与实践》","author_index":"爱慢跑的乌龟"},{"id":"f7bc0ebd3befb631a0f9a8db60b72936","title":"拉普拉斯变换","content":"拉普拉斯变换\n拉普拉斯变换简表\n\n\n\n\n\n\n\n\n序号\n原函数\n象函数\n\n\n\n\n1\n单位阶跃函数\n\n\n\n2\n单位脉冲函数\n\n\n\n3\n常数\n\n\n\n4\n单位斜坡函数\n\n\n\n5\n\n\n\n\n6\n\n\n\n\n7\n\n\n\n\n8\n\n\n\n\n9\n\n\n\n\n10\n\n\n\n\n11\n\n\n\n\n12\n\n\n\n\n13\n\n\n\n\n14\n\n\n\n\n15\n\n\n\n\n16\n\n\n\n\n17\n\n\n\n\n18\n\n\n\n\n19\n\n\n\n\n\n拉普拉斯变换的定义\n设有时间函数,当时，；在时定义函数的拉普拉斯变换为：\n​ \n拉普拉斯变换：在一定条件下，把实数域中的实变函数变换到复数域内与之等价的复变函数\n\n\n\n\n\n\n\n\n\n判断拉氏变换是否存在\n拉氏变换是否存在取决于定义的积分是否收敛。拉氏变换存在的条件：\n\n当时，分段连续，只有有限个间断点；\n当时，的增长速度不超过某个指数函数，即\n\n\n在复平面上，对于的所有复数\n(Res表示s的实部)都使积分式绝对收敛，故是拉普拉斯变换的定义域，称为收敛坐标。\n拉普拉斯变换的基本性质\n线性定理\n若、是任意两个复常数，且：\n，\n则：\n平移定理\n若：\n则：\n微分定理\n若：\n则：\n同理 ，对于二阶导数的拉普拉斯变换：\n\n推广到 n 阶导数： \n积分定理\n若：\n则：\n对于 n 重积分：\n\n终值定理\n若：\n则：\n初值定理\n若：\n则：\n","slug":"Math/Laplace Transform","date":"2022-06-23T03:18:00.000Z","categories_index":"数学","tags_index":"拉普拉斯变换","author_index":"爱慢跑的乌龟"},{"id":"409671003844af96bee509bb7a2097ee","title":"Latex数学公式","content":"数学公式的插入\n\n\n\n类型\n环境名称\n\n\n\n\n行内公式\n$...$\n\n\n独行公式\n$$...$$\n\n\n\n希腊字母\n\n\n\n命令\n大写\n小写\n\n\n\n\nalpha\n\n\n\n\ngamma\n\n\n\n\nepsilon\n\n\n\n\neta\n\n\n\n\niota\n\n\n\n\nlambda\n\n\n\n\nnu\n\n\n\n\nxi\n\n\n\n\nrho\n\n\n\n\ntau\n\n\n\n\nphi\n\n\n\n\npsi\n\n\n\n\nbeta\n\n\n\n\ndelta\n\n\n\n\nzeta\n\n\n\n\ntheta\n\n\n\n\nkappa\n\n\n\n\nmu\n\n\n\n\nomicron\n\n\n\n\npi\n\n\n\n\nsigma\n\n\n\n\nupsilon\n\n\n\n\nchi\n\n\n\n\nomega\n\n\n\n\n\n声调/变音符号\n\n\n\n公式\n符号\n公式\n符号\n\n\n\n\n\\dot{a}\n\n\\ddot{a}\n\n\n\n\\acute{a}\n\n\\grave{a}\n\n\n\n\\check{a}\n\n\\breve{a}\n\n\n\n\\tilde{a}\n\n\\bar{a}\n\n\n\n\\hat{a}\n\n\\widehat{a}\n\n\n\n\\vec{a}\n\n\n\n\n\n\n标准函数\n\n\n\n\n\n\n\n\n\n公式\n符号\n公式\n符号\n\n\n\n\n\\exp_a b=a^b\n\n\\sin a\n\n\n\n\\exp b=e^b\n\n\\cos b\n\n\n\n10^m\n\n\\tan c\n\n\n\n\\arcsin a\n\n\\sec d\n\n\n\n\\arccos b\n\n\\csc e\n\n\n\n\\arctan c\n\n\\cot f\n\n\n\n\\sinh a\n\n\\operatorname{argsh} a\n\n\n\n\\cosh b\n\n\\operatorname{argch} b\n\n\n\n\\tanh c\n\n\\operatorname{argth} c\n\n\n\n\\coth d\n\n\\operatorname{}\n将任何字符转换成标准函数的形式\n\n\n\n界限\n\n\n\n公式\n符号\n公式\n符号\n\n\n\n\n\\min x\n\n\\lim u\n\n\n\n\\max y\n\n\\liminf v\n\n\n\n\\inf s\n\n\\limsup w\n\n\n\n\\sup t\n\n\\dim p\n\n\n\n\\deg q\n\n\\det m\n\n\n\n\\ker\\phi\n\n\n\n\n\n\n映射\n\n\n\n公式\n符号\n公式\n符号\n\n\n\n\n\\Pr j\n\n\\hom l\n\n\n\n\\lVert z\\rVert\n\n\\arg z\n\n\n\n\n微分和导数\n\n\n\n\n\n\n\n\n\n公式\n符号\n公式\n符号\n\n\n\n\ndt\n\n\\prime\n\n\n\n\\mathrm{d}t\n\n\\backprime\n\n\n\n\\partial t\n\nf^\\prime\n\n\n\n\\nabla\\psi\n\nf' f''\n\n\n\nf^{(3)}\n\n\\dot{y} \\ddot{y}\n\n\n\n\n类字母符号和常数\n\n\n\n公式\n符号\n公式\n符号\n\n\n\n\n\\infty\n\n\\aleph\n\n\n\n\\complement\n\n\\backepsilon\n\n\n\n\\eth\n\n\\Finv\n\n\n\n\\hbar\n\n\\Im\n\n\n\n\\imath\n\n\\jmath\n\n\n\n\\Bbbk\n𝕜\n\\ell\n\n\n\n\\mho\n\n\\wp\n\n\n\n\\Re\n\n\\circledS\n\n\n\n\n模算数\n\n\n\n\n\n\n\n\n\n公式\n符号\n公式\n符号\n\n\n\n\na\\equiv1\\pmod{m}\n**\na\\bmod b\n\n\n\n\\gcd(m,n)\n\n\\operatorname{lcm}(m,n)\n\n\n\n\\mid\n\n\\nmid\n\n\n\n\\shortmid\n\n\\nshortmid\n\n\n\n\n根号\n\n\n\n公式\n符号\n公式\n符号\n\n\n\n\n\\surd\n\n\\sqrt{2}\n\n\n\n\\sqrt[n]{}\n\n\\sqrt[n]{x}\n\n\n\n\n运算符\n\n\n\n\n\n\n\n\n\n公式\n符号\n公式\n符号\n\n\n\n\n+\n\n-\n\n\n\n\\pm\n\n\\mp\n\n\n\n\\dotplus\n\n\\times\n\n\n\n\\div\n\n\\divideontimes\n\n\n\n/\n\n\\backslash\n\n\n\n\\cdot\n\n*\n\n\n\n\\star\n\n\\circ\n\n\n\n\\bullet\n\n\\boxplus\n\n\n\n\\boxminus\n\n\\boxtimes\n\n\n\n\\boxdot\n\n\\oplus\n\n\n\n\\ominus\n\n\\otimes\n\n\n\n\\oslash\n\n\\odot\n\n\n\n\\circleddash\n\n\\circledcirc\n\n\n\n\\circledast\n\n\\bigoplus\n\n\n\n\\bigotimes\n\n\\bigodot\n\n\n\n\n集合\n\n\n\n\n\n\n\n\n\n公式\n符号\n公式\n符号\n\n\n\n\n\\{ \\}\n\n\\emptyset\n\n\n\n\\varnothing\n\n\\in\n\n\n\n\\notin\n\n\\not\\in\n\n\n\n\\ni\n\n\\not\\ni\n\n\n\n\\cap\n\n\\Cap\n\n\n\n\\sqcap\n\n\\bigcap\n\n\n\n\\cup\n\n\\Cup\n\n\n\n\\sqcup\n\n\\bigcup\n\n\n\n\\bigsqcup\n\n\\uplus\n\n\n\n\\biguplus\n\n\\setminus\n\n\n\n\\smallsetminus\n\n\\times\n\n\n\n\\subset\n\n\\Subset\n\n\n\n\\sqsubset\n\n\\supset\n\n\n\n\\Supset\n\n\\sqsupset\n\n\n\n\\subseteq\n\n\\nsubseteq\n\n\n\n\\subsetneq\n\n\\varsubsetneq\n\n\n\n\\sqsubseteq\n\n\\supseteq\n\n\n\n\\nsupseteq\n\n\\supsetneq\n\n\n\n\\varsupsetneq\n\n\\sqsupseteq\n\n\n\n\\subseteqq\n\n\\nsubseteqq\n\n\n\n\\subsetneqq\n\n\\varsubsetneqq\n\n\n\n\\supseteqq\n\n\\nsupseteqq\n\n\n\n\\supsetneqq\n\n\\varsupsetneqq\n\n\n\n\n关系符号\n\n\n\n\n\n\n\n\n\n公式\n符号\n公式\n符号\n\n\n\n\n\\ne\n\n\\neq\n\n\n\n\\equiv\n\n\\not\\equiv\n\n\n\n\\doteq\n\n\\doteqdot\n\n\n\n\\overset{\\underset{def}{}}{=}\n\n:=\n\n\n\n\\sim\n\n\\nsim\n\n\n\n\\backsim\n\n\\thicksim\n\n\n\n\\simeq\n\n\\backsimeq\n\n\n\n\\eqsim\n\n\\cong\n\n\n\n\\ncong\n\n\\approx\n\n\n\n\\thickapprox\n\n\\approxeq\n\n\n\n\\asymp\n\n\\propto\n\n\n\n\\varpropto\n\n&lt;\n\n\n\n\\nless\n\n\\ll\n\n\n\n\\not\\ll\n\n\\lll\n\n\n\n\\not\\lll\n\n\\lessdot\n\n\n\n&gt;\n\n\\ngtr\n\n\n\n\\gg\n\n\\not\\gg\n\n\n\n\\ggg\n\n\\not\\ggg\n\n\n\n\\gtrdot\n\n\\le\n\n\n\n\\leq\n\n\\lneq\n\n\n\n\\leqq\n\n\\nleq\n\n\n\n\\nleqq\n\n\\lneqq\n\n\n\n\\lvertneqq\n\n\\ge\n\n\n\n\\geq\n\n\\gneq\n\n\n\n\\geqq\n\n\\ngeq\n\n\n\n\\ngeqq\n\n\\gneqq\n\n\n\n\\gvertneqq\n\n\\lessgtr\n\n\n\n\\lesseqgtr\n\n\\lesseqqgtr\n\n\n\n\\gtrless\n\n\\gtreqless\n\n\n\n\\gtreqqless\n\n\\leqslant\n\n\n\n\\nleqslant\n\n\\eqslantless\n\n\n\n\\geqslant\n\n\\ngeqslant\n\n\n\n\\eqslantgtr\n\n\\lesssim\n\n\n\n\\lnsim\n\n\\lessapprox\n\n\n\n\\lnapprox\n\n\\gtrsim\n\n\n\n\\gnsim\n\n\\gtrapprox\n\n\n\n\\gnapprox\n\n\\prec\n\n\n\n\\nprec\n\n\\preceq\n\n\n\n\\npreceq\n\n\\precneqq\n\n\n\n\\succ\n\n\\nsucc\n\n\n\n\\succeq\n\n\\nsucceq\n\n\n\n\\succneqq\n\n\\preccurlyeq\n\n\n\n\\curlyeqprec\n\n\\succcurlyeq\n\n\n\n\\curlyeqsucc\n\n\\precsim\n\n\n\n\\precnsim\n\n\\precapprox\n\n\n\n\\precnapprox\n\n\\succsim\n\n\n\n\\succnsim\n\n\\succapprox\n\n\n\n\\succnapprox\n\n\n\n\n\n\n几何符号\n\n\n\n\n\n\n\n\n\n公式\n符号\n公式\n符号\n\n\n\n\n\\parallel\n\n\\nparallel\n\n\n\n\\shortparallel\n\n\\nshortparallel\n\n\n\n\\perp\n\n\\angle\n\n\n\n\\sphericalangle\n\n\\measuredangle\n\n\n\n45^\\circ\n\n\\Box\n\n\n\n\\blacksquare\n\n\\diamond\n\n\n\n\\Diamond\n\n\\lozenge\n\n\n\n\\blacklozenge\n\n\\bigstar\n\n\n\n\\bigcirc\n\n\\triangle\n\n\n\n\\bigtriangleup\n\n\\bigtriangledown\n\n\n\n\\vartriangle\n\n\\triangledown\n\n\n\n\\triangleright\n\n\\blacktriangle\n\n\n\n\\blacktriangledown\n\n\\blacktriangleleft\n\n\n\n\\blacktriangleright\n\n\n\n\n\n\n逻辑符号\n\n\n\n\n\n\n\n\n\n公式\n符号\n公式\n符号\n\n\n\n\n\\forall\n\n\\exists\n\n\n\n\\nexists\n\n\\therefore\n\n\n\n\\because\n\n\\And\n\n\n\n\\lor\n\n\\vee\n\n\n\n\\curlyvee\n\n\\bigvee\n\n\n\n\\land\n\n\\wedge\n\n\n\n\\curlywedge\n\n\\bigwedge\n\n\n\n\\bar{q}\n\n\\bar{abc}\n\n\n\n\\overline{q}\n\n\\overline{abc}\n\n\n\n\\lnot\n\n\\neg\n\n\n\n\\bot\n\n\\top\n\n\n\n\\vdash\n\n\\dashv\n\n\n\n\\vDash\n\n\\Vdash\n\n\n\n\\models\n\n\\Vvdash\n\n\n\n\\nvdash\n\n\\nVdash\n\n\n\n\\nvDash\n\n\\nVDash\n\n\n\n\\ulcorner\n\n\\urcorner\n\n\n\n\\llcorner\n\n\\lrcorner\n\n\n\n\n箭头\n\n\n\n\n\n\n\n\n\n公式\n符号\n公式\n符号\n\n\n\n\n\\Rrightarrow\n\n\\Lleftarrow\n\n\n\n\\Rightarrow\n\n\\nRightarrow\n\n\n\n\\Longrightarrow\n\n\\implies\n\n\n\n\\Leftarrow\n\n\\nLeftarrow\n\n\n\n\\Longleftarrow\n\n\\Leftrightarrow\n\n\n\n\\nLeftrightarrow\n\n\\Longleftrightarrow\n\n\n\n\\iff\n\n\\Uparrow\n\n\n\n\\Downarrow\n\n\\Updownarrow\n\n\n\n\\leftarrow\n\n\\rightarrow\n\n\n\n\\nleftarrow\n\n\\nrightarrow\n\n\n\n\\leftrightarrow\n\n\\nleftrightarrow\n\n\n\n\\longleftarrow\n\n\\longrightarrow\n\n\n\n\\longleftrightarrow\n\n\\uparrow\n\n\n\n\\downarrow\n\n\\updownarrow\n\n\n\n\\nearrow\n\n\\searrow\n\n\n\n\\nwarrow\n\n\\swarrow\n\n\n\n\\mapsto\n\n\\longmapsto\n\n\n\n\\rightharpoonup\n\n\\rightharpoondown\n\n\n\n\\leftharpoonup\n\n\\leftharpoondown\n\n\n\n\\upharpoonleft\n\n\\upharpoonright\n\n\n\n\\downharpoonleft\n\n\\downharpoonright\n\n\n\n\\leftrightharpoons\n\n\\rightleftharpoons\n\n\n\n\\curvearrowleft\n\n\\circlearrowleft\n\n\n\n\\Lsh\n\n\\upuparrows\n\n\n\n\\rightrightarrows\n\n\\rightleftarrows\n\n\n\n\\rightarrowtail\n\n\\rightarrowtail\n\n\n\n\\curvearrowright\n\n\\circlearrowright\n\n\n\n\\Rsh\n\n\\downdownarrows\n\n\n\n\\leftleftarrows\n\n\\leftrightarrows\n\n\n\n\\leftarrowtail\n\n\\looparrowleft\n\n\n\n\\hookrightarrow\n\n\\hookleftarrow\n\n\n\n\\multimap\n\n\\leftrightsquigarrow\n\n\n\n\\rightsquigarrow\n\n\\twoheadrightarrow\n\n\n\n\\twoheadleftarrow\n\n\\xleftarrow{left}\n\n\n\n\\xrightarrow{right}\n\n\n\n\n\n\n特殊符号\n\n\n\n\n\n\n\n\n\n公式\n符号\n公式\n符号\n\n\n\n\n\\amalg\n\n\\%\n\n\n\n\\dagger\n\n\\ddagger\n\n\n\n\\ldots\n\n\\cdots\n\n\n\n\\smile\n\n\\frown\n\n\n\n\\wr\n\n\\diamondsuit\n\n\n\n\\heartsuit\n\n\\clubsuit\n\n\n\n\\spadesuit\n\n\\Game\n\n\n\n\\flat\n\n\\natural\n\n\n\n\\sharp\n\n\\diagup\n\n\n\n\\diagdown\n\n\\centerdot\n\n\n\n\\ltimes\n\n\\rtimes\n\n\n\n\\leftthreetimes\n\n\\rightthreetimes\n\n\n\n\\eqcirc\n\n\\circeq\n\n\n\n\\triangleq\n\n\\bumpeq\n\n\n\n\\Bumpeq\n\n\\doteqdot\n\n\n\n\\risingdotseq\n\n\\fallingdotseq\n\n\n\n\\intercal\n\n\\barwedge\n\n\n\n\\veebar\n\n\\doublebarwedge\n\n\n\n\\between\n\n\\pitchfork\n\n\n\n\\vartriangleleft\n\n\\ntriangleleft\n\n\n\n\\vartriangleright\n\n\\ntriangleright\n\n\n\n\\trianglelefteq\n\n\\ntrianglelefteq\n\n\n\n\\trianglerighteq\n\n\\ntrianglerighteq\n\n\n\n\n\n上下标和积分\n\n\n\n\n\n\n\n\n\n公式\n符号\n公式\n符号\n\n\n\n\na^2\n\na_2\n\n\n\na^{2+2}\n\na_{i,j}\n\n\n\na^2_2\n\n{}^2_1\\!X^3_4\n\n\n\nx'\n\nx^\\prime\n\n\n\n\\dot{x}\n\n\\ddot{x}\n\n\n\n\\vec{x}\n\n\\overleftarrow{AB}\n\n\n\n\\overrightarrow{AB}\n\n\\widehat{AB}\n\n\n\n\\overset{\\frown}{AB}\n\n\\overline{ABC}\n\n\n\n\\underline{ABC}\n\n\n\n\n\n\n上括号\n\\overbrace{1+2+\\cdots+100}：\n\\begin{matrix}5050\\\\\\overbrace{1+2+\\cdots+100}\\end{matrix}：\n下括号\n\\underbrace{1+2+\\cdots+100}：\n\\begin{matrix}\\underbrace{1+2+\\cdots+100}\\\\5050\\end{matrix}：\n求和\n\\sum_{i=1}^na_i \\sum\\limits_{i=1}^na_i：\n求积\n$\\prod_{i=1}^na_i \\prod\\limits_{i=1}^na_i$：\n上积\n\\coprod_{i=1}^na_i \\coprod\\limits_{i=1}^na_i：\n极限\n\\lim_{n\\to\\infty}x_n \\lim\\limits_{n\\to\\infty}x_n：\n积分\n\\int_{-N}^{N}e^x\\,dx：\n二重积分\n\\iint_M^Ndx\\,dy：\n三重积分\n\\iiint_M^Ndx\\,dy\\,dz：\n闭合曲线、曲面积分\n\\oint_Cx^3\\,dx+4y^2\\,dy：\n交集\n\\bigcap_1^np \\bigcap\\limits_1^np：\n并集\n\\bigcup_1^np \\bigcup\\limits_1^np：\n","slug":"Math/Latex_formula","date":"2022-06-20T02:24:00.000Z","categories_index":"数学","tags_index":"Latex 公式","author_index":"爱慢跑的乌龟"},{"id":"a903464ea5b37de55ddd5756ddfafbfa","title":"MQTT V3.1","content":"消息格式\n每个 MQTT 消息可能包含三个部分：\n\nFixed header(全部消息类型)\nVariable header(部分消息类型)\nPayload(部分消息类型)\n\nFixed header\n每个 MQTT 消息类型都必须包含 fixed header. fixed header\n的格式如下表所示：\n\nMessage Type(消息类型)\nPosition：byte1，bits 7-4\n\nReserved\nCONNECT\nCONNACK\nPUBLISH\nPUBACK\nPUBREC\nPUBREL\nPUBCOMP\nSUBSCRIBE\nSUBACK\nUNSUBSCRIBE\nUNSUBACK\nPINGREQ\nPINGRESP\nDISCONNECT\nReserved\n\nenum msgTypes&#123;\n    CONNECT &#x3D; 1, CONNACK, PUBLISH, PUBACK, PUBREC, PUBREL, PUBCOMP, SUBSCRIBE, UNSUBSCRIBE, UNSUBACK, PINGREQ, PINGRESP, DISCONNECT\n&#125;\nFlags(标志位)\nDUP\nPosition: byte1， bit 3.\n当客户端或服务器试图重新发送时，设置次标志。\n注：只能用于 QoS 值大于 0\n的消息，并且需要一个确认(acknowledgment)。当 DUP 位被设置时，variable\nheader 需要包含 Message ID。\nQoS\nPosition：byte1，bits 2-1.\n该标志用于指示所发送的消息的保证级别。QoS 级别如下表：\n\nRETAIN\nPosition：byte1，bit 0.\n该标志只能用于 PUBLISH\n消息类型。当客户端向服务器发送一个 PUBLISH 消息时，如果\nRETAIN 标志设置为\n1，则服务器应该在将消息传递给订阅方之后，依然保存该消息。\n当一个 Topic 上建立了新的订阅时，且订阅方设置了 RETAIN\n标志位，服务器应该将最后保留的消息发送给该订阅方。若没有保留任何消息，则不发送消息。\n为了让客户端区分所接收到的消失是服务器保留的消息，还是服务器实时发布的消息。当原始\nPUBLISH 到达时已存在的订阅导致服务器向客户端发送\nPUBLISH时，不应使用 RETAIN 标志设置，不管原始\nPUBLISH 的保留标志。\n如果服务器接收到零长度 payload 的消息，并且在同一主题上设置了\nRETAIN 标志，则可以删除保留消息。\nRemaining Length\n表示当前消息中剩余的字节数，包括 variable header 和 payload\n中的数据。\nVariable header\n某些类型的 MQTT 命令消息还包含一个 variable header。它位于 fixed\nheader 和 payload 之间。\nRemaining Length 字段的字节不影响 Remaining\n的字节计数长度值。该值只考虑 variable header 和 payload。\nvariable header 字段的格式如下，它们必须按照顺序出现在报头中：\nProtocol name\n消息类型：CONNECT\n该字段是一个 UTF-encoded 的字符串，表示协议名称 MQIsdp。\nProtocol version\n消息类型：CONNECT\n该字段是一个8位无符号值，表示客户端使用的协议的修订级别。V3.1\n版本的协议表示如下：\n\nConnect flags\n消息类型：CONNECT\n标志位：Clean session flag、Will、Will QoS、Retain flags\n\nClean session flag\nPosition：bit 1\n如果没有设置(0)，那么服务器在断开连接后必须存储客户端的订阅。这包括继续存储订阅主题的\nQoS 1 和 QoS 2\n消息，以便在客户端重新连接时交付它们。服务器还必须维护在连接丢失时传递的动态消息的状态。这个信息必须保存到客户端重新连接。\n如果设置为(1)，那么服务器必须丢弃之前维护的关于客户端的任何信息，并将连接视为“干净的”。当客户端断开连接时，服务器也必须丢弃任何状态。\nWill flag\nPosition：bit 2\nWill message 是当服务器与客户端的连接意外发生中断(I/O错误，客户端在\nKeep Alive\n规定的时间内未能完成通信)时，由服务器代替客户端所发布的消息。\n如果设置了 Will 标志，那么 Will QoS 和\nWill Retain 标志必须出现在 Connect flags\n字段中。同时， Will Topic 和 Will Message\n字段也必须包含在 payload 中。\nWill QoS\nPosition：bit 4，3\n设置 Will Message 的 QoS level，QoS level 同上，分为 3 级。\nWill Retain\nPosition：bit 5\nWill Retain\n标志表示在客户端意外断开连接的情况下，服务器是否应该保留由服务器代表客户端发布的Will消息。\nUser name and password flags\nPosition：bits 6，7\n连接的客户端可以指定用户名和密码，设置标志位表示用户名和密码(可选)包含在\nCONNECT 消息的 payload。\n如果设置了 User Name 标志位，则 User Name\n字段为必填字段，否则其值将被忽略。 如果设置了 Password\n标志，则 Password 字段是必须的，否则其值将被忽略。\n不提供用户名而提供密码是无效的。\nKeep Alive timer\n消息类型：CONNECT\nKeep\nAlive计时器(以秒为单位)定义了从客户端接收到的消息之间的最大时间间隔。它使用服务器能够检测到客户端断开连接，并且不必等待\nTCP/IP 连接超时。客户端必须在每个 Keep Alive\n时间段内发送消息。如果在该时间段内没有与数据相关的消息，则客户端发送一个\nPINGREQ 消息，服务器用 PINGRESP\n消息表示确认。\nKeep Alive\n定时器是一个16位的值，表示该时间周期的秒数。实际值与应用程序相关，但典型值是几分钟。最长约18小时。值为0(0)表示客户机没有断开连接。\nKeep Alive计时器的格式如下表所示。Keep Alive Timer 的 2 字节顺序是\nMSB，然后是 LSB (big-endian)。\n\nConnect return code\n消息类型：CONNACK\n该字段定义一个 1 字节无符号返回码。返回码如下表所示：\n\n\nTopic name\n消息类型：PUBLISH\n主题名称是标识将有效负载数据发布到的信息通道的键。订阅方使用密钥来标识希望在其上接收发布信息的信息通道。\n主题名称是UTF-encoded 的字符串。主题名称的长度不超过32767个字符。\nPayload\nCONNECT\nPayload 包含一个或多个 UTF-8 encoded\n的字符串。它们为客户端指定一个唯一的标识符、一个Will主题和消息以及要使用的用户名和密码。除了第一个变量外，其他的都是可选的，它们的存在取决于变量头中的标志。\nSUBSCRIBE\nPayload 包含客户端可以订阅的主题名称列表和QoS级别。这些字符串是\nUTF-encoded。\nSUBACK\nPayload 包含授予的 QoS level 的列表。\n这些是服务端的管理员允许客户端订阅特定 Topic Name 的 QoS level。 授予的\nQoS 级别的列出顺序与对应的\nSUBSCRIBE消息中的主题名称相同。\n\nPUBLISH 消息的 Payload\n部分只包含特定于应用程序的数据。没有对数据的性质或内容做任何假设，消息的这一部分被视为\nBLOB。\nMessage identifiers\n消息类型：PUBLISH,PUBACK,PUBREC,PUBREL,PUBCOMP,SUBSCRIBE,SUBACK,UNSUBSCRIBE,UNSUBACK\n只有 QoS level 为 1 或 2 的消息才会有 Message ID。\nMessage ID 是一个 16\n位无符号整数，在特定通信方向的“正在传输”消息集合中必须是唯一的。\n注：客户端将维护它自己的 Message IDs 列表，与它所连接的服务器使用的\nMessage IDs 分开。客户端可以发送一个 Message ID 为 1 的\nPUBLISH，同时接收 Message ID 为 1\n的PUBLISH。\nMessage Identifier 的两个字节顺序是 MSB，然后是 LSB(大端序)。\n\nMQTT and UTF-8\n在MQTT中，字符串的前缀是两个字节，以表示长度，如下表所示。\n\n字符串长度是编码字符串的字节数，而不是字符数。例如，字符串OTWP使用UTF-8编码，如下表所示。\n\n命令报文\nCONNECT -\n客户端向服务器提交连接请求\n当建立从客户机到服务器的 TCP/IP 套接字连接时，必须使用\nCONNECT 流创建一个协议级别的会话。\nFixed header\n\nRemaining Length 是可变报头的长度(12字节) 和 Payload\n的长度。这可以是一个多字节字段。\nVariable header\n\n\nPayload\nCONNECT 消息的 payload\n包含一个或多个UTF-8编码的字符串，基于 variable header\n中的标志。如果存在字符串，则必须按以下顺序出现:\nClient Identifier\nUTF-encoded 字符串，长度在 1 - 23\n个字符之间，在所有连接到服务器的客户端中，ID 必须是唯一的。如果 ID\n字符超过 23 个，服务器将返回错误代码 2：Identifier Rejected.\nWill Topic\n(如果 Will Flag 设置)第 2 个 UTF-8 encoding 字符串为 Will Topic。Will\nMessage 将被发布到 Will Topic。\nWill Message\n(如果 Will Flag 设置)第 3 个 UTF-8 encoding 字符串为 Will\nMessage。Will Message 定义了在客户端意外断开连接时发布到 Will Topic\n的消息的内容。这可能是一个零长度的消息。\nUser Name\n(如果 User Name Flag 设置)第 4 个 UTF-8 encoding 字符串为 User\nName。User Name 用于标识正在连接的用户的名称，用于认证。User Name\n的长度建议不超过12个字符。\nPassword\n(如果 Password Flag 设置)第 5 个 UTF-8 encoding 字符串为\nPassword。连接用户对应的密码，可用于认证。建议密码长度不超过12个字符。\nResponse\n服务器发送 CONNACK 消息来响应来自客户端的\nCONNECT 消息。\n如果在 TCP/IP\n连接建立后，服务器在合理的时间内没有收到CONNECT消息，服务器应该关闭连接。\n如果客户端在合理的时间内没有收到来自服务器的 CONNACK\n消息，客户端应该关闭TCP/IP\n套接字连接，并通过打开一个新的套接字到服务器并发出 CONNECT\n消息来重新启动会话。\n如果具有相同客户端 ID 的客户端已经连接到服务器，在完成新客户端的\nCONNECT 流之前，服务器必须断开“旧的”客户端。\nCONNACK - 确认连接请求\nCONNACK 消息是服务器响应客户端 CONNECT\n请求而发送的消息。\nFiexed header\n\nVariable header\n\n\nPayload\n无\nPUBLISH - 发布消息\nPUBLISH\n消息由客户机发送到服务器，分发给感兴趣的订阅者。每个\nPUBLISH\n消息都与一个主题名称(也称为主题或通道)相对应。发布到特定主题名称的消息将传递给该主题的连接订阅者。\nFixed header\n\nVariable header\nTopic name\n一个 UTF-encoding 字符串。不能包含 Topic\n通配符。当使用通配符订阅的客户端接收到此字符串时，此字符串将是原始发布者指定的绝对主题，而不是客户端使用的订阅字符串。\nMessage ID\n用于具有 QoS level 1 和 QoS level 2\n的消息。\n下表显示了 PUBLISH 消息的一个示例 Variable header。\n\n\n\nField\nValue\n\n\n\n\nTopic Name:\n\"a/b\"\n\n\nQoS level\n1\n\n\nMessage ID:\n10\n\n\n\n本例中 Variable header 的格式如下表所示。\n\nPayload\n包含要发布的数据。数据的内容和格式是应用程序特有的。\nResponse\n对 PUBLISH 消息的响应取决于 QoS\nlevel。下表显示了预期的响应。\n\n\n\nQoS Level\nExpected response\n\n\n\n\nQoS 0\nNone\n\n\nQoS 1\nPUBACK\n\n\nQoS 2\nPUBREC\n\n\n\nPUBACK - 发布确认\nPUBACK 消息是对 QoS level 1 的 PUBLISH\n消息的响应。服务器发送 PUBACK 消息以响应来自发布客户机的\nPUBLISH 消息，订阅者发送 PUBACK\n消息以响应来自服务器的PUBLISH 消息。\nFixed header\n\nVariable header\n包含正在被确认的 PUBLISH 消息的消息标识符(Message\nID)。下表显示了变量头文件的格式。\n\nPayload\n无\nActions\n当客户端接收到 PUBACK\n消息时，它会丢弃原始消息，因为它也被服务器接收(并记录)。\nPUBREC - 确认发布被接受\nPUBREC 消息是对具有 QoS level 2 的 PUBLISH\n消息的响应。它是 QoS level 2 协议流的第二条消息。PUBREC\n消息由服务器发送，以响应来自发布客户机的 PUBLISH\n消息，或者由订阅方发送，以响应来自服务器的 PUBLISH\n消息。\nFixed header\n\nVariable header\nVariable header 包含已确认的 PUBLISH 的 Message\nID。下表显示了变量头文件的格式。\n\nPayload\n无\nActions\n当接收到 PUBREC 消息时，接收方向发送方发送\nPUBREL 消息， Message ID 与 PUBREC\n消息相同。\nPUBREL - 确认发布\nPUBREL 消息是发布方对来自服务器的 PUBREC\n消息的响应，或服务器对来自订阅方的PUBREC 消息的响应。它是\nQoS 2 协议流中的第三条消息。\nFixed header\n\nVariable header\nVariable header 包含与被确认的 PUBREC 消息相同的 Message\nID。下表显示了变量头文件的格式。\n\nPayload\n无\nActions\n当服务器接收到来自发布方的 PUBREL\n消息时，服务器使原始消息对感兴趣的订阅者可用，并向发布者发送具有相同\nMessage ID 的PUBCOMP\n消息。当订阅者从服务器接收到PUBREL\n消息时，订阅者使该消息对订阅应用程序可用，并向服务器发送\nPUBCOMP 消息。\nPUBCOMP - 确认发布完成\n此消息要么是服务器对发布者的 PUBREL\n消息的响应，要么是订阅者对服务器的 PUBREL 消息的响应。它是\nQoS 2 协议流中的第四个也是最后一个消息。\nFixed header\n\n\nVariable header\nVariable header 包含与确认的 PUBREL 消息相同的 Message\nID。\n\nPayload\n无\nActions\n当客户端接收到 PUBCOMP\n消息时，它会丢弃原始消息，因为它已经被传递给服务器(仅一次)。\nSUBSCRIBE - 订阅命名主题\nSUBSCRIBE\n消息允许客户端向服务器注册对一个或多个主题名称。发布到这些主题的消息作为\nPUBLISH\n消息从服务器传递到客户端。订阅消息还指定订阅者希望在其上接收发布消息的\nQoS level。\nFixed header\n\nVariable header\n\nPayload\nSUBSCRIBE\n消息的有效负载包含客户端希望订阅的主题名称列表，以及客户端希望接收消息的\nQoS级别。\n字符串是 UTF-encoded\n编码的，QoS级别占用单个字节的2位。主题字符串可以包含特殊的topic\n通配符来表示一组主题。 这些 topic/QoS 对是连续打包的，如下表中的示例\npayload 所示。\n\n\n\nTopic name\n\"a/b\"\n\n\n\n\nRequested QoS\n1\n\n\nTopic name\n\"c/d\"\n\n\nRequested QoS\n2\n\n\n\nSUBSCRIBE 消息中的主题名称没有被压缩。示例 payload\n的格式如下表所示。\n\n假设请求的 QoS 级别被授权，客户端接收到的 PUBLISH\n消息小于或等于这个级别，这取决于来自发布者的原始消息的 QoS 级别。\n例如，如果客户端对特定主题有 QoS leve 1\n的订阅，那么将以 QoS level 0 向客户端发送到该主题的 QoS level 0\nPUBLISH 消息。发送到同一主题的 QoS level 2\nPUBLISH 消息被降级为 QoS level 1\n以交付给客户端。\n这意味着发布者负责确定消息可以传递的最大QoS，但订阅者可以将QoS降级为更适合其使用的QoS。消息的QoS从不升级。\n一个同时设置了两个 QoS\n级别位的请求应该被认为是一个无效的数据包，并且连接被关闭。\nResponse\n当它从客户端接收到一个 SUBSCRIBE 消息时，服务器用一个\nSUBACK 消息响应。\n服务器可以在客户端接收到 SUBACK\n消息之前开始发送由于订阅而产生的 PUBLISH 消息。\nSUBACK - 订阅确认\n服务器向客户端发送 SUBACK 消息以确认接收到\nSUBSCRIBE 消息。\nSUBACK 消息包含授权的 QoS\n级别的列表。SUBACK 消息中授予的 QoS 级别的顺序与相应的\nSUBSCRIBE 消息中的主题名称的顺序匹配。\nFixed header\n\nVariable header\nVariable header 包含被确认的订阅消息的 Message\nID。下表显示了变量头文件的格式。\n\nPayload\nPayload 包含一个已授权的 QoS 级别向量。每个级别对应于相应的\nSUBSCRIBE 消息中的主题名称。SUBACK 消息中的\nQoS 级别的顺序与 SUBSCRIBE 消息中主题名称和请求的QoS\n对的顺序匹配。Variable header 中的 Message ID 使能够进行匹配\nSUBACK 消息与相应的 SUBSCRIBE 消息。\nUNSUBSCRIBE - 取消订阅主题\n客户端向服务器发送 UNSUBSCRIBE\n消息以取消对指定主题的订阅。\nFixed header\n\nVariable header\nVariable header 包含一个 Message ID，因为 UNSUBSCRIBE\n消息的 QoS级别为 1。\n\nPayload\n客户端的 payload 中是取消订阅的主题列表。字符串是\nUTF-encoded，并且连续打包。UNSUBSCRIBE\n消息中的主题名称没有被压缩。下表显示了一个示例 payload。\n\n\n\nTopic Name\n\"a/b\"\n\n\n\n\nTopic Name\n\"c/d\"\n\n\n\n\nResponse\n服务器发送 UNSUBACK 到客户端响应\nUNSUBSCRIBE 消息。\nUNSUBACK - 取消订阅确认\nUNSUBACK 消息由服务器发送给客户端，以确认接收到\nUNSUBSCRIBE 消息。\nFixed header\n\nVariable header\n\nPayload\n无\nPINGREQ\nPINGREQ\n消息是从已连接的客户端发送到服务器的“心跳”消息。\nFixed header\n\nVariable header\n无\nPayload\n无\nResponse\n对 PINGREQ 消息的响应是 PINGRESP 消息。\nPINGRESP - PING 响应\nFixed header\n\n\nVariable header\n无\nPayload\n无\nDISCONNECT\n客户端向服务器发送 DISCONNECT 消息，表示它即将关闭\nTCP/IP 连接。这允许干净的断开连接，而不是仅仅删除线路。\n如果客户端连接了 clean\n会话标志集，那么之前维护的关于客户端的所有信息将被丢弃。\nFixed header\n\nVariable header\n无\nPayload\n无\n\nQoS level 1：\n\nQoS level 2：\n\n","slug":"IOT/Mqtt","date":"2022-06-18T12:30:03.000Z","categories_index":"通信协议","tags_index":"MQTT","author_index":"爱慢跑的乌龟"},{"id":"d8ed3ff70bac5529479cf8a31499ebd5","title":"Linux 服务","content":"Linux 服务\ndaemon与服务\n系统为了某些功能必须要提供一些服务（系统本身或者网络方面），这个服务就称为service。service\n的提供需要程序来运行，完成这个 service 的程序就称之为\ndaemon。\n\n\n\n\n\n\n\n\n\n服务的名称被建立之后，在 Linux\n中使用时，通常在服务的名称之后会加上一个d。\nsystemd\nsystemd 全部就是仅有一个 systemd 服务搭配\nsystemctl 命令来处理，无须其他额外的命令来支持。\nsystemd\n将所有的服务定义为一个服务单元(unit)，并将每个\nunit 归类到不同的服务类型中(type)中。\nsystemd\n将服务单元(unit)以下几个类型(type):\n\nservice\nsocket\ntarget\npath\nsnapshot\ntimer\n...\n\nsystemd 将许多的功能集合成为一个所谓的\ntarget\n项目，这个项目这要在设计操作环境的创建，所以是集合了许多的\ndaemon，执行某个 target 就是执行很多的\ndaemon。\nsystemd\n配置文件放置的目录\n服务的基本类型包括：系统服务、数据监听与交换的 socket\n文件服务(socket)、存储系统状态的快照类型、提供不同类似运行级别分类的操作环境(target)。\n文件目录：\n\n/usr/lib/systemd/system/：每个服务最主要的启动脚本设置。\n/run/systemd/system/：系统执行过程中所产生的服务脚本。\n/etc/systemd/system/：管理员根据主机系统的需求所建立的执行脚本。\n\n操作系统所执行的服务均设置在/etc/systemd/system/\n中设置，仅是一些链接文件。而实际的启动脚本文件在\n/usr/lib/systemd/system/\n中，必须在该目录下才能修改相应服务的启动设置。\nsystemd 的 unit\n类型\n扩展名就是服务的类型。例如：multipathd.service\n、multi-user.target。\n几种常见的 systemd 的服务类型：\n\n\n\n\n\n\n\n扩展名\n主要服务功能\n\n\n\n\n.service\n一般服务类型(service\nunit)：主要是系统服务，包括服务器本身需要的本地服务以及网络服务等，经常被使用到的服务大多是这种类型。所以，这也是最常见的类型了。\n\n\n.socket\n内部程序数据交换的 socket\n服务(socket unit)：主要是 IPC(Inter-process communication)\n的传输信息 socket 文件 (socket file)\n功能。这种类型的服务通常在监控信息传递的\nsocket文件中，当通过此 socket\n文件传递信息要链接服务时，就根据当时的状态将该用户的要求传送到对应的\ndaemon，若 daemon 尚未启动，则启动该\ndaemon 后在传送用户的要求。 使用 socket\n类型的服务一般较少用到，因此在开机启动时通常会稍微延迟启动的时间。一般用于本地服务较多。\n\n\n.target\n执行环境类型(target unit)：其实是一群\nunit 的集合。\n\n\n.mount.automount\n文件系统挂载相关的服务(automount\nunit/mount unit)：例如来自网络的自动挂载、NFS\n文件系统挂载等与文件系统相关性较高的进程管理。\n\n\n.path\n检测特定文件或目录类型(path\nunit)：某些服务需要检测某些特定的目录来提供队列服务，例如最常见的打印服务，就是通过检测打印队列目录来启动打印功能。\n\n\ntimer\n循环执行的服务(timer unit)：这个服务有点类似\nanacrontab，不过是由 systemd 主动提供。\n\n\n\nsystemctl 管理服务\nsystemd 这个启动服务的机制，主要是通过一个名为\nsystemctl 的命令来完成的。\nsystemctl\n管理单一服务(service unit) 的启动/开机启动与查看状态\nsystemctl [command] [unit]\ncommand:\nstart:\t\t立刻开启[unit]\nstop:\t\t立刻关闭[unit]\nrestart:\t立刻重新启动[unit]\nreload: \t不关闭[unit]的情况下，重新加载配置文件，让设置生效\nenable:\t\t设置开机时，[unit]自动启动\ndisable:\t关闭开机时自动启动\nstatus:\t\t当前[unit]的状态\nis-active:\t当前是否正在运行中\nis-enable:\t是否设置开机自动启动\nsystemctl status docker.service:\n\n\nLoaded：开机是服务是否自动启动\n[enabled，disabled]\nActive：是否正在执行[running，dead]\n\n几种常见的服务状态：\n\nactive (running)：正在运行\nactive (exited)：仅执行一次就正常结束的服务，目前没有进程执行\nactive\n(waiting)：正在运行中，还需要等待其他事件发生才能继续执行\ninactive：服务当前没有运行\n\ndaemon 的默认状态：\n\nenabled：开机自动运行\ndisabled：开机不运行\nstatic：不可以自行启动，但是可能会其他 enabled\n的服务唤醒\nmask：daemon\n无论如何都不会被启动，因为已经被强制注销\n\nsystemctl\n查看系统上的所有服务\nsystemctl [command] [--type&#x3D;TPYE] [--all]\ncommand:\nlist-units:\t\t\t依据 unit 显示目前所有启动 unit，若加上 --all 会列出没有启动的\nlist-units-files:\t依据 &#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F; 内的文件，将所有文件列表说明\n--type&#x3D;TPYE: 服务类型: service、socket、target等\nsystemctl\n管理不同的操作环境(target unit)\nsystemctl list-units --type=target --all：\n\n与操作界面相关性较高的 tatget 有以下几个：\n\ngraphical.target：命令加上图形界面，包含有 multi-user.target\nmulti-user.target：纯命令行模式\nrescue.target：在无法使用 root 登录的情况下，systemd\n在启动时会多加一个额外的临时系统，与原本的操作系统无关，此时可以获得\nroot 权限来维护系统。\nemergency.target：紧急处理系统的错误，还是需要使用 root\n登录的情况，在无法使用 rescue.target 时，可以尝试这种模式\nshutdown.target：关机模式\ngetty.target：可设置需要几个 tty 的操作\n\nsystemctl [command] [unit.target]\ncommand:\nget-default:\t获取当前的 target\nset-default:\t设置 [unit.target] 为默认的操作模式\nisolate:\t\t切换到 [unit.target] 操作模式\n\n在不重新启动的情况下，将目前操作环境改为纯命令模式，关闭图形界面\nsystemctl isolate multi-user.target\n在 target 项目中必须使用\nisolate 才能切换操作环境，而不是 start\n\nsystemd 还提供可一些简单的命令来切换操作模式：\nsystemctl poweroff\t\t系统关机\nsystemctl reboot \t\t重新启动\nsystemctl suspend\t\t进入挂起模式\nsystemctl hibernate\t\t进入休眠模式\nsystemctl rescue\t\t强制进入休眠模式\nsystemctl emergency \t强制进入紧急恢复模式\n\nsuspend：挂起模式会将系统的状态数据保存到内存中，然后关闭大部分的系统硬件。当用户按下唤醒机器的按钮时，系统数据会在内存中恢复，然后启动大部分被关闭的硬件\nhibernate：休眠模式则是将系统状态保存到硬盘当中，保存完毕后，将计算机关机。\n\nsystemctl\n分析各种服务之间的依赖关系\nsystemctl list-dependencies [unit] [--reverse]\n--reverse: 反向追踪谁使用该 [unit].\nsystemctl list-dependencies：\n\n与 systemd\n的 daemon 运行过程相关的目录\nsystemd 启动脚本配置文件在\n/usr/lib/systemd/system/ 与\n/etc/systemd/system/ 目录下。\n\n/usr/lib/systemd/system/\n官方提供的软件安装后，默认的启动脚本配置文件放在该目录下，这里的数据尽量不要修改，如需要修改，应该修改\n/etc/systemd/system/ 下的文件\n/run/systemd/system/\n系统执行过程中所产生的服务脚本，其优先级高于\n/usr/lib/systemd/system/\n/etc/systemd/system/\n管理员依据主机系统的需要所建立的执行脚本，执行优先级高于\n/run/systemd/system/\n/etc/sysconfig/*\n服务将初始化的一些选项设置写入到这个目录\n/var/lib/\n一些会产生数据的服务都会将它的数据写入到 /var/lib/\n目录中。\n/run/\n放置 daemon 的缓存\n\n\n获取 socket 文件的位置：\nsystemctl list-sockets:\n\n\n查询服务所对应的端口，位于 /etc/services\n执行 cat /etc/services 查看端口：\n\n\n关闭网络服务\n\n\n\n\n\n\n\n\n\n会产生一个网络监听端口(port)的进程，就可以称它是网络服务\n查看网络端口的方式：\nnetstat -tlunp\n\n关闭一个网络服务：\nsystemctl stop avahi-daemon.service\nsystemctl stop avahi-daemon.socket\nsystemctl disable avahi-daemon.service avahi-daemon.socket\nsystemctl\n对于 service 类型的配置文件\n\n/usr/lib/systemd/system/vsftpd.service\n：官方发布默认配置文件\n/etc/systemd/system/vsftpd.service.d/custom.conf：在\n/etc/systemd/system\n下建立与配置文件相同文件名的目录，但是要加上 .d\n扩展名，然后在该目录下建立配置文件即可。配置文件的扩展名最好用\n.conf。\n/etc/systemd/system/vsftpd.service.wants/*：此目录内的文件为链接文件，设置依赖服务的链接。启动\nvsftpd.service 之后，最好加上该目录下建议的服务。\n/etc/systemd/system/vsftpd.service.requires/*：此目录内的文件为链接文件，设置依赖服务的链接。在启动\nvsftpd.service 之前，需要事先启动的服务。\n\n\n配置文件中，能够将整个设置分为三个部分：\n\n[Unit]：unit 本身的说明，以及其他依赖\ndeamon 的设置，包括在什么服务之后才启动此 unit\n之类的设置值。\n[Service]、[Socket]、[Timer]、[Mount]、[Path]：不同的 unit\n类型就要使用相应的设置项目。这个项目主要用来规范服务启动的脚本、环境配置文件名、重新启动的方式等。、\n[Install] ：将此 unit 安装到哪个 target 里去\n\n配置文件内的设置规则：\n\n设置项目通常是可以重复的，例如可以重复设置两个 After\n在配置文件中，但是会替换前面的。\n如果设置参数需要有\n【是/否】的项目(布尔值，Boolean)，可以使用1、yes、true、on代表启动，用0、no、false、off代表关闭\n空白行、开头为 # 或 ；的那一行，代表注释\n\n两个 vsftpd 运行的实例\n# 1. 建立所需要的配置文件\ncd &#x2F;etc&#x2F;vsftpd\ncp vsftpd.conf vsftpd2.conf\n# 修改端口\nvim vsftpd2.conf\nlisten_port&#x3D;555\n# 2. 处理启动脚本设置\ncd &#x2F;etc&#x2F;systemd&#x2F;system\ncp &#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;vsftpd.service vsftpfd2.service\nvim vsftpd.service\n# 3. 重新加载 systemd 的脚本配置文件内容\nsystemctl daemon-reload\n自定义服务\n脚本：\n# vim &#x2F;backups&#x2F;backup.sh\n----\n#! &#x2F;bin&#x2F;bash\nsource &#x3D; &quot;&#x2F;etc &#x2F;home &#x2F;root &#x2F;var&#x2F;lib &#x2F;var&#x2F;spool&#x2F;&#123;cron, at, mail&#125;&quot;\ntarget &#x3D; &quot;&#x2F;backups&#x2F;backup-system-$(data +%Y-%m-%d).tar.gz&quot;\n[ ! -d &#x2F;backups ] &amp;&amp; mkdir &#x2F;backups\ntar -zcvf $&#123;target&#125; $&#123;source&#125; $&gt; &#x2F;backups&#x2F;backup.log\n# chmod a+x &#x2F;backups&#x2F;backup.sh\n设计一个名为 bachup.service 的启动脚本设置：\n# vim &#x2F;etc&#x2F;systemd&#x2F;system&#x2F;backup.service\n[Unit] \nDescription&#x3D;backup my server\nRequires&#x3D;atd.service\n[Service]\nType&#x3D;simple\nExecStart&#x3D;&#x2F;bin&#x2F;bash -c &quot; echo &#x2F;backups&#x2F;bachup.sh | at now&quot;\n[Install]\nWantedBy&#x3D;multi-user.target\nsystemctl 针对\ntimer 的配置文件\n任务需求：\n想要使用 systemd 的 timer 功能，必须要有几个要件：\n\n操作系统的 timer.target 一定要启动。\n要有个 sname.service 的服务存在(sname\n是你自己指定的名称)\n要有个 sname.timer 的时间启动服务存在\n\n sname.timer  的设置值\n可以到 /etc/systemd/system 下面去建立一个\n*.timer 文件\n基本设置如下：\n\n\n\n\n\n\n\n设置参数\n参数说明\n\n\n\n\nOnActiveSec\n当 timer.target 启动多久后才执行这个 unit\n\n\nOnBootSec\n当启动完成后多久之后才执行\n\n\nOnStartupSec\n当 systemd 第一次启动之后过多久才执行\n\n\nOnUnitActiveSec\n这个 timer 配置文件所管理的那个 unit\n服务在最后一次启动后，隔多久再执行一次的意思\n\n\nOnUnitlnactiveSec\n这个 timer 配置文件所管理的那个 unit\n服务在最后一次停止后，隔多久再执行一次的意思\n\n\nOnCalendar\n使用实际时间（非循环时间）的方式来启动服务的意思\n\n\nUnit\n一般来说不太需要设置，因此如同上面提到的，基本上我们设置都是\nsname.server + sname.timer，那如果你的 sname 并不相同时，那在 .timer\n的文件中，就得要指定是哪个 service unit\n\n\nPersistent\n当使用 OnCalendar\n的设置时，指定该功能要不要持续进行的意思，通常是设置为\nyes，比较能够满足类似 anacron 的功能\n\n\n\n使用于 OnCalendar 的时间 \n\n\n\n\n\n\n\n\n\n语法：英文周名 YYYY-MM-DD HH:MM:SS\n范例：Thu 2015-08-13 13:40:00\n也可以直接使用间隔时间来处理。常用的间隔时间单位有：\n\nus 或 usec：微妙\nms 或 msec：毫秒\ns、sec、second、seconds\nm、min、minute、minutes\nh、hr、hour、hours\nd、day、days\nw、week、weeks\nmonth、months\ny、year、years\n\n常见的使用范例：\n\n\n\n\n\n\n\n\n\n隔 3 小时： 3h 或 3hr 或 3hours\n隔 300 分钟过 10 秒： 10s 300m\n隔 5 天又 100 分钟： 100m 5 day\n一个循环时间运行的案例：\n\n启动后 2 小时开始执行一次 backup.service\n自从第一次执行后，未来每两天执行一次 backup.service\n\n# vim &#x2F;etc&#x2F;systemd&#x2F;system&#x2F;backup.timer\n[Unit]\nDescription&#x3D;backup my server timer\n[Timer]\nOnBootSec&#x3D;2hrs\nOnUnitActiveSec&#x3D;2days\n[Install]\nWantedBy&#x3D;multi-user.target\n固定日期运行案例：\n\n星期天凌晨2点运行\n\n# vim &#x2F;etc&#x2F;systemd&#x2F;system&#x2F;backup2.timer\n[Unit]\nDescription&#x3D;backup my server timer2\n[Timer]\nOnCalendar&#x3D;Sun *-*-* 02:00:00\nPersistent&#x3D;true\nUnit&#x3D;backup.service\n[Install]\nWantedBy&#x3D;multi-user.target\n","slug":"Linux/service","date":"2022-05-04T04:05:00.000Z","categories_index":"Linux","tags_index":"Linux 服务","author_index":"爱慢跑的乌龟"},{"id":"2b59eb5778e5da9b12f5210e8d61016e","title":"路径规划算法","content":"1.\n自动驾驶汽车定位-感知-规划-决策-控制概述\n定位\n\n定位，即通过GPS、惯导、激光雷达等传感器，获取车辆的位置和航向信息。\n绝对定位是指通过GPS实现，采用双天线，通过卫星获得车辆在地球上的绝对位置和航向信息。\n相对定位是指根据车辆的初始位姿，通过惯导、里程计等传感器获得加速度信息，将其对时间进行积分，即可得到相对初始位姿的当前位姿信息。\n\n感知\n\n环境感知，即通过摄像头、激光雷达、毫米波雷达、超声波雷达等队中传感器，感知周围环境信息和车辆状态信息。\n环境信息包括：道路、方向、曲率、坡度、交通标志，信号灯；车辆状态信息包括：车辆前进的速度、加速度、转向角度、车身位置及姿态。\n多种传感器虽然可以获得丰富、细致的环境信息，但如何对多种传感器的信息进行融合统一处理\n\n规划\n\n规划是对未来时域、空域的车辆一系列动作的计划。从涉及的时空大小全局（宏观）路径规划和局部（微观）路径规划。\n全局路径规划指在已知全局地图的情况下，从车辆当前位置规划出一条到目的地的全局路径。\n局部路径规划指根据环境感知的信息在环道、转弯、躲避障碍物等情况下，实时规划出一条安全、平顺、舒适的行驶路径。\n\n决策控制\n\n决策控制，包括决策和控制两部分\n决策，在整个无人驾驶系统中，扮演驾驶员大脑的角色，根据定位、感知、路径规划的信息，决定无人车的形式策略。包括：选取哪条车道、是否换道、是否跟车行驶、是否绕道、是否停车等。\n控制，主要包括转向、驱动、制动三方面的控制，执行规划决策模块下发的期望速度和期望转向角度，也包括转向灯、喇叭、门窗等的控制。\n\n2.全局路径规划算法——Dijkstra算法\n算法简介\n迪杰斯特拉算法(Dijkstra)是由荷兰计算机科学家狄克斯特拉于1959年提出的，因此又叫狄克斯特拉算法。是从一个节点遍历其余各节点的最短路径算法，解决的是有权图中最短路径问题\n算法思想\n\n设是一个带权有向图，把图中节点集合V分成两组，第一组为已求出最短路径的集合,(用S表示，初始时S中只有一个源点，以后每求得一条最短路径，就将该节点加入到集合S中，直到全部节点都加入到S中，算法结束)\n第二组为区域未确定最短路径的节点集合（用U表示），按最短路径长度的递增次序依次把第二组的节点加入S中。在加入的过程中，总保持从源点v到S中各节点的最短路径长度不大于从源点v到U中任何节点的最短路径长度。\n此外，每个节点对应一个距离，S中的节点的距离就是从v到此节点的最短距离路径长度，U中的节点的距离，是从v到此节点只包括S中的节点为中间节点的当前最短路径长度。\n\n\n算法精讲\n\n初始时，S只包含起点s；U包含除s外的其他节点，且U中节点的距离为”起点s到该节点的距离“[例如，U中节点v的距离为(s,v)的长度，然后s和v不相邻，则v的距离为].\n从U中选出”距离最短的节点k“，并将节点k加入到S中；同时，从U中移除节点k。\n更新U中各节点到起点s的距离。之所以更新U中节点的距离，是因为上一步确定了k是求出最短路径的节点，从而可以利用k来更新其他节点的距离；例如，的距离可能大于的距离。\n重复步骤(2)和(3)，直到遍历完所有节点。\n\n\n选取节点， \n\n选取节点，，.\n\n选取节点，，.\n\n选取节点，，.\n\n，.\n\n，.\n\n，.\n\n的最优路径为\n最短距离为22\nMatlab实现\nclc\nclear\nclose all\n%% 图定义\n% 根据节点的邻近节点表及字母点-数字节点对应表，构造节点元胞数组\nnodes_dist = cell(0);\nnodes_dist(1,:) = {1, [2, 6, 7], [12, 16, 14]};\nnodes_dist(2,:) = {2, [1, 3, 6], [12, 10, 7]};\nnodes_dist(3,:) = {3, [2, 4, 5, 6], [10, 3, 5, 6]};\nnodes_dist(4,:) = {4, [3, 5], [3, 4]};\nnodes_dist(5,:) = {5, [3, 4, 6, 7], [5, 4, 2, 8]};\nnodes_dist(6,:) = {6, [1, 2, 3, 5, 7], [16, 7, 6, 2, 9]};\nnodes_dist(7,:) = {7, [1, 5, 6], [14, 8, 9]};\n\n%% 算法初始化\n% S/U的第一列表示节点编号\n% 对于S,第二列表示从源节点到本节点已求得的最小距离，不再变更；\n% 对于U,第二列表示从源节点到本节点暂时求得的最小距离，可能会变更\nS = [4, 0];\nU(:,1) = [1, 2, 3, 5, 6, 7];\nU(:,2) = [inf, inf, 3, 4, inf, inf]};\n\n% 最优路径及暂时的最优路径的初始化\npath_opt = cell(7, 2);\npath_opt(4,:) = {4, 4};\n\npath_temp = cell(7, 2);\npath_temp(3,:) = {3, [4, 3]};\npath_temp(4,:) = {4, 4};\npath_temp(5,:) = {5, [4, 5]};\n\n%% 循环遍历所有节点\nwhile ~isempty(U)\n[dist_min, idx] = min(U(:,2));\nnode_min = U(idx, 1);\nS(end+1,:) = [node_min, dist_min];\nU(idx,:) = [];\n\n% 将最小的距离值的节点添加到到最优路径集合\npath_opt(node_min,:) = path_temp(node_min,:);\n\n%% 依次遍历最小距离节点的邻节点，判断是否在U集合中更新邻节点的距离值\nfor i = 1:length(nodes_dist{node_min, 2})\n\ti = 1;\n\t% 需要判断的节点\n\tnode_temp = nodes_dist{node_min, 2}(i);\n\t\n\t% 找出U集合中节点node_temp的索引值\n\tidx_temp = find(node_temp == U(:,1));\n\t\n\t% 判断是否更新\n\tif ~isempty(idx_temp)\n\t\tif dist_min + node_dist{node_min, 3}(i) &lt; U(idx_temp, 2)\n\t\t\tU(idx_temp, 2) = dist_min + nodes_dist{node_min, 3}(i)\n\t\t\t\n\t\t\t% 更新暂时最优路径\n\t\t\tpath_temp{node_temp, 1} = node_temp;\n            path_temp{node_temp, 2} = [path_opt{node_min, 2}, node_temp];\n            end        \nPython实现\n# 图定义\n# 根据节点的邻近节点表-数字对应表，构造图\nnodes_dist = dict()\nnodes_dist[1] = {2: 12, 6: 16, 7: 14}\nnodes_dist[2] = {1: 12, 3: 10, 6: 7}\nnodes_dist[3] = {2: 10, 4: 3, 5: 5, 6: 6}\nnodes_dist[4] = {3: 3, 5: 4}\nnodes_dist[5] = {3: 5, 4: 4, 6: 2, 7: 8}\nnodes_dist[6] = {1: 16, 2: 7, 3: 6, 5: 2, 7: 9}\nnodes_dist[7] = {1: 14, 5: 8, 6: 9}\n\n# S 集合\nS = dict()\n\n# U 集合\nU = dict()\nU[1] = float('inf')\nU[2] = float('inf')\nU[3] = float('inf')\nU[4] = 0\nU[5] = float('inf')\nU[6] = float('inf')\nU[7] = float('inf')\n\n# 当前最优路径\nkeys = [i for i in range(1, 8)]\npath_temp = dict([(k, []) for k in keys])\n\n\n# 最终最优路径\npath_opt = dict([(k, []) for k in keys])\n\n# 循环遍历U集合，直到所有节点被确定，并移出集合\nwhile U:\n    # 寻找U集合中的最小值，及其对应的节点\n    dist_min = min(U.values())\n    node_min = min(U, key=U.get)\n    # 将最小值节点移出U集合，移入S集合\n    S[node_min] = dist_min\n    del U[node_min]\n\n    # 确定该最小值节点的最终最优路径\n    path_opt[node_min] += path_temp[node_min]\n    path_opt[node_min].append(node_min)\n\n    # 围绕该最小值节点，循环遍历其相邻节点\n    for node_temp in nodes_dist[node_min].keys():\n        # 判断该相邻节点是否在集合U中，即该节点是否已经被确定。若已确定，则不做考虑\n        if node_temp in list(U.keys()):\n            # 判断该路径是否比原有路径短\n            if (dist_min + nodes_dist[node_min][node_temp]) &lt; U[node_temp]:\n                # 更新最短距离\n                U[node_temp] = dist_min + nodes_dist[node_min][node_temp]\n                # 该最短距离所对应的新路径\n                path_temp[node_temp] = path_opt[node_min]\n\nprint(S, U)\nprint(path_opt)\n3.全局路径规划算法——蚁群算法\n算法简介\n蚁群算法是一种智能算法，它是由一群无智能或有微智能的个体(Agent)通过相互协作表现出智能行为，从而为求解复杂问题提供了一个新的可能性。\n\n蚁群算法(Ant Colony Algorithm, ACA)\n于1992年首次提出，该算法模拟了自然界中蚂蚁的觅食行为.\n蚂蚁在寻找食物源时，会在其经过的路径上释放一种信息素，并能够感知其他蚂蚁释放的信息素，信息素浓度的大小表征路径的远近，信息素浓度越高，表示对应的路径距离越短。\n通常，蚂蚁会以较大的概率优先选择信息素浓度较大路径，并释放一定量的信息素，以增强该条路径上的信息素浓度，这样，会形成正反馈。最终，蚂蚁能够找到一条从巢穴到食物源的最佳路径，即距离最短。\n\nTSP问题描述\n蚁群算法最早用来解决TSP问题，并且表现出很大的优越性，因为它有分布式特性、鲁棒性强并且容易与其他算法结合，但是同时也存在收敛速度慢，容易陷入局部最优等缺点。\nTSP问题(Travel Salesperson\nProblem，即旅行商问题或者称为中国邮递员问题)，是一种NP-hard问题，此类问题用一般的算法很难得到最优解的，所以一般需要借助一些启发式算法求解，例如遗传算法(GA)，蚁群算法(ACO)，微粒群算法(PSO)等。\n\n\n\n\n\n\n\n\n\nTSP问题（旅行商问题）是指旅行家旅行n个城市，要求各个城市经历且仅经历一次然后回到出发城市，并要求所走路程最短。\n一个TSP问题可以表达为：求解遍历图，所有的节点一次并且回到起始节点，使得连接这些节点的路径成本最低。\n算法思想\n\n用蚂蚁的行走路径并表示待优化问题的可行解，整个蚂蚁群的所有路径构成待优化问题的解空间。\n路径较短的，蚂蚁会释放较多的信息素，随着时间的推进，较短的路径上积累的信息素浓度逐渐增高，选择该路径的蚂蚁个数也愈来愈多。\n最终，整个蚂蚁会在正反馈的作用下集中到最佳的路径上，此时对应的便是待优化问题的最优解。\n\n\n算法精讲\n原理\n假如蚁群中所有蚂蚁的数量为，所有城市之间的信息素用矩阵表示，最短路径为\n，最佳路径为。每只蚂蚁都有自己的内存，内存中用一个禁忌表(Tabu)来存储蚂蚁已经访问过的城市，表示以后的搜索将不能访问这些城市；还有用另外一个允许访问的城市表(Allowed)来存储它还可以访问的城市；另外还用矩阵(Delta)来储存它在一个循环（或者迭代）中经过的路径释放的信息素；还有另外一些数据，例如一些控制参数，该蚂蚁行走完全程的总成本或距离(tourLength)，等等。假定算法总共运行MAX_GEN次，运行时间为t.\n蚁群算法计算过程如下：\n\n初始化\n为每只蚂蚁选择下一个节点。\n更新信息素矩阵\n检查终止条件\n\n\n\n\n\n\n\n\n\n\n如果达到最大迭代数MAX_GEN，算法终止，转到第(5)步；否则，重新初始化所有蚂蚁的Delta矩阵所有元素初始化为0，Tabu表清空，Allowed表加入所有城市节点。随机选择它们的起始位置（也可以人为指定）。在Tabu表中加入起始节点，Allowed表中删除该起始节点，重复执行(2),(3),(4)步。\n\n输出最优值\n\n\n不失一般性，设整个蚂蚁群体中蚂蚁的数量为，城市的数量为，城市与城市之间的相互距离为，时刻城市与城市连接路径上的信息素浓度为。初始时刻，各个城市间连接路径上的信息素浓度相同，不妨设为。\n蚂蚁根据各个城市间连接路径上的信息素浓度决定其下一个访问的城市，设表示时刻蚂蚁从城市转移到城市的概率，其计算公式如下：\n​ \n其中，为启发函数，，表示蚂蚁从城市转移到城市的期望程度，蚂蚁待访问城市的集合。开始时，中有个元素，即包括除了蚂蚁出发城市的其他所有城市，随着时间的推进，中的元素不断减少，直至为空，即表示所有的城市均访问完毕。为信息素重要程度因子，其值越大，表示信息素的浓度在转移中起的作用越大；为启发函数重要程度因子，其值越大，表示启发函数转移中的作用越大，即蚂蚁会以较大的概率转移到距离短的城市。\n在蚂蚁释放信息素的同时，各个城市间连接路径上的信息素逐渐消失，设参数表示信息挥发程度。因此，当所有蚂蚁完成一次循环后，各个城市间连接路径上的信息素浓度需要进行实时更新，具体公式如下：\n​ \n其中，表示第只蚂蚁在城市与城市连接路径上释放的信息素浓度，表示所有蚂蚁在城市与城市连接路径上释放的信息素浓度之和。\nant cycle system 模型中，的计算公式如下：\n​ 第只蚂蚁从城市访问城市其它\n\n\n\n\n\n\n\n\n\n定义\n参数影响分析\n\n\n\n\n\n信息启发式因子\n值越大，蚂蚁选择之前走过的路径可能性就越大，搜索路径的随机性减弱，越小，蚁群搜索范围就会减少，容易陷入局部最优\n\n\n\n期望启发式因子\n值越大，蚁群越容易选择局部较短路径，这时算法的收敛速度是加快了，但是随机性却不高，容易得到局部最优解\n\n\n\n蚁群数量\n数目越多，得到的最优解就越精确，但是会产生不少重复解，随着算法接近最优解的收敛，信息正反馈作用降低，大量的重复工作，消耗了资源，增加了时间复杂度\n\n\n\n信息挥发因子，表示残留因子\n过小时，在各路径上残留的信息素过多，导致无效的路径继续被搜索，影响到算法的收敛速率；过大，无效的路径虽然可以被排除搜索，但是不能保证有效的路径也会被搜索，影响到最优值的搜索。\n\n\n\n蚁群算法中主要参数的理想选择如下：\n\n\n\n参数\n取值范围\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n流程图：\n\n文献\n1.蚁群算法中参数\nα、β 、ρ设置的研究 ———以 TSP 问题为例\n蚁群算法在TSP问题应用中取得了良好的效果，但也存在一些不足：\n\n如果参数、、设置不当，导致求解速度很慢且所得的解质量特别差；\n基本蚁群算法计算量大，求解所需要的时间较长；\n基本蚁群算法中理论上要求所有的蚂蚁选择同一路线，该线路即为所求的最优线路；但在实际计算中，在给定一定循环次数的条件下很难实现这种情况。\n另一方面，在其他实际应用中，如图像处理中寻求最优模板问题，并不要求所有的蚂蚁都能找到最优的模板，而只需要一只找到即可。\n\n时刻在路径上的信息素浓度为：\n​ \n表示蚂蚁在时间段到的过程中，在到的路径上留下的残留信息浓度。根据信息素更新策略的不同，有3种不同的蚁群算法模型：\n\nant-quantity模型\n，如果蚂蚁经过，如果蚂蚁不经过\n式中，是常量，信息素的增量与之间的距离有关。\nant-density模型\n，如果蚂蚁经过，如果蚂蚁不经过\n式中，是常量，则信息素增加一个固定值，与之间的距离无关\nant-cycle模型\n，如果蚂蚁在巡回中经过，如果蚂蚁在巡回中不经过\n式中，是常量；表示第只蚂蚁的循环路线，即如果蚂蚁经过，则信息素增量为一个常量除以蚂蚁的巡回路线长。这里，信息素增量只与蚂蚁的巡回路线和有关系，而和具体的无关。\n\n代码实现\nimport random\nimport copy\nimport time\nimport sys\nimport math\nimport tkinter\nimport threading\nfrom functools import reduce\n\n# 参数\n'''\nAlpha:信息启发因子，值越大，则蚂蚁选择之前走过的路径可能性就越大，值越小，则蚁群搜索范围就会减少，容易陷入局部最优\nBeta:值越大，蚁群就越容易选择局部最短路径，这时算法收敛速度加快，但是随机性不高，容易得到局部的相对最优\n'''\n(Alpha, Beta, Rho, Q) = (1.0, 2.0, 0.5, 100.0)\n# 城市数，蚁群\n(city_num, ant_num) = (50, 50)\ndistance_x = [\n    178,272,176,171,650,499,267,703,408,437,491,74,532,\n    416,626,42,271,359,163,508,229,576,147,560,35,714,\n    757,517,64,314,675,690,391,628,87,240,705,699,258,\n    428,614,36,360,482,666,597,209,201,492,294]\ndistance_y = [\n    170,395,198,151,242,556,57,401,305,421,267,105,525,\n    381,244,330,395,169,141,380,153,442,528,329,232,48,\n    498,265,343,120,165,50,433,63,491,275,348,222,288,\n    490,213,524,244,114,104,552,70,425,227,331]\n\n# 城市距离和信息素\ndistance_graph = [[0.0 for col in range(city_num)] for raw in range(city_num)]\npheromone_graph = [[1.0 for col in range(city_num)] for raw in range(city_num)]\n\n\n#----------蚂蚁-----------\nclass Ant(object):\n    def  __init__(self, ID):\n        self.ID = ID                    # ID\n        self.__clean_data()             # 随机初始化出生点\n4.全局路径规划算法——动态规划算法\n算法简介\n\n动态规划是运筹学的一个分支，是求解多阶段决策过程最优化问题的数学方法。\n各个阶段决策的选取不是任意确定的，它依赖于当前面临的状态，又影响以后的发展。当各个阶段的决策确定以后，就组成一个决策序列，因而也就决定了整个过程的一条活动路线，这样的一个前后关联具有链状结构的多阶段过程就称为多阶段决策问题。\n动态规划在车辆工程技术领域有着广泛的应用，如“两档变速器的最优换挡规律”、“混合动力汽车最优能量管理策略”、“栅格地图最优路径搜索”等。\n\n动态规划算法是通过拆分问题，定义问题状态和状态之间的关系，使得问题能够以递推（或者说分治）的方式去解决。动态规划算法的基本思想与分治法类似，也是将待求解问题分解为若干子问题（阶段），按顺序求解子阶段，前一子问题的解，为后一子问题的求解提供了有用的信息。在求解任一子问题时，列出各种可能的局部解，最后一个子问题就是初始问题的解。\n算法思想\n\n美国数学家Bellman等人在20世纪50年代初提出了著名的最优化原理，把多阶段决策问题转化为一系列单阶段最优化问题。\n对最佳路径（最佳决策过程）所经过的各个阶段，其中每各阶段起始点到全过程终点的路径，必定是该阶段起始点到全过程终点的一切可能路径中的最佳路径（最优决策），这就是Bellman提出的著名的最优化原理。\n简言之，一个最优决策的子决策必然是最优的。\n\n\n算法精讲\n\n逆向寻优，正向求解\nDP算法本质由三层循环构成\n第一层遍历每一个阶段；\n第二层遍历第i个阶段的每个状态；\n第三层循环遍历第i+1个阶段的每一个状态。\n\n\n\n第四阶段 (D-&gt;E): D有两条路线到终点E。\n\n\n第三阶段(C-&gt;D): C到D有6条路线\n第3阶段的C有3个状态值，分别讨论经过该状态值的最优路线\n经过C1\n\n最短路线为\n经过C2\n\n最短路线为\n经过C3\n\n最短路线为\n\n第二阶段(B-&gt;C): B到C有9条路线。\n第2阶段的B有3个状态值，分别讨论经过该状态值的最优路线\n经过B1\n\n最短路线为\n经过B2\n\n最短路线为\n经过C3\n\n最短路线为\n\n第一阶段(A-&gt;B)：A到B有3条路线\n\n最短路线为\n5.全局路径规划算法——A*算法\n算法简介\n\nA*(A-Star)算法是一种静态路网求解最短路径最有效的直接搜索方法，也是解决许多搜索问题的有效算法，\n广泛应用于室内机器人路径搜索、游戏动画路径搜索等。\n\n算法思想\n\nA*算法结合了贪心算法（深度优先）和Dijkstra算法（广度优先），是一种启发是搜索算法。\n路径优劣的评价公式为：\n是从初始状态经由状态到目标状态的代价估计，\n是在状态空间中从初始状态到状态的实际代价\n是从状态到目标状态的最佳路径的估计代价\n使用了两个状态表，分别称为openList表和closeList表。openList表由待考察的节点组成，closeList表由已经考察过节点组成。\n\n算法精讲——预处理\n\n将地图栅格化，把每一个正方形格子的中央称为节点；\n确定栅格属性，即每一个格子有两种状态：可走和不可走（体现障碍物）。\n定义两个列表集合：openList和closeList。openList表由待考察的节点组成，closeList由已经考察的节点组成。类似Dijkstra算法的U集合和S集合。\n确定起始节点和目标节点。\n\n\n\n初始时，定义A为父节点，节点A离自身的距离为0，路径完全确定，移入closeList中；\n父节点周围共有8个节点，定义为子节点。将子节点放入openList中，成为待考察对象。\n若某个节点既未在openList，也没在closeList中，则表明还有未搜索到该节点。\n路径优劣的判断依据是移动代价，单步移动代价采取Manhattan\n计算方式，即把横向和纵向移动一个节点的定义为10。斜向移动代价参考等腰三角形计算斜边的方式，距离为14。\n算法精讲——开始搜索\n\n移动代价评价函数为：。是初始状态经由状态到目标状态的代价估计，是在状态空间中从初始状态到状态的实际代价，是从状态到目标状态的最佳路径的估计代价。以节点为例。\n首先考察，由于从A到该格子是斜向移动，单步移动距离为14，故\n在考察估计代价。估计的含义是忽略剩下的路径是否包含有障碍物（不可走），完全按照Manhattan计算方式，计算只做横向或纵向移动的累计代价：横向向右移动3步，纵向向上移动1步，总共4步，故为.\n因此从A节点移动I节点的总移动代价为：\n以此类推，分别计算当前openList中余下的7个子节点的移动代价，挑选最小代价节点F，移动到closeList中。\n现在\n\n\n","slug":"Self-Driving/PathPlan","date":"2022-05-03T16:00:00.000Z","categories_index":"自动驾驶","tags_index":"路径规划","author_index":"爱慢跑的乌龟"},{"id":"b64cd93b72faed23ef520531eb71c1e8","title":"pacman 文档","content":"pacman - Arch Linux\n软件管理器\nSYNOPSIS\npacman &lt;operation&gt; [options] [targets]\nDESCRIPTION\nPacman 是一个包管理的使用程序，用于跟踪 Linux\n系统上以安装的包。它具有依赖性支持、软件包组、安装和卸载脚本，以及将本地机器与远程存储库同步以自动升级包的功能。Pacman\n包是 tar 压缩格式。\n调用 pacman\n涉及到指定一个带有任何潜在选项(options)和目标(targets)的操作(operation)。目标通常是包名(package\nname)、文件名(file name)、URL或搜索字符串(search\nstring)。目标可以作为命令行参数提供。\nOPERATIONS\n\n-D， --database\n对包数据库进行操作。通过该操作，可以修改 pacman\n数据库中已安装软件包的某些属性。检查数据库内部一致性。\n-Q，--query\n查询包数据库。该操作可以查看已安装的包及其文件，以及关于单个包的元信息。这可以针对本地包数据库运行，可以用于单个包文件。\n-R，--remove\n从系统中移除包。还可以指定要删除的组，在这种情况下，该组中的每个包都会被删除。属于指定包的文件将会被删除，数据库将会更新。\n-S，--sync\n同步包。包直接从远程仓库中安装，包括所需的所有依赖项。如果一个包名存在于多个仓库中，可以显示的指定仓库来确定需要安装的包。对于版本要求：pacman -S \"bash&gt;=3.2\"(需要使用双引号)。\n除了包之外，还可以指定组(group)。例：如果 gnome\n是一个已定义的包组，那么 pacman -S gnome\n将提供一个提示，允许从编号列表中选择要安装的包。包的选择是使用空格和\"/\"或逗号的包号(package\nnumbers)列表来指定的。可以用连字符(-)分隔第一个和最后一个包号来选择连续的包。排除包可以在数字或数字范围前加上插入符号(^)来实现。\n提供其他包的包(Packages that provide other\npackages)也被处理。例：pacman -S foo 将首先查找一个 foo\n包。如果没有找到 foo，将搜索提供与 foo 相同功能的包。\n可以使用 pacman -Su 来升级所有过时的软件包。\n-T --deptest\n检查依赖关系；这在 makepkg\n等脚本中用于检查已安装的包。该操作检查指定的每个依赖项，并返回系统当前不满足的依赖项列表。例：pacman -T qt \"bash&gt;=3.2\"\n-U，--upgrade\n向系统升级或添加包，并从同步仓库中安装所需的依赖项。可以指定\nURL或文件路径。这是一个“删除尔后添加”的过程。\n-F，--files\n查询 files\n数据库。查找或显示属于某个包的文件。只有作为同步数据库一部分的包才会被搜索。\n-V，--version\n版本信息\n-h，--help\n显示给定操作的语法。如果没有提供操作，则显示一般语法。\n\nOPTIONS\n\n-b，--dbpath \n指定数据库的位置(默认：/var/lib/pacman)。注意：这必须是一个绝对路径。\n-r，--root \n指定安装跟目录(默认：/)。这不能作为将软件安装到/usr/local而不是/usr的一种方式。\n-v，--verbose\n输出路径，如根目录(Root)，配置文件(Conf File)，DB路径(DB\nPath)，缓存目录(Cache Dirs)等。\n--arch \n指定架构(architecture)\n--cachedir\n\n指定包的缓存目录(默认：/var/cache/pacman/pkg)。可以指定多个缓存目录，并按照传递给\npacman\n的顺序依次尝试它们。注意：这必须是一个绝对路径。\n--color \n指定何时启动着色。选项有 [always, never, auto]。\n--config \n指定配置文件\n--debug\n显示调试消息。当报告错误时，建议使用此选项。\n--gpgdir\n\n指定 GnuPG\n校验包签名的文件目录(默认：/etc/pacman.d/gnupg)。这个目录应该包含两个文件：pubring.gpg\n和 trustdb.gpg。注意：这必须是一个绝对路径。\n--hookdir\n\n指定一个有钩子文件(hook\nfiles)的目录(默认：/etc/pacman.d/hooks)。可以指定多个钩子目录，使后面目录中的钩子优先于前面目录中的钩子。注意:这是一个绝对路径。\n--logfile \n指定一个备用日志文件。这是一个绝对路径，与安装根目录设置无关。\n--noconfirm\n绕过任何“你确定吗?””消息。这样做不是一个好主意，除非你想从脚本运行pacman。\n--confirm\n取消先前的—noconfirm的影响。\n--disable-download-timeout\n在下载时禁用默认的低速限制和超时。如果你用代理和/或安全网关下载文件有问题，请使用这个。\n--sysroot\n\n指定一个替代系统根(system\nroot)。在运行Pacman之前，将chroot和chdir放入系统根目录。这允许正确地操作挂载的客户系统。给出的任何其他路径都将被解释为相对于系统根。需要root特权。\n\nSYNC OPTIONS (APPLY TO -S)\n\n-c，--clean\n从缓存和当前未使用的同步数据库中删除不再安装的包，以释放磁盘空间。当\npacman 下载软件包时，它会把它们保存在一个缓存目录中。-c\n仅删除那些不再被安装的包，-cc\n会删除缓存中的所有文件。\n-g，--groups\n显示每个指定包组的所有成员。如果没有提供组名，将列出所有组；传递标志两次(-gg)以查看所有组及其成员。\n-i，--info\n显示给定同步数据库包的信息。-ii\n将显示所有依赖于此包的存储库中的那些包。\n-l，--list\n列出指定仓库中的所有包。可以在命令行上指定多个仓库。\n-q，--quiet\n为某些同步操作显示较少的信息。当在脚本中处理 pacman\n的输出时，这很有用。搜索将只显示包名，而不显示仓库、版本、组和描述信息；List将只显示包名，而忽略数据库和版本;组将只显示包名而忽略组名。\n-s，--search \n这将搜索同步数据库中的每个包，以查找匹配regexp的名称或描述。当您包含多个搜索条件时，只有描述匹配所有这些条件的包将被返回。\n-u，--sysupgrade\n升级所有过期的软件包。如果有新的包存在，将检查和升级当前安装的每个包。所有要升级的包将会显示一个报告，没有用户的确认操作将不会进行。依赖关系将在此级别自动解决，并将在必要时进行安装/升级。\n-y，--refresh\n从 pacman.conf(/etc/pacman.conf)\n中定义的服务器下载一个新的主包数据库副本。这通常应该在每次使用\n-u 时使用。-yy\n将强制刷新所有包数据库，即使它们看起来是最新的。\n\nREMOVE OPTIONS (APPLY TO -R)\n\n-c，--cascade\n删除所有目标包，以及依赖于一个或多个目标包的所有包。这个操作是递归的，必须小心使用，因为它可能会删除许多可能需要的包。\n-n，--nosave\n指示 pacman\n忽略文件备份指定。通常，当从系统中删除一个文件时，数据库会检查该文件是否应该以\n.pacsave 扩展名重命名。\n-s，--recursive\n删除指定的每个目标，包括它们的所有依赖项，前提是(A)其他包不需要它们;(B)它们不是由用户明确安装的。如果要忽略条件(B)，则传递此选项两次(-ss)。\n-u，--unneeded\n删除任何其他包不需要的目标。这在不使用 -c\n选项删除组时非常有用，以避免破坏任何依赖关系。\n\n\nEXAMPLES\npacman -Ss ne.hack\n# 搜索仓库中符合正则表达式&quot;ne.hack&quot;的包\npacman -S gpm\n# 下载并安装gpm，包括依赖项。\npacman -U &#x2F;home&#x2F;user&#x2F;ceofhack-0.6-1-x86_64.pkg.tar.gz\n# 从本地文件安装&quot;ceofhack-0.6-1&quot;软件包。\npacman -Syu\n# 更新包列表并升级所有包。\npacman -Syu gpm\n# 更新包列表，升级所有的包，然后安装gpm(如果还没有安装的话)。\n\n官方帮助文档：pacman\n","slug":"Linux/pacman","date":"2022-04-28T07:42:04.000Z","categories_index":"Linux","tags_index":"Pacman 命令","author_index":"爱慢跑的乌龟"},{"id":"a48e6dda0c21e40880cba7e763278b04","title":"Docker","content":"Docker\n\n官方文档地址\n中文参考手册\n\n\n1.什么是Docker\n1.1 官方定义\n\n\n\n\n\n\n\n\n\n\n官方介绍\n\nWe have a vomplete container solution for you - no matter who you\nare where you are on your containeriztion jouery.\n翻译：我们为你提供一个完整的容器解决方案，不管你是谁，无论你在哪，你都可以可是容器的旅程。\n官方定义：docker 是一个容器技术\n\n\n1.2 Docker 的起源\n\n\n\n\n\n\n\n\n\nDocker 最初是 dotCloud 公司创始人 Solomon Hykes\n在法国期间发起的一个公司内部项目，它是基于dotCloud\n公司多年云服务技术的一次革新，并于 2013年 3月以Apache 2.0\n授权协议开源，主要项目代码在 Github 上进行维护。Docker 项目后来还加入\nLinux 基金会，并成功推动 开放容器联盟(OCI)。\nDocker 自开源后受到了广泛的关注和讨论，至今其 Github 项目已经超过 5万\n7千个星标和一万多个 fork。甚至由于Docker 项目火爆，在 2013\n年底，dotCloud 公司决定改名为 Docker。 Docker 最初是在 Ubuntu 12.04\n上开发实现的；Red Hat 则从 RHEL.6.5 开始对 Docker 进行支持；Google\n也在其 PaaS 产品中广泛应用 Docker。\nDocer 使用 Google 公司推出的 Go 语言进行开发实现，基于 Linux 内核的\ncgroup， namespace，以及 OverlayFS\n类等技术，对进程进行封装隔离，属于操作系统层面的虚拟化技术。由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。\n2. 为什么是Docker\n\n在开发的时候，在本机测试环境可以跑，生成环境跑不起来\n这里我们拿 java Web 应用程序举例，我们一个 java Web\n应用程序涉及的东西很多，比如\njdk、tomcat、mysql等软件环境。当这些其中某一项版本不一致的时候，可能就会导致应用程序跑不起来这种情况。Docker\n则将程序以及使用的软件环境直接打包在一起，无论在哪个机器上都保证了环境一致。\n优势1：一致的运行环境，更轻松的迁移\n服务器自己的程序挂了，结果发现是别人程序出了问题把内存吃完了，自己的程序因为内存不够就挂了\n这种也是一种比较常见的情况，如果你的程序重要性不是特别高的话，公司基本上不可能让你的程序独享一台服务器，这时候你的服务器就会跟公司其他人的程序共享一台服务器，所以不可避免地就会受到其他程序的干扰，导致自己的程序出现问题。Docker\n就很好解决了环境隔离的问题，别人的程序不会影响到自己的程序。\n优势2：对进程进行封装隔离，容器与容器之间互不影响，更高效的利用系统资源\n公司要弄一个活动，可能会有大量的流量进来，公司需要部署几十台服务器\n在没有 Docker\n的情况下，要在几天内部署几十台服务器，这对运维来说是一件非常折磨人的事，而且每台服务器的环境还不一定一样，就会出现各种问题。用\nDocker\n的话，只需要将程序打包到镜像，需要多少台服务器，就跑多少容器，极大地提高了部署效率。\n优势3：通过镜像复制N多个环境一致的容器\n\n3. Docker 和虚拟机的区别\n\n\nDocker\n\n虚拟机是携带操作系统的，本身很小的应用却因为携带了操作系统而变得非常大，很笨重。Docker\n是不携带操作系统的，所以 Docker\n的应用就非常的轻巧。另外，在调用宿主机的CPU、磁盘等等资源的时候，拿内存举例，虚拟机时利用\nHypervisor 去虚拟化内存，整个调用过程时虚拟内存 -&gt; 虚拟物理内存 -&gt;\n真正物理内存，但是 Docker 是利用Docker Engine\n去调用宿主机的资源，这个过程是 虚拟内存 -&gt; 真正物理内存。\n\n\n\n\n\n\n\n\n\n传统虚拟机\nDocker 容器\n\n\n\n\n磁盘占用\n几个GB到几十个GB\n几十MB到几百MB\n\n\nCPU　内存占用\n虚拟操作系统非常占用CPU和内存\nDocker 引擎占用极低\n\n\n启动速度\n几分钟\n几秒\n\n\n安装管理\n需要专门的运维技术\n安装、管理方便\n\n\n应用部署\n每次部署都费时费力\n从第二次部署开始轻松简洁\n\n\n耦合性\n多个应用服务安装到一起，容易相互影响\n每个应用服务一个容器，达到隔离\n\n\n系统依赖\n无\n需求相同或相似的内核，目前推荐Linux\n\n\n\n4. Docker 的安装\n4.1 安装 docker(centos 7.x)\n\n卸载原始 Docker\n$ sudo yum remove docker \\\n\t\t\t\t  docker-client \\\n\t\t\t\t  docker-client-latest \\\n\t\t\t\t  docker-common \\\n\t\t\t\t  docker-latest \\\n\t\t\t\t  docker-latest-logrotate \\\n\t\t\t\t  docker-logrotate \\\n\t\t\t\t  docker-engine\n安装 docker 依赖\n$ sudo yum install -y yum-utils \\\n  device-mapper-persistent-data \\\n  lvm2\n设置 docker 的 yum 源\n$ sudo yum-config-manager \\\n\t--add-repo \\\n\thttps:&#x2F;&#x2F;download.docker.com&#x2F;linux&#x2F;centos&#x2F;docker-ce.repo\n安装最新版的 docker\n$ sudo yum install docker-ce docker-cecli containerd.io\n指定版本安装 docker\n$ yum install docker-ce --showduplicates | sort -r\n$ yum install docker-ce-&lt;VERSION_STRING&gt; docker-ce-cli-&lt;VERSION_STRING&gt; containerd.io\n$ yum install docker-ce-18.09.5-3.e17 docker-ce-cli-18.09.5-3.e17 containerd.io\n启动 docker\n$ sudo systemctl enable docker\n$ sudo systemctl start docker\n关闭 docker\n$ sudo systemctl stop docker\n测试 docker 安装\n$ sudo docker run hello-world\n\n4.2 bash 安装(通用所有平台)\n$ curl -fsSL get.docker.com -o get-docker.sh\n$ sudo sh get-docker.sh --mirror Aliyun\n\n启动 docker\n$ sudo systemctl enable docker\n$ sudo systemctl start doecker\n创建 docker 用户组\n$ sudo groupadd docker\n当前的用户加入 docker 组\n$ sudo usermod -aG docker $USER\n测试 docker 安装是否正确\n$ docker run hello-world\n\n5. Docker 的核心架构\n\n镜像 image 复数 images\n定义：一个镜像代表着一个软件 如：MySQL镜像 redis镜像\nnginx镜像····\n容器 container\n定义：基于某个镜像运行一次就会生成一个程序实例，一个实例称之为一个容器\n特点：可读、可写\n仓库 repository\n定义：用来存储 docker 中的所有镜像\n远程仓库：docker 官方维护的一个唯一的远程仓库\n本地仓库：当前机器的镜像存储位置\n\n\n\ndockerKernel\n\n6. 镜像的相关操作\n6.1 辅助命令\n# 1. 安装完成辅助命令\n\tdocker version\t---------------------\t查看 docker 的信息\n\tdocker info\t\t---------------------\t查看更详细的信息\n\tdocker --help \t---------------------\t帮助命令\n6.2 Images 镜像命令\n# 1. 查看本机中所有镜像\n\tdocker images\t------------------------\t列出本地所有镜像\n\t\t-a\t列出所有镜像\n\t\t-q\t只显示镜像 id\n# 2. 搜素镜像\n\tdocker search [options] 镜像名 -----------\t去 dockerhub 上查询当前镜像\n\t\t-s\t指定值\t\t列出收藏数不少于指定值的镜像\n\t\t--no-trunc\t  显示完整的镜像信息\n# 3. 从仓库下载镜像\n\tdocker pull 镜像名[:TAG|@DIGEST] ----------\t下载镜像\n# 4. 删除镜像\n\tdocker rmi 镜像名  -----------------------\t 删除镜像\n\t\t-f\t强制删除\n# 5. 载入镜像\n\tdocker load -i xxx.tar\n6.3 Contrainer 容器命令\n# 1. 运行容器\n\tdocker run 镜像名\t---------------\t镜像名新建并启动容器\n\t--name\t\t为容器起一个名字\n\t-d\t\t\t启动守护容器（在后台启动容器）\n\t-p\t\t\t映射端口号：原始端口号\t\t指定端口号启动\n# 2. 查看运行的容器\n\tdocker ps\t---------------------\t列出所有正在运行的容器\n\t-a\t\t\t正在运行的和历史运行的容器\n\t-q\t\t\t静默模式，只显示容器编号\n# 3. 停止|关闭|重启容器\n\tdocker start 容器名称或容器ID\t---------- 开启容器\n\tdocker restart 容器名或容器ID\t----------- 重启容器\n\tdocker stop 容器名或容器ID\t----------- 正常停止容器\n\tdocker kill 容器名或容器ID\t----------- 立即停止容器运行\n# 4. 删除容器\n\tdocker rm 容器名称|容器ID\t\t----------- 删除停止的容器\n\t-f\t\t删除正在运行的容器\n# 5. 查看容器内进程\n\tdocker top\t容器名称|容器ID\t----------- 查看容器内进程\n# 6. 查看容器内部细节\n\tdocker inspect\t容器名称|容器ID\t----------- 查看容器内部细节\n# 7. 查看运行日志\n\tdocker logs [OPTIONS] 容器名称|容器ID\t----------- 查看容器内进程\n\t-t\t\t加入时间戳\n\t-f\t\t跟随最新的日志打印\n\t--tail\t数字\t显示最后多少条\n# 8. 进入容器\n\tdocker exec -it\t容器名称|容器ID bash\t--------- 进入容器bash，与容器交互\n\t退出容器\texit\n# 9. 操作系统与容器的文件传输\n\t从容器到操作系统：\tdocker cp 容器ID:容器内资源路径 \t操作系统路径\n\t从操作系统到容器：\tdocker cp 文件|目录\t容器ID：容器路径\n# 10. 数据卷(volum)实现与宿主机共享目录\n\tdocker run -v 宿主机的路径|任意别名:&#x2F;容器内的路径\t\t镜像名\n\tdocker run -v 宿主机的路径|任意别名:&#x2F;容器内的路径:ro\t镜像名\n\tro：镜像只读\n\t\t注意：\n\t\t\t1. 如果是宿主机类路径必须是绝对路径，宿主机目录会覆盖容器内目录内容\n\t\t\t2. 如果是别名则会在docker运行容器时自动在宿主机中创建一个目录，并将容器目录文件复制到宿主机中\n# 11. 打包镜像\n\tdocker save 镜像名\t-o 名称.tar\n# 12. 载入镜像\n\tdocker load -i 名称.tar\n# 13. 容器打包成新的镜像\n\tdocker commit -m &quot;描述信息&quot; -a &quot;作者信息&quot;\t（容器ID或名称） 打包的镜像的名称：标签\n7. Dokcer 中容器之间的网络配置\n\n\n\n\n\n\n\n\n\nDocker 允许通过外部访问容器或容器互联的方式来提供网络服务\n7.1 docker\n容器与操作系统通信机制\n当 Docker 启动时，会自动在主机上创建一个 docker0\n虚拟网桥，实际上是 Linux 的一个\nbridge，可以理解为一个软件交换机。它会在挂载到它的网口之间进行转发。\n同时，Docker 随机分配一个本地未占用的私有网段（在 RFC1918中定义）中的一个地址给\ndocker0 接口。比如典型的 172.17.0.1，掩码为\n255.255.0.0。此后启动的容器内的网口也会自动分配一个同一网段（172.17.0.0/16）的地址。\n\n\nnetDocker0\n\n当创建一个 Docker 容器的时候，同时会创建了一对 veth pair\n接口（当数据包发送到一个接口时，另外一个接口也可以收到相同的数据包）。这对接口一端在容器内，即\neth0；另一端在本地并被挂载到 docker0\n网桥，名称以 veth 开头（例如\nvethAQI2QT）。通过这种方式，主机可以跟容器通信，容器之间也可以相互通信。Docker\n就创建了在主机和所有容器之间一个虚拟共享网络。\n\n\ndocker0\n\n7.2 Docker 网络使用\n注意：一般在使用 docker 网桥(bridge)\n实现容器与容器通信时，都是站在一个应用的角度进行容器通信。\n# 1. 查看 docker 网桥配置\n\tdocker network ls\n# 2. 自定义网桥\n\tdocker network create -d bridge 网桥名称\n# 3. 指定容器网桥\n\tdocker run --network 网桥名称 \n&gt; docker network [OPTION]\n     connect     Connect a container to a network\n     create      Create a network\n     disconnect  Disconnect a container from a network\n     inspect     Display detailed information on one or more networks\n     ls          List networks\n     prune       Remove all unused networks\n     rm          Remove one or more networks\n​\n8. 数据卷\n数据卷\n是一个可供一个或多个容器使用的特殊目录，它绕过\nUFS，可以提供很多有用的特性\n\n数据卷 可以在容器之间共享和重用\n对 数据卷 的修改会立马生效\n对 数据卷 的更新，不会影响镜像\n数据卷 默认会一直存在，即使容器被删除\n\n\n\n\n\n\n\n\n\n\n注意：数据卷 的使用，类似于 Linux 下对目录或文件进行\nmount，镜像中的被指定为挂载点的目录中的文件会复制到数据卷中（仅数据卷为空时会复制）。\n# 1. 自定义数据卷目录\n\tdocker run -v 绝对路径:容器内路径\n# 2. 自动创建数据卷\n\tdocker run -v 卷名：容器内路径\ndocker 操作数据卷命令\n# 1. 查看数据卷\n\tdocker volume ls\n# 2. 查看数据卷细节\n\tdocker volume inspect 卷名\n&gt; docker volume [OPTION]\n     create      Create a volume\n     inspect     Display detailed information on one or more volumes\n     ls          List volumes\n     prune       Remove all unused local volumes\n     rm          Remove one or more volumes\n9. Dockerfile\n什么是 Dockerfile\n定义：用来帮助我们自己构建一个自定义镜像 Dockerfile 成为镜像构建文件\n描述文件\nDockerfile 的保留命令\n官方说明(https://docs.docker.com/engine/reference/builder/)\n\n\n\n\n\n\n\n保留字\n作用\n\n\n\n\nFROM\n当前镜像是基于哪个镜像的\n\n\nMAINTAINER\n镜像维护者的姓名和邮箱地址\n\n\nRUN\n构建镜像时需要运行的指令\n\n\nEXPOSE\n当前容器对外暴露的端口号\n\n\nWORKDIR\n指定再创建容器后，终端默认登录进来的工作目录，一个落脚点\n\n\nENV\n用来再构建镜像的过程中设置环境变量\n\n\nADD\n将宿主机目录下的文件拷贝进镜像且ADD命令会自动处理URL和解压tar包\n\n\nCOPY\n类似于 ADD\n，拷贝文件和目录到镜像中将从构建上下文目录中的文件/目录复制到新的一层的镜像内的位置\n\n\nVOLUME\n容器数据卷，用于数据保存和持久化工作\n\n\nCMD\n指定一个容器启动时要运行的命令\nDockerfile 中可以有多个CMD 指令，但只有最后一个生效， CMD\n会被 docker run 之后的参数替换\n\n\nENTRYPOINT\n指定一个容器启动时要运行的命令\nENTRYPOINT 的目的和 CMD\n一样，都是在指定容器启动程序及其参数\n\n\n\nFROM 命令\n\n基于哪个镜像进行构建新的镜像，在构建时会自动从 docker hub 拉取\nbase 镜像 必须作为 Dockerfile 的一个指令出现\n语法\nFROM &lt;image&gt;\nFROM &lt;image&gt;[:&lt;tag&gt;]\t使用版本\nFROM &lt;image&gt;[@&lt;digest&gt;]\t使用摘要\n\nRUN 命令\n\nRUN\n指令将在当前映像之上的新层中执行任何命令并提交结果。生成的提交映像将用于\nDockerfile 中下一步\n语法：\nRUN &lt;command&gt;\nRUN echo hello\nRUN [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;](exec form)\nRUN [&quot;&#x2F;bin&#x2F;bash&quot;, &quot;-c&quot;, &quot;echo hello&quot;]\n\nEXPOSE 命令\n\n用来指定构建的镜像在运行为容器时对外暴露的端口\n语法：\nEXPOSE 80&#x2F;tcp\t如果没有显示指定则默认暴露都是 tcp\nEXPOSE 80&#x2F;udp \n\nCMD 命令\n\n用来为启动的容器指定执行的命令，在 Dockerfile 中只能有一条 CMD\n指令。如果列出多个命令，则只有最后一个命令才会生效。\n注意：Dockerfile 中只能有一条 CMD\n指令。如果列出多个命令，则只有最后一个命令才会生效。\n语法：\nCMD [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]\nCMD [&quot;param1&quot;, &quot;param2&quot;]\nCMD command param1 param2 (shell form)\n\nWORKDIR 命令\n\n用来为 Dockerfile 中的任何 RUN、CMD、ENTRYPOINT、COPY 和 ADD\n指令设置工作目录。如果 WORKDIR 不存在，即使它没有在任何后续 Dockerfile\n指令中使用，它也将被创建。\n语法：\nWORKDIR &#x2F;path&#x2F;to&#x2F;workdir\n\nWORKDIR &#x2F;a\nWORKDIR b\nWORKDIR c\n\nADD 命令\n\n用来从 context 上下文复制新文件、目录或远程文件\nurl，并将它们添加到位于指定路径的映像文件系统中\n语法：\nADD hom* &#x2F;mydir&#x2F; \t通配符添加多个文件\nADD hom?.txt &#x2F;mydir 通配符添加\nADD test.txt relativeDir&#x2F; 可以指定相对路径\nADD test.txt &#x2F;absoluteDir&#x2F; 绝对路径\nADD url\n\nCOPY 命令\n\n用来将 context 目录中指定文件复制到镜像的指定目录中\n语法：\nCOPY src dest\nCOPY [&quot;&lt;src&gt;&quot;,... &quot;&lt;dest&gt;&quot;]\n\nVOLUME 命令\n\n用来定义容器运行时可以挂载到宿主机的目录\n语法：\nVOLUME [&quot;&#x2F;data&quot;]\n\nENV 命令\n\n用来为构建镜像设置环境变量。这个值将会出现在构建阶段中所有的后续指令的环境中。\n语法：\nENV &lt;key&gt; &lt;value&gt; \nENV &lt;key&gt; &lt;value&gt; ...\n\nENTRYPOINT 命令\n\n用来指定容器启动时执行命令和 CMD 类似\n语法：\n[&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]\nENTRYPOINT command param1 param2\n\n","slug":"Linux/Docker","date":"2022-04-24T16:00:00.000Z","categories_index":"Docker","tags_index":"Docker 入门","author_index":"爱慢跑的乌龟"},{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"Welcome to Hexo! This is your very\nfirst post. Check documentation for\nmore info. If you get any problems when using Hexo, you can find the\nanswer in troubleshooting or\nyou can ask me on GitHub.\nQuick Start\nCreate a new post\n$ hexo new &quot;My New Post&quot;\nMore info: Writing\nRun server\n$ hexo server\nMore info: Server\nGenerate static files\n$ hexo generate\nMore info: Generating\nDeploy to remote sites\n$ hexo deploy\nMore info: Deployment\n---\ntitle: \ndata:\ncategories:\ntag:\nindex_img:\nbanner_img:\nexcerpt:\n---\n","slug":"hello-world","date":"2022-03-29T16:00:00.000Z","categories_index":"","tags_index":"","author_index":"爱慢跑的乌龟"}]