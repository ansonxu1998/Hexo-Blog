[{"id":"5af98a3dea0ccd1a1ddd7da3e7c8bdbc","title":"功能抑制管理 FiM 模块","content":"Ref: 功能抑制管理 FiM 模块\n一、FiM 模块总体介绍\n1.1 Autosar 架构 FiM 模块层级关系\n\n\nAUTOSAR 采用分层软件架构模式，总体划分为六大层级：\n\nMCAL 层\nECU 硬件抽象层\n系统服务层\n复杂驱动层\nRTE 层\n应用层\n\nFiM 模块属于系统服务层\nFiM 模块与硬件完全解耦\n\n1.2 FiM 模块依赖关系\n\nDem -&gt; FiM: Dem 模块上报故障状态至 FiM 模块\nFiM -&gt; SW-C: FiM 模块提供 SW-C 模块函数接口获取功能降级状态\nFiM -&gt; EcuM: FiM 模块提供 EcuM 初始化函数用于初始化和去初始化\nFiM -&gt; BSW: FiM 模块提供 BSW 模块函数接口用于获取功能降级状态\nFiM -&gt; RTE: FiM 模块提供相关主函数用于在 RTE 中系统调度\n\n\n1.3 主体功能与应用场景\n\n\nFiM 模块提供了一种基于抑制场景的功能降级策略，同时该抑制场景可配置\n可通过特定的 Function Identifier(FID) 来实现相应的抑制场景\n抑制场景可基于 Dem 模块的 Event 在 FiM 模块中根据降级需求完成映射\nFiM 模块为 BSW 以及 SW-C 各模块的抑制场景提供了一种有效的降级手段\n\n二、FiM 模块基本参数\n2.1 Diagnostic Event Status\n\n\n\n\n\n\n\n\n\nstatusOfDTC: bit field name\nBit#\nBit state\nDescription\n\n\n\n\ntestFailed\n0\n0\nDTC is not failed at the time of the request\n\n\ntestFailedThisOperationCycle\n1\n0\nDTC failed during the current operation cycle\n\n\npendingDTC\n2\n0\nDTC was not failed on the current or previous operation cycle\n\n\nconfirmedDTC\n3\n0\nDTC is not confiremed at the time of the request\n\n\ntestNotCompletedSinceLastClear\n4\n0\nDTC test was completed since the last code clear\n\n\ntestFailedSinceLastClear\n5\n0\nDTC test never failed since last code clear\n\n\ntestNotCompletedThisOperationCycle\n6\n0\nDTC test completed this operation cycle\n\n\nwarningIndicatorRequested\n7\n0\nServer is not requesting warningIndicator to be active\n\n\n\n\n每个在 Dem 模块中定义的 Event 均有唯一的 Event ID 与之对应、\n每个 Event Status 均有与之对应的 Event Status 定义，如上表所示\nEvent Status 如何变化取决于应用层或者 BSW 如何触发\n调用 Dem 模块标准接口来实现故障事件 Event 的上报（PASS/FAIL/PREFAIL/PREPASS)\n\n2.2 Functino Identifier\n\n\n每一个功能抑制场景可以唯一的 Function Identifier(FID)进行标识\n不同的功能抑制场景不能使用相同的 FID\n多个 Event ID 可以 Map 到同一个 FID\n每个 FID 的允许状态仅由 Map 到 该 FID 的所有 EventID 的 Event Status 共同决定（或运算）\n\n2.3 Inhibition Mask &amp; FID Perimission State\n\nIhibition Mask:\n\n每个 Event 的 Event Status 存在对应的 Inhibition Mask，两者之间采用与运算\n一个或多个 Eevent ID 可以 Map 至同一 FID\nInhibition Mask 可以理解为 FID 的使能条件，即对 Map 该 FID 的 Event Status 中的哪个 Bit 为进行关联\n\nFID Permission State：\n\nFID 是否置位的结果用来表示 FID Permission State\n若 FID Permission State == TRUE，则该 FID 对应的功能可以被使能\n若 FID Permission State == FALSE，则该 FID 对应的功能不可以被使能\n\n三、FiM 模块间交互关系\n3.1 FiM 与 Dem 模块交互关系\n\n\nEvent Status：即 Dem 模块中的 Event status，每一个 Bit 代表相应的含义\nInhibition Mask：用于决定什么样的 Event Status 会触发上述 FID 置位，有以下三种取值：\n\nInhibit if Failed：当 Event Status Bit0 = 1 时，该位为 1，否则为 0\nInhibit if Tested：当 Event Status Bit6 = 0 时，该值为 1，否则为 0\nInhibit if Not Tested：当 Event Status Bit6 = 1时，该值为 1，否则为 0\n\nFID：Function Identifier，Bool 类型\n\nFID_1 == TRUE：即抑制场景不激活，功能不降级\nFID_1== FALSE：即抑制场景激活，功能降级\n\nFID Counter：用于表征当前存在几个 Event 同时发生导致了该类型的抑制场景激活，进而功能降级\n\n\n\nEvent ID 的状态与 Inhibition MASK 是位与的关系，若位与的结果为1，对应 Mapping 的 FID Counter 就会加 1\n每个 FID 仅能选择其中一种类型 Inhibition MASK，该参数仅支持工具中静态配置，不支持动态更改\n假设 Event A，Event B，Event C 均 Map 了 FID_A，也就意味着当这三个 Event 中任意一个或多个发生时，FID_A 就会置位，即 FID_A == FALSE。每个 FID Counter 初始值均为 0 且值永远大于等于 0\n系统降级算法规则：当 FID_A Counter &gt; 0，FID_A 就会置位，即为 FALSE，相应的系统降级行为就会发生。\n\n\n\n\nEvent Status &amp; Inhibition MASK\nFID_ACounter\n系统功能\n\n\n\n\nTRUE\n1\n降级\n\n\nTRUE\n2\n降级\n\n\nTRUE\n3\n降级\n\n\nFALSE\n2\n降级\n\n\nFALSE\n1\n降级\n\n\nFALSE\n0\n不降级\n\n\n\n\n根据位与的结果，只要 FID_A Counter 不等于 0，FID_A 就会等于 FALSE，系统就会降级\n虽然知道系统降级，但根据 FID 无法判断是哪个 Event 导致的降级，需要通过诊断服务读取内部的 Event 且该 Event 也确实 Map 了该 FID\n\n3.2 FiM 与 SW-C 模块交互关系\n\n\nFront-Left Anti-pinch SW-C 上报 anti_pinch 故障到 DEM 模块\nDEM 模块会识别为 Event anti_Pinch 故障，并调用 DEM 模块接口通知该 Event Status 发生变化\nDEM 模块会调用 FIM 模块相应的函数接口来通知 FIM 中该 Event Status 对相应 FID 的影响\nFront-left Window-lifter SW-C 模块会调用 FIM 模块函数接口 FiM_GetFunctionPermission 轮询相应的 FID 状态，然后做出相应的系统降级行为\n\n四、FiM 模块调度时序\n4.1 FiM 模块函数调用接口\n\n\n\n\n\n\n\n主要函数接口\n基本功能\n\n\n\n\nFiM_Init\n完成 FiM 模块相关变量的初始化工作\n\n\nFiM_DemTriggerOnMonitorStatus\n提供 DEM 模块当 Event Status 发生变化时通知 FIM 的函数接口，属于 Trigger Action 行为；其中 FIM 获取 Event Status 状态变化，还有一种方法就是 Polling，但是 Polling 方式的缺点是，当 Event 数目较大时，有时候就无法及时察觉某些 Event Status 的快速变化，所以一般而言，都优先选择 Trigger 方式来完成对 FIM 模块的 Event Status 通知。\n\n\nFiM_DemTriggerOnComponentStatus\n当 DEM 模块中的 Component 状态为 FAILED 时就会触发该函数调用通知 FIM 模块\n\n\nFiM_GetFunctionPermission\n提供给 BSW 或 SWC 模块来获取 FID 状态的函数接口\n\n\nFiM_SetFunctionAvailable\n用于 BSW 或者 SWC 模块来主动设置某功能是否可用，若输入参数为 FALSE，该功能不可用\n\n\nFiM_MainFunction\n实现对 Event Status 与 Inhibition MASK 的计算，此处有两种方式，一种就是 Polling 方式，另外一种就是 Event Trigger 方式，这两种方式的使能通过工具选项 FiMEventUpdateTriggeredByDem 是否为 TRUE 决定\n\n\n\n4.2 FiM 模块初始化时序\n\n① EcuM 模块首先调用 Dem_Preinit 接口\n② 通过 NVM_ReadAll 函数来获取最近存储的所有 Event 的状态\n③ EcuM 模块调用 FiM_Init 函数来完成内部变量的初始化；调用结束之后，并不能立即被使用\n④ EcuM 模块调用 Dem_Init 完成 Dem 内部变量的初始化，然后在其内部调用 FiM_DemInit 来最终完成 FiM 模块的初始化\n⑤ 从 S4 开始 Dem 模块与 FiM 模块就最终完成了初始化，其他相关函数接口才能够被正常使用\n\n\n\n\n\n\n\n\n\n若在 Dem_Init 之前就调用 FiM_GetFunctionPermission 的函数接口，那么就会直接返回 E_NOT_OK\n4.3 FiM 模块功能作用时序\n\n① Dem 模块调用 FiM_DemTriggerOnMontiorStatus 来通知 FiM 模块 Event Status 发生变化\n② FiM 模块调用 Dem_GetMonitorStatus 来获取最新的 Event Status\n③ SW-C 模块则会调用 FiM 模块功能可用性接口 FiM_GetFunctionPermission 来轮询当前功能是否可用\n五、基于 ETAS 工具 FiM 模块配置\n5.1 FiM General 配置\n\n\n\n\n\n\n\n\n\n序号\n配置参数\n配置说明\n\n\n\n\n1\nFimDevErrorDetect\nTRUE：开启 Det 模块检测，有错误上报至 Det 模块FALSE：关闭 Det 模块检测，有错误不上报\n\n\n2\nFiMEventUpdateTriggeredByDeM\nTRUE：FIM 模块采用 Event Trigger 模式检测故障状态变化FALSE：FIM 模块采用 Polling 方式来检测故障状态变化\n\n\n3\nFiMTaskTime\n单位：s，表示 FiM_Mainfunction 的运行周期，一般为 10 ms\n\n\n4\nFiMVersionInfoApi\nTRUE：使能获取 FIM 模块 AUTOSAR 版本的函数接口FALSE：关闭获取 FIM 模块 AUTOSAR 版本的函数接口\n\n\n\n5.2 FiMConfigSet 配置\n5.2.1 FiMFID 配置\n\n在 FiMFID container 中新建一个名为 \"FiMFID\" 的子项，便创建了一个新的 FID。\n5.2.2 FiMInhibitionConfiguration 配置（创建 Event ID-InhibitionMask-FID 映射关系）\n\n\n\n\n\n\n\n\n\n序号\n配置参数\n配置说明\n\n\n\n\n1\nFiMInhibitionMask\nFIM_LAST_FAILED：识别 Eevent Status 的 bit 0 是否置位，若为 1，则表示功能抑制使能FIM_NOT_TESTED：识别 Event Status 的 bit 6 是否置位，若为 1，则表示功能抑制使能FIM_TESTED：识别 Event Status 的 bit 6 是否置位，若为 0，则表示功能抑制使能FIM_TESTED_AND_FAILED：识别 Event Status 的 bit 6 == 0 与 bit 0 == 1，若为 1，则表示功能抑制使能\n\n\n2\nFiMInhFunctionId\n用于索引上述创建的 FiMFID （如 FiMFID_Test)\n\n\n3\nFiMInhComponentRef\n用于索引 Dem 模块中的 Component 模块，若对应的 Component ID 为 FAIL，则表示功能抑制使能\n\n\n4\nFiMInhEventRef\n用于索引该 FID 所需 Map 的 Event，ETH 相关事件的状态与 Inhibition MASK 进行与运算，若结果非 0，则对应的 FiMFID_Test 状态则为 FALSE，即触发系统降级行为\n\n\n5\nFiMInhSumRef\n用于索引相关 Event 事件的集合，便于某一类 Event 会 Map 多个不同的 FID 时，可以实现索引的复用\n\n\n\n5.2.3 FiMSummaryEvent 配置\n在 FiMSummaryEvents Container 中创建一个子项 \"FimSummaryEvent_0\"，通过在该子项中 FiMInputEventRef 中索引 Dem 模块中的 Event 作为同一个 summary Event，供 FiMInhibitionConfigurations 中参数索引使用\n\n","slug":"Electronic/功能抑制管理 FiM 模块","date":"2023-09-22T07:00:00.000Z","categories_index":"汽车电子","tags_index":"Autosar","author_index":"爱慢跑的乌龟"},{"id":"3c1e105762b23aa3751ddcfe95ca126f","title":"无感 FOC-扩展卡尔曼滤波观测器","content":"电机状态方程\n永磁同步电机在  坐标下的方程为：  其中 \n反电动势  为：  转速  和转子位置  的关系如下：  综上可得： \n线性系统的状态观测器\n\n确定状态观测器的状态变量为   卡尔曼观测器的输出矩阵  为：  故  矩阵为：   矩阵为：  将状态方程写成矩阵的形式： \n\n由该系统是非线性系统，所以暂时无法确定状态矩阵  ，令：  则此时状态方程为： \n非线性系统线性化\n使用泰勒公式对非线性的系统进行线性化，从而确定上述状态方程中的状态矩阵  。\n泰勒公式如下：  取前两项：  对  进行展开：  舍去余项：  将  代入状态方程：  则电机在  出的状态矩阵  就是  ，即  \n连续系统的离散化\n连续系统中的微分在离散系统中为差分形式：  则离散分状态方程为： \n\n卡尔曼滤波算法\n\n先验估计：\n\n\n\n误差协方差：\n\n\n\n卡尔曼增益：\n\n\n\n后验估计：\n\n\n\n更新误差协方差\n\n\n","slug":"Control/无感FOC-扩展卡尔曼滤波观测器","date":"2023-07-10T07:17:00.000Z","categories_index":"自动控制","tags_index":"FOC","author_index":"爱慢跑的乌龟"},{"id":"406f35918def0d366ae46a92ad742516","title":"MCU Bootloader","content":"中断向量地址偏移\n① 重新设置 _vector 地址\n② 从 new vector 取出第 1 个值赋给 SP\n③ 从 new vector 取出第 2 个值赋给 PC\nstart_app\tPROC\n\t\tEXPORT\tstart_app\n\t\t; 设置异常向量地址为 0x08040000\n\t\tldr r3, &#x3D;0xE000ED08 ; 寄存器地址\n\t\tstr r0, [r3]\n\t\t\n\t\tldr sp,\t[r0]\t\t\n\t\tldr r1, [r0, #4]\n\t\t\n\t\tBX r1\n\t\tENDP\n\t\tEND\nBootloader 主函数：\nextern void start_app(unsigned int new_vector);\n\nint main()&#123;\n    unsigned int new_vector &#x3D; 0x08040000;\n    start_app(new_vector);\n    return 0;\n&#125;\nAPP 复制自身代码到 RAM 中\nReset_Handler\tPROC\n\t\t\t\tEXPORT\tReset_Handler\n\t\t\t\tIMPORT\tmymain\n\t\t\t\tIMPORT\tcopy_myself\n\t\t\t\tIMPORT\t|Image$$ER_IROM1$$Length|\n\t\t\t\t\n\t\t\t\tadr\tr0, Reset_Handler\t; r0 &#x3D; 0x08040000\n\t\t\t\tbic\tr0, r0, #0xff\n\t\t\t\t\n\t\t\t\tldr\tr1, &#x3D;__Vectors\t; r1 &#x3D; 0x20000000\n\t\t\t\tldr r2, &#x3D; |Image$$ER_IROM1$$Length| ; LENGTH\n\t\t\t\t\n\t\t\t\tBL\tcopy_myself\n\t\t\t\tBL \tmymain\n\t\t\t\t; 绝对跳转\n\t\t\t\t; lar pc, &#x3D;mymain\n\t\t\t\t\n\t\t\t\tENDP\n\t\t\t\tEND\nvoid copy_myself(int *from, int *to, int len)&#123;\n    int i,\n    for (i &#x3D; 0; i &lt; len&#x2F;4 + 1; i++)&#123;\n        to[i] &#x3D; from[i];\n    &#125;\n&#125;\n为 APP.bin 添加 U-boot 头部\n镜像头部结构体：\ntypedef struct image_header&#123;\n    __be32\tih_magic;\t&#x2F;* Image Header Magic Number *&#x2F;\n    __be32\tih_hcrc;\t&#x2F;* Image Header\tCRC Checksum *&#x2F;\n    __be32\tih_time;\t&#x2F;* Image Header\tCreation Timestamp *&#x2F;\n    __be32\tih_size;\t&#x2F;* Image Data Size *&#x2F;\n    __be32 \tih_load;\t&#x2F;* Data\tLoad Address *&#x2F;\n    __be32\tih_ep;\t\t&#x2F;* Entry Point Address *&#x2F;\n    __be32\tih_dcrc;\t&#x2F;* Image Data CRC  Checksum *&#x2F;\n    uint8_t\tih_os;\t\t&#x2F;* Operating System *&#x2F;\n    uint8_t ih_arch;\t&#x2F;* CPU architecture *&#x2F;\n    uint8_t ih_type;\t&#x2F;* Image Type *&#x2F;\n    uint8_t ih_comp;\t&#x2F;* Compression Type *&#x2F;\n    uint8_t ih_name[IH_NMLEN] &#x2F;* Image Nmae *&#x2F;\n&#125;image_header_t;\n使用 mkimage 工具添加头部：\nUsage: .&#x2F;mkimage -l image\n          -l &#x3D;&#x3D;&gt; list image header information\n.&#x2F;mkimage [-x] -A arch -O os -T type -C comp -a addr -e ep -n name -d data_file\n[:data_file...] image\n          -A &#x3D;&#x3D;&gt; set architecture to &#39;arch&#39;\n          -O &#x3D;&#x3D;&gt; set operating system to &#39;os&#39;\n          -T &#x3D;&#x3D;&gt; set image type to &#39;type&#39;\n          -C &#x3D;&#x3D;&gt; set compression type &#39;comp&#39;\n          -a &#x3D;&#x3D;&gt; set load address to &#39;addr&#39; (hex)\n          -e &#x3D;&#x3D;&gt; set entry point to &#39;ep&#39; (hex)\n          -n &#x3D;&#x3D;&gt; set image name to &#39;name&#39;\n          -d &#x3D;&#x3D;&gt; use image data from &#39;datafile&#39;\n          -x &#x3D;&#x3D;&gt; set XIP (execute in place)\n       .&#x2F;mkimage [-D dtc_options] [-f fit-image.its|-F] fit-image\n          -D &#x3D;&gt; set all options for device tree compiler\n          -f &#x3D;&gt; input filename for FIT source\n\n-A：指定 CPU 架构\nAlpha、ARM、Intel x86、IA64、MIPS、MIPS 64 Bit、PowerPC、IBM S390、SuperH、SPARC、SPARC 64 Bit、MC68000\n-O：指定操作系统\nopenbsd、netbsd、freebsd、4_4bsd、linux、svr4、esix、solaris、irix、sco、dell、ncr、lynxos、vxworks、psos、qnx、u-boot、rtems、artos\n-T：指定映像类型\nstandalone、kernel、ramdisk、multi、firmware、script、filesystem\n-C：映像压缩方式\nnone、gzip、bzip2\n-a：指定映象在内存中的加载地址\n-e：指定映象运行的入口点地址\n-n： 指定映象名 -d： 指定制作映象的源文件\nBootloader 解析头部信息：\n#define IH_NMLEN\t32\t\t&#x2F;* Image Name Length *&#x2F;\ntypedef unsigned int __be32;\ntypedef unsigned char uint8_t;\ntypedef struct image_header&#123;\n    __be32\tih_magic;\t&#x2F;* Image Header Magic Number *&#x2F;\n    __be32\tih_hcrc;\t&#x2F;* Image Header\tCRC Checksum *&#x2F;\n    __be32\tih_time;\t&#x2F;* Image Header\tCreation Timestamp *&#x2F;\n    __be32\tih_size;\t&#x2F;* Image Data Size *&#x2F;\n    __be32 \tih_load;\t&#x2F;* Data\tLoad Address *&#x2F;\n    __be32\tih_ep;\t\t&#x2F;* Entry Point Address *&#x2F;\n    __be32\tih_dcrc;\t&#x2F;* Image Data CRC  Checksum *&#x2F;\n    uint8_t\tih_os;\t\t&#x2F;* Operating System *&#x2F;\n    uint8_t ih_arch;\t&#x2F;* CPU architecture *&#x2F;\n    uint8_t ih_type;\t&#x2F;* Image Type *&#x2F;\n    uint8_t ih_comp;\t&#x2F;* Compression Type *&#x2F;\n    uint8_t ih_name[IH_NMLEN]; &#x2F;* Image Nmae *&#x2F;\n&#125;image_header_t;\n\n&#x2F;&#x2F; 字节序转换\nunsigned int be32_to_cpu(unsigned int x)&#123;\n    unsigned char *p &#x3D; (unsigned char *)&amp;x;\n    unsigned int le;\n    le &#x3D; (p[0] &lt;&lt; 24) + (p[1] &lt;&lt; 16) + (p[2] &lt;&lt; 8) + p[3];\n    return le;\n&#125; \n\n&#x2F;&#x2F; 拷贝程序\nvoid copy_app(int *from, int *to, int len)&#123;\n    int i;\n    for (i &#x3D; 0; i &lt; len&#x2F;4 + 1; i++)&#123;\n        to[i] &#x3D; from[i];\n    &#125;\n&#125;\nvoid relocate_start_app(unsigned int pos)&#123;\n    image_header_t *head;\n    unsigned int load;\n    unsigned int size;\n    unsigned int new_pos &#x3D; pos+sizeof(image_header_t);\n    &#x2F;* 读出头部 *&#x2F;\n    head &#x3D; (image_header_t *)pos;\n    &#x2F;* 解析头部 *&#x2F;\n    load &#x3D; be32_to_cpu(head-&gt;ih_load);\n    size &#x3D; be32_to_cpu(head-&gt;ih_size);\n    &#x2F;* 拷贝程序到 RAM *&#x2F;\n    copy_app((int *)new_pos, (int *)load, size); &#x2F;&#x2F; 偏移一个头部的大小\n    &#x2F;* 跳转执行 *&#x2F;\n    start_app(new_pos);\n&#125;\nstart_app\tPROC\n\t\t\tEXPORT\tstart_app\n\t\t\tldr r3, &#x3D;0xE000ED08\n\t\t\tstr r0, [r3]\n\t\t\t\n\t\t\tldr\tsp, [r0]\n\t\t\tldr\tr1, [r0, #4]\n\t\t\t\n\t\t\tbx\tr1\n\t\t\tENDP\n\t\t\tEND\n若 MCU 不支持中断向量地址偏移\n在 Bootloader 中实现必要的中断向量：\n&#x2F;* file: start.s *&#x2F;\n                PRESERVE8\n                THUMB\n\n\n; Vector Table Mapped to Address 0 at Reset\n                AREA    RESET, DATA, READONLY\n\t\t\t\tEXPORT  __Vectors\n\t\t\t\t;IMPORT SVC_Handler\n\t\t\t\tIMPORT PendSV_Handler\n\t\t\t\tIMPORT SysTick_Handler\n\t\t\t\tIMPORT USART1_IRQHandler\n\t\t\t\tIMPORT USART3_IRQHandler\n\t\t\t\tIMPORT EXTI15_10_IRQHandler\n\t\t\t\tIMPORT TIM8_UP_IRQHandler\n\t\t\t\t\t\n__Vectors       DCD     0               ; Top of Stack\n                DCD     Reset_Handler              ; Reset Handler\n                DCD     0 ;NMI_Handler                ; NMI Handler\n                DCD     0 ;HardFault_Handler          ; Hard Fault Handler\n                DCD     0 ;MemManage_Handler          ; MPU Fault Handler\n                DCD     0 ;BusFault_Handler           ; Bus Fault Handler\n                DCD     0 ;UsageFault_Handler         ; Usage Fault Handler\n                DCD     0                          ; Reserved\n                DCD     0                          ; Reserved\n                DCD     0                          ; Reserved\n                DCD     0                          ; Reserved\n                DCD     SVC_Handler                ; SVCall Handler\n                DCD     0 ;DebugMon_Handler           ; Debug Monitor Handler\n                DCD     0                          ; Reserved\n                DCD     PendSV_Handler             ; PendSV Handler\n                DCD     SysTick_Handler            ; SysTick Handler\n\n                ; External Interrupts\n                DCD     0 ;WWDG_IRQHandler            ; Window Watchdog\n                DCD     0 ;PVD_IRQHandler             ; PVD through EXTI Line detect\n                DCD     0 ;TAMPER_IRQHandler          ; Tamper\n                DCD     0 ;RTC_IRQHandler             ; RTC\n                DCD     0 ;FLASH_IRQHandler           ; Flash\n                DCD     0 ;RCC_IRQHandler             ; RCC\n                DCD     0 ;EXTI0_IRQHandler           ; EXTI Line 0\n                DCD     0 ;EXTI1_IRQHandler           ; EXTI Line 1\n                DCD     0 ;EXTI2_IRQHandler           ; EXTI Line 2\n                DCD     0 ;EXTI3_IRQHandler           ; EXTI Line 3\n                DCD     0 ;EXTI4_IRQHandler           ; EXTI Line 4\n                DCD     0 ;DMA1_Channel1_IRQHandler   ; DMA1 Channel 1\n                DCD     0 ;DMA1_Channel2_IRQHandler   ; DMA1 Channel 2\n                DCD     0 ;DMA1_Channel3_IRQHandler   ; DMA1 Channel 3\n                DCD     0 ;DMA1_Channel4_IRQHandler   ; DMA1 Channel 4\n                DCD     0 ;DMA1_Channel5_IRQHandler   ; DMA1 Channel 5\n                DCD     0 ;DMA1_Channel6_IRQHandler   ; DMA1 Channel 6\n                DCD     0 ;DMA1_Channel7_IRQHandler   ; DMA1 Channel 7\n                DCD     0 ;ADC1_2_IRQHandler          ; ADC1 &amp; ADC2\n                DCD     0 ;USB_HP_CAN1_TX_IRQHandler  ; USB High Priority or CAN1 TX\n                DCD     0 ;USB_LP_CAN1_RX0_IRQHandler ; USB Low  Priority or CAN1 RX0\n                DCD     0 ;CAN1_RX1_IRQHandler        ; CAN1 RX1\n                DCD     0 ;CAN1_SCE_IRQHandler        ; CAN1 SCE\n                DCD     0 ;EXTI9_5_IRQHandler         ; EXTI Line 9..5\n                DCD     0 ;TIM1_BRK_IRQHandler        ; TIM1 Break\n                DCD     0 ;TIM1_UP_IRQHandler         ; TIM1 Update\n                DCD     0 ;TIM1_TRG_COM_IRQHandler    ; TIM1 Trigger and Commutation\n                DCD     0 ;TIM1_CC_IRQHandler         ; TIM1 Capture Compare\n                DCD     0 ;TIM2_IRQHandler            ; TIM2\n                DCD     0 ;TIM3_IRQHandler            ; TIM3\n                DCD     0 ;TIM4_IRQHandler            ; TIM4\n                DCD     0 ;I2C1_EV_IRQHandler         ; I2C1 Event\n                DCD     0 ;I2C1_ER_IRQHandler         ; I2C1 Error\n                DCD     0 ;I2C2_EV_IRQHandler         ; I2C2 Event\n                DCD     0 ;I2C2_ER_IRQHandler         ; I2C2 Error\n                DCD     0 ;SPI1_IRQHandler            ; SPI1\n                DCD     0 ;SPI2_IRQHandler            ; SPI2\n                DCD     USART1_IRQHandler          ; USART1\n                DCD     0 ;USART2_IRQHandler          ; USART2\n                DCD     USART3_IRQHandler          ; USART3\n                DCD     EXTI15_10_IRQHandler       ; EXTI Line 15..10\n                DCD     0 ;RTC_Alarm_IRQHandler        ; RTC Alarm through EXTI Line\n                DCD     0 ;USBWakeUp_IRQHandler       ; USB Wakeup from suspend\n                DCD     0 ;TIM8_BRK_IRQHandler        ; TIM8 Break\n                DCD     TIM8_UP_IRQHandler         ; TIM8 Update\n                DCD     0 ;TIM8_TRG_COM_IRQHandler    ; TIM8 Trigger and Commutation\n                DCD     0 ;TIM8_CC_IRQHandler         ; TIM8 Capture Compare\n                DCD     0 ;ADC3_IRQHandler            ; ADC3\n                DCD     0 ;FSMC_IRQHandler            ; FSMC\n                DCD     0 ;SDIO_IRQHandler            ; SDIO\n                DCD     0 ;TIM5_IRQHandler            ; TIM5\n                DCD     0 ;SPI3_IRQHandler            ; SPI3\n                DCD     0 ;UART4_IRQHandler           ; UART4\n                DCD     0 ;UART5_IRQHandler           ; UART5\n                DCD     0 ;TIM6_IRQHandler            ; TIM6\n                DCD     0 ;TIM7_IRQHandler            ; TIM7\n                DCD     0 ;DMA2_Channel1_IRQHandler   ; DMA2 Channel1\n                DCD     0 ;DMA2_Channel2_IRQHandler   ; DMA2 Channel2\n                DCD     0 ;DMA2_Channel3_IRQHandler   ; DMA2 Channel3\n                DCD     0 ;DMA2_Channel4_5_IRQHandler ; DMA2 Channel4 &amp; Channel5\n__Vectors_End\n\n__Vectors_Size  EQU  __Vectors_End - __Vectors\n\n\n\t\t\t\tAREA    |.text|, CODE, READONLY\n\n; Reset handler\nReset_Handler   PROC\n\t\t\t\tEXPORT  Reset_Handler             [WEAK]\n                IMPORT  mymain\n\t\t\t\tLDR SP, &#x3D;(0x20000000+0x10000)\n\t\t\t\tBL mymain\n                ENDP\n\nstart_app   PROC\n\t\t\t\tEXPORT  start_app\n\n\t\t\t\t; set vector base address as 0x08040000\n\t\t\t\t;ldr r3, &#x3D;0xE000ED08\n\t\t\t\t;str r0, [r3]\n\t\t\t\tldr sp, [r0]      ; read val from new vector\n\t\t\t\tldr r1, [r0, #4]  ; read val from &quot;new vector + 4“\n\t\t\t\tBX r1\n                ENDP\n\nSVC_Handler     PROC\n                EXPORT  SVC_Handler\n\t\t\t\tldr r0, &#x3D;(0x20000000 + 0x10000 - 4)\n\t\t\t\tldr r0, [r0]  ; r0 &#x3D; new_vector\n\t\t\t\tldr r0, [r0, #0x2c]  ; new SVC_Handler\n\t\t\t\tbx r0\n                ENDP\n\t\t\t\tEND\n当中断产生时，Bootloader 中的中断向量跳转到 App 中的新的中断向量：\ntypedef void (*exception_func)(void);\nstruct vectors &#123;\n\tunsigned int sp;\n\texception_func     Reset_Handler              ; \n\texception_func     NMI_Handler                ; \n\texception_func     HardFault_Handler          ; \n\texception_func     MemManage_Handler          ; \n\texception_func     BusFault_Handler           ; \n\texception_func     UsageFault_Handler         ; \n\texception_func     dummy0                     ; \n\texception_func     dummy1                     ; \n\texception_func     dummy2                     ; \n\texception_func     dummy3                     ; \n\texception_func     SVC_Handler                ; \n\texception_func     DebugMon_Handler           ; \n\texception_func     dummy4                     ; \n\texception_func     PendSV_Handler             ; \n\texception_func     SysTick_Handler            ; \n\n\t&#x2F;&#x2F; External Interrupts\n\texception_func     WWDG_IRQHandler            ; \n\texception_func     PVD_IRQHandler             ; \n\texception_func     TAMPER_IRQHandler          ; \n\texception_func     RTC_IRQHandler             ; \n\texception_func     FLASH_IRQHandler           ; \n\texception_func     RCC_IRQHandler             ; \n\texception_func     EXTI0_IRQHandler           ; \n\texception_func     EXTI1_IRQHandler           ; \n\texception_func     EXTI2_IRQHandler           ; \n\texception_func     EXTI3_IRQHandler           ; \n\texception_func     EXTI4_IRQHandler           ; \n\texception_func     DMA1_Channel1_IRQHandler   ; \n\texception_func     DMA1_Channel2_IRQHandler   ; \n\texception_func     DMA1_Channel3_IRQHandler   ; \n\texception_func     DMA1_Channel4_IRQHandler   ; \n\texception_func     DMA1_Channel5_IRQHandler   ; \n\texception_func     DMA1_Channel6_IRQHandler   ; \n\texception_func     DMA1_Channel7_IRQHandler   ; \n\texception_func     ADC1_2_IRQHandler          ; \n\texception_func     USB_HP_CAN1_TX_IRQHandler  ;  \n\texception_func     USB_LP_CAN1_RX0_IRQHandler ;  \n\texception_func     CAN1_RX1_IRQHandler        ; \n\texception_func     CAN1_SCE_IRQHandler        ; \n\texception_func     EXTI9_5_IRQHandler         ; \n\texception_func     TIM1_BRK_IRQHandler        ; \n\texception_func     TIM1_UP_IRQHandler         ; \n\texception_func     TIM1_TRG_COM_IRQHandler    ; \n\texception_func     TIM1_CC_IRQHandler         ; \n\texception_func     TIM2_IRQHandler            ; \n\texception_func     TIM3_IRQHandler            ; \n\texception_func     TIM4_IRQHandler            ; \n\texception_func     I2C1_EV_IRQHandler         ; \n\texception_func     I2C1_ER_IRQHandler         ; \n\texception_func     I2C2_EV_IRQHandler         ; \n\texception_func     I2C2_ER_IRQHandler         ; \n\texception_func     SPI1_IRQHandler            ; \n\texception_func     SPI2_IRQHandler            ; \n\texception_func     USART1_IRQHandler          ; \n\texception_func     USART2_IRQHandler          ; \n\texception_func     USART3_IRQHandler          ; \n\texception_func     EXTI15_10_IRQHandler       ; \n\texception_func     RTC_Alarm_IRQHandler       ;\n\texception_func     USBWakeUp_IRQHandler       ; \n\texception_func     TIM8_BRK_IRQHandler        ; \n\texception_func     TIM8_UP_IRQHandler         ; \n\texception_func     TIM8_TRG_COM_IRQHandler    ;\n\texception_func     TIM8_CC_IRQHandler         ; \n\texception_func     ADC3_IRQHandler            ; \n\texception_func     FSMC_IRQHandler            ; \n\texception_func     SDIO_IRQHandler            ; \n\texception_func     TIM5_IRQHandler            ; \n\texception_func     SPI3_IRQHandler            ; \n\texception_func     UART4_IRQHandler           ; \n\texception_func     UART5_IRQHandler           ; \n\texception_func     TIM6_IRQHandler            ; \n\texception_func     TIM7_IRQHandler            ; \n\texception_func     DMA2_Channel1_IRQHandler   ; \n\texception_func     DMA2_Channel2_IRQHandler   ; \n\texception_func     DMA2_Channel3_IRQHandler   ; \n\texception_func     DMA2_Channel4_5_IRQHandler ; \n&#125;;\n\n&#x2F;&#x2F; 存放新的中断向量地址的地址，确保该内存不会被占用\n#define RAM_END (0x20000000+0x10000-4)\n\n&#x2F;&#x2F; 设置跳转的新中断向量\nvoid set_new_vector(unsigned int new_pos)&#123;\n\t*((unsigned int *)RAM_END) &#x3D; new_pos;  &#x2F;* 0x20000000 *&#x2F;\n&#125;\n\nvoid PendSV_Handler(void)&#123;\n\tstruct vectors *new_vector &#x3D; (struct vectors *)(*((unsigned int *)RAM_END));\n\tnew_vector-&gt;PendSV_Handler();\n&#125;\n\nvoid SysTick_Handler(void)&#123;\n\tstruct vectors *new_vector &#x3D; (struct vectors *)(*((unsigned int *)RAM_END));\n\tnew_vector-&gt;SysTick_Handler();\n&#125;\n\nvoid USART1_IRQHandler(void)&#123;\n\tstruct vectors *new_vector &#x3D; (struct vectors *)(*((unsigned int *)RAM_END));\n\tnew_vector-&gt;USART1_IRQHandler();\n&#125;\n\nvoid USART3_IRQHandler(void)&#123;\n\tstruct vectors *new_vector &#x3D; (struct vectors *)(*((unsigned int *)RAM_END));\n\tnew_vector-&gt;USART1_IRQHandler();\n&#125;\n\nvoid EXTI15_10_IRQHandler(void)&#123;\n\tstruct vectors *new_vector &#x3D; (struct vectors *)(*((unsigned int *)RAM_END));\n\tnew_vector-&gt;EXTI15_10_IRQHandler();\n&#125;\n\nvoid TIM8_UP_IRQHandler(void)&#123;\n\tstruct vectors *new_vector &#x3D; (struct vectors *)(*((unsigned int *)RAM_END));\n\tnew_vector-&gt;TIM8_UP_IRQHandler();\n&#125;\n","slug":"MCU/MCU_Bootloader","date":"2023-06-30T03:01:00.000Z","categories_index":"STM32","tags_index":"Bootloader","author_index":"爱慢跑的乌龟"},{"id":"6196392442c97458b57996bc517db85e","title":"OBD2 协议","content":"Ref: OBD2 Explained - A Simple Intro [2023]\nOBD2 原始数据帧\nOBD2 消息由标识符和数据组成。数据由于 Mode、PID 和 数据字节(A,B,C,D)组成。\n\n\nIdentifier - OBD 消息的标识符是标准的 11 位的，用于区分 \"request messages\" (ID 7DF) 和 \"response messages\" (ID 7E8 to 7EF)。7E8 通常是主发动机或 ECU 响应的地方。\nLength - 剩余数据(03-06)的字节长度。以车速为例，请求值是 02 (包含 01 和 0D)，而响应是 03 (包含 41、0D 和 32)。\nMode - 请求是 01-0A 之间，如果是响应则将 0 替换位 4 (41-4A 之间)。SAE J1979 标准中描述了 10 中模式。模式 1 位显示当前数据，车速、RPM 等。其它模式用于显示或清除存储的诊断故障代码和显示冻结帧数据。\nPID - 对于每一种模式，都有一系列标准的 OBD2 PIDs。例如，在模式 0 中，PID 0D 代表车速。每个 PID 都有描述，有些还有最大/最小值以及转换公式。\nA, B, C, D - HEX 格式的数据字节，用于 PID 公式计算之前需要先转换为十进制形式。最后一个字节未被使用。\n\nOBD2 的请求与响应\n如图所示，PID 'Vehicle Speed' 的请求/响应 CAN 消息的值为 50 km/h:\n\n\n\n\n\n\n\n\n\n\n\n在某些车辆中，原始的 CAN 数据使用的是扩展的 29 位标识符。在这种情况下，需要修改 OBD2 的 PID 请求，使用的 CAN ID 是 18DB33F1 而不是 7DF。数据结构与标准帧相同。响应的 CAN ID 为 18DAF100 - 18DAF1FF。\n10 种 OBD2 服务\nSAE J1979 OBD2 标准中描述了10 种 OBD2 诊断服务(或模式)。模式 1 显示当前数据，用于查看实时参数，如车速，RPM，油门位置等。其他模式例如用于显示/清除诊断故障代码 (DTCs) 和显示冻结帧数据。制造商不必支持所有的诊断服务，他们可以支持这10种服务之外的模式(即制造商特定的OBD2服务)。\n\n记录 OBD2 数据\n\n将 OBD2 记录器连接到 OBD2 连接器\n使用该工具通过 CAN 发送 \"request frames\"\n相关的 ECU 通过 CAN 发送 \"response frames\"\n解析原始的 OBD2 响应，如 DBC 文件\n\n5 种 OBD2 协议\n今天，通过 ISO-15765, CAN 总线作为绝大多数汽车中 OBD2 通信的基础。对于较旧的汽车(2008年以前)，可能使用其他四种协议。还要注意引脚，它可以用来确定汽车可能使用哪种协议。\n\n\nISO 15765 (CAN bus) - 绝大多数汽车都在使用\nISO14230-4 (KWP2000) - Keyword Protocol 2000 是 2003+ 汽车的通用协议，例如亚洲\nISO9141-2 - 2000-04 用于欧盟，克莱斯勒和亚洲汽车\nSAE J1850 (VPW) - 主要用于老款通用汽车\nSAE J1850 (PWM) - 主要用于老款福特汽车\n\nOBD 2 相关协议标准：\n\nSAE J1962 - 该标准定义了用于 OBD2 接口的物理连接器，即 OBD2 连接器。该标准描述了车载 OBD2 连接器和外部测试设备(例如OBD2 扫描仪或 OBD2 数据记录器) 使用的连接器。特别是，该标准规定了 OBD2 连接器的位置和访问权限。\nSAE J1979 - 该标准描述了通过 OBD2 协议请求诊断信息的方法。它还包括 OEM 可能在汽车中实现的标准化公共 OBD2 parameter IDs (OBD2 PIDs)列表。除了 SAE J1979 标准所规定的之外，OEM 也可能使用额外的专有 OBD2 PIDs。\nSAE J1939 - 该标准描述了用于重型车辆通信的数据协议。虽然 OBD2 PID 信息仅在 OBD2 测试设备请求时可用，但 J1939 协议用于大多数重型车辆，作为通信 CAN 流量的基本手段-这意味着数据连续广播。\nISO 11898: - 该标准描述了 CAN 总线数据链路层和物理层，作为当今大多数汽车中 OBD2 通信的基础。\nISO 15765-2 - ISO-TP 标准描述了 'Transport Layer'，即如何通过 CAN 总线发送超过 8 字节的数据包。该标准非常重要，因为它构成了UDS (Unified Diagnostic Services) 通信的基础，UDS 依赖于发送多帧 CAN 数据包。\nISO 14229 - UDS 通信的详细介绍\n\n\n","slug":"Automotive-Electronic/OBD2","date":"2023-06-28T02:36:00.000Z","categories_index":"汽车电子","tags_index":"汽车诊断协议","author_index":"爱慢跑的乌龟"},{"id":"80d29f01d39b07c6bd5a27520f206740","title":"网络管理工具 NetworkManager","content":"NetworkManager 是一个系统网络服务，它可以管理网络设备和网络连接，在可用的情况下保持网络连接的通畅。它管理以太网、WiFi、移动宽带和PPPoE设备，同时还提供各种不同VPN服务的VPN集成。\n默认情况下，Ubuntu Core 的网络管理由 systemd 的 network 和 netplan 来处理。当安装 NetworkManger 时，它将通过创建一个 netplan 配置文件来控制系统中的所有网络设备，在该文件中，它将设置自己为默认的网络呈现器。\nNetworkManager的功能\n上游的 NetworkManager 项目提供了广泛的特性，其中大部分(但不是全部)目前都在snap包中可用（Ubuntu）。\n\nWiFi connectivity\nWAN connectivity(together with ModemManager)\nEthernet connectivity\nWiFi access point creation\nShared connections\nVPN connections\n\n安装 NetworkManager 服务\nsudo apt-get install networkmanager\nsnap install network-manager\n查看网络状态\n使用 nmcli 命令行工具查询 NetworkManager 的连接和设备状态。\n显示 NetworkManager 已知的设备状态：nmcli d\n$ nmcli d\nDEVICE           TYPE      STATE      CONNECTION\nwlp3s0           wifi      connected  WHUT-WLAN\n显示 NetworkManager 连接的当前状态：nmcli c\n$ nmcli c\nNAME       UUID                                  TYPE  DEVICE\nWHUT-WLAN  e95d5c84-cd1e-4995-b91d-9e0014fab93b  wifi  wlp3s0\n查看无线接口的状态，包括 WiFi 和 WWAN(蜂窝) 的 radio 参数：nmcli r\n$ nmcli r\nWIFI-HW  WIFI     WWAN-HW  WWAN\nenabled  enabled  enabled  enabled\n配置 WiFi 连接\n建立无线连接\n确保 WiFi radio 是打开状态：\n$ nmcli r wifi on\n列出可用的 WiFi 连接：\n$ nmcli d wifi list\n\nIN-USE  BSSID              SSID        MODE   CHAN  RATE        SIGNAL  BARS  SECURITY\n        9C:1C:12:A3:34:42  WHUT-1X     Infra  1     195 Mbit&#x2F;s  57      ▂▄▆_  WPA2 802.1X\n        9C:1C:12:A3:34:41  WHUT-WLAN6  Infra  1     195 Mbit&#x2F;s  57      ▂▄▆_  --\n*       9C:1C:12:A8:91:D0  WHUT-WLAN   Infra  153   405 Mbit&#x2F;s  52      ▂▄__  --\n        8C:AB:8E:97:13:A0  PDCN        Infra  12    270 Mbit&#x2F;s  25      ▂___  WPA2\n        9C:1C:12:A3:34:50  WHUT-WLAN   Infra  161   405 Mbit&#x2F;s  25      ▂___  --\n        A2:C5:F7:ED:79:1D  a506        Infra  36    270 Mbit&#x2F;s  22      ▂___  WPA2\n接入 WiFi 命令：\n$ nmcli d wifi connect &lt;SSID&gt; password &lt;password&gt;\n连接隐藏网络\n\n\n\n\n\n\n\n\n\n隐藏网络是一种普通的无线网络，除非请求，否则它不会广播自己的SSID。这意味着它的名称不能搜索，必须从其他来源知道。\n$ nmcli c add type wifi con-name &lt;name&gt; ifname wlan0 ssid &lt;ssid&gt;\n$ nmcli c modify &lt;name&gt; wifi-sec.key-mgmt wpa-psk wifi-sec.psk &lt;password&gt;\n$ nmcli c up &lt;name&gt;\n配置 WiFi 接入点（AP）\n可以使用 NetworkManager 创建 WiFi 接入点：\n$ nmcli d wifi hotspot ifname &lt;wifi_iface&gt; ssid &lt;ssid&gt; password &lt;password&gt;\n\n - wifi network interface\n - AP 的 SSID\n - 访问密码\n\n如果命令成功，NM 将创建一个名为 Hotspot &lt;N&gt;的连接。\n\n\n\n\n\n\n\n\n\n默认情况下，创建的 AP 提供共享连接，因此如果提供 AP 的设备也具有访问 Internet 的权限，那么连接到它的设备应该能够访问Internet。\n配置蜂窝连接\n首先需要安装 modem-manager:\n$ sudo apt install modem-manager\n检查 modem 是否正常检测：\n$ sudo modem-manager.mmcli -L\n显示 modem 的详细信息：\n$ sudo modem-manager.mmcli -m 0\n0 - 设备索引\n输入SIM PIN:\n$ sudo modem-manager.mmcli -i 0 --pin&#x3D;&lt;PIN&gt;\nsuccessfully sent PIN code to the SIM\n更多用于处理SIM卡 PIN 的命令包括:\n$ sudo modem-manager.mmcli -i 0 --pin&#x3D;&lt;PIN&gt; --enable-pin\n$ sudo modem-manager.mmcli -i 0 --pin&#x3D;&lt;PIN&gt; --disable-pin\n$ sudo modem-manager.mmcli -i 0 --pin&#x3D;&lt;PIN&gt; --change-pin&#x3D;&lt;NEW_PIN&gt;\n$ sudo modem-manager.mmcli -i 0 --puk&#x3D;&lt;PUK&gt;\n分别是启用 PIN 锁定、禁用 PIN 锁定、更改 PIN 码和解锁 PUK锁定的SIM卡。\n之后，添加一个蜂窝连接：\n$ nmcli c add type gsm ifname &lt;interface&gt; con-name &lt;name&gt; apn &lt;operator_apn&gt;\n$ nmcli r wwan on\n\n - sudo mmcli -m &lt;N&gt; 输出中作为 “主端口” 列出的字符串\n - 用于标识连接的任意名称\n - APN 名称\n\n注意，这通常是带有模式 tty* 或 cdc-wdm* 设备的串行端口，而不是网络接口。由于这些接口名称可能会根据系统中存在的设备而更改，因此更好的替代方法是使用 mmcli (device:…) 显示的 sysfs 路径或使用' * '，它将使用 MM 检测到的任何 modem 设备:\nsudo nmcli c add type gsm ifname &#39;*&#39; con-name &lt;name&gt; apn &lt;operator_apn&gt;\n在执行这些命令之后，每当 ModemManager 报告 modem 已注册时，NetworkManager 将自动尝试启动蜂窝连接。成功完成后，NetworkManager 将为新网络接口创建路由，优先级低于以太网或 WiFi 接口。要禁用连接，执行如下命令:\n$ nmcli r wwan off\n或者更改 autoconnect 属性并关闭连接，如果需要更精细的控制:\n$ nmcli c modify &lt;name&gt; connection.autoconnect [yes|no]\n$ nmcli c down &lt;name&gt;\n在创建/修改 WWAN 连接时，可以提供 PIN (因此它是自动输入的)或其他 APN 配置信息。例如:\n$ nmcli c add type gsm ifname &lt;interface&gt; con-name &lt;name&gt; apn &lt;operator_apn&gt; username &lt;user&gt; password &lt;password&gt; pin &lt;PIN&gt;\n配置共享网络\n将设备作为其他设备可以连接的网关。使用如下的命令：\n$ nmcli c add con-name &lt;name&gt; type ethernet ifname &lt;iface&gt; ipv4.method shared ipv6.method ignore \n$ nmcli c up &lt;name&gt;\n\n - 连接的任意名称\n - 外部设备将连接到的接口名称\n\n在这种情况下，使用以太网接口(类型以太网)，提供 IPv 4地址，但这扩展到其他接口和IPv6。当连接建立时，NM 启动一个监听 &lt; interface &gt; 的 DHCP 服务器，并更改网络配置，以便转发数据包，并为接口启用伪装。当然，要做到这一点，我们需要一个不同于 &lt; interface &gt; 的接口，它必须具有外部连接。\n配置 VPN\nVPN 支持需要使用 core22 和来自 22/* 通道的 network-manager。目前支持两种类型的 VPN:\n\nOpenVPN\nWireGuard\n\n配置 OpenVPN 连接\nNetwork Manager 支持两种创建 OpenVPN 连接的方法:\n\n导入 OpenVPN 证书文件\n使用 nmcli 手动设置所需的参数\n\n第一种方法只需要将 OpenVPN 配置文件复制到以下位置之一:\nsudo nmcli c import type openvpn file &#x2F;var&#x2F;snap&#x2F;network-manager&#x2F;common&#x2F;myopenvp.ovpn\n该命令需要以 root 用户身份运行，因为它使用从配置文件中提取的数据创建证书和密钥文件。这些需要由 network-manager 访问，它本身以root id 运行。\n使用第二种方法需要复制证书和密钥，并根据需要创建/修改连接。例如:\nnmcli c add connection.id vpntest connection.type vpn \\\n    vpn.service-type org.freedesktop.NetworkManager.openvpn \\\n    ipv4.never-default true \\\n    ipv6.never-default true \\\n    +vpn.data ca&#x3D;&#x2F;var&#x2F;snap&#x2F;network-manager&#x2F;common&#x2F;creds&#x2F;server_ca.crt \\\n    +vpn.data cert&#x3D;&#x2F;var&#x2F;snap&#x2F;network-manager&#x2F;common&#x2F;creds&#x2F;user.crt \\\n    +vpn.data cert-pass-flags&#x3D;0 \\\n    +vpn.data cipher&#x3D;AES-128-CBC \\\n    +vpn.data comp-lzo&#x3D;adaptive \\\n    +vpn.data connection-type&#x3D;tls \\\n    +vpn.data dev&#x3D;tun \\\n    +vpn.data key&#x3D;&#x2F;var&#x2F;snap&#x2F;network-manager&#x2F;common&#x2F;creds&#x2F;user.key \\\n    +vpn.data ping&#x3D;10 \\\n    +vpn.data ping-restart&#x3D;60 \\\n    +vpn.data remote&#x3D;&lt;server&gt;:&lt;port&gt; \\\n    +vpn.data remote-cert-tls&#x3D;server \\\n    +vpn.data ta&#x3D;&#x2F;var&#x2F;snap&#x2F;network-manager&#x2F;common&#x2F;creds&#x2F;tls_auth.key \\\n    +vpn.data ta-dir&#x3D;1 \\\n    +vpn.data verify-x509-name&#x3D;name:access.is\n配置 WireGuard 连接\nnmcli c import type WireGuard file &#x2F;var&#x2F;snap&#x2F;nm-vpn-client&#x2F;common&#x2F;wg.conf\n编辑连接\n使用 nmcli 控制台\n除了提供使用命令行管理和修改网络连接的可能性之外，network-manager 还提供了一个内置的交互式控制台来实现相同的功能：\n$ nmcli connection edit\n它将打开一个交互式控制台。在第一步中，系统将提示输入连接类型。有效连接类型的列表将显示在屏幕上。选择连接类型之后，将跳转到 nmcli 控制台。\n或者，如果已知有效的连接类型，你可以通过提供类型作为参数直接跳转到 nmcl i控制台:\n$ nmcli connection edit type &lt;type&gt;\n$ nmcli c edit\nValid connection types: 6lowpan, 802-11-olpc-mesh (olpc-mesh), 802-11-wireless (wifi), 802-3-ethernet (ethernet), adsl, bluetooth, bond, bridge, cdma, dummy, generic, gsm, infiniband, ip-tunnel, macsec, macvlan, ovs-bridge, ovs-interface, ovs-port, pppoe, team, tun, vlan, vpn, vxlan, wifi-p2p, wimax, wireguard, wpan, bond-slave, bridge-slave, team-slave\nEnter connection type: wifi\n\n&#x3D;&#x3D;&#x3D;| nmcli interactive connection editor |&#x3D;&#x3D;&#x3D;\n\nAdding a new &#39;802-11-wireless&#39; connection\n\nType &#39;help&#39; or &#39;?&#39; for available commands.\nType &#39;print&#39; to show all the connection properties.\nType &#39;describe [&lt;setting&gt;.&lt;prop&gt;]&#39; for detailed property description.\n\nYou may edit the following settings: connection, 802-11-wireless (wifi), 802-11-wireless-security (wifi-sec), 802-1x, ethtool, match, ipv4, ipv6, tc, proxy\nnmcli&gt;\n要获取可用命令列表，输入 'help' 或 '?':\nnmcli&gt; ?\n------------------------------------------------------------------------------\n---[ Main menu ]---\ngoto     [&lt;setting&gt; | &lt;prop&gt;]        :: go to a setting or property\nremove   &lt;setting&gt;[.&lt;prop&gt;] | &lt;prop&gt; :: remove setting or reset property value\nset      [&lt;setting&gt;.&lt;prop&gt; &lt;value&gt;]  :: set property value\ndescribe [&lt;setting&gt;.&lt;prop&gt;]          :: describe property\nprint    [all | &lt;setting&gt;[.&lt;prop&gt;]]  :: print the connection\nverify   [all | fix]                 :: verify the connection\nsave     [persistent|temporary]      :: save the connection\nactivate [&lt;ifname&gt;] [&#x2F;&lt;ap&gt;|&lt;nsp&gt;]    :: activate the connection\nback                                 :: go one level up (back)\nhelp&#x2F;?   [&lt;command&gt;]                 :: print this help\nnmcli    &lt;conf-option&gt; &lt;value&gt;       :: nmcli configuration\nquit                                 :: exit nmcli\n------------------------------------------------------------------------------\nnmcli&gt;\n修改连接细节\n可以通过打印连接详细信息从命令行了解可用的设置：\n$ nmcli c show &lt;name&gt;\n\n - 连接名称\n\nIPv4 and IPv6 选项\n例如，对于 IPv4 设置，可以这样做:\n$ nmcli c show &lt;name&gt; | grep ipv4\nipv4.method:                            auto\nipv4.dns:\nipv4.dns-search:\nipv4.dns-options:                       (default)\nipv4.addresses:\nipv4.gateway:                           --\nipv4.routes:\nipv4.route-metric:                      -1\nipv4.ignore-auto-routes:                no\nipv4.ignore-auto-dns:                   no\nipv4.dhcp-client-id:                    --\nipv4.dhcp-timeout:                      0\nipv4.dhcp-send-hostname:                yes\nipv4.dhcp-hostname:                     --\nipv4.dhcp-fqdn:                         --\nipv4.never-default:                     no\nipv4.may-fail:                          yes\nipv4.dad-timeout:                       -1 (default)\n例如，设置 DNS 服务器需要输入:\n$ nmcli c modify &lt;name&gt; ipv4.dns &quot;8.8.8.8&quot;\nWiFi 省电选项\nWiFi 省电选项可以有以下值之一:\n\n\n\nVALUE\nMEANING\n\n\n\n\n0\nDefault\n\n\n1\nIgnore, do not touch currently configured setting\n\n\n2\nDisable\n\n\n3\nEnable\n\n\n\n$ nmcli c modify &lt;name&gt; 802-11-wireless.powersave 2\n日志\nNetworkManager 支持动态更改日志级别，并允许对记录的内容进行细粒度控制。\n首先检查当前的日志设置，输入:\n$ nmcli general logging\n可以全局更改级别，也可以单独更改每个域的级别：\n$ nmcli general logging [level &lt;level&gt; [domain &lt;domain&gt;]]\n日志级别：\nERR: will log only critical errors WARN: will log warning messages INFO: will log various informational messages DEBUG: enables verbose logging for debugging purposes is the category of messages that shall be logged with given severity. WIFI will include only WiFi related messages, IP4 will include only IPv4 related messages, and so on.\n","slug":"Linux/NetworkManager","date":"2023-06-17T04:51:00.000Z","categories_index":"Linux","tags_index":"网络管理工具","author_index":"爱慢跑的乌龟"},{"id":"15a22b4df3f9daa5f948365cdbe57588","title":"cron 计划任务","content":"\n\n\n\n\n\n\n\n\n守护进程执行调度命令：安排任务在特定时间自动运行\n熟练的系统管理员知道何时以及如何以编程方式安排任务以特定的间隔执行，无论是重复执行还是执行一定次数。可以在许多场景中应用此技能，例如调度备份、定期收集系统日志或自动化基本和重复的任务\ncron 使用一个守护进程（crond) 来读取不同的配置文件。在 /etc/cron.d 文件夹中存放着每个用户的 cron 文件，/etc/crontab 文件是全系统的。\n$ sudo systemctl status cron.service\n● cron.service - Regular background program processing daemon\n     Loaded: loaded (&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;cron.service; enabled; vendor preset: enabled)\n     Active: active (running) since Tue 2023-06-20 10:48:16 CST; 51min ago\n       Docs: man:cron(8)\n   Main PID: 404783 (cron)\n      Tasks: 1 (limit: 4474)\n     Memory: 516.0K\n        CPU: 446ms\n     CGroup: &#x2F;system.slice&#x2F;cron.service\n             └─404783 &#x2F;usr&#x2F;sbin&#x2F;cron -f -P\n\nJun 20 10:48:16 ansonserver systemd[1]: Started Regular background program processing daemon.\nJun 20 10:48:16 ansonserver cron[404783]: (CRON) INFO (pidfile fd &#x3D; 3)\nJun 20 10:48:16 ansonserver cron[404783]: (CRON) INFO (Skipping @reboot jobs -- not system startup)\nJun 20 10:50:01 ansonserver CRON[405459]: (anson) CMD (python3 &#x2F;home&#x2F;anson&#x2F;NetworkLogin&#x2F;NetworkLogin.py)\n\n$ ll &#x2F;etc&#x2F;crontab\n-rw-r--r-- 1 root root 1136 Mar 23  2022 &#x2F;etc&#x2F;crontab\n\n$ ll &#x2F;etc&#x2F;cron.d&#x2F;\ntotal 16\ndrwxr-xr-x   2 root root 4096 Feb 18 01:24 .&#x2F;\ndrwxr-xr-x 112 root root 4096 Jun 20 10:33 ..&#x2F;\n-rw-r--r--   1 root root  201 Jan  9  2022 e2scrub_all\n-rw-r--r--   1 root root  102 Mar 23  2022 .placeholder\n通过编辑 crontab 文件来操作 cron 的任务调度，或者在用户的 cron.d 目录中创建包含相关参数的文件。\n最常用的 crontab 参数包括：\n\n-l: 显示当前 crontab (当前用户的计划任务)\n-r: 删除当前 crontab\n-e: 编辑当前 crontab，使用环境变量指定的编辑器。退出编辑器后，将自动安装修改后的 crontab。\n\ncrontab 文件的语法:\n$ cat &#x2F;etc&#x2F;crontab\n# &#x2F;etc&#x2F;crontab: system-wide crontab\n# Unlike any other crontab you don&#39;t have to run the &#96;crontab&#39;\n# command to install the new version when you edit this file\n# and files in &#x2F;etc&#x2F;cron.d. These files also have username fields,\n# that none of the other crontabs do.\n\nSHELL&#x3D;&#x2F;bin&#x2F;sh\n# You can also override PATH, but by default, newer versions inherit it from the environment\n#PATH&#x3D;&#x2F;usr&#x2F;local&#x2F;sbin:&#x2F;usr&#x2F;local&#x2F;bin:&#x2F;sbin:&#x2F;bin:&#x2F;usr&#x2F;sbin:&#x2F;usr&#x2F;bin\n\n# Example of job definition:\n# .---------------- minute (0 - 59)\n# |  .------------- hour (0 - 23)\n# |  |  .---------- day of month (1 - 31)\n# |  |  |  .------- month (1 - 12) OR jan,feb,mar,apr ...\n# |  |  |  |  .---- day of week (0 - 6) (Sunday&#x3D;0 or 7) OR sun,mon,tue,wed,thu,fri,sat\n# |  |  |  |  |\n# *  *  *  *  * user-name command to be executed\n\n\n\n\n\n\n\n\n\n其它用法：\n\n使用 x-y 表示范围：例如，在 \"Days\" 列中输入 1-5，表示任务从周一运行到周五。\n使用 x,y 表示列表：例如，在 \"Minutes\" 列中设置 5,10-13,17，任务将在整点过5、10、11、12、13和17分时运行。\n使用 */x 表示间隔 x：例如，在 \"Minutes\" 列中输入 */7 表示每 7 分钟运行一次任务。\n\n将日志信息发送到指定的邮箱：\n# file: crontab\nMAILTO&#x3D;aosonxu_vip@163.com\n","slug":"Linux/crond","date":"2023-06-16T15:07:00.000Z","categories_index":"Linux","tags_index":"计划任务","author_index":"爱慢跑的乌龟"},{"id":"5de91de1b3c23479ddb38340c9771a7c","title":"日志管理 journalctl","content":"Journald 是 systemd 的守护进程，用于从各种日志源(如syslog)收集日志。Journalctl 是一个命令行工具，可以使用该命令行对日志进行管理和分析。通过 journalctl，可以读取日志，实时监控日志，根据时间，服务，严重程度和其他参数过滤日志。\nJournald 日志的默认存储位置：/var/log/journal/\n在 /etc/systemd/journal .conf 文件中，确保 Storage 的值被设置为 auto 或 persistent。\nJournalctl 命令的使用\n使用 journalctl 读取日志\n$ journalctl\n\n以上日志是按时间顺序显示的。Journalctl使用 less 来显示日志。使用与使用 less 命令相同的键来移动日志。\n\n\n\nKey\nDescription\n\n\n\n\nArrow\nMove by one line\n\n\nSpace\nMove down one page\n\n\nb\nMove up one page\n\n\ng\nGo to the first line\n\n\nG\nGo to the last line\n\n\n100g\nGo to the 100th line\n\n\n/string\nSearch for the string from current position\n\n\nn/N\nGo to the next or previous search match\n\n\nq\nExit the logs\n\n\n\n如果不希望日志以 less-like 查看模式显示，可以使用 --no-pager 参数。这将直接在屏幕上显示整个日志：\n$ journalctl --no-pager\n按时间倒序显示日志\n如果想要查看最近的日志，你可以使用 -r 选项以相反的顺序显示日志：\n$ journalctl -r\n按 q 退出日志。\n只显示 N 行最近的日志\n使用 -n 选项选择只显示日志中的特定行数，而不是显示所有日志。\n$ journalctl -n 25\n实时显示日志\n$ journalctl -f\n以UTC时间显示日志\n$ journalctl --utc\n只显示内核信息\n$ journalctl -k\n\n\n\n\n\n\n\n\n\n\n使用 sudo 查看所有日志\n显示来自特定 boot 会话的消息\nJournalctl 命令使用选项 -b 访问属于特定 boot 会话的日志。\n可以使用 --list-boots 参数列出所有 boot 会话:\n$ journalctl --list-boots\n0 de0eb89fb7f243a89fe27c180ad1cec9 Tue 2023-06-20 14:46:52 CST—Fri 2023-06-23 17:05:56 CST\nBoot 会话 0 是当前启动会话。Boot 会话 -1 是最后启动的会话，依此类推。\n$ journalctl -b -2\n筛选特定系统服务的日志\n可以根据 systemd 服务对日志进行过滤。\n$ journalctl -u service_name\n过滤一定时间间隔的日志\n您可以使用自然语言对日志进行过滤。 yesterday, today 和 tomorrow 这样的术语是可用的：\n$ journalctl --since&#x3D;yesterday --until&#x3D;now\n$ journalctl --since &quot;2020-07-10 15:10:00&quot; --until &quot;2020-07-12&quot;\n根据 UID、GID 和 PID 对日志进行过滤\n$ journalctl _PID&#x3D;1234\n仅显示错误日志\n$ journalctl -p 3 -xb\n\n-p 3: 过滤优先级为3的日志\n-x: 提供关于日志的其他信息\n-b: 自上次启动以来(即当前会话)\n\n还可以使用其他优先级来获取调试、警告甚至关键级别的日志。\n\n\n\nPriority\nCode\n\n\n\n\n0\nemerg\n\n\n1\nalert\n\n\n2\ncrit\n\n\n3\nerr\n\n\n4\nwarning\n\n\n5\nnotice\n\n\n6\ninfo\n\n\n7\ndebug\n\n\n\n检查日志的磁盘占用\n$ journalctl --disk-usage\n日志清理\n在清理日志之前的第一件事是调换日志文件。就是将当前活动的日志标记为存档，并创建新的日志。这是可选的，但这是有必要的。\n$ sudo journalctl --rotate\n1. 清理过去 x 天的日志\n$ sudo journalctl --vacuum-time&#x3D;2d\n2. 限制日志的空间大小\n$ sudo journalctl --vacuum-size&#x3D;100M\n3. 限制日志文件的数量\n$ journalctl --vacuum-files&#x3D;5\n自动日志清理\nJournalctl 的配置文件位于 /etc/systemd/journald.conf。有些设置被注释掉了。注释行基本上表示这些设置参数的默认值(即使它们被注释掉了)。可以更改其中一些默认设置以自动清除日志文件。\n\n\n\nSetting\nDescription\n\n\n\n\nSystemMaxUse\nMax disk space logs can take\n\n\nSystemMaxFileSize\nMax size of an INDIVIDUAL log file\n\n\nSystemMaxFiles\nMax number of log files\n\n\n\n修改配置文件之后，重启服务。\n$ sudo systemctl restart systemd-journald\n","slug":"Linux/journalctl","date":"2023-06-16T08:46:00.000Z","categories_index":"Linux","tags_index":"日志管理","author_index":"爱慢跑的乌龟"},{"id":"bf8918495fd2885b956948d83a291295","title":"CubeMX 添加 DSP 库","content":"\n\n\n添加宏定义：\n\n在 keil 中添加宏定义：\n\n调用 arm_math.h\n\n","slug":"MCU/CubeMX-DSP","date":"2023-06-08T02:30:00.000Z","categories_index":"STM32","tags_index":"DSP 库","author_index":"爱慢跑的乌龟"},{"id":"72c8bb50db339fd6a5c5fe75ad80519f","title":"Simulink 编译动态链接库","content":"一、创建输入输出变量\n\n\n将变量设置为全局变量：\n右击信号线，选择 Properties\n\nCurrent &#x3D; Simulink.Signal;\nCurrent.CoderInfo.StorageClass &#x3D; &quot;ExportedGlobal&quot;;\n编译之后的 C 语言变量为:\n\n二、设置编译器\n设置求解器为固定步长\n\n设置代码生成\n\n\n生成代码\n\n\n生成的动态链接库\n\nPython 调用动态链接库\n变量类型映射\n动态库的变量类型是按照 Simulink 中定义的，如 real_T，需要将 Simulink 中的类型映射到 Python 中的变量类型。映射文件为 rtwtypes.py\nimport ctypes\n\n&quot;&quot;&quot;\n&#x2F;*&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;*\n * Fixed width word size data types:                                     *\n *   int8_T, int16_T, int32_T     - signed 8, 16, or 32 bit integers     *\n *   uint8_T, uint16_T, uint32_T  - unsigned 8, 16, or 32 bit integers   *\n *   real32_T, real64_T           - 32 and 64 bit floating point numbers *\n *&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;*&#x2F;\n&quot;&quot;&quot;\nint8_T &#x3D; ctypes.c_byte\nuint8_T &#x3D; ctypes.c_ubyte\nint16_T &#x3D; ctypes.c_short\nuint16_T &#x3D; ctypes.c_ushort\nint32_T &#x3D; ctypes.c_int\nuint32_T &#x3D; ctypes.c_uint\nint64_T &#x3D; ctypes.c_longlong\nuint64_T &#x3D; ctypes.c_ulonglong\nreal32_T &#x3D; ctypes.c_float\nreal64_T &#x3D; ctypes.c_double\n&quot;&quot;&quot;\n&#x2F;*&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;*\n * Generic type definitions: boolean_T, char_T, byte_T, int_T, uint_T,       *\n *                           real_T, time_T, ulong_T, ulonglong_T.           *\n *&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;*&#x2F;\n&quot;&quot;&quot;\nreal_T &#x3D; ctypes.c_double\ntime_T &#x3D; ctypes.c_double\nboolean_T &#x3D; ctypes.c_ubyte\nint_T &#x3D; ctypes.c_int\nuint_T &#x3D; ctypes.c_uint\nulong_T &#x3D; ctypes.c_ulong\nulonglong_T &#x3D; ctypes.c_ulonglong\nchar_T &#x3D; ctypes.c_char\nuchar_T &#x3D; ctypes.c_ubyte\nchar_T &#x3D; ctypes.c_byte\n&quot;&quot;&quot;\n&#x2F;*&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;*\n * Complex number type definitions                                           *\n *&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;*&#x2F;\n&quot;&quot;&quot;\n\n\nclass creal32_T(ctypes.Structure):\n    _fields_ &#x3D; [\n        (&quot;re&quot;, real32_T),\n        (&quot;im&quot;, real32_T),\n    ]\n\n\nclass creal64_T(ctypes.Structure):\n    _fields_ &#x3D; [\n        (&quot;re&quot;, real64_T),\n        (&quot;im&quot;, real64_T),\n    ]\n\n\nclass creal_T(ctypes.Structure):\n    _fields_ &#x3D; [\n        (&quot;re&quot;, real_T),\n        (&quot;im&quot;, real_T),\n    ]\n\n\nclass cint8_T(ctypes.Structure):\n    _fields_ &#x3D; [\n        (&quot;re&quot;, int8_T),\n        (&quot;im&quot;, int8_T),\n    ]\n\n\nclass cuint8_T(ctypes.Structure):\n    _fields_ &#x3D; [\n        (&quot;re&quot;, uint8_T),\n        (&quot;im&quot;, uint8_T),\n    ]\n\n\nclass cint16_T(ctypes.Structure):\n    _fields_ &#x3D; [\n        (&quot;re&quot;, int16_T),\n        (&quot;im&quot;, int16_T),\n    ]\n\n\nclass cuint16_T(ctypes.Structure):\n    _fields_ &#x3D; [\n        (&quot;re&quot;, uint16_T),\n        (&quot;im&quot;, uint16_T),\n    ]\n\n\nclass cint32_T(ctypes.Structure):\n    _fields_ &#x3D; [\n        (&quot;re&quot;, int32_T),\n        (&quot;im&quot;, int32_T),\n    ]\n\n\nclass cuint32_T(ctypes.Structure):\n    _fields_ &#x3D; [\n        (&quot;re&quot;, uint32_T),\n        (&quot;im&quot;, uint32_T),\n    ]\n\n\nclass cint64_T(ctypes.Structure):\n    _fields_ &#x3D; [\n        (&quot;re&quot;, int64_T),\n        (&quot;im&quot;, int64_T),\n    ]\n\n\nclass cuint64_T(ctypes.Structure):\n    _fields_ &#x3D; [\n        (&quot;re&quot;, uint64_T),\n        (&quot;im&quot;, uint64_T),\n    ]\n函数调用\nimport ctypes\nimport os\nfrom rtwtypes import *\n\ncathode_pressure_in &#x3D; 2.3967033719742803\nrh_cathode &#x3D; 0.9249641277501583\noer &#x3D; 1.614672377913217\ntemperature &#x3D; 378.9999999270832\n\npath &#x3D; &quot;Optimize1_win64.dll&quot;\nmodel_dll_path &#x3D; os.path.abspath(path)\nmodel_dll &#x3D; ctypes.windll.LoadLibrary(model_dll_path)\nmodel_initialize &#x3D; model_dll.Optimize1_initialize\nmodel_step &#x3D; model_dll.Optimize1_step\nmodel_terminate &#x3D; model_dll.Optimize1_terminate\n# Input Signals\nCurrent &#x3D; real_T.in_dll(model_dll, &quot;Current&quot;)\nTemperature &#x3D; real_T.in_dll(model_dll, &quot;Temperature&quot;)\nPressureAnode &#x3D; real_T.in_dll(model_dll, &quot;PressureAnode&quot;)\nOER &#x3D; real_T.in_dll(model_dll, &quot;OER&quot;)\nPressureCathode &#x3D; real_T.in_dll(model_dll, &quot;PressureCathode&quot;)\nRH_Cathode &#x3D; real_T.in_dll(model_dll, &quot;RH_Cathode&quot;)\n# Output Signals\nNetPower &#x3D; real_T.in_dll(model_dll, &quot;NetPower&quot;)\n# Input Parameters\nCurrent.value &#x3D; 200\nPressureCathode.value &#x3D; cathode_pressure_in * 101325\nPressureAnode.value &#x3D; cathode_pressure_in * 101325\nOER.value &#x3D; oer\nRH_Cathode.value &#x3D; rh_cathode\nTemperature.value &#x3D; temperature\n# Simulation\nmodel_initialize()\nfor _ in range(1000):\n    model_step()\nmodel_terminate()\n# OutPut Parameters\nnetpower &#x3D; NetPower.value\nprint(netpower)\n使用 ctypes 库调用 dll 动态库文件。\n# 导入 dll 文件\nmodel_dll_path &#x3D; os.path.abspath(path)\nmodel_dll &#x3D; ctypes.windll.LoadLibrary(model_dll_path)\n# 模型初始化\nmodel_initialize &#x3D; model_dll.Optimize1_initialize\n# 单步仿真\nmodel_step &#x3D; model_dll.Optimize1_step\n# 终止仿真\nmodel_terminate &#x3D; model_dll.Optimize1_terminate\n# 变量映射\nCurrent &#x3D; real_T.in_dll(model_dll, &quot;Current&quot;)\nTemperature &#x3D; real_T.in_dll(model_dll, &quot;Temperature&quot;)\nPressureAnode &#x3D; real_T.in_dll(model_dll, &quot;PressureAnode&quot;)\n# 变量赋值\nCurrent.value &#x3D; 200\nPressureCathode.value &#x3D; cathode_pressure_in * 101325\nPressureAnode.value &#x3D; cathode_pressure_in * 101325\n","slug":"Simulink/Simulink 编译动态链接库","date":"2023-06-05T13:20:00.000Z","categories_index":"Simulink","tags_index":"代码生成","author_index":"爱慢跑的乌龟"},{"id":"0de178335a5288a6c84f26e77dfbea47","title":"FreeRTOS 的定时器 (Timer)","content":"软件定时器用于在将来一个设定的时间或以固定频率定期的执行函数。软件定时器所执行的函数被称为软件定时器的回调函数。\n软件定时器由 FreeRTOS\n内核实现，并受其控制。它不需要硬件支持，也与硬件定时器或硬件计数器无关。软件计时器不使用任何处理时间，除非软件计时器回调函数正在实际执行。\n\n\n\n\n\n\n\n\n\n软件定时器的功能是可选的，配置软件定时器功能：\n\n引入软件定时器的头文件 timer.c\n配置 configUSE_TIMERS 为 1\n\n软件定时器的回调函数\n软件定时器的回调函数实现为 C\n函数。唯一的特殊之处在于它的原型，它的返回类型必须是\nvoid，并将一个软件定时器的句柄作为其唯一的参数：\nvoid ATimerCallback(TimerHandle_t xTimer);\n软件定时器回调函数从头到尾执行，并以正常方式退出。它应该尽可能的短，并且不能进入阻塞状态。\n\n\n\n\n\n\n\n\n\n当 FreeRTOS\n的调度启动时，软件定时器回调函数在自动创建的任务上下文中执行。因此，软件定时器回调函数绝不能调用会导致调用任务进入阻塞状态的\nFreeRTOS API 函数。调用 xQueueReceive()\n等函数是可以的，但前提是函数的 xTicksToWait 参数必须设置为 0。调用\nvTaskDelay() 等函数是不行的，因为调用\nvTaskDelay() 将始终将调用任务进入阻塞状态。\n软件定时器的属性和状态\n软件定时器的周期\n软件定时器的“周期”是软件定时器启动和软件计时器回调函数执行之间的时间。\n单次定时器和自动重装载定时器\n软件定时器有两种类型:\n\nOne-shot timers\n\n一旦启动，一次性定时器将只执行一次回调函数。一次性定时器可以手动重启，但不会自行重启。\n\nAuto-reload timers\n\n一旦启动，自动重装载定时器将在每次过期时重新启动自己，从而周期性地执行其回调函数。\n\n\n软件定时器的状态\n\nDormant\n\n休眠软件定时器可以被它的句柄引用，但是没有运行，所以它的回调函数不会执行。\n\nRunning\n\n正在运行的软件计时器将在自软件计时器进入“正在运行”状态以来经过与其时间段相等的时间或自上次重置软件计时器以来执行其回调函数。\n\n\n自动加载软件定时器的状态转换：\n\n一次性软件定时器的状态转换：\n\n自动加载定时器执行回调函数后进入 Running\n状态，一次性定时器执行回调函数后进入休眠状态。\nxTimerDelete() API\n函数的作用是删除定时器。定时器可以在任何时候删除。\n软件定时器的上下文\nRTOS 守护进程(定时器服务)任务\n所有的软定时器回调函数都在同一个 RTOS 守护进程（或\n“定时器服务”）任务的上下文中执行。\n守护进程任务是一个标准的 FreeRTOS\n任务，在调度程序启动时自动创建。它的优先级和栈大小分别由\nconfigTIMER_TASK_PRIORITY 和\nconfigTIMER_TASK_STACK_DEPTH 常数设置。\n软件定时器回调函数不得调用会导致调用任务进入阻塞状态的 FreeRTOS API\n函数，因为这样做会导致守护程序任务进入阻塞状态。\n定时器命令队列\n软件定时器 API 函数将命令从调用任务通过一个名为 timer command queue\n的队列发送到守护任务。命令包括 start a timer、stop a timer 和 reset a\ntimer。\n\ntimer command queue 是一个标准的 FreeRTOS\n队列，它在调度程序启动时自动创建。定时器命令队列的长度由\nconfigTIMER_QUEUE_LENGTH 常数设置。\n守护进程任务调度\n守护进程任务和其他 FreeRTOS\n任务一样被调度，只有当它是能够运行的最高优先级任务时，它才会处理命令或执行计时器回调函数。\n当 Daemon task 的有优先级低于调用\nxTimerStart() API 函数的任务的优先级时：\n\n任务 1 调用 xTimerStart() API\n函数。xTimerStart()\n向定时器命令队列发送命令，使守护进程任务离开阻塞状态。由于任务 1\n的优先级高于守护任务的优先级，所以守护任务不会抢占任务 1。\n当任务 1 调用 API\n函数进入阻塞状态。守护任务则是处于就绪状态的最高优先级任务，因此调度器选择守护任务作为进入运行状态的任务。然后，守护进程任务开始处理任务\n1 发送到计时器命令队列的命令。\n\n\n\n\n\n\n\n\n\n启动状态的软件定时器过期的时间是从 start a timer\n命令发送到定时器命令队列的时间开始计算的，而不是从守护任务从定时器队列接收\nstart a timer 命令的时间开始计算的。\n当 Daemon task 的有优先级高于调用\nxTimerStart() API 函数的任务的优先级时：\n\n任务 1 调用 xTimerStart() API\n函数。xTimerStart()\n向定时器命令队列发送命令，使守护进程任务离开阻塞状态。守护进程任务的优先级高于任务\n1 的优先级，因此调度器选择守护进程任务作为要进入的任务运行状态。\n任务 1 在完成执行 xTimerStart()\n函数之前被守护进程任务抢占，现在处于Ready状态。守护任务开始处理任务 1\n发送给定时器命令队列的命令。\n发送到 timer\n命令队列的命令包含一个时间戳。时间戳用于说明应用程序任务发送命令与守护进程任务处理同一命令之间的任何时间间隔。例如，如果发送\nstart a timer 命令来启动一个周期为 10 个 ticks\n的定时器，则使用时间戳来确保正在启动的定时器在命令发送后10个\nticks 过期，而不是在命令被守护任务处理后10个 ticks 过期。\n创建并启动一个软件定时器\nxTimerCreate() API 函数\n软件定时器由 TimerHandle_t\n类型的变量引用。xTimerCreate()\n用于创建一个软件定时器，并返回一个 TimerHandle_t\n来引用它所创建的软件定时器。软件定时器在休眠状态下创建。\n软件定时器可以调度器启动之前创建，也可以在调度器启动之后创建。\nTimerHandle_t xTimerCreate(const char * const pcTimerName,\n                           TickType_t xTimerPeriodInTicks,\n                           UBaseType_t uxAutoReload,\n                           void * pvTimerID,\n                           TimerCallbackFunction_t pxCallbackFunction);\n\n\n\n\n\n\n\npcTimerName\n定时器的描述名称，便于识别\n\n\nxTimerPeriodInTicks\n定时器的周期，单位是 Tick。可以是 pdMS_TO_TICKS()\n宏函数\n\n\nuxAutoReload\npdTRUE/pdFALSE 是否自动重装载\n\n\npvTimerID\n每个软件定时器都有一个 ID 值\n\n\npxCallbackFunction\n软件计时器回调函数\n\n\nReturned value\n创建失败返回 NULL，成功则返回定时器句柄\n\n\n\nxTimerStart() API 函数\nxTimerStart()\n用于启动处于休眠状态的软件定时器，或重置(重新启动)处于运行状态的软件定时器。xTimerStop()\n用于停止处于运行状态的软件定时器。停止软件定时器相当于将定时器转换为休眠状态。\n可以在调度器启动之前调用\nxTimerStart()，但是当这样做时，软件计时器直到调度器启动时才真正启动。\n\n\n\n\n\n\n\n\n\n中断中应当使用 TimerStartFromISR() API 函数\nBaseType_t xTimerStart( TimerHandle_t xTimer, TickType_t xTicksToWait );\n\n\n\n\n\n\n\nParameter Name\nDescription\n\n\n\n\nxTimer\n软件定时器句柄\n\n\nxTicksToWait\n如果队列已经满了，调用任务应该保持在阻塞状态以等待定时器命令队列上的空间变得可用的最大时间。\n\n\nReturned value\npdPASS/pdFALSE\n\n\n\nExample 13\n创建一个一次性的和一个自动重装载的寄存器\n#define mainONE_SHOT_TIMER_PERIOD pdMS_TO_TICKS( 3333 )\n#define mainAUTO_RELOAD_TIMER_PERIOD pdMS_TO_TICKS( 500 )\nint main(void)\n{ \n    TimerHandle_t xAutoReloadTimer, xOneShotTimer;\n\tBaseType_t xTimer1Started, xTimer2Started;\n    \n    USART_Printf_Init(115200);\n    printf(\"SystemClk:%d\\r\\n\",SystemCoreClock);\n    printf(\"FreeRTOS Kernel Version:%s\\r\\n\",tskKERNEL_VERSION_NUMBER);\n\n    GPIO_Toggle_INIT();\n    /* 创建一个一次性定时器 */\n    xOneShotTimer = xTimerCreate(\"OneShot\",\n   \t\t\t\t\t\t\t\t mainONE_SHOT_TIMER_PERIOD,\n   \t\t\t\t\t\t\t\t pdFALSE,\n    \t\t\t\t\t\t\t 0,\n    \t\t\t\t\t\t\t prvOneShotTimerCallback);\t\n    /* 创建一个自动重装载定时器 */\n    xAutoReloadTimer = xTimerCreate(\"AutoReload\",\n                                    mainAUTO_RELOAD_TIMER_PERIOD,\n                                    pdTRUE,\n                                    0,\n                                    prvAutoReloadTimerCallback);\n    /* 检查软件定时器是否创建成功 */\n    if((xOneShotTimer != NULL) &amp;&amp; (xAutoReloadTimer != NULL))\n    {\n        xTimer1Started = xTimerStart(xOneShotTimer, 0);\n        xTimer2Started = xTimerStart(xAutoReloadTimer, 0);\n        if((xTimer1Started == pdPASS) &amp;&amp; (xTimer2Started == pdPASS))\n        {\n            /* Start the scheduler. */\n            vTaskStartScheduler();\n        }\n    }\n    while(1);\n}\n定时器回调函数：\nstatic void prvOneShotTimerCallback(TimerHandle_t xTimer)\n{\n    TickType_t xTimeNow;\n    /* 获得当前 Tick 计数器 */\n    xTimeNow = xTaskGetTickCount();\n    printf(\"One-shot timer callback executing %d\", xTimeNow);\n    /* File scope variable. */\n    ulCallCount++;\n}\nstatic void prvAutoReloadTimerCallback(TimerHandle_t xTimer)\n{\n    TickType_t xTimeNow;\n    /* 获得当前 Tick 计数器 */\n    xTimeNow = xTaskGetTickCount();\n\tprintf(\"Auto-reload timer callback executing %d\", xTimeNow);\n    ulCallCount++;\n}\n实验结果：\n\n定时器 ID\n每个软件定时器都有一个 ID，它是一个标签值。该 ID 存储在 (void *)\n中，因此可以直接存储整数值，指向任何其他对象，或用作函数指针。在创建软件定时器时为该\nID 分配一个初始值，之后可以通过 vTimerSetTimerID() API\n函数更新该 ID，并通过 pvTimerGetTimerID() API 函数查询该\nID。\n与其他软件定时器 API 函数不同，vTimerSetTimerID() 和\npvTimerGetTimerID()\n直接访问软件定时器，它们不向定时器命令队列发送命令。\nvTimerSetTimerID() API\n函数\nvoid vTimerSetTimerID(const TimerHandle_t xTimer, void *pvNewID);\n\n\n\nParameter Name\nDescription\n\n\n\n\nxTimer\n软件定时器句柄\n\n\npvNewID\n设置软件定时器 ID 的值。\n\n\n\npvTimerGetTimerID() API\n函数\nvoid *pvTimerGetTimerID( TimerHandle_t xTimer );\n\n\n\nParameter Name\nDescription\n\n\n\n\nxTimer\n软件定时器句柄\n\n\nReturned value\n软件定时器的 ID 值\n\n\n\nExample 14\n使用回调函数参数和软件定时器 ID\n同一个回调函数可以分配给多个软件定时器。完成后，使用回调函数参数来确定哪个软件计时器过期了。\n/* Create the one shot timer software timer */\nxOneShotTimer = xTimerCreate(\"OneShot\",\n\t\t\t\t\t\t\t mainONE_SHOT_TIMER_PERIOD,\n\t\t\t\t\t\t\t pdFALSE,\n\t\t\t\t\t\t\t 0,\n                             prvTimerCallback);\n/* Create the auto-reload software timer*/\nxAutoReloadTimer = xTimerCreate(\"AutoReload\",\n\t\t\t\t\t\t\t\tmainAUTO_RELOAD_TIMER_PERIOD,\n\t\t\t\t\t\t\t\tpdTRUE,\n                                0,\n                                prvTimerCallback );\nprvTimerCallback()\n将在其中一个计时器到期时执行。prvTimerCallback()\n使用函数的参数来确定调用它是因为一次性定时器过期，还是因为自动加载定时器过期。\nprvTimerCallback() 还演示了如何使用软件定时器 ID\n作为定时器特定的存储，每个软件定时器都在自己的 ID\n中保存过期次数的计数，自动重新加载计时器使用该计数在第五次执行时停止自己。\nstatic void prvTimerCallback(TimerHandle_t xTimer)\n{\n    TickType_t xTimeNow;\n    uint32_t ulExecutionCount;\n    /* 获得定时器 ID */\n    ulExecutionCount = (uint32_t) pvTimerGetTimerID(xTimer);\n    ulExecutionCount++;\n    vTimerSetTimerID(xTimer, (void *)ulExecutionCount);\n    /* 获得当前 Tick 计数 */\n    xTimeNow = xTaskGetTickCount();\n    /* 判断是哪个定时器到期 */\n    if(xTimer == xOneShotTimer)\n    {\n    \tprintf(\"One-shot timer callback executing %d\\r\\n\", xTimeNow);\n    }\n    else\n    {\n    \tprintf(\"Auto-reload timer callback executing %d\\r\\b\", xTimeNow);\n        if(ulExecutionCount == 5)\n        {\n            /* 自动装载 5 次后，停止定时器 */\n            xTimerStop( xTimer, 0 );\n        }\n    }\n}\n实验结果：\n\n更改一个定时器的周期\nxTimerChangePeriod()\nAPI 函数\n通过 xTimerChangePeriod()\n函数修改软件定时器的周期。如果使用 xTimerChangePeriod()\n来更改已经运行的定时器的周期，则定时器将使用新的周期值来重新计算其到期时间。重新计算的过期时间是相对于\nxTimerChangePeriod()\n被调用的时间，而不是相对于定时器最初启动的时间。\n如果 xTimerChangePeriod()\n用于更改处于休眠状态(未运行的计时器)的定时器的周期，则定时器将计算到期时间，并转换到运行状态(计时器将开始运行)。\n\n\n\n\n\n\n\n\n\n中断中应当使用 xTimerChangePeriodFromISR() API 函数\nBaseType_t xTimerChangePeriod(TimerHandle_t xTimer,\n                              TickType_t xNewTimerPeriodInTicks,\n                              TickType_t xTicksToWait );\n\n\n\nParameter Name\nDescription\n\n\n\n\nxTimer\n定时器句柄\n\n\nxTimerPeriodInTicks\n新的定时器周期\n\n\nxTicksToWait\n写入定时器命令队列的阻塞时间\n\n\nReturned value\npdPASS/pdFALSE\n\n\n\n重置软件定时器\n重置软件定时器是指重新启动定时器，定时器的过期时间被重新计算为相对于定时器重置的时间，而不是定时器最初启动的时间。\nxTimerReset() API 函数\n使用 xTimerReset() API\n函数重置计时器。xTimerReset()\n也可用于启动处于休眠状态的计时器。\n\n\n\n\n\n\n\n\n\n中断中应该使用 xTimerResetFromISR() API 函数\nBaseType_t xTimerReset( TimerHandle_t xTimer, TickType_t xTicksToWait );\n\n\n\nParameter Name\nDescription\n\n\n\n\nxTimer\n定时器句柄\n\n\nxTicksToWait\n写入定时器命令队列的阻塞时间\n\n\nReturned value\npdPASS/pdFALSE\n\n\n\n","slug":"FreeRTOS/Timer","date":"2023-05-07T09:24:00.000Z","categories_index":"嵌入式","tags_index":"FreeRTOS","author_index":"爱慢跑的乌龟"},{"id":"b5bbb50a4ed24d8a8d9fcbeb2df5e6ea","title":"FreeRTOS 的队列 (Queue)","content":"队列提供一种任务到任务、任务到中断和中断到任务之间的通信机制。\n队列的特点\n数据存储\n队列可保存有限数量的固定大小的数据项。一个队列可以容纳的最大数据量称为它的长度。在创建队列时需要指定每个数据项的长度和大小。队列通常使用先进先出(FIFO)缓冲区，数据在队列末尾被被写入并仓队列前端删除。\n\n有两种方式实现队列行为：\n\n复制\n将发送到队列的数据逐字节地复制到队列中。\n引用\n只保存指向发送到队列的数据的指针，而不是数据本身。\n\nFreeRTOS\n采用的复制的方法。复制的方法通常比引用更强大，同时也更简单，原因如下：\n\n栈变量可以直接发送到队列，即便声明它的函数退出后，该变量不存在了。\n可以将数据发送到队列，而无需首先分配一个缓冲区来保存数据，然后将数据复制到已分配的缓冲区中。\n发送任务可以立即重用发送到队列的变量或缓冲区。\n发送任务和接收任务是完全解耦的。\nRTOS 完全负责分配用于存储数据的内存。\n\n多任务访问\n队列本身就是对象，任何的任务和 ISR\n都可以访问它。任意数量的任务都可以写入同一队列，任意数量的任务都可以从同一队列中读取数据。在实际中，多个任务写同一队列很常见，而多个任务读同一队列却并不常见。\n读队列阻塞\n当一个任务试图从队列中读取数据时，它可以选择指定一个阻塞时间。当队列为空时，任务将保持阻塞状态以等待队列中有可用的数据。当有数据写入到队列时，处于阻塞状态的任务将自动转为就绪状态。如果指定的阻塞时间到了，还没有等到队列中的数据，任务也将自动从阻塞状态转为就绪状态。\n可以有多个数据读队列，因此一个队列可能会有多个任务阻塞在它上面等地数据。在这种情况下，当队列中有可用数据时，只有一个任务能被解除阻塞状态。解除阻塞的任务将始终是所有等待数据的任务中最高优先级的，如果优先级相同，解除阻塞的将是等待时间最长的任务。\n写队列阻塞\n任务向对列写入时可以指定阻塞时间。如果队列在准备写入时已满，任务将进入阻塞状态，阻塞时间是任务等待队列可写入的最长时间。可以有多个任务向队列写入，因此一个队列可能阻塞多个任务。当队列上有一个可写入空间时，则只能有一个任务完成写入而解除阻塞。解除阻塞的任务将是所有阻塞任务中优先级最高的。如果阻塞任务的优先级相同，则解除阻塞的任务将是等待时间最长的任务。\n多队列上的阻塞\n可以将队列分组为集合，允许任务进入阻塞状态，以等待数据在集合中的任何队列上可用\n使用一个队列\nxQueueCreate() API 函数\n在队列使用之前，必须显式低创建队列。\n队列通过一个句柄来引用，句柄是 QueueHandle_t\n类型的变量。 xQueueCreate() API 函数创建一个队列并返回一个\nQueueHandle_t，这个句柄引用了它创建的队列。\n当创建队列时，FreeRTOS 从 FreeRTOS 堆中分配 RAM。RAM\n用于保存队列数据结构和包含在队列中的项。如果要创建的队列没有足够的堆内存可用，xQueueCreate()\n将返回 NULL。\nQueueHandle_t xQueueCreate( UBaseType_t uxQueueLength, UBaseType_t uxItemSize );\n\n\n\n\n\n\n\nParameter Name\nDescription\n\n\n\n\nuxQueueLength\n队列长度，最多能存放多少个数据(item)\n\n\nuxItemSize\n每个数据(item)的大小：以字节为单位\n\n\nReturn Value\n非\n0：成功，返回句柄，以后使用句柄来操作队列NULL：失败，因为内存不足\n\n\n\n创建队列后，可以使用 xQueueReset() API\n函数将队列返回到其原始空状态。\nxQueueSendToBack()\n和 xQueueSendToFront() API 函数\nxQueueSendToBack()\n函数用于将数据发送到队列的末尾。xQueueSendToFront()\n用于将数据发送到队列的开头。\n\n\n\n\n\n\n\n\n\n不要在中断服务函数中调用 xQueueSendToBack() 和\nxQueueSendToFront() 函数。应该在中断服务程序中使用\nxQueueSendToFrontFromISR() 和\nxQueueSendToBackFromISR() 安全版本。\nBaseType_t xQueueSendToFront(QueueHandle_t xQueue,\n\t\t\t\t\t\t\t const void * pvItemToQueue,\n\t\t\t\t\t\t\t TickType_t xTicksToWait );\nBaseType_t xQueueSendToBack(QueueHandle_t xQueue,\n\t\t\t\t\t\t\tconst void * pvItemToQueue,\n\t\t\t\t\t\t\tTickType_t xTicksToWait );\n\n\n\n\n\n\n\nParameter Name\nDescription\n\n\n\n\nxQueue\n队列的句柄。\n\n\npvItemToQueue\n指向要复制到队列中的数据的指针。在创建队列时设置了队列可以容纳的数据的长度，因此这些字节将从\npvItemToQueue 复制到队列存储区域。\n\n\nxTicksToWait\n阻塞时间。等待时间为 tick 中断数。设置为\n0，则不等待立即返回。设置为 portMAX_DELAY，将永远等待\n(INCLUDE_vTaskSuspend 要设置为 1)。\n\n\nReturned value\npdPASS: 数据成功发送到队列。errQUEUE_FULL:\n写入失败，队列已满。\n\n\n\nxQueueReceive() API\n函数\nxQueueReceive()\n用于从队列中读取数据。读取过的数据将从队列中删除。\n\n\n\n\n\n\n\n\n\n不要从中断服务程序中调用\nxqueuerreceive()。中断服务函数中使用安全的\nxQueueReceiveFromISR() API函数。\nBaseType_t xQueueReceive(QueueHandle_t xQueue,\n\t\t\t\t\t\t void * const pvBuffer,\n\t\t\t\t\t\t TickType_t xTicksToWait );\n\n\n\n\n\n\n\nParameter Name\nDescription\n\n\n\n\nxQueue\n队列句柄。\n\n\npvBuffer\n指向内存的指针，读取到的数据将被复制到其中\n\n\nxTicksToWait\n阻塞时间。等待时间为 tick 中断数。设置为\n0，则不等待立即返回。设置为 portMAX_DELAY，将永远等待\n(INCLUDE_vTaskSuspend 要设置为 1)。\n\n\nReturned value\npdPASS: 数据成功发送到队列。errQUEUE_FULL:\n写入失败，队列已满。\n\n\n\nuxQueueMessagesWaiting()\nAPI 函数\nuxQueueMessagesWaiting()\n用于查询当前在队列中的数据个数。\n\n\n\n\n\n\n\n\n\n在中断服务函数中使用 uxQueueMessagesWaitingFromISR()\nUBaseType_t uxQueueMessagesWaiting( QueueHandle_t xQueue );\n\n\n\nParameter Name\nDescription\n\n\n\n\nxQueue\n队列句柄。\n\n\nReturned value\n队列中的存在的数据个数。如果返回0，则队列为空。\n\n\n\nExample 10\n接受队列数据时阻塞\n创建队列、从多个任务向队列发送数据以及从队列接收数据的过程。发送到队列的任务的优先级低于从队列接收的任务的优先级。这意味着队列不应该包含多数据，因为一旦数据被发送到队列，接收任务就会解除阻塞，抢占发送任务，并删除数据，使队列再次为空。\nstatic void vSenderTask(void *pvParameters){\n  int32_t lValueToSend;\n  BaseType_t xStatus;\n\n  lValueToSend = (int32_t)pvParameters;\n\n  while (1){\n    xStatus = xQueueSendToBack(xQueue, &amp;lValueToSend, 0);\n    if (xStatus != pdPASS){\n      printf(\"Could not send to the queue.\\r\\n\");\n    }\n  }\n}\nstatic void vReceiverTask(void *pvParameters){\n    int32_t lReceivedValue;\n    BaseType_t xStatus;\n    \n    while (1)\n    {\n      if(uxQueueMessagesWaiting(xQueue) != 0){\n        printf(\"Queue should have been empty!\\r\\n\");\n      }\n\n      xStatus = xQueueReceive(xQueue, &amp;lReceivedValue, pdMS_TO_TICKS(100));\n      if(xStatus == pdPASS){\n        printf(\"Received = %d\", lReceivedValue);\n      }else{\n        printf(\"Could not receive from the queue.\\r\\n\");\n      }\n    } \n}\nint main(void)\n{\n    USART_Printf_Init(115200);\n    printf(\"SystemClk:%d\\r\\n\",SystemCoreClock);\n    printf(\"FreeRTOS Kernel Version:%s\\r\\n\",tskKERNEL_VERSION_NUMBER);\n\n    GPIO_Toggle_INIT();\n    xQueue = xQueueCreate(5, sizeof(int32_t));\n    \n    if(xQueue != NULL){\n      xTaskCreate(vSenderTask, \"Sender1\", 1000, (void*) 100, 1, NULL);\n      xTaskCreate(vSenderTask, \"Sender2\", 1000, (void*) 200, 1, NULL);\n\n      xTaskCreate(vReceiverTask, \"Receiver\", 1000, NULL, 2, NULL);\n      vTaskStartScheduler();\n    }else{\n      printf(\"The queue could not be created.\");\n    }\n    while(1)\n    {\n        printf(\"shouldn't run at here!!\\n\");\n    }\n}\n实验结果：\n\n从多个来源接收数据\n一个任务从多个来源接收数据是很常见的。接收数据的任务需要直到数据来自何处，以确定应该如何处理数据。一个简单的设计方案是使用单个队列来传输一个结构体，在结构体的字段中包含数据值和数据来源。\n\n\n创建一个保存 Data_t\n结构体类型的队列。结构体成员允许在一条消息中将数据值和枚举类型（指示数据的含义）发送到队列。\nController\n任务用于执行系统的主要功能。它必须对队列上传递给它的系统状态的输入和更改做出反应。\nCAN 总线任务用于封装 CAN 总线接口功能。当 CAN\n总线任务接收并解码消息后，它将已解码的消息以 Data_t 结构体发送给\nController 任务。传输结构体的 eDataID 成员用于让 Controller\n任务知道数据是什么。\n人机界面 (HMI) 任务用于封装所有 HMI\n功能。机器操作员可能会以多种方式输入命令和查询值，这些方式必须在 HMI\n任务中进行检测和解释。当输入一个新命令时，HMI 任务将命令以Data_t\n结构体发送给 Controller 任务。\n\nExample 11 向队列发送结构体\n创建消息结构体：\ntypedef enum{\n    eSender1,\n    eSender2,\n} DataSource_t;\n\ntypedef struct{\n    uint8_t ucValue;\n    DataSource_t eDataSource;\n} Data_t;\n\nstatic const Data_t xStructsToSend[2] = {\n    {100, eSender1},\n    {200, eSender2}\n};\n发送任务具有更高的优先级，因此队列通常是满的。这是因为，一旦接收任务从队列中删除一个项目，它就会被其中一个发送任务抢占，然后立即重新填充队列。然后，发送任务重新进入阻塞状态，等待队列上的空间再次可用。\n发送任务：\nstatic void vSenderTask(void *pvParameters){\n    BaseType_t xStatus;\n    \n    while(1){\n        xStatus = xQueueSendToBack(xQueue, pvParameters, pdMS_TO_TICKS(100));\n        if(xStatus != pdPASS){\n            printf(\"Could not send to the queue.\\r\\n\");\n        }\n    }\n}\n接收任务：\nstatic void vReceiverTask(void *pvParameters){\n    Data_t xReceivedStructure;\n    BaseType_t xStatus;\n    \n    while(1){\n        if(uxQueueMessagesWaiting(xQueue) != 3){\n            printf(\"Queue should have been full!\\r\\n\");\n        }\n        xStatus = xQueueReceive(xQueue, &amp;xReceivedStructure, 0);\n        if(xStatus == pdPASS){\n            if(xReceivedStructure.eDataSource == eSender1){\n                printf(\"From Sender 1 = %d \\r\\n\", xReceivedStructure.ucValue);\n            }else{\n                printf(\"From Sender 2 = %d \\r\\n\", xReceivedStructure.ucValue);\n            }\n        }else{\n            printf(\"Could not receive from the queue.\\r\\n\");\n        }\n    }\n}\n主函数：\nint main(void){\n    xQueue = xQueueCreate(3, sizeof(Data_t));\n    if(xQueue != NULL){\n        xTaskCreate(vSenderTask, \"Sender1\", 256, (void *) &amp;(xStructsToSend[0]), 2, NULL);\n         xTaskCreate(vSenderTask, \"Sender2\", 256, (void *) &amp;(xStructsToSend[1]), 2, NULL);\n        xTaskCreate(vReceiverTask, \"Receiver\", 256, NULL, 1, NULL);\n        vTaskStartScheduler();\n    }else{\n        printf(\"The queue could not be created\");\n    }\n    while(1);\n}\n实验结果：\n\n处理大型或可变大小的数据\nQueuing Pointers\n如果存储在队列中的数据的大小很大，那么最好使用队列来传输指向数据的指针，而不是将数据本身一个字节一个字节地复制到队列中或从队列中复制出来。传递指针在处理时间和创建队列所需内存空间方面都更有效。但是，在使用指针队列时，必须非常小心，以确保：\n\n被指向的 RAM 所有者是明确定义的。\n当通过指针在任务之间共享内存时，必须确保两个任务不会同时修改内存内容，或者采取任何其他可能导致内存内容无效或不一致的操作。理想情况下，应该只允许发送任务访问内存，直到指向内存的指针进入队列，并且在从队列接收指针之后，应该只允许接收任务访问内存。\n所指向的 RAM 始终有效\n如果所指向的内存是动态分配的，或者是从预分配的缓冲区池中获得的，那么应该只有一个任务负责释放内存。在内存被释放后，任何任务都不应该尝试访问内存。\n绝不应该使用指针来访问已在任务栈上分配的数据。在栈帧改变后，数据将无效。\n\n示例：创建一个最多可容纳 5 个指针的队列。\nQueueHandle_t xPointerQueue;\nxPointerQueue = xQueueCreate( 5, sizeof( char * ) );\n示例：分配一个缓冲区，向缓冲区写入一个字符串，然后向队列发送一个指向缓冲区的指针。\nvoid vStringSendingTask(void *pvParameters){\n    char *pcStringToSend;\n    const size_t xMaxStringLength = 50;\n    BaseType_t xStringNumber = 0;\n    while(1){\n        pcStringToSend = (char *)prvGetBuffer(xMaxStringLength);\n        snprintf(pcStringToSend, xMaxStrintLength, \"String number %d\\r\\n\", xStringNumber);\n        xStringNumber++;\n        xQueueSend(xPointerQueue,\n                   &amp;pcStringToSend,\n                   portMAX_DELAY);\n    }\n}\n示例：从队列接收一个指向缓冲区的指针，然后打印缓冲区中包含的字符串。\nvoid vStringReceivingTask(void *pvParameters){\n    char *pcReceivedString;\n    while(1){\n        xQueueReceive(xPointerQueue,\n                      &amp;pcReceivedString,\n                      portMAX_DELAY);\n        vPrintString(pcReceivedString);\n        prvReleaseBuffer(pcReceivedString);\n    }\n}\n使用队列发送不同类型和长度的数据\n结合将结构体发送到队列和将指针发送到队列的技术，任务可以使用单个队列从任何数据源接收任何数据类型。FreeRTOS+TCP\nTCP/IP 栈提供了如何实现这一目标的实际示例。\nTCP/IP\n栈在自己的任务中运行，必须处理来自许多不同源的事件。不同的事件类型与不同的数据类型和长度相关联。所有发生在\nTCP/IP 任务之外的事件都由 IPStackEvent_t\n类型的结构体描述，并以队列的形式发送给 TCP/IP 任务。IPStackEvent_t\n结构体的 pvData\n成员是一个指针，可以用来直接保存一个值，或者指向一个缓冲区。\n/* A subset of the enumerated types used in the TCP/IP stack to identify events. */\ntypedef enum{\n    eNetworkDownEvent = 0, /* The network interface has been lost, or needs (re)connecting. */\n    eNetworkRxEvent, /* A packet has been received from the network. */\n    eTCPAcceptEvent, /* FreeRTOS_accept() called to accept or wait for a new client. */\n    /* Other event types appear here but are not shown in this listing. */\n} eIPEvent_t;\n\n/* The structure that describes events, and is sent on a queue to the TCP/IP task. */\ntypedef struct IP_TASK_COMMANDS\n{\n    /* An enumerated type that identifies the event. See the eIPEvent_t definition above. */\n    eIPEvent_t eEventType;\n    /* A generic pointer that can hold a value, or point to a buffer. */\n    void *pvData;\n} IPStackEvent_t;\nTCP/IP事件及其相关数据包括:\n\neNetworkRxEvent: 从网络接收到一个数据包。\n\n从网络接收到的数据使用 IPStackEvent_t 类型的结构体发送到 TCP/IP\n任务。结构体的 eEventType 成员被设置为 eNetworkRxEvent，结构体的 pvData\n成员被用来指向包含接收数据的缓冲区。\nvoid vSendRxDataToTheTCPTask(NetworkBufferDescriptor_t *pxRxedData){\n    IPStackEvent_t xEventStruct;\n    /* Complete the IPStackEvent_t structure. The received data is stored in pxRxedData. */\n    xEventStruct.eEventType = eNetworkRxEvent;\n    xEventStruct.pvData = (void*) pxRxedData;\n    /* Send the IPStackEvent_t structure to the TCP/IP task. */\n    xSendEventStructToIPTask(&amp;xEventStruct);\n}\n\neTCPAcceptEvent: 套接字将接受或等待来自客户端的连接。\n\n接收事件从调用 FreeRTOS_accept() 的任务发送到使用\nIPStackEvent_t 类型结构的 TCP/IP 任务。结构体的 eEventType 成员设置为\neTCPAcceptEvent，结构体的 pvData\n成员设置为正在接受连接的套接字的句柄。\nvoid vSendAcceptRequestToTheTCPTask(Socket_t xSocket){\n    IPStackEvent_t xEventStruct;\n    /* complete the IPStackEvent_t structure. */\n    xEventStruct.eEventType = eTCPAcceptEvent;\n    xEventStruct.pvData = (void*) xSocket;\n    \n    /* Send the IPStackEvent_t structure to the TCP/IP task. */\n    xSendEventStructToIPTask(&amp;xEventStruct);\n}\n\neNetworkDownEvent: 网络需要连接或重新连接。\n\n网络 down 事件使用 IPStackEvent_t 类型的结构体从网络接口发送到 TCP/IP\n任务。结构体的eEventType 成员被设置为\neNetworkDownEvent。网络关闭事件不与任何数据相关联，因此不使用结构的\npvData 成员。\nvoid vSendNetworkDownEventToTheTCPTask(Socket_t xSocket){\n    IPStackEvent_t xEventStruct;\n    /* Complete the IPStackEvent_t structure. */\n    xEventStruct.eEventType = eNetworkDownEvent;\n    xEventStruct.pvData = NULL;\n    /* Send the IPStackEvent_t structure to the TCP/IP task.*/\n    xSend the IPStackStructToIPTask(&amp;xEventStruct);\n}\nTCP/IP 任务：\nIPStackEvent_t xReceivedEvent;\nxReceivedEvent.eEventType = eNoEvent;\nxQueueReceive(xNetworkEventQueue, &amp;xReceivedEvent, xNextIPSleep);\n/* Which event was received, if any? */\nswitch( xReceivedEvent.eEventType )\n{\n    case eNetworkDownEvent :\n        prvProcessNetworkDownEvent();\n        break;\n    case eNetworkRxEvent:\n        prvHandleEthernetPacket( ( NetworkBufferDescriptor_t * )( xReceivedEvent.pvData ) );\n        break;\n    case eTCPAcceptEvent:\n        xSocket = ( FreeRTOS_Socket_t * ) ( xReceivedEvent.pvData );\n        xTCPCheckNewClient( pxSocket );\n        break;\n    /* Other event types are processed in the same way, but are not shown here. */\n}\n从多个队列接收数据\n队列集\n一个任务有时候需要接收不同大小的数据、不同含义的数据和来自不来源的数据。使用单队列发送结构体数据是一种简单有效的方法。但是有时需要为某些数据源提供单独的队列来传输数据。例如，将第三方代码集成到设计中时，可能需要为这些数据提供专门的队列。在这种情况下，可以使用队列集。\n队列集允许任务从多个队列接收数据，而无需一次轮询每个队列以确定哪个队列包含数据。\n与使用单个队列接收结构体的方法相比，使用队列集从多个来源接收数据的设计不那么整洁，效率也更低。因此，仅在设计受到约束而绝对有必要使用队列集时才使用队列集。\n使用队列集的方法：\n\n创建一个队列集\n添加队列到集合中（信号量也可以添加到队列中）\n读取队列集以确定该集合中的哪些队列包含数据。\n当作为集合成员的队列接收数据时，接收队列的句柄被发送到队列集中，并在任务调用函数读取队列集时返回给任务。因此，如果从队列集返回队列句柄，则确定该句柄引用的队列包含数据，然后任务可以直接从队列中读取数据。\n\n\n\n\n\n\n\n\n\n\n如果队列是队列集的成员，则不要从队列中读取数据，除非队列的句柄已从队列集中读取。\n若要启用队列集功能，则需要将 configUSE_QUEUE_SETS 配置为\n1.\nxQueueCreateSet() API\n函数\n队列集由句柄引用，句柄是 QueueSetHandle_t\n类型的变量。xQueueCreateSet()\n函数创建一个队列集，并返回一个引用它创建的队列集的 QueueSetHandle_t\n句柄。\nQueueSetHandle_t xQueueCreateSet( const UBaseType_t uxEventQueueLength );\n\n\n\n\n\n\n\nParameter Name\nDescription\n\n\n\n\nuxEventQueueLength\n当作为队列集成员的队列接收数据时，接收队列的句柄被发送到队列集。uxEventQueueLength\n定义了队列集可以包含的队列句柄的数量。\n\n\nReturn Value\n若成功则返回队列集的句柄，否则返回 NULL。\n\n\n\n只有当队列集内的队列接收到数据时，才会将队列的句柄发送到队列集中。如果队列已满，则无关接收数据，因此如果队列集中的所有队列都已满看，则不能向队列集发送队列句柄。因此，队列集一次必须容纳的最大数据量是集合中每个队列长度的总和。\n例如，如果集合中有三个空队列，每个队列的长度为\n5，那么在集合中的所有队列都满之前，集合中的队列总共可以接收 15\n个数据。在该示例中，uxEventQueueLength 必须设置为\n15，以保证队列集可以接收发送给它的每个数据。\n信号量也可以添加到队列集中，二进制信号量的长度为\n1，计数信号量的长度有信号量的最大计数值给出。\n如果队列集包含一个长度为 3 的队列和一个二进制信号量，则\nuxEventQueueLength 必须设置为 4。\nxQueueAddToSet() API 函数\nxQueueAddToSet() 向队列集添加队列或信号量。\nBaseType_t xQueueAddToSet(QueueSetMemberHandle_t xQueueOrSemaphore,\n\t\t\t\t\t\t  QueueSetHandle_t xQueueSet );\n\n\n\nParameter Name\nDescription\n\n\n\n\nxQueueOrSemaphore\n队列或信号量的句柄。\n\n\nxQueueSet\n队列集句柄。\n\n\nReturn Value\npdPASS：添加成功pdFAIL：添加失败\n\n\n\n队列和二进制信号量只有在为空时才能添加到集合中。计数信号量只有在计数为零时才能添加到集合中。队列和信号量一次只能是一个集合的成员。\nxQueueSelectFromSet()\nAPI 函数\nxQueueSelectFromSet() 从队列集中读取队列句柄。\n当集合成员接收到数据，接收队列或信号量的句柄将被发送到队列集，并在任务调用\nxQueueSelectFromSet() 时返回。如果调用\nxQueueSelectFromSet()\n返回句柄，则该句柄引用的队列或信号量已知包含数据，然后调用任务必须直接从队列或信号量中读取数据。\n\n\n\n\n\n\n\n\n\n不要直接从队列集的成员中直接读取数据，必须使用该函数返回的队列或信号量的句柄来读取数据。\nQueueSetMemberHandle_t xQueueSelectFromSet(QueueSetHandle_t xQueueSet,\n\t\t\t\t\t\t\t\t\t\t   const TickType_t xTicksToWait);\n\n\n\nParameter Name\nDescription\n\n\n\n\nxQueueSet\n队列集句柄\n\n\nxTicksToWait\n阻塞等待时间\n\n\nReturn Value\n已包含数据的队列或信号量的句柄，否则返回 NULL\n\n\n\nExample 12 使用一个队列集\n创建 2 个发送任务和 1\n个接收任务。发送任务通过两个单独的队列向接收任务发送数据，每个任务一个队列。将这两个队列添加到一个队列集中，接收任务从队列集读取数据，以确定两个队列中哪一个包含数据。\nstatic QueueHandle_t xQueue1 = NULL, xQueue2 = NULL;\nstatic QueueSetHandle_t xQueueSet = NULL;\n\nint main(void)\n{\n    USART_Printf_Init(115200);\n    printf(\"SystemClk:%d\\r\\n\", SystemCoreClock);\n    printf(\"FreeRTOS Kernel Version:%s\\r\\n\",tskKERNEL_VERSION_NUMBER);\n\n    GPIO_Toggle_INIT();\n    /* 创建两个队列 */\n    xQueue1 = xQueueCreate(1, sizeof(char *));\n    xQueue2 = xQueueCreate(1, sizeof(char *));\n    /* 创建一个队列集 */\n    xQueueSet = xQueueCreateSet(1 * 2);\n    /* 添加队列到队列集 */\n    xQueueAddToSet(xQueue1, xQueueSet);\n    xQueueAddToSet(xQueue2, xQueueSet);\n    /* 创建任务发送数据到队列 */\n    xTaskCreate(vSenderTask1, \"Sender1\", 256, NULL, 1, NULL);\n    xTaskCreate(vSenderTask2, \"Sender2\", 256, NULL, 1, NULL);\n    /* 创建一个接收任务 */\n    xTaskCreate(vReceiverTask, \"Receiver\", 256, NULL, 2, NULL);\n    /* 启动调度器 */\n    vTaskStartScheduler();\n    while(1)\n    {\n        printf(\"shouldn't run at here!!\\n\");\n    }\n}\n第一个发送任务使用 xQueue1 每 100\n毫秒向接收任务发送一个字符指针。第二个发送任务使用xQueue2 每 200\n毫秒向接收任务发送一个字符指针。\nstatic void vSenderTask1(void *pvParameters){\n    const char * const pcMeassge = \"Message from vSenderTask1\\r\\n\";\n    while(1){\n        vTaskDelay(pdMS_TO_TICKS(100));\n        xQueueSend(xQueue1, &amp;pcMeassge, 0);\n    }\n}\n\nstatic void vSenderTask2(void *pvParameters){\n    const char * const pcMeassge = \"Message from vSenderTask2\\r\\n\";\n    while(1){\n        vTaskDelay(pdMS_TO_TICKS(200));\n        xQueueSend(xQueue2, &amp;pcMeassge, 0);\n    }\n}\n接收任务：\nstatic void vReceiverTask(void *pvParameters){\n    QueueHandle_t xQueueThatContainsData;\n    char *pcReceivedString;\n    while(1){\n        xQueueThatContainsData = (QueueHandle_t) xQueueSelectFromSet(xQueueSet, portMAX_DELAY);\n\n        xQueueReceive(xQueueThatContainsData, &amp;pcReceivedString, 0);\n        printf(pcReceivedString);\n    }\n}\n实验结果：\n\n更现实的队列集用例\n在实际应用程序中，队列集可能同时包含队列和信号量，并且队列可能并不都持有相同的数据类型。在这种情况下，有必要在使用返回值之前测试\nxQueueSelectFromSet() 返回的值。\n/* char 指针队列 */\nQueueHandle_t xCharPointerQueue;\n/* Uint32_t 队列 */\nQueueHandle_t xUint32tQueue;\n/* 二值信号量 队列 */\nQueueHandle_t xBinarySemaphore;\n/* 队列集队列 */\nQueueSetHandle_t xQueueSet;\n\nvoid vAMoreRealisticReceiverTask(void *pvParameters){\n    QueueSetMemberHandle_t xHandle;\n    char *pcReceivedString;\n    uint32_t ulRecievedValue;\n    while(1){\n        xHandle = xQueueSelectFromSet(xQueueSet, pdMS_TO_TICKS(100));\n        \n        if(xHandle == NULL){\n            printf(\"The call to xQueueSelectFromSet() timed out.\");\n        }else if(xHandle == (xQueueSetMemberHandle_t) xCharPointerQueue){\n            xQueueReceive(xCharPointerQueue, &amp;pcReceivedString, 0);\n        }else if(xHandle == (xQueueSetMemberHandle_t) xUint32tQueue){\n            xQueueReceive(xUint32tQueue, &amp;ulRecievedValue, 0);\n        }else if(xHandle == (xQueueSetMemberHandle_t) xBinarySemaphore){\n            xSemaphoreTake( xBinarySemaphore, 0 );\n        }\n    }\n}\n使用队列创建一个邮箱\n“邮箱”在不同的 RTOS 中有不同的含义。在 Free RTOS\n中，术语邮箱指的是长度为 1\n的队列。之所以称这种队列为邮箱，是因为它再引用程序中的使用方式，而不是因为它与队列有功能上的区别:\n\n队列用于将数据从一个任务发送到另一个任务，或从中断服务例程发送到另一个任务。发送方将一个数据项放入队列，接收方从队列中删除该数据项。数据通过队列从发送方传递到接收方。\n邮箱用于保存可由任何任务或任何中断服务例程读取的数据。数据不通过邮箱，而是保留在邮箱中，直到它被覆盖。发件人将覆盖邮箱中的值。接收方将从邮箱中读取该值，但不从邮箱中删除该值。\n\ntypedef struct xExampleStructure\n{\n    TickType_t xTimeStamp;\n    uint32_t ulValue;\n} Example_t;\n/* 邮箱是一个队列，因此它的句柄存储在类型的变量 QueueHandle_t 中 */\nQueueHandle_t xMailbox;\n\nvoid vAFunction(void)\n{\n    /* 创建将用作邮箱的队列。队列的长度为 1，允许它与 xQueueOverwrite() API函数一起使用 */\n\txMailbox = xQueueCreate(1, sizeof(Example_t));\n}\nxQueueOverwrite() API\n函数\n与 xQueueSendToBack() API\n函数一样，xQueueOverwrite() API\n函数将数据发送到队列。与xQueueSendToBack()\n不同的是，如果队列已经满了，那么 xQueueOverwrite()\n将覆盖队列中已经存在的数据。\nxQueueOverwrite()只能用于长度为 1 的队列。\n\n\n\n\n\n\n\n\n\n在中断中应当使用 xQueueOverwriteFromISR() API 函数\nBaseType_t xQueueOverwrite( QueueHandle_t xQueue, const void * pvItemToQueue );\n\n\n\n\n\n\n\nParameter Name\nDescription\n\n\n\n\nxQueue\n队列句柄\n\n\npvItemToQueue\n指向要复制到队列中的数据的指针。\n\n\nReturn Value\n即使队列已满，函数也会覆盖原有值。因此，pdPASS 是唯一返回值\n\n\n\nvoid vUpdateMailbox(uint32_t ulNewValue)\n{\n    Example_t xData;\n    xData.ulValue = ulNewValue;\n    xData.xTimeStamp = xTaskGetTickCount();\n    xQueueOverwrite(xMailbox, &amp;xData);\n}\nxQueuePeek() API 函数\nxQueuePeek()\n用于从队列中接收一个数据项，而不从队列中删除该项目。xQueuePeek()\n从队列的头部接收数据，而不修改队列中存储的数据，也不修改队列中存储数据的顺序。\n\n\n\n\n\n\n\n\n\n在中断中应当使用 xQueuePeekFromISR() API 函数\nBaseType_t xQueuePeek(QueueHandle_t xQueue,\n                      void * const pvBuffer,\n                      TickType_t xTicksToWait );\nBaseType_t vReadMailbox(Example_t *pxData)\n{\n    TickType_t xPreviousTimeStamp;\n    BaseType_t xDataUpdated;\n    xPreviousTimeStamp = pxData-&gt;xTimeStamp;\n    xQueuePeek(xMailbox, pxData, portMAX_DELAY);\n    if(pxData-&gt;xTimeStamp &gt; xPreviousTimeStamp )\n    {\n    \txDataUpdated = pdTRUE;\n    }\n    else\n    {\n    \txDataUpdated = pdFALSE;\n    }\n    return xDataUpdated;\n}\n","slug":"FreeRTOS/Queue","date":"2023-05-05T12:57:00.000Z","categories_index":"嵌入式","tags_index":"FreeRTOS","author_index":"爱慢跑的乌龟"},{"id":"01ed63026d9bc8723f828c17bac96fdf","title":"FreeRTOS 的任务 (Task)","content":"\nFreeRTOS 是由 Real Time Engineers 公司独家拥有、开发和维护的。Real\nTime Engineers\n公司已经与世界领先的芯片公司密切合作了十多年，为您提供屡获殊荣的商业级和完全免费的高质量软件。\nFreeRTOS\n非常适合使用微控制器或小型微处理器的深度嵌入式实时应用程序。这种类型的应用程序通常包括硬实时和软实时需求的混合。\n\n\n\n\n\n\n\n\n\n\nFreeRTOS 的官网\n官方文档下载地址\nFreeRTOS 的基本概念\nFreeRTOS 的核心文件\n最核心的文件有两个：\n\nFreeRTOS/Source/task.c\nFreeRTOS/Source/list.c\n\n\n\n\n核心文件\n作用\n\n\n\n\ntask.c\n必需，用于实现任务操作\n\n\nlist.c\n必需，用于实现列表\n\n\nqueue.c\n必需，队列用于实现任务间的数据传递\n\n\ntimer.c\n可选，实现软件定时器\n\n\nevent_groups.c\n可选，提供事件组功能\n\n\ncroutine.c\n可选，弃用\n\n\n\n移植时涉及的文件\nFreeRTOS 移植时需要使用的文件位于\nFreeRTOS/Source/portable/[compiler]/[architecture]\n目录中。例如：RVDS/ARM_CM3，表示 cortex M3 架构在 RVDS 或\nKeil 工具上的移植文件，内有 2 个文件：\n\nport.c\nportmacro.h\n\n头文件目录\nFreeRTOS 需要 3 个头文件目录：\n\nFreeRTOS 核心代码的头文件：FreeRTOS/Source/include\n移植使用的头文件：FreeRTOS/Source/portable/[compiler]/[architecture]\n相关功能配置的文件：FreeRTOSConfig.h\n\n头文件的作用：\n\n\n\n\n\n\n\n头文件\n作用\n\n\n\n\nFreeRTOSConfig.h\nFreeRTOS\n的配置文件，相关算法的选择。特定功能函数的开关，使用什么函数就编译什么函数\n\n\nFreeRTOS.h\n使用 FreeRTOS 的 API 函数时必须包含该头文件。在\nFreeRTOS.h\n文件之后，再包含其它头文件，如：task.h\n、queue.h 等\n\n\n\n内存管理\nFreeRTOS 的内存管理文件位于\nFreeRTOS/Source/portable/MemMang 文件夹中，它放在\nportable 文件夹下，表示可以提供自己的函数。文件中有 5\n个源代码文件，对应 5 中内存管理的方法。\n\n\n\n\n\n\n\n\n文件\n优点\n缺点\n\n\n\n\nheap_1.c\n分配简单，时间确定\n只分配，不回收\n\n\nheap_2.c\n动态分配、最佳匹配\n碎片，时间不定\n\n\nheap_3.c\n调用标准库函数\n速度慢，时间不定\n\n\nheap_4.c\n相邻空闲内存可合并\n可解决碎片问题，时间不定\n\n\nheap_5.c\n再 heap_4 基础上支持分割的内存块\n可解决碎片问题，时间不定\n\n\n\n数据类型和编程规范\n数据类型\n每个移植版本都含有自己的 pormacro.h 头文件，里面定义了 2\n个数据类型：\n\nTickType_t:\n\nFreeRTOS 配置了一个周期性时钟中断：Tick Interrupt\n每次发生一次中断，中断次数累加，这被称为 tick count\ntick count 这个变量的类型就是 TickType_t\nTickType_t 可以是 16 位的，也可以是 32 位的\nFreeRTOSConfig.h 中定义 configUSE_16_BIT_TICKS\n时，TickType_t 就是 uint16_t\n否则 TickType_t 就是 uint32_t\n对于 32 位结构，建议把 TickType_t 配置为 uint32_t\n\nBaseType_t:\n\n这是该架构最高效的数据类型\n32 位架构中， 为 uint32_t 类型\n16 位架构中，为 uint16_t 类型\n8 位架构中，为 uint8_t 类型\nBaseType_t 通常用作简单的返回值的类型，还有逻辑值，如\npdTRUE/pdFALSE\n\n\n变量名\n\nuint32_t 类型变量以 ul 为前缀，其中 \"u\" 表示\n\"unsigned\"，\"l\" 表示 \"long\"\nuint16_t 类型变量以 us 为前缀，其中 \"u\" 表示\n\"unsigned\"，\"s\" 表示 \"short\"\nuint8_t 类型变量以 uc 为前缀，其中 \"u\" 表示\n\"unsigned\"，\"c\" 表示 \"char\"\n非 stdint 类型的变量 以 x 为前缀，例如：BaseType_t 和\nTickType_t\n非 stdint 类型的 unsigned 变量附加前缀 u。例如：UBaseType_t\n类型变量 以 ux 为前缀\nsize_t 类型变量也带有 x 前缀\n枚举变量以 e 为前缀\n指针以附加 p 为前缀，例如：指向 uint16_t 的指针以\npus 为前缀\n根据 MISRA 指南，未限定标准 char 类型仅包含 ASCII\n字符，并以 c 为前缀\n根据 MISRA 指南，char 类型变量仅可包含指向 ASCII\n字符串的指针，并以 pc 为前缀\n\n函数\n\n文件作用域静态（私有）函数以 prv 为前缀\n根据变量定义的相关规定，API 函数以其返回类型为前缀，并未\nvoid 添加前缀 v\nAPI 函数名称以定义 API 函数文件的名称开头。例如，在\ntasks.c 中定义 vTaskDelete，并且具有 void\n返回类型\n\n宏\n\n宏以定义宏的文件为前缀。前缀为小写。例如，在\nFreeRTOSConfig.h 中定义 configUSE_PREEMPTION\n除前缀外，所有宏均使用大写字母书写，并使用下划线来分隔单词\n\n任务 Task\n使用 RTOS\n的实时应用程序可以被构建为一组独立的任务。每个任务在自己的上下文中执行，不依赖于系统内的其它任务或\nRTOS 调度器本身。在任何时间点，应用程序中只能执行一个任务，实时 RTOS\n调度器负责决定所要执行的任务。因此，RTOS\n调度器可以在应用程序执行时重复启停每个任务（将任务调入或调出）。由于任务不了解\nRTOS 调度器活动，因此实时 RTOS\n调度器负责确保任务调入时的处理器上下文（寄存器值、堆栈内容等）与任务调出时的处理器上下文完全相同。为实现这一点，每个任务都分配了自己的栈。\n任务的状态\n任务可以运行在以下 4 种状态之一：\n\n运行状态\n当任务被执行时，它将处于运行状态。任务将占用处理器。如何处理器只有一个内核，那么同一时间只能有一个任务被处理器执行，即只有一个任务能处于运行状态。\n就绪状态\n处于就绪状态的任务能够被处理器执行，它们没有处于阻塞或挂起状态，但是由于具有同等优先级或更高优先级的任务正在被执行，无法占用处理器，需要等待被执行。\n阻塞状态\n如果任务正在等待时间或外部事件，则该任务被认为处于阻塞状态。任务可以被延时函数阻塞，抑或是等待队列、信号量、事件组或通知等。处于阻塞状态的任务通常有一个“超时”期，超时后任务将被解除阻塞，即使该任务所等待的事件没有发生。\n阻塞状态下的任务不使用任何处理时间，不能进入运行状态\n挂起状态\n处于挂起状态的任务不能被选择进入运行状态，但是挂起状态不存在超时。任务只能被别通过\nvTaskSuspend() 和 vTaskResume() API\n调用时，才会进入或退出挂起状态。\n\n\n任务优先级\n每个任务都具有一个优先级，优先级的大小在 0 到\n(configMAX_PRIORITIES -1)\n之间，configMAX_PRRIORITIES 在\nFreeRTOSConfig.h 文件中被定义。\n如果正在使用的端口实现了端口优化的任务选择机制，该机制使用“前导零计数”类指令（用于单个指令中的任务选择）且在\nFreeRTOSConfig.h 中将\nconfigUSE_PORT_OPTIMISED_TASK_SELECTION 设置为 1， 则\nconfigMAX_PRIORITIES 不得大于\n32。在所有其它情况下，configMAX_PRIORITIES\n可以设置任何合理范围内的值，但是考虑到 RAM\n使用效率，应保持在实际需求的最小值。\n低优先级数字表示低优先任务。空闲任务的优先级为零(tskIDLE_PRIORIEY)。\nFreeRTOS\n的调度器会确保处于运行状态的任务是当前可运行任务中最高优先级的。\n任意数量的任务可使用相同的优先级。如果\nconfigUSE_TIME_SLICING 未定义，或者\nconfigUSE_TIME_SLICING 设置为\n1，则相同优先级的就绪状态任务将使用时间片轮询调度方案共享可用的处理时间。\n任务调度\n默认的 RTOS 调度策略（单核）\nFreeRTOS\n默认使用固定优先级的抢占式调度策略，对同等优先级的任务执行时间片轮询调度：\n\n“固定优先级”\n是指调度器不会永久更改任务优先级，尽管它可能会有因为优先级继承而暂时提高任务的优先级。\n“抢占式调度” 是指调度器始终运行优先级最高且可运行的 RTOS\n任务，无论任务何时能够运行。例如，如果中断服务程序 (ISR)\n更改了优先级最高且可运行的任务，调度器会停止当前正在运行的低优先级任务，并启动高优先级任务——即使这发生在同一个时间片内。此时，称为高优先级任务“抢占”了低优先级的任务。\n“轮询调度” 是指具有相同优先级的任务轮流进入运行状态。\n“时间片” 是指调度器会在每个 tick\n中断上在同等优先级的任务之间进行切换，tick\n中断之间的时间构成一个时间片。tick 中断是 RTOS\n用来衡量时间的周期性中断。\n\n使用优先排序的抢占式调度器，避免任务饥饿\n如果总是运行优先级最高的任务，可能会造成这样的后果，永远不会进入“阻塞”或“挂起”状态的高优先级任务让所有任意执行时长的低优先级任务永久饥饿。这就是为什么通常最好创建事件驱动型任务的原因之一。例如，如果一个高优先级的正在等待一个事件，那么它就不应该处于事件的循环（轮询）中，因为如果处于轮询中，它会一直运行，永远不进入“阻塞”或“挂起”状态。反之，该任务应进入“阻塞”状态来等大事件。可以使用众多的\nFreeRTOS\n任务间通信将事件发送给任务。接收到事件后，优先级更高的任务会自动解除“阻塞”状态。高优先级任务处于“阻塞”状态时，低优先级任务会运行。\n配置 RTOS 调度策略\n以下 FreeRTOSConfig.h 配置更改默认的调度行为：\n\nconfigUSE_PREEMPTION\n如果 configUSE_PREEMPTION 设置为\n0，则关闭“抢占”，只有当运行状态的任务进入“阻塞”或“挂起”状态，或运行状态任务调用\ntaskYIELD()，或中断服务程序(ISR)手动请求上下文切换时，才会发生上下文切换。\nconfigUSE_TIME_SLICING 设置为\n0，则表示时间片已关闭。因此调度器不会在每个 tick\n中断上在同等优先级的任务之间切换。\n\nFreeRTOS AMP 调度策略\n使用 FreeRTOS 的非对称多处理(AMP)\n是指多核设备的每个核心都单独运行自己的 FreeRTOS\n实例。这些核心并不都需要具有相同的架构，但如果 FreeRTOS\n实例之间需要进行通信，则需要共享一些内存。\n每个核心都会运行自己的 FreeRTOS\n实例，因此任何给定核心上的调度算法与单核系统调度算法完全相同。可以使用流缓冲区或消息缓冲区作为核间通信原语。\nFreeRTOS SMP 调度策略\n使用 FreeRTOS 的对称多处理(SMP) 是指一个 FreeRTOS\n实例可以跨多个处理器核心调度 RTOS 任务。由于只有一个FreeRTOS\n实例在运行，一次只能使用 FreeRTOS\n的一个端口，因此每个核心必须具有相同的处理器架构并共用相同的内存空间。\nFreeRTOS SMP 调度策略使用与单核调度策略相同的算法，但与单核和 AMP\n场景不同的是，SMP\n在任何给定时间都会导致多个任务处于运行状态（每个核心上都有一个运行状态的任务）这意味着，只有缺乏可运行的高优先级任务时，才会运行低优先级任务的假设不再成立。\n配置 SMP RTSO 调度策略\n以下配置选项有助于移动下述代码：将为单核或 AMP RTOS\n配置编写的代码移动到 SMP RTOS\n配置中，且这些代码依赖于该假设——如果有一个运行的高优先级任务，那么低优先级任务不会运行：\n\nconfigRUN_MULTIPLE_PRIORITIES\n如果将 configRUN_MULTIPLE_PRIORITIES 设置为\n0，则调度器只会同时运行具有相同优先级的多个任务。这可能会修复基于”一次只运行一个任务“这一假设编写的代码，但这就享受到\nSMP 配置带来的一些好处。\nconfigUSE_CORE_AFFINITY\n\n如果将 configUSE_CORE_AFFINITY 设置为 1， 则\nvTaskCoreAffinitySet() API\n函数可用于定义某个任务可以在哪些核心上运行以及不可以在那个核心上运行。\n任务的实现\n任务是以 C 函数来实现的。它们唯一的特殊之处在于它们的原型，必须返回\nvoid 并接受一个 void\n指针参数。函数原型如下：\nvoid ATaskFunction(void *pvParameters);\n每个任务本身就是一个小程序。通常会处于一个无限循环中永远运行，且不会退出。任务函数不允许实现返回，即不允许包含\nreturn 语句。如果想要删除掉任务，需要使用\nvTaskDelete( NULL );\n函数。同一个函数可以创建多个任务，每个任务都是独立运行的实例，具有自己的栈和任务本身定义的任何自动变量的副本。\n创建任务\nFreeRTOS 使用 xTaskCreate() API 函数创建任务。\nBaseType_t xTaskCreate(TaskFunction_t pvTaskCode,\n                       const char* const pcName,\n                       uint16_t usStackDepth,\n                       void *pvParameters,\n                       UBaseType_t uxPriority,\n                       TaskHandle_t *pxCreatedTask)\n\n\n\n\n\n\n\nParamter Name\nDescription\n\n\n\n\npvTaskCode\npvTaskCode\n参数只是一个指针，指向实现任务的函数（就是函数名）\n\n\npcName\n任务的描述性名称。FreeRTOS\n不会使用它，仅仅是调试时的辅助工具，有利于辨识。configMAX_TASK_NAME_LEN\n定义名称的最大长度，包括 NULL 终止符，超出的名称将会被截断。\n\n\nusStackDepth\n指定任务栈的深度，即栈可容纳的字数(word)，不是字节(byte)。如果栈的宽度是\n32-bit，深度是 100，那么栈空间就是 100 * 4 bytes。栈空间不能超过\nuint16_t 类型的最大值。分配的栈大小只能通过大致估算得到。\n\n\npvParameters\n任务函数接受指向 void (void *)\n的指针类型的形参。分配给 pvParameters 的值将传递给任务函数。\n\n\nuxPriority\n定义任务的优先级。优先级可以从 0\n(最低优先级) 分配到 configMAX_PRIORITIES -\n1(最高优先级)。\n\n\npxCreatedTask\n向正在创建的任务传递句柄。这个句柄用于在\nAPI 调用中引用任务。\n\n\n返回值\n成功：pdPASS；失败：errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY(失败原因只有内存不足)\n\n\n\nExample 1 创建两个任务\n任务一：\nvoid task1_task(void *pvParameters){\n    UBaseTpye_t msticks = 0;\n    msticks = pdMS_TO_TICKS(500);\n    while(1){\n        printf(\"task1 entry\\r\\n\");\n        GPIO_SetBits(GPIOA, GPIO_Pin_0);\n        vTaskDelay(msticks);\n        GPIO_ResetBits(GPIOA, GPIO_Pin_0);\n        vTaskDelay(msticks);\n    }\n}\n任务二：\nvoid task2_task(void *pvParameters){\n    UBaseType_t msticks = 0;\n    msticks = pdMS_TO_TICKS(1000);\n    while(1){\n        printf(\"task2 entry\\r\\n\");\n        GPIO_ResetBits(GPIOA, GPIO_Pin_1);\n        vTaskDelay(msticks);\n        GPIO_SetBits(GPIOA, GPIO_Pin_1);\n        vTaskDelay(msticks);\n    }\n}\n创建任务：\n#define TASK1_TASK_PRIO     5\n#define TASK1_STK_SIZE      256\n#define TASK2_TASK_PRIO     5\n#define TASK2_STK_SIZE      256\n/* create two task */\nxTaskCreate((TaskFunction_t )task2_task,\n            (const char*    )\"task2\",\n            (uint16_t       )TASK2_STK_SIZE,\n            (void*          )NULL,\n            (UBaseType_t    )TASK2_TASK_PRIO,\n            (TaskHandle_t*  )&amp;Task2Task_Handler);\n\nxTaskCreate((TaskFunction_t )task1_task,\n            (const char*    )\"task1\",\n            (uint16_t       )TASK1_STK_SIZE,\n            (void*          )NULL,\n            (UBaseType_t    )TASK1_TASK_PRIO,\n            (TaskHandle_t*  )&amp;Task1Task_Handler);\n/* Start the scheduler so the tasks start executing. */\nvTaskStartScheduler();\n\n\n\n\n\n\n\n\n\n实验使用沁恒 CH32F203C8T6 开发板\n实验结果：\n\ntask1 和 task2 两个任务看似是在同时执行，但是 MCU\n只有一个处理核心，不可能同时执行两个任务。实际是，MCU\n快速交替执行这两个任务，由于这两个任务具有相同的优先级，所以它们在一个处理器核心上共享时间。\n\n在任务调度器启动前，从 main()\n函数中创建两个任务。还可以从一个任务中创建另一个任务。\nvoid vTask1(void *pvParameters){\n    const char *pcTaskName = \"Task 1 is running\\r\\n\";\n    volatile uint32_t ul; \n    xTaskCreate(vTask2, \"Task2\", 1000, NULL, 1, NULL);\n    for(;;){\n        vPrintString(pcTaskName);\n        for(ul = 0; ul &lt; mainDELAY_LOOP_COUNT; ul++){\n            \n        }\n    }\n}\nExample 2 使用任务参数\n使用同一函数创建不同任务，并在创建任务时传入不同的参数，以此区别两个独立的任务。\nvoid vTaskFunction(void *pvParameters){\n    const char *pcTaskText = pvParameters;\n    UBaseType_t msticks = 0;\n    msticks = pdMS_TO_TICKS(100);\n    while (1){\n        printf(pcTaskText);\n        vTaskDelay(msticks);\n    } \n}\npcTaskText 变量接受创建任务时传入的\npvParameters 参数，不同的任务可以有不同的\npvParameters。\nstatic const char *pcTextForTask1 = \"Task 1 \\r\\n\";\nstatic const char *pcTextForTask2 = \"Task 2 \\r\\n\";\n\n/* 创建两个任务 */\nxTaskCreate(vTaskFunction, \"Task 1\", TASK1_STK_SIZE, (void *)pcTextForTask1, TASK1_TASK_PRIO, &amp;Task1Task_Handler);\nxTaskCreate(vTaskFunction, \"Task 2\", TASK2_STK_SIZE, (void *)pcTextForTask2, TASK2_TASK_PRIO, &amp;Task2Task_Handler);\n实验结果：\n\n任务优先级\nuxPriority 参数是在 xTaskCreate() API\n函数创建任务时，为任务分配的初始优先级。在任务开始调度之后，可以使用\nvTaskPrioritySet() API 函数为任务更改优先级。\n最大的任务优先级由 FreeRTOSConfig.h 文件中的\nconfigMAX_PRIORITIES 常量配置。数字越高，则由优先级越高。0\n为最低优先级，configMAX_PRIORITIES - 1\n为最高优先级。同一优先级的任务数量不受限制。\nFreeRTOS\n调度器可以使用两种方法中的一种来决定哪个任务将处于运行状态。configMAX_PRIORITIES\n可以设置的最大值取决于所使用的方法：\n\nGeneric Method\n\n通用方法是用 C 语言实现的，可以在所有的 FreeRTOS 架构端口上使用。\n当使用通用方法时，configMAX_PRIORITIES\n可设置的最大值不受限制。但应当将其限制在必要情况的最小值，以节省片上资源。其值越高消耗的\nRAM 就越多。\n设置 Generic Method:\n\nconfigUSE_PORT_OPTIMISED_TASK_SELECTION 置 0\nconfigUSE_PORT_OPTIMISED_TASK_SELECTION 未定义\nGeneric 是为使用中的 FreeRTOS 端口提供的唯一方法。\n\n\nArchitecture Optimized Method\n\n架构优化方法使用的汇编代码较少，且速度比通用方法快。configMAX_PRIORITIES\n设置不影响最坏情况下的执行时间。如果使用了架构优化方法，则\nconfigMAX_PRIORITIES 不能大于\n32。同样，应该尽可能的小。\n设置 Architecture Optimized Method:\n\nconfigUSE_PORT_OPTIMISED_TASK_SELECTION 置 1\n\n\n\n\n\n\n\n\n\n\n并非所有的FreeRTOS端口都提供了架构优化的方法\nFreeRTOS\n调度器将始终确保能够运行的最高优先级任务是被选择进入运行状态的任务。当多个具有相同优先级的任务能够运行时，调度器将依次将每个任务转换为运行状态和退出运行状态。\nTick 中断\n调度算法使用“时间片”功能使得两个优先级相同任务能够连续运行。每个任务在自己的时间片中运行，一个时间片开始时，任务进入运行状态，一个时间片结束时，任务退出运行状态。\n为了能够选择下一个要运行的任务，调度器必须在每个时间片结束时执行。这个时间片就是一个周期性中断，称为\nTick 中断。时间片的长度是由 Tick 中断的频率决定的，该频率由\nconfigTICK_RATE_HZ 常量配置。\n\n\n\n\n\n\n\n\n\n如果将 configTICK_RATE_HZ 设置为 100\n(Hz)，那么时间片就是 10 ms。两次 Tick 中断之间的时间称为 “Tick\n周期”。一个时间片等于一个 Tick 周期。\nconfigTICK_RATE_HZ\n的最佳值取决于正在开发的应用程序，尽管典型值为100。\n\npdMS_TO_TICKS() 宏将以毫秒为单位指定的时间转换为以 ticks\n为单位指定的时间。可用的分辨率取决于定义的 tick 频率，如果 tick\n频率高于1KHz( configTICK_RATE_HZ 大于 1000)，则不能使用\npdMS_TO_TICKS()。\nTickType_t xTimeInTicks = pdMS_TO_TICKS(200);\n\n\n\n\n\n\n\n\n\n不建议在应用程序中直接指定以刻度为单位的时间，而是使用\npdMS_TO_TICKS()\n宏来指定以毫秒为单位的时间，这样做可以确保即使刻度频率发生变化，应用程序中指定的时间也不会改变。\ntick count 值是自调度器启动以来发生的 tick\n中断的总数，假设 tick\n计数没有溢出。用户应用程序在指定延迟时间时不必考虑溢出，因为时间一致性是由\nFreeRTOS 内部管理的。\nExample 3 任务优先级\n调度器将始终保证能够运行的最高优先级的任务是被选择进入运行状态的任务。以下将创建一个优先级为\n1 的任务和一个优先级为 2 的任务：\nxTaskCreate(vTaskFunction, \"Task 1\", 256, (void *)pcTextForTask1, 1, &amp;Task1Task_Handler);\nxTaskCreate(vTaskFunction, \"Task 2\", 256, (void *)pcTextForTask2, 2, &amp;Task2Task_Handler);\n实验结果：\n\n因为任务 2 的优先级比任务 1 的高，只要任务 2\n是可运行的状态，系统将一直运行任务 2。任务 1 将永远得不到运行，称任务 1\n处于 “饥饿” 状态。\n其它任务状态\n如果一个任务不需要等待任何事情的发生，总是能处于运行状态，那么这种类型的任务的用处是十分有限的。这种任务只能以最低的优先级运行，因为如果它们处于高优先级，那么低优先级的任务将得不到运行，始终处于\n“饥饿” 状态。\n任务如果想要有用，那么它们必须为事件所驱动。事件驱动的任务只有在触发它的事件发生之后才能被执行，且在事件发生之前不能处于\nrunning\n状态。调度器始终选择能够运行的最高优先级任务。高优先级任务无法运行意味着调度器无法选择它们，而必须选择能够运行的低优先级任务。因此，使用事件驱动任务意味着可以在不同的优先级下创建任务，而不会使优先级最高的任务耗尽所有优先级较低的处理时间任务。\n阻塞状态 (The Blocked State)\n等待事件的任务被称为 “阻塞” 状态，这是 Not Running\n状态的一个子状态。\n任务等待事件的种类：\n\n事件(与时间相关)的时间 ——\n这个时间可以是一段延时，或某个绝对时间。例如延时 10 ms。\n同步事件 —— 事件源于另一个任务或中断。\n\n\n\n\n\n\n\n\n\n\nFreeRTOS 的队列(queues)、二进制信号量(binary\nsemaphores)、计数信号量(counting\nsemaphores)、互斥锁(mutexes)、递归互斥锁(recursive\nmutexes)、事件组(event groups)和任务通知(task\nnotifications)都可以用来创建同步事件。\n任务阻塞可以设置超时时间，如果在规定时间内事件已发生，或超过规定时间未发生，任务将离开阻塞状态。\n挂起状态(The Suspended State)\n挂起是 Not Running\n的一个子状态。处于挂起状态的任务无法被调度器调度。进入挂起状态的唯一方法是调用\nvTaskSuspend() API 函数。调用 xTaskResume() 或\nvTaskResumeFromISR() API\n函数将恢复任务调度。大多数应用不使用挂起状态。\n就绪状态(The Ready State)\n处于 Not Running\n状态但未被阻塞或挂起的任务称为处于“就绪”状态。它们能够运行，因此“准备好”运行，但当前不处于运行状态。\nExample 4\n使用阻塞状态创建延时\n任何形式的轮询最重要的是效率低下。在轮询期间，任务实际上没有任何工作要做，但它仍然使用最大的处理时间，因此浪费了处理器周期。调用\nvTaskDelay() API 函数来是任务进入阻塞状态，\n避免轮询空循环，大大提升了处理器的效率。注意，只有当\nINCLUDE_vTaskDelay 设置为 1 时，vTaskDelay()\nAPI 函数才可用。\nvTaskDelay() 将调用任务置于阻塞状态，用于固定数量的 tick\n中断。任务在处于阻塞状态时不使用任何处理时间，因此任务仅在有实际工作要完成时使用处理时间。\nvoid vTaskDelay( TickType_t xTicksToDelay );\n\n\n\nParamter Name\nDescription\n\n\n\n\nxTicksToDelay\n任务保持阻塞状态所持续的 tick 中断数。\n\n\n\nvoid vTaskFunction(void *pvParameters){\n    const char *pcTaskText = pvParameters;\n    TickType_t msticks = 0;\n    msticks = pdMS_TO_TICKS(500);\n    while (1){\n        printf(pcTaskText);\n        /* 延时 500 ms */\n        vTaskDelay(msticks);\n    } \n}\n实验结果：\n\n因为 vTaskDelay() 函数阻塞了任务 2，使得较低优先级的任务\n1 能够被运行。\nvTaskDelayUntil() API\n函数\nvTaskDelay() 阻塞的时常是一个相对的时间，从调用\nvTaskDelay() 函数开始进入阻塞状态，阻塞的时长为\nxTicksToDelay 参数所指定的 tick\n中断数。但是，vTaskDelayUntil()\n函数的参数指定任务从阻塞到就绪状态确切的 tick 计数值(tick count\nvalue)。当任务需要按照固定周期执行时，需要调用\nvTaskDelayUntil() API\n函数，因为任务解除阻塞状态的时间是绝对的，而不是相对于函数被调用的时间。\nvoid vTaskDelayUntil( TickType_t * pxPreviousWakeTime, TickType_t xTimeIncrement );\n\n\n\n\n\n\n\nParameter Name\nDescription\n\n\n\n\npxPreviousWakeTime\n保存任务最后离开阻塞状态的时间，此时间作为参考点，以计算下次离开阻塞状态的时间。它将在\nAPI 函数中自动更新，但必须在第一次使用它之前将其初始化为当前的 tick\n计数。\n\n\nxTimeIncrement\n任务固定执行的频率，也就是阻塞的时间长度。可用\npdMS_TO_TICKS() 宏将毫秒转称 tick 数值。\n\n\n\nExample 5 使用\nvTaskDelayUntil() 阻塞\n创建两个任务 task1_task 和 task2_task，任务 1 的优先级为 2， 任务 2\n的优先级为 1。PA0 端口为 1 时， 表示任务 1 正在执行，为 0 时，表示任务 2\n正在执行。分别用 vTaskDelay() 和\nvTaskDelayUntil() 对任务 1 进行阻塞。\n/* 任务 1 */\nvoid task1_task(void *pvParameters)\n{\n\tTickType_t xLastWakeTime;\n    int i;\n    /*初始的 Tick Count*/\n    xLastWakeTime = xTaskGetTickCount();\n    while(1)\n    {\n        GPIO_SetBits(GPIOA, GPIO_Pin_0);\n        for(i = 0; i &lt; 5; i++){\n            printf(\"Task1 is runnig\\r\\n\");\n        }\n\n#if 1\n        vTaskDelay(pdMS_TO_TICKS(50));\n#else \n        vTaskDelayUntil(&amp;xLastWakeTime, pdMS_TO_TICKS(50));\n#endif\n    }\n}\n/* 任务 2 */\nvoid task2_task(void *pvParameters)\n{\t\n    while(1)\n    {\n        GPIO_ResetBits(GPIOA, GPIO_Pin_0);\n        printf(\"Task 2 is running\\r\\n\");\n    }\n}\n/* 主函数 */\nint main(void)\n{\n    USART_Printf_Init(115200);\n    printf(\"SystemClk:%d\\r\\n\",SystemCoreClock);\n    printf(\"FreeRTOS Kernel Version:%s\\r\\n\",tskKERNEL_VERSION_NUMBER);\n    GPIO_Toggle_INIT();\n    xTaskCreate(task1_task, \"Task 1\", 256, NULL, 2, &amp;Task1Task_Handler);\n    xTaskCreate(task2_task, \"Task 2\", 256, NULL, 1, &amp;Task2Task_Handler);\n    vTaskStartScheduler();\n    while(1)\n    {\n        printf(\"shouldn't run at here!!\\n\");\n    }\n}\n逻辑分析仪分析 PA0 端口电平变换：\n\n\n空闲任务及其钩子函数\n空闲任务\n当创建的任务均处于阻塞状态，但是必须始终至少有一个任务可以进入\nRunning 状态。为了确保这一点，调度程序在调用\nvTaskaStartScheduler() 时，会自动创建一个 Idle\n任务。空闲任务只在循环中执行很少的操作，因此它并不妨碍其它任务的执行。\n空闲任务具有尽可能低的优先级(0\n优先级)，以确保它永远不会阻止更高优先级的任务进入运行状态。如果一定要创建与空闲任务同优先级的任务，可以通过配置\nconfigIDLE_SHOULD_YILED\n来防止空闲任务占用过多的处理时间。\n\n\n\n\n\n\n\n\n\n如果程序使用 vTaskDelete() API 函数，那么必须确保 Idle\n任务有机会得到运行。因为 Idle 任务负责在任务被删除之后清理内核资源。\n空闲任务的钩子函数\n可以通过使用空闲钩子(或空闲回调)函数将特定于应用程序的功能直接添加到空闲任务中，该函数在空闲任务循环的每次迭代中由空闲任务自动调用一次。\n空闲任务钩子函数的用法：\n\n执行低优先级、后台或连续处理功能\n测量空闲处理的时间。(空闲任务只有在所有高优先级应用程序任务没有工作可执行时才会运行;因此，测量分配给空闲任务的处理时间可以清楚地表明有多少处理时间是空闲的。)\n将处理器置于低功耗模式，当没有应用程序处理要执行时，提供一种简单而自动的省电方法\n\n对空闲任务钩子函数实现的限制：\n\n空闲任务钩子函数绝不能试图阻塞或挂起。\n如果应用程序使用 vTaskDelete()\nAPI函数，那么空闲任务钩子必须要在合理的时间段内返回到其调用者。这是因为\nIdle 任务负责在任务被删除后清理内核资源。如果空闲任务永久地保留在 Idle\n钩子函数中，则不能进行清理。\n\n空闲任务钩子函数必须具有以下的函数名和原型：\nvoid vApplicationIdleHook( void );\nExample 6\n创建空闲任务钩子函数\nvolatile uint32_t ulIdleCycleCount = 0UL;\n/* 创建钩子函数 */\nvoid vApplicationIdleHook(void){\n    ulIdleCycleCount++ ;\n}\n在 FreeRTOSConfig.h 中，将 configUSE_IDLE_HOOK 设置为\n1，空闲钩子函数才会被调用。\nvoid vTaskFunction(void *pvParameters){\n    const char *pcTaskText = pvParameters;\n    while (1)\n    {\n        printf(pcTaskText);\n        printf(\"Idle Cycle Count = %d\", ulIdleCycleCount);\n        vTaskDelay(pdMS_TO_TICKS(1000));   \n    }  \n}\n更改任务优先级\nvTaskPrioritySet() API\n函数\nvTaskPrioritySet() API\n函数用于在调度器启动后更改任何任务的优先级。\n\n\n\n\n\n\n\n\n\n需要将 NCLUDE_vTaskPrioritySet 设置为 1\nvoid vTaskPrioritySet( TaskHandle_t pxTask, UBaseType_t uxNewPriority );\n\n\n\n\n\n\n\nParameter Name\nDescription\n\n\n\n\npxTask\n任务句柄任务可以通过传递 NULL\n代替有效的任务句柄来改变自己的优先级。\n\n\nuxNewPriority\n要设置的新的优先级\n\n\n\nxTaskPriorityGet() API\n函数\nuxTaskPriorityGet() API\n函数可以用来查询任务的优先级。\n\n\n\n\n\n\n\n\n\n需要将 INCLUDE_uxTaskPriorityGet 设置为 1\nUBaseType_t uxTaskPriorityGet( TaskHandle_t pxTask );\n\n\n\n\n\n\n\nParameter Name\nDescription\n\n\n\n\npxTask\n任务句柄任务可以通过传递 NULL\n代替有效的任务句柄来查询自己的优先级。\n\n\nReturned value\n查询任务的优先级\n\n\n\nExample 7 改变任务优先级\n以不同的优先级创建两个任务，两个都不会进入阻塞状态。优先级相对较高的任务将被点调度器选择运行。\n\n任务 1\n以最高优先级创建，因此将会首先运行。先打印出两个字符串，在将任务 2\n的优先级提高到高于自己的优先级。\n在任务 2 中打印一条信息，再将自己的优先级设置到低于任务 1\n的优先级。\n\n任务 1：\nvoid vTask1(void *pvParameters){\n    UBaseType_t uxPriority;\n    uxPriority = uxTaskPriorityGet(NULL);\n    while (1)\n    {\n        printf(\"Task 1 is running\\r\\n\");\n        printf(\"About to raise the Task 2 priority\\r\\n\");\n        vTaskPrioritySet(xTask2Handle, (uxPriority + 1));\n    }   \n}\n任务 2：\nvoid vTask2(void *pvParameters){\n    UBaseType_t uxPriority;\n    uxPriority = uxTaskPriorityGet(NULL);\n\n    while (1)\n    {\n        printf(\"Task 2 is running\\r\\n\");\n        printf(\"About to lower the Task 2 priority\\r\\n\");\n        vTaskPrioritySet(NULL, (uxPriority - 2));\n    }  \n}\n创建任务：\nxTaskCreate(vTask1, \"Task 1\", 256, NULL, 2, &amp;xTask1Handle);\nxTaskCreate(vTask2, \"Task 2\", 256, NULL, 1, &amp;xTask2Handle);\nvTaskStartScheduler();\n实验结果：\n\n删除任务\nvTaskDelete() API 函数\n任务可以使用 vTaskDelete() API\n函数来删除自己或任何其他任务。\n\n\n\n\n\n\n\n\n\n需要将 INCLUDE_vTaskDelete 设置为 1\n删除的任务不再存在，不能再进入“运行”状态。空闲任务负责释放分配给已删除的任务的内存。因此，重要的是，使用\nvTaskDelete() API\n函数的应用程序不要完全耗尽空闲任务的所有处理时间。\n\n\n\n\n\n\n\n\n\n当任务被删除时，只有内核自己分配给任务的内存才会被自动释放。任务实现分配的任何内存或其他资源必须显式释放。\nvoid vTaskDelete( TaskHandle_t pxTaskToDelete );\n\n\n\n\n\n\n\nParameter Name\nDescription\n\n\n\n\npxTaskToDelete\n待删除任务的句柄任务可以通过传递NULL来代替有效的任务句柄来删除自己\n\n\n\nExample 8 删除任务\n任务 1：\nTaskHandle_t xTask2Handle = NULL;\nvoid vTask1(void *pvParameters){\n    const TickType_t xDelay100ms = pdMS_TO_TICKS(100UL);\n    while(1){\n        printf(\"Task 1 is running\\r\\n\");\n        /* 创建任务 2 */\n        xTaskCreate(vTask2, \"Task 2\", 1000, NULL, 2 &amp;xTask2Handle);\n        /* 进入阻塞状态，使得 Idle 任务可以运行 */\n        vTaskDelay(xDelay100ms);\n    }\n}\n任务 2：\nvoid vTask2(void *pvParameters){\n    printf(\"Task 2 is running and about to delete itself\\r\\n\");\n    /* 删除自身，传入 NULL 也可 */\n    vTaskDelete(xTask2Handle);\n}\n主函数：\nint main(void){\n    xTaskCreate(vTask1, \"Task 1\", 1000, NULL, 1, NULL);\n    vTaskStartScheduler();\n    while(1);\n}\n调度算法\n配置调度算法\n调度算法决定就绪状态中的哪个任务进入运行状态。可以使用\nconfigUSE_PREEMPTION 和configUSE_TIME_SLICING\n配置常量更改算法。第三个配置常量 configUSE_TICKLESS_IDLE\n也会影响调度算法，使用它可能导致在较长时间内完全关闭 Tick 中断。\n在所有可能的配置中，FreeRTOS\n调度器将确保共享优先级的任务依次被选择进入运行状态，即轮询调度。轮循调度算法不能保证同等优先级的任务之间的时间分配均等，只能保证同等优先级的任务依次进入运行状态。\n带时间片的固定优先级抢占调度\n\n\n\nConstant\nValue\n\n\n\n\nconfigUSE_PREEMPTION\n1\n\n\nconfigUSE_TIME_SLICING\n1\n\n\n\n以上配置称为“固定优先级抢占式时间片调度”的调度算法，这是大多数小型\nRTOS 应用程序使用的调度算法。\n调度策略的术语的解释：\n\n\n\n\n\n\n\nTerm\nDefinition\n\n\n\n\nFixed Priority\n被称为 “固定优先级”\n的调度算法不会改变分配给被调度任务的优先级，但也不会阻止任务本身改变自己或其他任务的优先级。\n\n\nPre-emptive\n抢占调度算法会在优先级高于“运行”的任务进入“就绪”状态时，立即对“运行”任务进行“抢占”。\n\n\nTime Slicing\n时间片用于在具有相同优先级的任务之间共享处理时间，即使任务没有显式地放弃或进入阻塞状态。如果有与运行任务相同优先级的任务处于就绪状态，“时间片”调度算法将在每个时间片结束时选择一个新任务进入运行状态。一个时间片等于两个\nRTOS Tick中断之间的时间。\n\n\n\n不带时间片的固定优先级抢占调度\n不使用时间片的优先级抢占调度与之前的任务选择和抢占算法相同，但不使用时间片在相同优先级的任务之间共享处理时间。\n\n\n\nConstant\nValue\n\n\n\n\nconfigUSE_PREEMPTION\n1\n\n\nconfigUSE_TIME_SLICING\n0\n\n\n\n如果不使用时间片，则调度器只会在以下情况下选择一个新任务进入运行状态：\n\n高优先级的任务进入就绪状态。\n处于 “运行” 状态的任务进入 “阻塞” 或 “挂起” 状态。\n\n不使用时间片时，任务上下文切换比使用时间片时要少。因此，关闭时间片可以减少调度器的处理开销。然而，关闭时间片也会导致同等优先级的任务接收到的处理时间差异很大，由于这个原因，不使用时间切片运行调度器被认为是一种高级技术，只应该由有经验的用户使用。\n合作调度\n\n\n\nConstant\nValue\n\n\n\n\nconfigUSE_PREEMPTION\n0\n\n\nconfigUSE_TIME_SLICING\nAny value\n\n\n\n当使用合作调度时，只有当运行状态任务进入阻塞状态，或者运行状态任务通过调用\ntaskYIELD()\n(手动请求重新调度)时，才会发生上下文切换。任务永远不会被抢占，所以不能使用时间片。\n","slug":"FreeRTOS/Task","date":"2023-04-23T09:13:00.000Z","categories_index":"嵌入式","tags_index":"FreeRTOS","author_index":"爱慢跑的乌龟"},{"id":"0d8865dd6f5b4fb80b5a9df16b916aeb","title":"链表 linked list","content":"链表 linked list\n什么是链表\n链表是数据元素的线性集合，其顺序不是由它们在内存中的物理位置给出的。每个元素都指向下一个元素。它是一种数据结构，由一组节点组成，这些节点共同表示一个序列。在其最基本的形式中，每个节点都包含：数据和指向序列中下一个节点的指针（链接）。这种结构允许在迭代期间从序列中的任何位置有效地插入或删除元素。链表的一个缺点是访问时间是线性的(difficult\nto\npipeline)。更快的访问（例如随机访问）是不行的。与链表相比，数组具有更好的缓存局部性(cache\nlocality)。\n链表是最简单和最常见的数据结构之一。它们可用于实现其它几种常见的抽象数据类型，包括列表、栈(Stack)、队列、关联数组和\nS 表达式，尽管直接实现这些数据结构而不使用链表作为基础并不罕见。\n链表相对于传统数组的主要优点是，可以轻松插入或删除列表中的元素，而无需重新分配或重组整个结构，因为数据项不需要连续存储在内存或磁盘上，而在运行时重组数组是一项成本更高的操作。链表允许在列表中的任意位置\n插入和删除节点，并且允许在列表遍历期间将链接保留在内存中添加或删除的链接之前，以恒定数量的操作来执行次操作。\n但是，由于简单链表本身不允许随机访问数据或任何形式的有效索引，因此许多基本操作（例如获取列表的最后一个节点、查找包含给定基准的节点或定位应插入新节点的位置）可能需要遍历大部分或全部列表元素。\n\n\n\n\n\n\n\n\n\n\n链表的每条记录通常称为“元素”(element)\n或节点(node)。包含下一个节点地址的字段通常称为“下一个链接”或“下一个指针”。其余称为“数据”。\n为什么要使用链表？\n数组(Arrays)可以用来存储相似类型的线性数据，但数组有以下的限制：\n\n数组的大小是固定的：因此使用数组时必须先预设元素数量的上限。此外，通常情况下，无论是否使用，都需要分配数组上限大小的内存。\n插入一个元素或删除一个数组中的已有元素花费很大：必须为新元素创建空间，为了创建这个空间，现有的数组元素必须移动。\n\nExample：\n在一个系统中，如果我们在一个数组\nid[] = [1000, 1010, 1050, 2000, 2040] 中维护一个有序的 ID\n列表。此时，想要插入一个新的 ID\n1005，那么为了维持排序的顺序，我们必须移动 1000 之后的所有元素。\n链表相对于数组的优点\n\n动态数组\n易于插入和删除\n在开头插入一个元素是一个常数时间操作，需要 O(1)\n时间，而在数组的开头插入一个元素需要 O(n) 时间，其中 n\n是数组中元素的数量。\n\n链表的缺点\n\n不能随机访问。必须从第一个节点开始按顺序访问节点。因此，不能用它的默认实现对链表进行有效的二分搜索。\n对于列表中的每个元素，指针都需要额外的内存空间。\n不是缓存友好(cache-friendly)。由于数组元素是连续位置，因此存在引用的局部性，这在链表中是不存在的。\n遍历和更改指针需要花费大量的时间。\n反向遍历单链表是不可能的。\n链表不可能像在数组中那样通过索引直接访问元素。\n所搜一个元素的代价很高，需要 O(n) 时间复杂度。\n链表的排序是十分复杂的，同时花费巨大。\n\n链表的种类\n\n简单链表 (Simple Linked List) -\n只能在一个方向上移动或遍历链表。每个节点的 next\n指针指向其它节点，最后一个节点的 next 指针指向\nNULL。它也被称为“单链表”。\n双链表 (Doubly Linked List) -\n在这种类型的链表中看，可以在两个方向（向前和向后）移动或遍历链表。\n循环链表 (Circular Linked List) - 链表的最后一个节点的\nnext 指针指向第一个节点。\n双向循环链表 (Doubly Circular Linked List) -\n这是一种更复杂的链表类型，它包含指向列表中下一个节点和上一个节点的指针。双链表和循环双向链表的区别，与单链表和循环链表的区别一样的。循环双向链表在第一个节点的前一个字段中不包含\nNULL。\nHeader Linked List - 它在列表的开头包含一个标题节点。\n\n链表的基本操作\n\nDeletion\nInsertion\nSearch\nDisplay\n\n单链表的简单实现\nC\n&#x2F;&#x2F; A linked list node\nstruct Node&#123;\n    int data;\n    struct Node* next;\n&#125;\nC++\nclass Node&#123;\npublic:\n    int data;\n    Node* next;\n&#125;\nPython\n# Node class\nclass Node:\n    # Function to initialize the node object\n    def __init__(self, data):\n        self.data &#x3D; data\t# Assign data\n        self.next &#x3D; Node\n遍历链表\nC\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nstruct Node&#123;\n    int data;\n    struct Node* next;\n&#125;;\n\nvoid printList(struct Node* n)&#123;\n    while(n !&#x3D; NULL)&#123;\n        printf(&quot;%d&quot;, n-&gt;data);\n        n &#x3D; n-&gt;next;\n    &#125;\n&#125;\n\nint main()&#123;\n    struct Node* head &#x3D; NULL;\n    struct Node* second &#x3D; NULL;\n    struct Node* third &#x3D; NULL;\n    \n    &#x2F;&#x2F; allocate 3 nodes in the heap\n    head &#x3D; (struct Node*)malloc(sizeof(struct Node));\n    second &#x3D; (struct Node*)malloc(sizeof(struct Node));\n    third &#x3D; (struct Node*)malloc(sizeof(struct Node));\n    \n    head-&gt;data &#x3D; 1;\n    head-&gt;next &#x3D; second;\n    \n    seconde-&gt;data &#x3D; 2;\n    seconde-&gt;next &#x3D; third;\n    \n    third-&gt;data &#x3D; 3;\n    third-&gt;next &#x3D; NULL;\n    \n    prinfList(head);\n    \n    return 0;\n&#125;\nC++\nusing namespace std;\n\nclass Node&#123;\npublic:\n    int data;\n    Node* next;\n&#125;;\n\nvoid printList(Node* n)&#123;\n    while(n !&#x3D; NULL)&#123;\n        cout &lt;&lt; n-&gt;data &lt;&lt; &quot; &quot;;\n        n &#x3D; n-&gt;next;\n    &#125;\n&#125;\n\nint main()&#123;\n    Node* head &#x3D; NULL;\n    Node* second &#x3D; NULL;\n    Node* third &#x3D; NULL;\n    \n    &#x2F;&#x2F; allocate 3 nodes in the heap\n    head &#x3D; new Node();\n    second &#x3D; new Node();\n    third &#x3D; new Node();\n    \n    head-&gt;data &#x3D; 1;\n    head-&gt;next &#x3D; second;\n    \n    second-&gt;data &#x3D; 2;\n    second-&gt;next &#x3D; third;\n    \n    third-&gt;data &#x3D; 3;\n    third-&gt;next &#x3D; NULL;\n    \n    printList(head);\n    \n    return 0;\n&#125;\nPython\nclass Node:\n    def __init__(self, data):\n        self.data &#x3D; data\n        self.next &#x3D; None\n        \nclass LinkedList:\n    def __init__(self):\n        self.head &#x3D; None\n       \n    def printList(self):\n        temp &#x3D; self.head\n        while(temp):\n            print(temp.data)\n            temp &#x3D; temp.next\n            \nif __name__ &#x3D;&#x3D; &quot;__main__&quot;:\n    llist &#x3D; LinkedList()\n    \n    llist.head &#x3D; Node(1)\n    second &#x3D; Node(2)\n    third &#x3D; Node(3)\n    \n    llist.head.next &#x3D; second\n    second.next &#x3D; third\n    \n    llist.printList()\n链表的应用\n\n链表可以用来实现其它的数据结构，如堆栈和队列\n链表可以用来实现哈希表\n链表可以用来实现图\n\n链表的操作：Traverse,\nInsert and Delete\n\nTraversal - 访问链表的每一个元素\nInsertion - 添加一个新的元素到链表中\nDeletion - 删除一个已有元素\nSearch - 在链表中找到一个节点\nSort - 对链表的节点进行排序\n\n遍历一个链表\nstruct node *temp &#x3D; head;\nprintf(&quot;\\n\\nList elements are - \\n&quot;);\nwhile(temp !&#x3D; NULL)&#123;\n    printf(&quot;%d ---&gt;&quot;, temp-&gt;data);\n    temp &#x3D; temp-&gt;next;\n&#125;\n插入一个元素到链表中\n\n在开头插入\n\n\n为新节点分配内存\n存入数据\n新节点的 next 指向 head\n更改 head 指向最新创建的节点\n\nstruct node *newNode;\nnewNode &#x3D; malloc(sizeof(struct node));\nnewNode-&gt;data &#x3D; 4;\nnewNode-&gt;next &#x3D; head;\nhead &#x3D; newNode;\n\n在末尾插入\n\n\n为新节点分配内存\n存入数据\n遍历到最后一个节点\n更改最后一个节点的 next 指向最新的节点\n\nstruct node *newNode;\nnewNode &#x3D; malloc(sizeof(struct node));\nnewNode-&gt;data &#x3D; 4;\nnewNode-&gt;next &#x3D; NULL;\n\nstruct node *temp &#x3D; head;\nwhile(temp-&gt;next !&#x3D; NULL)&#123;\n    temp &#x3D; temp-&gt;next;\n&#125;\ntemp-&gt;next &#x3D; newNode\n\n在中间插入\n\n\n为新节点分配内存\n存入数据\n遍历到新节点存入位置之前的节点\n更改 next 指针\n\nstruct node *newNode;\nnewNode &#x3D; malloc(sizeof(struct node));\nnewNode-&gt;data &#x3D; 4;\n\nstruct node *temp &#x3D; head;\nfor(int i &#x3D; 2; i &lt; position; i++)&#123;\n    if(temp-&gt;next !&#x3D; NULL)&#123;\n        temp &#x3D; temp-&gt;next;\n    &#125;\n&#125;\nnewNode-&gt;next &#x3D; temp-&gt;next;\ntemp-&gt;next &#x3D; newNode;\n从链表中删除一个节点\n\n删除头节点\n\n\n将 head 指向第二个节点\n\nhead &#x3D; head-&gt;next;\n\n删除末尾的节点\n\n\n遍历到倒数第二个元素\n将它的 next 指针指向 NULL\n\nstruct node* temp &#x3D; head;\nwhile(temp-&gt;next-&gt;next !&#x3D; NULL)&#123;\n    temp &#x3D; temp-&gt;next;\n&#125;\ntemp-&gt;next &#x3D; NULL;\n\n删除中间的节点\n\n\n遍历到要删除节点之前的节点\n更改其 next 指针， 将要删除的节点从链表中排除\n\nfor(int i &#x3D; 2; i &lt; position; i++)&#123;\n    if(temp-&gt;next !&#x3D; NULL)&#123;\n        temp &#x3D; temp-&gt;next;\n    &#125;\n&#125;\ntemp-&gt;next &#x3D; temp-&gt;next-&gt;next;\n在链表中搜索一个元素\n\n将 head 作为 current 节点\n运行一个循环，直到 current 节点是\nNULL，因为最后一个节点指向 NULL\n在每次迭代中，检测节点是否等于 item。如果与\nitem 匹配，则返回 true，否则返回\nfalse。\n\nbool searchNode(struct Node** head_ref, int key)&#123;\n    struct Node* current &#x3D; *head_ref;\n    \n    while(current !&#x3D; NULL)&#123;\n        if(current-&gt;data &#x3D;&#x3D; key) return true;\n        current &#x3D; current-&gt;next;\n    &#125;\n    return false;\n&#125;\n链表元素排序\n冒泡排序：\n\n将 head 作为 current 节点，并创建一个\nindex 节点备用。\n如果 head 是空，则返回。\n否则，运行一个循环直到以后一个节点。\n在每次迭代中依次执行 5-6 步。\n存储 current 的下一个节点在 index\n中。\n检查 current\n节点的数据是否大于下一个节点的。如果是，则交换 current 和\nindex。\n\nvoid sortLinkedList(struct Node** head_ref)&#123;\n    struct Node *current &#x3D; *head_ref, *index &#x3D; NULL;\n    int temp;\n    \n    if(head_ref &#x3D;&#x3D; NULL)&#123;\n        return;\n    &#125;else&#123;\n        while(current !&#x3D; NULL)&#123;\n            &#x2F;&#x2F; index points to the node next to current\n            index &#x3D; current-&gt;next;\n            \n            while(index !&#x3D; NULL)&#123;\n                if(current-&gt;data &gt; index-&gt;data)&#123;\n                    temp &#x3D; current-&gt;data;\n                    current-&gt;data &#x3D; index-&gt;data;\n                    index-&gt;data &#x3D; temp;\n                &#125;\n                index &#x3D; index-&gt;next;\n            &#125;\n            current &#x3D; current-&gt;next;\n        &#125;\n    &#125;\n&#125;\nPython\n# Linked list operations in Python\n\n# create a node\nclass Node:\n    def __init__(self, data):\n        self.data &#x3D; data\n        self.next &#x3D; None\n\nclass LinkedList:\n    def __init__(self):\n        self.head &#x3D; None\n        \n    # Insert at the begining\n    def insertAtBegining(self, new_data):\n        new_node &#x3D; Node(new_data)\n        \n        new_node.next &#x3D; self.head\n        self.head &#x3D; new_node\n    \n    # Insert after a node\n    def insertAfter(self, prev_node, new_data):\n        if prev_node is None:\n            print(&quot;The given previous node must inLinkedList.&quot;)\n            return\n        new_node &#x3D; Node(new_data)\n        new_node.next &#x3D; prev_node.next\n        prev_node.next &#x3D; new_node\n    # Insert at the end\n    def insertAtEnd(self, new_data):\n        new_node &#x3D; Node(new_data)\n        \n        if self.head is None:\n            self.head &#x3D; new_node\n            return\n        \n        last &#x3D; self.head\n        while(last.next):\n            last &#x3D; last.next\n        \n        last.next &#x3D; new_node\n        \n    # Deleting a node\n    def deleteNode(self, position):\n        if self.head is None:\n            return\n        \n        temp &#x3D; self.head\n        \n        if position &#x3D;&#x3D; 0:\n            self.head &#x3D; temp.next\n            temp &#x3D; None\n            return\n        \n        # Find the key to be deleted\n        for i in range(position - 1):\n            temp &#x3D; temp.next\n            if temp is None:\n                break\n        \n        # If the key is not present\n        if temp is None:\n            return \n        \n        if temp.next is None:\n            return\n        \n        next &#x3D; temp.next.next\n        temp.next &#x3D; None\n        temp.next &#x3D; next\n    \n    # Search an element\n    def search(self, key):\n        current &#x3D; self.head\n        \n        while current is not None:\n            if current.data &#x3D;&#x3D; key:\n                return True\n            \n            current &#x3D; current.next\n        \n        return False\n    \n    # Sort the linked list\n    def sortLinkedList(self, head):\n        current &#x3D; head\n        index &#x3D; Node(None)\n        \n        if head is None:\n            return\n        else:\n            while current is not None:\n                # index points to the node next to current \n                index &#x3D; current.next\n                \n                while index is not None:\n                    if current.data &gt; index.data:\n                        current.data, index.data &#x3D; index.data, current.data\n                    index &#x3D; index.next\n                current &#x3D; current.next\n\n    # Print the linked list\n    def printList(self):\n        temp &#x3D; self.head\n        while(temp):\n            print(str(temp.data) + &quot; &quot;, end&#x3D;&quot;&quot;)\n            temp &#x3D; temp.next\n\nif __name__ &#x3D;&#x3D; &#39;__main__&#39;:\n    llist &#x3D; LinkedList()\n    llist.insertAtEnd(1)\n    llist.insertAtBeginning(2)\n    llist.insertAtBeginning(3)\n    llist.insertAtEnd(4)\n    llist.inserAfter(llist.head.next, 5)\n    \n    print(&quot;linked list: &quot;)\n    llist.printList()\n    \n    print(&quot;\\nAfter deleting an element:&quot;)\n    llist.deleteNode(3)\n    llist.printList()\n    \n    print()\n    item_to_find &#x3D; 3\n    if llist.search(item_to_find):\n        print(str(item_to_find) + &quot;is found&quot;)\n    else:\n        print(str(item_to_find) + &quot;is not found&quot;)\n        \n    llist.sortLinkedList(llist.head)\n    print(&quot;Sorted List: &quot;)\n    llist.printList()\nC\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nstruct Node&#123;\n    int data;\n    struct Node* next;\n&#125;;\n\n&#x2F;&#x2F; Insert at the beginning\nvoid insertAtBeginning(struct Node** head_ref, int new_data)&#123;\n    &#x2F;&#x2F; Allocate memory to a node\n    struct Node* new_node &#x3D; (struct Node*)malloc(sizeof(struct Node));\n    \n    &#x2F;&#x2F; insert the data\n    new_node-&gt;data &#x3D; new_data;\n    new_node-&gt;next &#x3D; (*head_ref);\n    \n    &#x2F;&#x2F; Move head to new node\n    (*head_ref) &#x3D; new_node;\n&#125;\n\n&#x2F;&#x2F; Insert a node after a node\nvoid insertAfter(struct Node* prev_node, int new_data)&#123;\n    if(prev_node &#x3D;&#x3D; NULL)&#123;\n        printf(&quot;the given previous node cannot be NULL&quot;);\n        return;\n    &#125;\n    struct Node* new_node &#x3D; (struct Node*)malloc(sizeof(struct Node));\n    new_node-&gt;data &#x3D; new_data;\n    new_node-&gt;next &#x3D; prev_node-&gt;next;\n    prev_node-&gt;next &#x3D; new_node;\n&#125;\n\n&#x2F;&#x2F; Insert the end\nvoid insertAtEnd(struct Node** head_ref, int new_data)&#123;\n    struct Node* new_node &#x3D; (struct Node*)malloc(sizeof(struct Node));\n    struct Node* last &#x3D; *head_ref;\n    \n    new_node-&gt;data &#x3D; new_data;\n    new_node-&gt;next &#x3D; NULL;\n    \n    if(*head_ref &#x3D;&#x3D; NULL)&#123;\n        *head_ref &#x3D; new_node;\n        return;\n    &#125;\n    while(last-&gt;next !&#x3D; NULL) last &#x3D; last-&gt;next;\n    last-&gt;next &#x3D; new_node;\n    return;\n&#125;\n\n&#x2F;&#x2F; Delete a node\nvoid deleteNode(struct Node** head_ref, int key)&#123;\n    struct Node *temp &#x3D; *head_ref, *prev;\n    \n    if(temp !&#x3D; NULL &amp;&amp; temp-&gt;data &#x3D;&#x3D; key)&#123;\n        *head_ref &#x3D; temp-&gt;next;\n        free(temp);\n        return;\n    &#125;\n    &#x2F;&#x2F; Find the key to be deleted\n    while(temp !&#x3D; NULL &amp;&amp; temp-&gt;data !&#x3D; key)&#123;\n        prev &#x3D; temp;\n        temp &#x3D; temp-&gt;next;\n    &#125;\n    \n    &#x2F;&#x2F; If the key is not present\n    if(temp &#x3D;&#x3D; NULL) return;\n    \n    &#x2F;&#x2F; Remove the node\n    prev-&gt;next &#x3D; temp-&gt;next;\n    free(temp);\n&#125;\n\n&#x2F;&#x2F; Search a node\nint searchNode(struct Node** head_ref, int key)&#123;\n    struct Node* current &#x3D; *head_ref;\n    \n    while(current !&#x3D; NULL)&#123;\n        if (current-&gt;data &#x3D;&#x3D; key) return 1;\n        current &#x3D; current-&gt;next;\n    &#125;\n    return 0;\n&#125;\n\n&#x2F;&#x2F; Sort the linked list\nvoid sortLinkedList(struct Node** head_ref)&#123;\n    struct Node* current &#x3D; *head_ref, *index &#x3D; NULL;\n    int temp;\n    if(head_ref &#x3D;&#x3D; NULL)&#123;\n        return;\n    &#125;else&#123;\n        while(current !&#x3D; NULL)&#123;\n            index &#x3D; current-&gt;next;\n            \n            while(index !&#x3D; NULL)&#123;\n                if(current-&gt;data &gt; index-&gt;data)&#123;\n                    temp &#x3D; current-&gt;data;\n                    current-&gt;data &#x3D; index-&gt;data;\n                    index-&gt;data &#x3D; temp;\n                &#125;\n                index &#x3D; index-&gt;next;\n           &#125;\n            current &#x3D; current-&gt;next;\n        &#125;\n    &#125;\n&#125;\n\n&#x2F;&#x2F; Print the linked list\nvoid printList(struct Node* node)&#123;\n    while(node !&#x3D; NULL)&#123;\n        printf(&quot; %d &quot;, node-&gt;data);\n        node &#x3D; node-&gt;next;\n    &#125;\n&#125;\n\nint main()&#123;\n    struct Node* head &#x3D; NULL;\n    \n    insertAtEnd(&amp;head, 1);\n    insertAtBeginning(&amp;head, 2);\n    insertAtBeginning(&amp;head, 3);\n    insertAtEnd(&amp;head, 4);\n    insertAfter(head-&gt;next, 5);\n    \n    printf(&quot;Linked list: &quot;);\n    printList(head);\n    \n    printf(&quot;\\nAfter deleting an element: &quot;);\n    deleteNode(&amp;head, 3);\n    printList(head);\n    \n    int item_to_find &#x3D; 3;\n    if(searchNode(&amp;head, item_to_find))&#123;\n        printf(&quot;\\n%d is found&quot;, item_to_find);\n    &#125;else&#123;\n        printf(&quot;\\n%d is not found&quot;, item_to_find);\n    &#125;\n    \n    sortLinkedList(&amp;head);\n    printf(&quot;\\nSorted List: &quot;);\n    printList(head);\n&#125;\n\n","slug":"DSAA/链表","date":"2023-04-14T12:00:00.000Z","categories_index":"数据结构与算法","tags_index":"计算机","author_index":"爱慢跑的乌龟"},{"id":"386d227c4f88ed4186d8b0b65da86630","title":"CAN 总线协议","content":"CAN 总线协议\nController Area Network (CAN bus)\n是一种车辆总线标准，允许为控制器和设备在没有主机的情况下与彼此的应用程序进行通信（没有主从关系）。它是一种基于消息的协议，最初设计用于汽车内的多路复用电线以节省铜线，但它也可以许多其他情况。对于每个设备，帧中的数据是串行传输的，但如果多个设备同时传输，最高优先级的设备可以继续传输，而其他设备则推出。帧被所有设备接受，包括发送设备。\nCAN 总线的历史\n1983-1991: CAN 总线的诞生和发展\nCAN 总线最初是由德国博世公司（Bosch），在 1983 年开发，并于 1986\n年首次发布。CAN\n总线最初用于汽车电子系统的通信，并逐渐得到其他领域的广泛应用。在这一时期，CAN\n总线标准得到了进一步完善和发展，包括 CAN 2.0A 和 CAN 2.0B\n等版本的发布。\n1991-2000年: CAN\n总线的普及和标准化\nCAN\n总线在这一时期得到了广泛的应用和推广，成为汽车电子系统、工业控制和自动化领域的主流通信协议。CAN\n总线标准也到了进一步的标准化和完善，包括 ISO 11898 等标准的发布。\n2000年至今: CAN\n总线的进一步发展和应用扩展\n2012 年，博世发布了CAN FD1.0，即 CAN with Flexible\nData-Rate。该规范使用不同的帧格式，允许不同的数据长度，并在仲裁决定后可选择切换到更快的比特率。CAN\nFD 与现有的 CAN 2.0 网络兼容，因此新的 CAN FD 设备可以与现有的 CAN\n设备在同一网络中共存。截至 2018 年，博世积极扩展 CAN 标准。\nCAN 总线的标准\n1. CAN 2.0A 和 2.0B\nCAN 2.0A 和 2.0B 是最基本的 CAN 标准，定义了 CAN\n总线上数据的帧格式、速率、物理层等特性，能够支持最高 1 Mbps\n的数据传输速率。其中，CAN 2.0A 标准采用 11\n位标识符（ID）进行帧的识别和过滤，而 CAN 2.0B 标准则采用 29\n位标识符进行帧的识别和过滤。\n2. ISO 11898-2\nISO 11898-2 是 CAN 总线的物理层规范，主要定义了 CAN\n总线在电气特性方面的规范，包括电压、电流、传输速率、传输距离等。此规范还定义了两根差分信号线（CAN_H\n和 CAN_L）以及地线的连接方式，以保证 CAN 总线的抗干扰能力和可靠性。\n3. ISO 11898-3\nISO 11898-3 是高速 CAN 总线的物理层规范，定义了在高速传输模式下 CAN\n总线的电气特性和信号波形。在该标准下，CAN 总线的最高传输速率可以达到 1\nMbps，传输距离可以达到 40 米。\n4. ISO 11898-4\nISO 11898-4 是低速 CAN 总线的物理层规范，定义了在低速传输模式下 CAN\n总线的电气特性和信号波形。在该标准下，CAN 总线的最高传输速率为 125\nKbps，传输距离可以达到 500 米。\n5. SAE J1939\nSAE J1939 是一种 CAN\n总线协议，主要用于商用车辆和重型机械设备的通信。它定义了 CAN\n总线上的数据格式、物理层、协议等方面的规范，能够实现多节点、高速、实时的数据交换。\n6. DeviceNet\nDeviceNet 是一种 CAN\n总线协议，主要用于工业自动化领域的设备通信。它定义了 CAN\n总线上的数据格式、物理层、协议等方面的规范，能够实现设备的控制和信息交换。'\n物理层标准\nISO 11898-2\n\n\n\n\n\n\n\n\n\nHigh-speed medium access unit:\n定义了 CAN\n的高速物理介质附件(HS-PMA)，广泛用于汽车行业的串行通信协议，支持分布式实时控制和多路传输。\nHS-PMA\n包括一个传输和一个接受实体。它应能够使连接的物理介质，即两线电缆，相对于公共接地偏压。发送单元在\nCAN_H 和 CAN_L 两根信号线上施加差分电压，以表示逻辑信号 0\n(dominant)，不施加差分电压时，表示逻辑信号 1\n(recessive)，这些信号将被连接在完全相同介质的其他节点所接收。这两个信号是物理介质相关子层的接口。\nHS-PMA 应当提供一个 AUI 给物理编码子层。它包括 TXD 和 RXD 信号以及\nGND。TXD 信号接受来自物理编码子层的 bit 流，并传输给 MDI。RXD 信号将来自\nMDI 的 bit 流发送给物理编码子层。\n\n\n\n\n\n\n\n\n\nAUI: attachment unit interface 附件单元接口\nMDI: media dependent interface 介质相关接口\n由一个或多个 HS-PMA\n组成的应用至少应支持正常功率运行模式。实现低功耗模式是可选的。\n\n\n\n\n\n\n\n\nOperating mode\nBus biasing behaviour\nTransmitter behavior\n\n\n\n\nNormal\nBus biasing active\nDominant or recessive\n\n\nLow-power\nBus biasing active or inactive\nRecessive\n\n\n\nHS-PMA 测试回路\nHS-PMA 输出 CAN 信号是由 CAN_H 和 CAN_L 实现的，TXD\n是传输数据输入，RXD\n是接收数据输出。下图展示的外围电路定义所有必需电压电流参数的测量条件。 表示 HS-PMA\n在网络中使用时的有效阻性负载（总线负载），代表可选的分立终端电容器。\n\n\nHS-PMA test circuit\n\n\n\n\n\n\n\n\n\n\n differential\nvoltage between CAN_H and CAN_L wires\n single ended\nvoltage on CAN_H wire\n single ended\nvoltage on CAN_L wire\n capacitive load\non RXD\n\n发送特性\n\n为了达到可接受的低射频发射水平，发送端应满足下表所要求的驱动信号对称性：\n\n发送端的最大输出电流的限制如下：\n\n表5详细说明了总线偏置激活时的隐性输出特性：\n\n表6详细说明了总线偏置未激活时的隐性输出特性：\n\nHS-PMA 可以限制显性传输的持续时间，防止 TXD\n因为故障持续输出显性，从而干扰其他节点的通信。HS-PMA\n应该在表7中指定的限制范围内实现超时：\n\n\n\n\n\n\n\n\n\n\n\n的最小值与最小的比特率之间存在一定的关系。 的最小值为 0.8\nms，bit 流大于或等于 21.6 kbit/s 时，可以容纳 17 个连续的显性位；当 bit\n流大于或等于 45.8 kbit/s 时，可以容纳 36 个连续的显性位。值 17 表明 PMA\n尝试发送一个显性位，并且每次在接收数据输入时都看到一个隐性电平。当前五次尝试的最后一位有位错误时，值\n36 反映连续 6 个错误帧。\n接收特性\n当 HS-PMA\n处于低功耗模式，并且总线偏置被激活时，隐性和显性状态的差分输入电压范围如表\n8 所示：\n\n当 HS-PMA\n处于低功耗模式，并且总线偏置未被激活时，隐性和显性状态的差分输入电压范围如表\n9 所示：\n\n接收机的输入阻抗\n\nHS-PMA 应该具有表 10 给出的输入阻抗：\n\n同时，内部阻抗应当满足表 11 的需求：\n\n发送和接收的时序特性\n时序参数应在 HS-PMA 的 RXD 输出和 TXD 输入以及 CAN_H 和 CAN_L\n之间的差压上测量。\n图 5 展示了如何测量信号轨迹中的时序：\n\nHS-PMA 的循环延时要求：\n\n\n\n\n\n\n\n\n\n\n从 TXD 输入端的信号边沿到 RXD\n输出端的下一个具有相同极性的信号边沿的时间跨度，需要考虑两个信号边沿的最大延迟。\n\n\n， 和  的最大额定值\n表 15 反映了静态电压的上下限，可以连接到 CAN_H 和 CAN_L\n而不造成损坏，而 \n则保持在其自身的最大额定值范围内。\n\nCAN_H 和 CAN_L 的最大漏电流\n没有供电的 HS-PMA 不应干扰连接到同一媒介的其他 HS-PMA\n的通信，最大漏电流的要求如表 16 所示：\n\n低功耗模式的唤醒\n当由一个或多个 HS-PMA 组成的网络实现低功耗模式时，HS-PMA\n应能够发出唤醒事件信号。表17列出了定义的 HS-PMA 类型所需的唤醒机制：\n\n当一个 HS-PMA 有多个唤醒机制时，这写唤醒机制必须可配置。\n基本的唤醒：\n当接收到一个持续时间至少为 \n的显性状态，就能够触发一个唤醒事件。\n唤醒模式唤醒：\n当连续接收到两个持续时间至少为 \n的显性状态，并被一个持续时间至少为 \n的隐性状态隔开时，将发生唤醒事件。\n选择唤醒：\n一旦检测到一个唤醒帧 (WUF)，将触发唤醒事件。在 CBFF 或 CEFF 中解码\nCAN 帧并接受为 WUF 是由 HS-PMA\n完成的。如果启用，在正常和低功耗模式下都可以解码 CAN 帧。\n在偏置反应时间  过去后，可以忽略\nCBFF 和 CEFF 中最多 4 帧(当比特率高于 500 kbit/s 时最多 8\n帧)，并且不能忽略 CBFF 和 CEFF 中的任何后续帧。\n在错误通信的情况下，HS-PMA\n应在内部错误计数器溢出时或溢出后发出唤醒信号。\n\n正常模式到低功耗模式转换时的行为\n\n如果在模式更改之前启用了选择性唤醒，并且 HS-PMA\n不再忽略帧，则在模式转换期间也应支持 CAN\n数据和远程帧的解码，这些模式转换启用了帧检测 IP。 如果接收到的帧是有效的\nWUF，则收发器应指示唤醒。 如果启用，CAN\n数据的解码应在正常和低功耗模式下实现。\n\n位解码\n\n当 CAN_H 和 CAN_L\n之间的差分电压时序符合以下两种信号之一时，接收到的经典 CAN\n帧应被正确解码:\n\nbit 流由信号形状A的多个实例组成 (用于处理振铃);\nbit 流可以由信号形状 B1\n的多个实例和信号形状B2的一个实例组装而成(以处理发送方时钟容差和仲裁损失)。\n\n\n\n唤醒帧\n\n如果满足以下所有条件，一个有效的典型 CAN 将被认为是一个有效的\nWUF：\n\n当 DLC 匹配未禁用时，接收到的帧是典型 CAN 数据帧。当 DLC\n匹配被禁用时，帧也可能是远程帧。\n接收到的典型 CAN 帧的 ID 与相关 bit 位的配置 ID (在HS-PMA中)\n完全匹配。相关 bit 的位置是由一个 ID 掩码给出的。\n接收到的典型 CAN 数据帧的 DLC 与配置的 DLC 完全匹配。这个 DLC\n匹配条件可以通过 HS-PMA 实现中的配置禁用。\n当 DLC 大于 0 且启用 DLC\n匹配时，接收到的帧的数据字段在对应于配置的数据掩码中的设置的 bit\n位置上至少设置了一位。\n收到正确的循环冗余校验 (CRC)，包括隐性 CRC 分隔符，并且在确认 (ACK)\n之前未检测到错误。图7描述了被认为是“不关心”的 bit。\n\n\n\n\n\n\n\n\n\n\nDLC: data length code\n\n\n帧错误计数机制\n\n在激活选择唤醒功能和  结束时，错误\nCAN 帧的计数器应设置为零。计数器的初始值为零。当检测到位填充、CRC 或 CRC\n分隔符形式错误时，该计数器将加1。如果已经接收到一个典型 CAN\n帧，并且计数器不为零，那么计数器将减1。在 CRC\n定界符和间歇字段结束之间的显性位不应增加帧错误计数器。\n在此计数器的每次递增或递减时，HS-PMA 中的解码器单元应等待 \n个隐性位，然后考虑一个显性位作为帧的开始。图8描述了在接收到典型 CAN\n帧和出现错误场景时，强制开始帧 (SOF) 检测的位置。\n\n当计数器达到阈值时，应立即或在下一次接收 WUP\n时进行唤醒。默认阈值是32，其他值可能是可配置的。\n在偏置反应时间  结束后开始的连续 4\n个(比特率&gt; 500 kbit/s时最多 8 个)的典型 CAN\n数据和远程帧可能被忽略(失败时错误计数器没有增加)或被判断为错误(即使没有错误，错误计数器也会增加)。\n接收带有非标称保留位 (SRR, r0)的 CEFF\n帧不会导致错误计数器的增加。\n\n唤醒帧 ID\n\n支持 CAN-ID 掩码机制，以在比较中排除 ID 位。支持 11 位和 29 位的\nCAN-ID 和 ID 掩码。用户选择 WUF 是否必须出现在 CBFF 或 CEFF 中。IDE\n位不是 ID 掩码的一部分。在任何情况下都要进行判别。\n除 \"don't care\" 外，所有被掩码的 ID 位都与配置的 ID\n位完全匹配。如果掩码 ID 位配置为 \"don't care\"，则 “1” 和 “0”\n都将被接受。\n\n\n唤醒帧 DLC\n\n如果启用了 DLC 匹配条件，则只有当接收帧的 DLC 与配置的 DLC\n完全匹配时，典型 CAN 帧才能是有效的 WUF。\n如果 DLC 匹配条件被禁用，则 DLC 和数据字段不被计算，当标识符匹配且\nCRC 正确时，典型 CAN 帧已经是有效的 WUF。\n\n唤醒帧的数据域\n\n如果启用了 DLC 匹配条件，则只有在接收到的 WUF\n的数据字段中至少有一个逻辑 1 位与配置的 WUF 中的数据字段的逻辑 1\n位匹配时，典型 CAN 帧才能是有效的 WUF。\n如果 DLC 匹配条件被禁用，则 DLC 和数据字段不被计算，当标识符匹配且\nCRC 正确时，典型 CAN 帧已经是有效的 WUF。\n\n使用该机制，只需一个唤醒帧就可以唤醒 64 个独立的 ECU 组。\n总线偏置 (Bus biasing)\n当 HS-PMA\n具有低功耗模式和选择性唤醒时，需要自动电压偏置。对于所有其他\nHS-PMA，应实现正常偏置或自动电压偏置。\n\n正常偏置\n\n正常偏置意味着总线偏置在正常模式下激活，在低功率模式下不激活。\n\n自动电压偏置\n\n自动电压偏置是指在正常模式下总线偏置是激活的，在低功耗模式下由 CAN_H\n和 CAN_L 之间的电压差控制。下面的状态机说明了这种机制。\n\n图 11 中的状态机定义了所有操作模式的总线偏置行为。进入状态 1\n时，可选定时器 \n复位并重新启动；当进入状态 3 或 4 时，定时器 \n复位并重新启动。\n表 20 指定了总线偏置控制时间，图 12 为偏置反应时间。\n\n\n数据链路层协议\nCAN 的特点\n（1） 多主控制\n当总线处于空闲状态时，所有的节点都可向总线发送消息。最先访问总线的节点可获得总线的发送权。当有多个节点同时向总线发送消息时，发送高优先级\nID 消息的节点可获得总线的发送权。\n（2）消息的发送\n在 CAN\n协议中，所有的消息都以统一的格式发送。总线处于空闲状态时，总线上的所有节点都可以向总线发送消息。当有多个节点同时向总线发送消息时，根据标识符\n（Identifier, ID) 决定优先级。ID\n并不是标识消息发送的目的地址，而是表示访问总线的消息的优先级。两个以上的节点同时开始发送消息时，对各个消息\nID\n的每个位进行逐个仲裁比较。仲裁获胜（被判定为优先级最高）的节点继续发送消息，仲裁失利的节点则立刻停止发送而进行接收工作。\n（3）系统的柔软性\n与总线相连的节点没有类似于“地址”的信息。因此在总线上增加节点时，连接在总线上的其它节点的软硬件及应用层都不需要做任何改变。\n（4）通信速度\n根据整个网络的规模，可设定合适的通信速度。在同一网络的中，所有的节点必须设定为统一的速度。即使有一个节点的通信速度与其它节点不同，该节点也将会输出错误信号，妨碍整个网络的通信。不同的网络则可以设置不同的通信速度。\n（5）远程数据请求\n可通过发送 “遥控帧” 请求其它节点发送数据。\n（6）错误检测功能·错误通知功能·错误恢复功能\n所有节点都可以检测错误（错误检测功能）。检测出错误的节点会立即通知其它所有节点（错误通知功能）。正在发送消息的节点一旦检测出错误，会强制结束当前的发送。强制结束发送的节点会不断重新发送此消息直到成功为止（错误恢复功能）。\n（7）故障封闭\nCAN\n可以判断出错误的类型是总线上暂时的数据错误（如外部噪声）还是持续的数据错误（如节点内部故障、驱动器故障、断线等）。由此功能，当总线上发生持续数据错误时，可将引起此故障的节点从总线上隔离出去。\n（8）连接\nCAN\n总线是可同时连接多个节点的总线。可连接的节点总数在理论上是没有限制的。但实际应用的过程中，可连接的节点数受总线上的时间延迟及电气负载的限制。降低通信速度，可连接的节点数增加；提高通信速度，则可连接的节点数减少。\nCAN 的错误\n错误的种类\n节点始终处于3 种状态之一。\n（1）主动错误状态\n主动错误状态是可以正常参加总线通信的状态。处于主动错误状态的节点检测出错误时，输出主动错误标志。\n（2）被动错误状态\n被动错误状态是易引起错误的状态。处于被动错误状态的节点虽然能够参加总线通信，但是为了不妨碍其它节点通信，接收时不能积极地发送错误通知。处于被动错误状态的节点即使检测出错误，而其它处于主动错误状态的节点如果没有发现错误，整个总线也被认为是没有错误的。处于被动错误状态的节点检测出错误时，输出被动错误标志。\n处于被动错误状态的节点在发送结束后不能立刻再次开始发送。在开始下次发送前，在间隔帧期间内必须插入\n“延迟传送”（8 个隐性位）\n（3）总线关闭态\n总线关闭态是不能参加总线上通信的状态。消息的接受和发送都是禁止的。\n\n\n\n\n\n\n\n\n\n这些状态依靠发送错误的计数和接收错误的计数来管理的，根据计数值决定进入那种状态。错误状态和计数值的关系如下：\n\n\n错误计算值\n发送错误计数值和接收错误计数值根据一定的条件发送变化。错误计数值的变动条件如下表所示。一次数据的接收和发送可能同时满足多个条件。错误计数器在错误标志的第一个位出现的时间点上开始计数。\n\n\n\n\n\n\n\n\n接受和发送错误计数值的变动条件\n发送错误计数值 (TEC)\n接收错误计数值 (REC)\n\n\n\n\n接收节点检测出错误时。例外：接收单元在发送错误标志或过载标志中检测出“位错误”时，接收错误计数值不增加。\n——\n+1\n\n\n接收节点在发送完错误标志后检测到的第一个位为显性电平时。\n——\n+8\n\n\n发送节点在输出错误标志时。\n+8\n——\n\n\n发送节点在发送主动错误标志或过载标志时，检测出位错误。\n+8\n——\n\n\n接收节点在发送主动错误标志或过载标志时，检测出位错误。\n——\n+8\n\n\n各节点从主动错误标志、过载标志的最开始检测出连续\n14 个位的显性位时。之后，每检测出连续的 8 个位的显性位时。\n发送时 +8\n接收时 +8\n\n\n检测出在被动错误标志后追加的连续 8\n个位的显性位时。\n发送时 +8\n接收时 +8\n\n\n发送单元正常发送数据结束时（返回 ACK\n且到帧结束也未检测出错误时）。\n-1 (TEC=0 时 )\n——\n\n\n接收单元正常接收数据结束时（到 CRC\n未检测出错误且正常返回 ACK 时）。\n——\n设\n\n\n处于总线关闭态的单元，检测到 128 次连续 11\n个位的隐性位。\nTEC=0\nREC=0\n\n\n\nCAN 协议\n帧的种类\n通信是通过以下 5 种类型的帧进行的。\n\n数据帧\n遥控帧\n错误帧\n过载帧\n帧间隔\n\n数据帧和遥控帧有标准格式和扩展格式两种格式。标准格式有11\n个位的标识符 (ID)，扩展格式有 29 个位的 ID。\n\n\n\n帧\n帧用途\n\n\n\n\n数据帧\n用于发送节点向接收节点传送数据的帧。\n\n\n遥控帧\n用于接收节点向具有相同 ID 的发送节点请求数据的帧。\n\n\n错误帧\n用于当检测出错误时向其它节点通知错误的帧。\n\n\n过载帧\n用于接收节点通知其尚未做好接收准备的帧。\n\n\n帧间隔\n用于将数据帧及遥控帧与前面的帧分离开来的帧。\n\n\n\n数据帧\n数据帧由 7 个段构成：\n\n帧起始：表示数据帧开始的段。\n仲裁段：表示该帧优先级的段。\n控制段：表示数据的字节数及保留位的段。\n数据段：数据的内容，可发送 0～8 个字节的数据。\nCRC 段：检查帧的传输错误的段。\nACK 段：表示确认正常接收的段。\n帧结束：表示数据帧结束的段。\n\n\n(1) 帧起始（标准、扩展格式相同）\n表示帧开始的段，1\n个位显性位。只有在总线空闲期间节点才能够发送 SOF.\n(2) 仲裁段\n表示数据优先级的段。\n标准帧有 11 位 ID，扩展帧有 29 位 ID。\nRTR 位：用于区分数据帧和遥控帧\n\n0：数据帧\n1：遥控帧\n\nIDE 位：用于区分标准帧和扩展帧\n\n0：标准帧\n1：扩展帧\n\nSSR 位：表明该位置代替了标准帧中的 RTR（无实际意义，SSR永远置 1）\n\n\n\n\n\n\n\n\n\n标准帧的 ID 有 11 个位。从 ID28 到 ID18 被依次发送。禁止高7\n位都为隐性。（禁止设定：ID=1111111XXXX）\n扩展帧的 ID 有 29 个位。基本 ID 从 ID28 到 ID18，扩展 ID 由 ID17 到\nID0 表示。基本 ID 和标准帧的 ID 相同。禁止高 7\n位都为隐性。（禁止设定：基本 ID=1111111XXXX）\n(3) 控制段\n控制段由 6\n个位构成，表示数据段的字节数。标准帧和扩展帧的构成有所不同。\n\n\n\n\n\n\n\n\n\n\n保留位（r0、r1）\n保留位必须全部以显性电平发送。但接收方可以接收显性、隐性及其任意组合的电平。\n数据长度码（DLC）\n数据长度码与数据的字节数的对应关系如下表所示。数据的字节数必须为 0～8\n字节。但接收方对 DLC = 9～15 的情况并不视为错误。\n\n\n(4) 数据场（标准帧和扩展帧相同）\n\n具有 0-8 个字节长度，由 DLC 确定\n包含 CAN 数据帧发送的内容\n\n(5) CRC 段（标准/扩展格式相同）\nCRC 段是检查帧传输错误的帧。由15 个位的 CRC 顺序和 1 个位的 CRC\n界定符（用于分隔的位）构成。\n\n\n\n\n\n\n\n\n\nCRC 顺序是根据多项式生成的 CRC 值，CRC\n的计算范围包括帧起始、仲裁段、控制段、数据段。\n接收方以同样的算法计算 CRC 值并进行比较，不一致时会通报错误。\n(6) ACK 段 ACK 段用来确认是否正常接收。由 ACK 槽\n(ACK Slot)和 ACK 界定符 2 个位构成。\n\n\n\n\n\n\n\n\n\n\n发送节点的ACK 段 发送节点在 ACK 段发送 2 个位的隐性位。\n接收节点的 ACK 段 接收到正确消息的节点在 ACK 槽(ACK\nSlot)发送显性位，通知发送节点正常接收结束。这称作“发送ACK”或者“返回ACK”。\n\n(7) 帧结束 帧结束是表示该该帧的结束的段。由 7\n个位的隐性位构成。\n遥控帧\n接收节点向发送节点请求发送数据所用的帧。遥控帧由 6\n个段组成。遥控帧没有数据帧的数据段。\n\n帧起始（SOF）：表示帧开始的段。\n仲裁段：表示该帧优先级的段。可请求具有相同 ID 的数据帧。\n控制段：表示数据的字节数及保留位的段。\nCRC 段：检查帧的传输错误的段。\nACK 段：表示确认正常接收的段。\n帧结束：表示遥控帧结束的段。\n\n\n\n\n\n\n\n\n\n\n\n遥控帧和数据帧\n\n数据帧和遥控帧的不同\n\n遥控帧的 RTR 位为隐性位，没有数据段\n没有数据的数据帧和遥控帧可通过 RTR 位来区分\n\n遥控帧没有数据段，数据长度码该如何表示？\n\n遥控帧的数据长度码以所请求数据帧的数据长度码表示。\n\n没有数据段的数据帧有何用途？\n\n可用于各节点的定期连接确认/应答、或仲裁段本身带有实质性信息的情况下。\n\n\n错误帧\n用于在接收和发送消息时检测出错误通知错误的帧。错误帧由错误标志和错误界定符构成。\n(1) 错误标志\n错误标志包括主动错误标志和被动错误标志两种。\n\n主动错误标志：6 个位的显性位。\n被动错误标志：6 个位的隐性位。\n\n(2) 错误界定符 错误界定符由 8\n个位的隐性位构成。\n\n\n\n\n\n\n\n\n\n\n\n主动错误标志：处于主动错误状态的节点检测出错误时输出的错误标志。\n被动错误标志：处于被动错误状态的节点检测出错误时输出的错误标志。\n\n过载帧\n过载帧是用于接收节点通知其尚未完成接收准备的帧。过载帧由过载标志和过载界定符构成。\n(1) 过载标志\n6 个位的显性位。\n过载标志的构成与主动错误标志的构成相同。\n(2) 过载界定符\n8 个位的隐性位。\n过载界定符的构成与错误界定符的构成相同。\n\n帧间隔\n帧间隔是用于分隔数据帧和遥控帧的帧。数据帧和遥控帧可通过插入帧间隔将本帧与前面的任何帧（数据帧、遥控帧、错误帧、过载帧）分开。\n过载帧和错误帧前不能插入帧间隔。\n\n(1) 间隔\n3 个位的隐性位。\n(2) 总线空闲\n隐性电平，无长度限制（0\n亦可）。本状态下，可视为总线空闲，要发送的节点可开始访问总线。\n(3) 延迟传送（发送暂时停止）\n8\n个位的隐性位。只在处于被动错误状态的节点刚发送一个消息后的帧间隔中包含的段。\n优先级仲裁\n在总线空闲态，最先开始发送消息的节点获得发送权。\n多个节点同时开始发送时，各发送节点从仲裁段的第一位开始进行仲裁。连续输出显性电平最多的节点可继续发送。\n\n(1) 数据帧何遥控帧的优先级\n具有相同 ID\n的数据帧和遥控帧在总线上竞争时，仲裁段的最后一位（RTR）为显性位的数据帧具有优先权，可继续发送。\n(2) 标准帧和扩展帧的优先级\n标准格式 ID 与具有相同 ID\n的遥控帧或者扩展格式的数据帧在总线上竞争时，标准格式的 RTR\n位为显性位的具有优先权，可继续发送。\n位填充\n位填充是为防止突发错误而设定的功能。当连续输出 5\n个相同极性的数据时，插入一个反极性的数据。\n\n(1) 发送节点的工作\n在发送数据帧和遥控帧时，SOF～CRC 段间的数据，输出 5\n个相同极性的电平，插入一个反极性的电平。\n(2) 接收节点的工作\n在接收数据帧和遥控帧时，SOF～CRC 段间的数据，如果接收连续 5\n个极性相同的位，则删除下一位，再继续接收。如果受到连续 6\n个相同极性的电平，将被视为错误并发送错误帧。\n错误的种类\n错误共有 5 种。多种错误可能同时发生。\n\n位错误\n填充错误\nCRC 错误\n格式错误\nACK 错误\n\n\n(1) 位错误\n\n位错误由向总线上输出数据帧、遥控帧、错误帧、过载帧的节点和输出 ACK\n的节点、输出错误的节点来检测。\n在仲裁段输出隐性电平，但检测出显性电平时，将被视为仲裁失利，而不是位错误。\n在仲裁段作为填充位输出隐性电平时，但检测出显性电平时，将不视为位错误，而是填充错误。\n发送单元在 ACK\n段输出隐性电平，但检测到显性电平时，将被判断为其它节点的 ACK\n应答，而非位错误。\n输出被动错误标志（6\n个位隐性位）但检测出显性电平时，将遵从错误标志的结束条件，等待检测出连续相同6\n个位的值（显性或隐性），并不视为位错误。\n\n(2) 格式错误\n\n即使接收节点检测出 EOF（7 个位的隐性位）的最后一位（第8\n个位）为显性电平，也不视为格式错误。\n即使接收节点检测出数据长度码 (DLC) 中 9∼15\n的值时，也不视为格式错误。\n\n错误帧的输出\n检测出满足错误条件的节点输出错误标志通报错误。\n处于主动错误状态的节点输出的错误标志为主动错误标志；处于被动错误状态的节点输出的错误标志为被动错误标志。\n发送节点发送完错误帧后，将再次发送数据帧或遥控帧。\n\n位时序\n由发送节点在非同步的情况下发送的每秒钟的位数称为位速率。一个位可分为\n4 段。\n\n同步段（SS）\n传播时间段（PTS）\n相位缓冲段1（PBS1）\n相位缓冲段2（PBS2）\n\n这些段又由可称为 Time Quantum（以下称为 Tq）的最小时间单位构成。\n1 位分为 4 个段，每个段又由若干个 Tq\n构成，这称为位时序。\n1 位由多少个 Tq 构成、每个段又由多少个 Tq\n构成等，可以任意设定位时序。通过设定位时序，多个节点可同时采样，也可任意设定采样点。\n\n\n\n\n\n\n\n\n\n\n\n采样点就是读取总线电平，并将读到的电平作为位值的点。\n同步方法\nCAN 协议的通信方法为 NRZ（Non-Return to\nZero）方式。各个位的开头或者结尾都没有附加同步信号。发送节点以与位时序同步的方式开始发送数据。另外，接收节点根据总线上电平的变化进行同步并进行接收工作。\n但是，发送节点和接收节点存在的时钟频率误差及传输路径上的（电缆、驱动器等）相位延迟会引起同步偏差。因此接收节点通过硬件同步或者再同步的方法调整时序进行接收。\n硬件同步\n接收节点在总线空闲状态检测出帧起始时进行的同步调整。\n在检测出边沿的地方不考虑 SJW 的值而认为是 SS 段。\n\n\n\n\n\n\n\n\n\nSJW: reSynchronization Jump Width 再同步补偿宽度\n\n再同步\n在接收过程中检测出总线上的电平变化时进行的同步调整。\n每当检测出边沿时，根据 SJW 值通过加长 PBS1 段，或缩短 PBS2\n段，以调整同步。但如果发生了超出 SJW 值的误差时，最大调整量不能超过 SJW\n值。\n\n调整同步的规则\n\n1 个位中只进行一次同步调整。\n只有当上次采样点的总线值和边沿后的总线值不同时，该边沿才能用于调整同步。\n在总线空闲且存在隐性电平到显性电平的边沿时，则一定要进行硬件同步。\n在总线非空闲时检测到的隐性电平到显性电平的边沿如果满足条件 (1) 和\n(2)，将进行再同步。但还要满足下面条件。\n发送节点观测到自身输出的显性电平有延迟时不进行再同步。\n发送节点在帧起始到仲裁段有多个单元同时发送的情况下，对延迟边沿不进行再同步。\n\n","slug":"Communication Protocol/CAN 总线","date":"2023-04-01T09:02:00.000Z","categories_index":"通信协议","tags_index":"CAN 总线","author_index":"爱慢跑的乌龟"},{"id":"5446d073459d8b66ad572b884caef029","title":"E96 系列电阻标称阻值","content":"E96系列电阻标称阻值\n\n\n\n\n\n\n","slug":"Electronic/E96系列电阻标称阻值","date":"2023-03-21T03:10:00.000Z","categories_index":"电子技术","tags_index":"阻值表","author_index":"爱慢跑的乌龟"},{"id":"f2d866e3599035768285c02ebfff1255","title":"STM32 定时器产生 PWM 波","content":"STM32 定时器产生 PWM 波\n对于 PWM\n波来说最重要的两个参数就是频率和占空比。频率是周期的倒数，占空比是指脉宽时间占周期的比例。微控制器产生\nPWM 波的原理是，定时器重复的从 0 计数到 ARR，设定比较值\nCCRx。当定时器的计数值向上计数到与 CCRx\n的值相等时，对应波形输出管脚电平翻转，当定时器计数值到 ARR\n时，输出管脚的电平再次发生翻转。定时器的一个计时周期对应一个 PWM\n周期，脉宽（高电平的宽度）需要根据输出管脚的初始电平不同，或者为 0~CCRx\n这一段，或者为 CCRx~ARR 这一段。改变 CCRx 的值即可实现脉宽的控制。PWM\n频率和占空比的影响因素有：\n\nARR：决定 PWM 周期（在系统时钟频率固定的情况下）\nCCRx：决定 PWM 占空比（高低电平所占整个周期比例）\n\n\nSTM32 的 TIM1 ~ TIM8 定时器，除了\nTIM6 和 TIM7 外的其他定时器都可以用来产生\nPWM 输出。高级定时器 TIM1 和\nTIM8 可以同时产生 7 路的 PWM\n输出。而通用定时器可以同时产生 4 路\nPWM。\n以通用定时器为例，这些定时器有 4\n个输出通道，每个通道都有一个捕获/比较寄存器，将寄存器，将寄存器值和计数器值比较，通过比较结果输出高低电平，实现\nPWM 信号输出。\n每个定时器只有一个计数器，但每个通道都有自己的捕获/比较寄存器，因此对于一个定时器来说，4\n路输出的 PWM\n频率（周期）是相同的，而不同通道的占空比可以是不同的。\n\n对 GPIO 和 TIM3 进行初始化：\nvoid TIM_Config(void){\n    GPIO_InitTypeDef GPIO_InitStructure;\n    \n    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE); // GPIOB 时钟打开\n    RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE); // TIM3 时钟打开\n    \n    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1;\n    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP; // 复用推挽输出\n    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; // 输出 50MHz\n    GPIO_Init(GPIOB, &amp;GPIO_InitStructure);\n}\n定时器 TIM3 配置：\nvoid TIM_Init(uint16_t arr, uint16_t duty){\n    TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure;\n    TIM_OCInitTypeDef TIM_OCInitStructure;\n    \n    TIM_DeInit(TIM3);\n    TIM_TimeBaseStructure.TIM_Period = arr - 1;\t// 自动重装载寄存器的值\n    TIM_TimeBaseStructure.TIM_Prescaler = 1; // 时钟预分频数\n    TIM_TimeBaseStructure.TIM_ClockDivsion = 0x0; // 采样分频\n    TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;\n    TIM_TimeBaseInit(TIM3, &amp;TIM_TimeBaseStructure);\n    \n    TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1; // TIM 的 PWM1 模式\n    TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;\n    TIM_OCInitStructure.TIM_Pulse = duty; // 设置占空比\n    TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High; // TIM 输出比较极性高\n   \tTIM_OC4Init(TIM3, &amp;TIM_OCInitStructure);\n    \n    TIM_OC4PreloadConfig(TIM3, TIM_OCPreload_Enable); // 使能定时器 TIM3 在 CCR3 上的预装在寄存器\n    TIM_ARRPreloadConfig(TIM3, ENABLE); // 使能定时器 TIM3 在 ARR 上的预装载寄存器\n    TIM_Cmd(TIM3, ENABLE); // 使能定时器3\n}\n计数模式：\n\nCubeMX 配置计时器：\n\n定时器的开关函数：\nHAL_TIM_Base_Start_IT(&amp;htim2); // 开启定时器及溢出中断\nHAL_TIM_Base_Stop_IT(&amp;htim2); // 关闭定时器及溢出中断\nHAL_TIM_Base_Strat(&amp;htim2); // 开启定时器（不开启中断）\nHAL_TIM_Base_Stop(&amp;htim2); // 关闭定时器\nPWM 配置：\n\n\n\n\nPrescaler 预分频系数：等待多少个时钟周期增加一次计数\nCounter Model 计数模式：向上、向下或者中间对齐等\nCounter Period 计数周期：重新开始计数前所要计数的最大数量\nInternal Clock Division 内部时钟分频：另一种时钟分频方法\nauto-reload-preload\n自动重装载：当计数达到最大时，重新启动计数器\n\n\n\n\n\n\n\n\n\n\nCalculate the PWM frequency\n\nSystem Clock is 72 MHz: We can \"count\" 72-million times each\nsecond\n8-bit resolution(0-255): Each cycle is 256 \"counts\"\n\n\nPWM frequency = 218250 Hz\n\n\nMode 模式：PWM1 、PWM2\n\n\n\n模式\n计数器 CNT 计数方式\n说明\n\n\n\n\nPWM1\n递增\nCNT&lt;CCR，通道 CH 为有效，否则为无效\n\n\n\n递减\nCNT&gt;CCR，通道 CH 为无效，否则为有效\n\n\nPWM2\n递增\nCNT&lt;CCR，通道 CH 为无效，否则为有效\n\n\n\n递减\nCNT&gt;CCR，通道 CH 为有效，否则为无效\n\n\n\nPulse 占空比：Counter Periode 之间的一个数\n\nHAL 库代码：\n#include \"stm32f1xx_hal.h\"\n\nTIM_HandleTypeDef htim2;\n\nvoid SystemClock_Config(void);\nvoid Error_Handler(void);\n\nvoid PWM_Init(void)\n{\n    TIM_OC_InitTypeDef sConfigOC;\n\n    htim2.Instance = TIM2;\n    htim2.Init.Prescaler = 7199;\n    htim2.Init.CounterMode = TIM_COUNTERMODE_UP;\n    htim2.Init.Period = 999;\n    htim2.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;\n    if (HAL_TIM_PWM_Init(&amp;htim2) != HAL_OK)\n    {\n        Error_Handler();\n    }\n\n    sConfigOC.OCMode = TIM_OCMODE_PWM1;\n    sConfigOC.Pulse = 499;\n    sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;\n    sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;\n    if (HAL_TIM_PWM_ConfigChannel(&amp;htim2, &amp;sConfigOC, TIM_CHANNEL_1) != HAL_OK)\n    {\n        Error_Handler();\n    }\n\n    HAL_TIM_MspPostInit(&amp;htim2);\n}\n\nint main(void)\n{\n    HAL_Init();\n    SystemClock_Config();\n\n    __HAL_RCC_GPIOA_CLK_ENABLE();\n    GPIO_InitTypeDef GPIO_InitStruct;\n    GPIO_InitStruct.Pin = GPIO_PIN_0;\n    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;\n    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;\n    HAL_GPIO_Init(GPIOA, &amp;GPIO_InitStruct);\n\n    PWM_Init();\n\n    HAL_TIM_PWM_Start(&amp;htim2, TIM_CHANNEL_1);\n\n    while (1)\n    {\n    }\n}\n修改频率:\n可以通过修改预分频器（Prescaler）和计数周期（Period）的值来改变 PWM\n信号的频率。\n例如，假设你希望生成 1 kHz 的 PWM 信号：\nhtim2.Init.Prescaler = 71;\nhtim2.Init.Period = 999;\n","slug":"MCU/STM32-PWM","date":"2023-02-13T10:57:00.000Z","categories_index":"单片机","tags_index":"STM32,PWM","author_index":"爱慢跑的乌龟"},{"id":"927bf395dd3f4c1ed23a8c2f2923f289","title":"脉冲宽度调制 PWM","content":"脉冲宽度调制 PWM\n\n\n\n\n\n\n\n\n\n脉宽调制(PWM)\n或脉冲持续时间调制(PDM)是一种通过有效地将电信号分成离散部分来降低电信号传输的平均功率的方法。馈送到负载的电压（和电流）的平均值通过快速打开和关闭电源与负载之间的开关来控制。同关断周期相比，开关开启的时间越长，提供给负载的总功率就越高。PWM\n特别适用于运行惯性负载，例如电机看，这些负载不容易受到这种离散开关的影响，因为它们的惯性导致它们反应缓慢。PWM\n开关频率必须足够高，以不影响负载，也就是说，负载感知到的合成波形必须尽可能平滑。\n占空比 Duty cycle\n占空比是指“开启”时间与固定间隔时间（周期）的比例；低占空比对应于低功率，因为电源大部分时间都是关闭的。占空比以百分比表示，100%表示完全开启。当数字信号在一半时间打开，另一半时间关闭时，数字信号的占空比为\n50%，类似于“方波”。\n\n\n占空比 Duty cycle\n\n原理 Principle\n脉宽调制使用矩形脉冲波，调制其脉冲宽度，导致波形平均值发生变化。如果我们考虑一个脉冲波形，其周期为 、最小值为 、最大值为  以及占空比 ，则其波形的平均值为：  因为  是脉冲波，当\n 时，其值为 ；当  时，其值为 ，上式可写为：  其中，，。因此，信号的平均值直接取决于占空比 。\n生成 PWM\n信号的最简单方法时交叉方法，它只需要一个锯齿波或三角波和一个比较器。当参考信号（红色正弦波）的值大于调制波形（蓝色）时，PWM\n信号（洋红色）处于高电平状态，否则处于电平状态。\n\n\nSPWM\n\nSimulink 生成 SPWM波\n\n正弦波\n\n它是基频(逆变器输出电压所需的频率)上的参考信号。\n\n锯齿波\n\n它是高频载波。\n\n参考波与载波相比较\n当 参考波 &gt; 载波，输出为高；当 参考波 &lt; 载波，输出为低。\n\n\n三个正弦波信号发生器，频率均为 ，相位相差\n120°。一个锯齿波信号发生器，其频率为 1000 Hz，相位是 180°。\n\n正弦波与锯齿波信号比较，生成 SPWM 信号：\n\n","slug":"Control/脉冲宽度调制 PWM","date":"2023-02-12T07:48:00.000Z","categories_index":"自动控制","tags_index":"PWM","author_index":"爱慢跑的乌龟"},{"id":"23c137308b786700ec637a83e6f97ae6","title":"特征值与特征向量","content":"在数学上，特别是线性代数中，对于一个给定的线性变换 ，它的特征向量  经过这个线性变换的作用之后，得到的新向量仍然与原来的  保持在同一条直线上。但其长度或许会发生改变。即  其中  为标量，即特征向量的长度在该线性变换下缩放的比例，称为其特征值。\n线性变换： \n\n若 ，则  ， 和  在一条直线上。\n\n\n2 -  的特征值\n -  的特征向量\n\n求解特征值和特征向量？ \n\n若上述方程组有非零解，则  解得  ，将求得的  代入  中，即  所得的  就是特征值  所对应的特征向量。\n\n应用：化对角矩阵，解耦（Decouple）\n， 和  为特征向量，P: coordinate transformation matrix  令 ，，同时左乘  得：  微分方程组，State-Space rep  矩阵形式：  状态方程：\n\n\n\n\n\n\n\n\n\n\n\n令  ，则 ， ：  左乘 ：  得： \n\n解得： ， ， 和  为常数。 \n","slug":"Math/特征值与特征向量","date":"2023-02-11T02:26:00.000Z","categories_index":"数学","tags_index":"特征值与特征向量","author_index":"爱慢跑的乌龟"},{"id":"d97c1a68285e6aac869410b1223c6673","title":"矩阵的导数运算(1)","content":"矩阵的导数运算 (1)\n标量方程对向量的导数：\n定义： \n\n - 标量 []\n\n- 向量 []\n\n\n\n\n\n\n\n\n\n\n求导结果的行数与分母相同，称为分母布局(Denominator\nLayout)\n\n\n\n\n\n\n\n\n\n\n行数和分子相同，称为分子布局(Numerator Layout)\n例\n\n\n\n\n\n\n\n\n\n，\n\n分母布局\n\n分子布局\n向量方程对向量的导数\n\n\n 分母布局\n常用特例\n若 ,\n, 则 \n\n若 ,\n , 则 .\n当 A 为对称矩阵时，, \n\n\n\n\n\n\n\n\n\n : 二次型\n","slug":"Math/矩阵的导数运算1","date":"2023-02-10T08:37:00.000Z","categories_index":"数学","tags_index":"矩阵求导","author_index":"爱慢跑的乌龟"},{"id":"eb44103d9200dfa14741693bcd11c4b0","title":"Python MongoDB","content":"PyMongo\nPython 要连接 MongoDB 需要MongoDB 驱动，这里使用 PyMongo 驱动连接。\npip 安装\n\n\n\n\n\n\n\n\n\n$ pip install pymongo\n安装指定版本：\n\n\n\n\n\n\n\n\n\n$ pip install pymongo==3.5.1\n测试PyMongo\nimport pymongo\n创建数据库\n创建一个数据库\nimport pymongo\n\nmyclient - pymongo.MongoClient(&quot;mongodb:&#x2F;&#x2F;localhost:27017&#x2F;&quot;)\nmydb &#x3D; myclient[&#39;runoobdb&#39;]\n判断数据库是否存在·\nimport pymongo\n\nmyclient - pymongo.MongoClient(&#39;mongodb:&#x2F;&#x2F;localhost:27017&#39;)\n\ndblist &#x3D; myclient.list_database_names()\nif &quot;runoobdb&quot; in dblist:\n    print(&quot;数据库已存在&quot;)\n创建集合\nMongoDB 中的集合类似 SQL 的表\n创建一个集合\nimport pymongo\n\nmyclient &#x3D; pymongo.MongoClient(&quot;mongodb:&#x2F;&#x2F;localhost:27017&#x2F;&quot;)\nmydb &#x3D; myclient[&quot;runoobdb&quot;]\n\nmycol &#x3D; mydb[&quot;sites&quot;]\n判断集合是否存在\nimport pymongo\n\nmyclient &#x3D; pymongo.MongoClient(&quot;mongodb:&#x2F;&#x2F;localhost:27017&#x2F;&quot;)\n\nmydb &#x3D; myclient[&quot;runoobdb&quot;]\n\ncollist &#x3D; mydb.list_collection_names()\nif &quot;sites&quot; in collist:\n    print(&quot;集合已存在&quot;)\n增、删、改、查等操作\n\n\n\n\n\n\n\n\n\nPytho Mongodb 插入文档\n插入集合\n集合中插入文档使用insert_one方法，该方法的第一参数是字典name =&gt; value对。\nimport pymongo\n\nmyclient &#x3D; pymongo.MongoClient(&quot;mongodb:&#x2F;&#x2F;localhost:27017&#x2F;&quot;)\nmydb &#x3D; myclient[&quot;runoobdb&quot;]\nmycol &#x3D; mydb[&quot;sites&quot;]\n\nmydict &#x3D; &#123;&quot;name&quot;: &quot;RUNOOB&quot;, &quot;alexa&quot;: &quot;10000&quot;, &quot;url&quot;: &quot;https:&#x2F;&#x2F;www.runoob.com&quot;&#125;\n\nx &#x3D; mycol.insert_one(mydict)\nprint(x)\n执行的输出结果：\n\n\n\n\n\n\n\n\n\n&lt;pymongo.results.InsertOneResult object at 0x10a34b288&gt;\n返回 _id 字段\ninsert_one()方法返回 InsertOneResult 对象，该对象包含 inserted_id 属性，它是插入文档的 id 值\nimport pymongo\n\nmyclient &#x3D; pymongo.MongoClient(&#39;mongodb:&#x2F;&#x2F;localhost:27017&#x2F;&#39;)\nmydb &#x3D; myclient[&#39;runoobdb&#39;]\nmycol &#x3D; mydb[&#39;sites&#39;]\n\nmydict &#x3D; &#123;&quot;name&quot;: &quot;Google&quot;, &quot;alexa&quot;: &quot;1&quot;, &quot;url&quot;: &quot;https:&#x2F;&#x2F;www.google.com&quot;&#125;\n\nx &#x3D; mycol.insert_one(mydict)\n\nprint(x.inserted_id)\n执行输出结果为：\n\n\n\n\n\n\n\n\n\n5b2369cac315325f3698a1cf\n插入多个文档\n集合中插入多个文档使用 insert_many() 方法，该方法的第一个参数是字典列表。\nimport pymongo\n\nmyclient &#x3D; pymongo.MongoClient(&quot;mongodb:&#x2F;&#x2F;localhost:27017&#x2F;&quot;)\nmydb &#x3D; myclient[&quot;runoobdb&quot;]\nmycol &#x3D; mydb[&quot;sites&quot;]\n \nmylist &#x3D; [\n  &#123; &quot;name&quot;: &quot;Taobao&quot;, &quot;alexa&quot;: &quot;100&quot;, &quot;url&quot;: &quot;https:&#x2F;&#x2F;www.taobao.com&quot; &#125;,\n  &#123; &quot;name&quot;: &quot;QQ&quot;, &quot;alexa&quot;: &quot;101&quot;, &quot;url&quot;: &quot;https:&#x2F;&#x2F;www.qq.com&quot; &#125;,\n  &#123; &quot;name&quot;: &quot;Facebook&quot;, &quot;alexa&quot;: &quot;10&quot;, &quot;url&quot;: &quot;https:&#x2F;&#x2F;www.facebook.com&quot; &#125;,\n  &#123; &quot;name&quot;: &quot;知乎&quot;, &quot;alexa&quot;: &quot;103&quot;, &quot;url&quot;: &quot;https:&#x2F;&#x2F;www.zhihu.com&quot; &#125;,\n  &#123; &quot;name&quot;: &quot;Github&quot;, &quot;alexa&quot;: &quot;109&quot;, &quot;url&quot;: &quot;https:&#x2F;&#x2F;www.github.com&quot; &#125;\n]\n \nx &#x3D; mycol.insert_many(mylist)\n \n# 输出插入的所有文档对应的 _id 值\nprint(x.inserted_ids)\ninsert_many() 方法返回 InsetManyResult 对象，该对象包含 inserted_ids 属性，该属性保存着所有插入文档的 id 值。\n插入指定 _id 的多个文档\n我们也可以自己指定 id，插入，以下实例我们在 site2 集合中插入数据，**_id** 为我们指定的：\nimport pymongo\n \nmyclient &#x3D; pymongo.MongoClient(&quot;mongodb:&#x2F;&#x2F;localhost:27017&#x2F;&quot;)\nmydb &#x3D; myclient[&quot;runoobdb&quot;]\nmycol &#x3D; mydb[&quot;site2&quot;]\n \nmylist &#x3D; [\n  &#123; &quot;_id&quot;: 1, &quot;name&quot;: &quot;RUNOOB&quot;, &quot;cn_name&quot;: &quot;菜鸟教程&quot;&#125;,\n  &#123; &quot;_id&quot;: 2, &quot;name&quot;: &quot;Google&quot;, &quot;address&quot;: &quot;Google 搜索&quot;&#125;,\n  &#123; &quot;_id&quot;: 3, &quot;name&quot;: &quot;Facebook&quot;, &quot;address&quot;: &quot;脸书&quot;&#125;,\n  &#123; &quot;_id&quot;: 4, &quot;name&quot;: &quot;Taobao&quot;, &quot;address&quot;: &quot;淘宝&quot;&#125;,\n  &#123; &quot;_id&quot;: 5, &quot;name&quot;: &quot;Zhihu&quot;, &quot;address&quot;: &quot;知乎&quot;&#125;\n]\n \nx &#x3D; mycol.insert_many(mylist)\n \n# 输出插入的所有文档对应的 _id 值\nprint(x.inserted_ids)\n\n\n\n\n\n\n\n\n\nPython Mongodb 查询文档\n查询集合中所有数据\nfind() 方法可以查询集合中的所有数据，类似 SQL 中的 SELECT * 操作。\nimport pymongo\n\nmyclient &#x3D; pymongo.MongoClient(&quot;mongodb:&#x2F;&#x2F;localhost:27017&#x2F;&quot;)\nmydb &#x3D; myclient[&#39;runoobdb&#39;]\nmycol &#x3D; mydb[&#39;sites&#39;]\n\nfor x in mycol.find():\n    print(x)\n查询指定字段的数据\n可以使用 find() 方法来查询指定字段的数据，将要返回的字段对应值设置为1。\nimport pymongo\n\nmyclient &#x3D; pymongo.MongoClient(&quot;mongodb:&#x2F;&#x2F;localhost:27017&#x2F;&quot;)\nmydb &#x3D; myclient[&quot;runoobdb&quot;]\nmycol &#x3D; mydb[&quot;sites&quot;]\n\nfor x in mycol.find(&#123;&#125;, &#123;&quot;_id&quot;: 0, &quot;name&quot;: 1, &quot;alexa&quot;: 1&#125;)\n根据指定条件查询\n可以在 find() 中设置参数来过滤数据。\nimport pymongo\n\nimport pymongo\n \nmyclient &#x3D; pymongo.MongoClient(&quot;mongodb:&#x2F;&#x2F;localhost:27017&#x2F;&quot;)\nmydb &#x3D; myclient[&quot;runoobdb&quot;]\nmycol &#x3D; mydb[&quot;sites&quot;]\n \nmyquery &#x3D; &#123; &quot;name&quot;: &quot;RUNOOB&quot; &#125;\n \nmydoc &#x3D; mycol.find(myquery)\n \nfor x in mydoc:\n  print(x)\n高级查询\nimport pymongo\n \nmyclient &#x3D; pymongo.MongoClient(&quot;mongodb:&#x2F;&#x2F;localhost:27017&#x2F;&quot;)\nmydb &#x3D; myclient[&quot;runoobdb&quot;]\nmycol &#x3D; mydb[&quot;sites&quot;]\n \nmyquery &#x3D; &#123; &quot;name&quot;: &#123; &quot;$gt&quot;: &quot;H&quot; &#125; &#125;\n \nmydoc &#x3D; mycol.find(myquery)\n \nfor x in mydoc:\n  print(x)\n使用正则表达式查询\nimport pymongo\n \nmyclient &#x3D; pymongo.MongoClient(&quot;mongodb:&#x2F;&#x2F;localhost:27017&#x2F;&quot;)\nmydb &#x3D; myclient[&quot;runoobdb&quot;]\nmycol &#x3D; mydb[&quot;sites&quot;]\n \nmyquery &#x3D; &#123; &quot;name&quot;: &#123; &quot;$regex&quot;: &quot;^R&quot; &#125; &#125;\n \nmydoc &#x3D; mycol.find(myquery)\n \nfor x in mydoc:\n  print(x)\n返回指定条数记录\n要对查询结果设置指定条数的记录可以使用 limit() 方法，该方法只接受一个数字参数。\nimport pymongo\n \nmyclient &#x3D; pymongo.MongoClient(&quot;mongodb:&#x2F;&#x2F;localhost:27017&#x2F;&quot;)\nmydb &#x3D; myclient[&quot;runoobdb&quot;]\nmycol &#x3D; mydb[&quot;sites&quot;]\n \nmyresult &#x3D; mycol.find().limit(3)\n \n# 输出结果\nfor x in myresult:\n  print(x)\n\n\n\n\n\n\n\n\n\nPython Mongodb 修改文档\n可以在 MongoDB 中使用 update_one() 方法修改文档中的记录。该方法第一个参数为查询条件，第二个参数为要修改的字段。\nimport pymongo\n \nmyclient &#x3D; pymongo.MongoClient(&quot;mongodb:&#x2F;&#x2F;localhost:27017&#x2F;&quot;)\nmydb &#x3D; myclient[&quot;runoobdb&quot;]\nmycol &#x3D; mydb[&quot;sites&quot;]\n \nmyquery &#x3D; &#123; &quot;alexa&quot;: &quot;10000&quot; &#125;\nnewvalues &#x3D; &#123; &quot;$set&quot;: &#123; &quot;alexa&quot;: &quot;12345&quot; &#125; &#125;\n \nmycol.update_one(myquery, newvalues)\n \n# 输出修改后的  &quot;sites&quot;  集合\nfor x in mycol.find():\n  print(x)\nupdate_one() 方法只能修改匹配到的第一条记录，如果要修改所有匹配到的记录，可以使用 update_many()。\nimport pymongo\n \nmyclient &#x3D; pymongo.MongoClient(&quot;mongodb:&#x2F;&#x2F;localhost:27017&#x2F;&quot;)\nmydb &#x3D; myclient[&quot;runoobdb&quot;]\nmycol &#x3D; mydb[&quot;sites&quot;]\n \nmyquery &#x3D; &#123; &quot;name&quot;: &#123; &quot;$regex&quot;: &quot;^F&quot; &#125; &#125;\nnewvalues &#x3D; &#123; &quot;$set&quot;: &#123; &quot;alexa&quot;: &quot;123&quot; &#125; &#125;\n \nx &#x3D; mycol.update_many(myquery, newvalues)\n \nprint(x.modified_count, &quot;文档已修改&quot;)\n\n\n\n\n\n\n\n\n\n排序\nsort() 方法可以指定升序或降序排序。\nsort() 方法第一个参数为要排序的字段，第二个字段指定排序规则，1为升序，-1为降序，默认为升序。\nimport pymongo\n\nmyclient &#x3D; pymongo.MongoClient(&quot;mongodb:&#x2F;&#x2F;localhost:27017&#x2F;&quot;)\nmydb &#x3D; myclient(&quot;runoob&quot;)\nmycol &#x3D; mydb[&quot;sites&quot;]\n\nmydoc &#x3D; mycol.find().sort(&quot;alexa&quot;)\nfor x in mydoc:\n    print(x)\n\n\n\n\n\n\n\n\n\nPython Mongodb 删除数据\n我们可以使用delete_one() 方法来删除一个文档，该方法第一个参数为查询对象，指定要删除的数据。\nimport pymongo\n\nmyclient &#x3D; pymongo.MongoClient(&quot;mongodb:&#x2F;&#x2F;localhost:27017&#x2F;&quot;)\nmydb &#x3D; myclient[&quot;runoobdb&quot;]\nmycol &#x3D; mydb[&quot;sites&quot;]\n \nmyquery &#x3D; &#123; &quot;name&quot;: &quot;Taobao&quot; &#125;\n \nmycol.delete_one(myquery)\n \n# 删除后输出\nfor x in mycol.find():\n  print(x)\n可以使用 delete_many() 方法来删除多个文档，该方法第一个参数为查询对象，指定要删除哪些数据。\nimport pymongo\n \nmyclient &#x3D; pymongo.MongoClient(&quot;mongodb:&#x2F;&#x2F;localhost:27017&#x2F;&quot;)\nmydb &#x3D; myclient[&quot;runoobdb&quot;]\nmycol &#x3D; mydb[&quot;sites&quot;]\n \nmyquery &#x3D; &#123; &quot;name&quot;: &#123;&quot;$regex&quot;: &quot;^F&quot;&#125; &#125;\n \nx &#x3D; mycol.delete_many(myquery)\n \nprint(x.deleted_count, &quot;个文档已删除&quot;)\n删除集合中的所有文档\ndelete_many() 方法如果传入的是一个空的查询对象，则会删除集合中的所有文档：\nimport pymongo\n \nmyclient &#x3D; pymongo.MongoClient(&quot;mongodb:&#x2F;&#x2F;localhost:27017&#x2F;&quot;)\nmydb &#x3D; myclient[&quot;runoobdb&quot;]\nmycol &#x3D; mydb[&quot;sites&quot;]\n \nx &#x3D; mycol.delete_many(&#123;&#125;)\n \nprint(x.deleted_count, &quot;个文档已删除&quot;)\n删除集合\n可以使用 drop() 方法来删除一个集合。\nimport pymongo\n \nmyclient &#x3D; pymongo.MongoClient(&quot;mongodb:&#x2F;&#x2F;localhost:27017&#x2F;&quot;)\nmydb &#x3D; myclient[&quot;runoobdb&quot;]\nmycol &#x3D; mydb[&quot;sites&quot;]\n \nmycol.drop()\nCounting\nIf we just want to know how many document match a query we can perform a count_documents() operation instead of a full query. We can get a count of all the documents in a collection:\nposts.count_documents(&#123;&#125;)\nof just of those documents that match a specific query:\nposts.count_documents(&#123;&quot;author&quot;: &quot;Mike&quot;&#125;)\nRange Queries\nMongoDB supports many different types of advanced queries.\nAs an example, lets perform a query where we limit reults to posts older than a certain date, but also sort the results by author:\nd &#x3D; datetime.datetime(2009, 11, 12, 12)\nfor post in posts.find(&#123;&quot;date&quot;: &#123;&quot;$lt&quot;: d&#125;&#125;).sort(&quot;author&quot;):\n    pprint.pprint(post)\nHere we use the special $lt operator to do a range query, and also call sort() to sort the results by author.\nIndexing\nAdding indexes can help accelerate certain queries and can also additional functionality to querying and storing documents. In this example, we'll demonstrate how to craete a unique index on a key that rejects documents whose value for that key already exists in the index.\nFirst, we'll need to create the index:\nresult &#x3D; db.profiles.create_index([(&#39;user_id&#39;, pymongo.ASCENDING)], unique&#x3D;True)\nsorted(list(db.profiles.index_information()))\n\n\n\n\n\n\n\n\n\nNotice that we have two indexes now: one is the index on _id that MongoDB creats automatically, and the other is the index on user_id we just created.\nThe index prevents us from inserting a document whose user_id is already in the collections:\nnew_profile &#x3D; &#123;&#39;user_id&#39;: 213, &#39;name&#39;: &#39;Drew&#39;&#125;\nduplicate_profile &#x3D; &#123;&#39;user_id&#39;: 212, &#39;name&#39;: &#39;Tommy&#39;&#125;\nresult &#x3D; db.profiles.insert_one(new_profile)  # This is fine.\nresult &#x3D; db.profiles.insert_one(duplicate_profile)\n# output:\nTraceback (most recent call last):\nDuplicateKeyError: E11000 duplicate key error index: test_database.profiles.$user_id_1 dup key: &#123; : 212 &#125;\n\n\n\n\n\n\n\n\n\nIndexes\nIndexes support the efficient execution of queries in MongoDB. Without indexes, MongoDB must perform a collection scan, i.e. scan every document in a collection, to select those documents that match the query statement. If an appropriate index exists for a query, MongoDB can use the index to limit the number of document it must inspect.\nIndexes are special data structures that store a small portion of the collection's data set in an easy to traverse form. The index stores the value of a specific field or set of fields, ordered by the value of the field. The ordering of the index entries supports efficient equality matches and range-based query operarions. In addition, MongoDB can return sorted results by using the ordering in the index.\nThe following diagram illustrates a query that selects and orders the matching document using an index:\n\nindex1\n\nExamples\n\nAggregation Examples\nAuthentication Examples\nCollations\nCopying a Database\nCustom Type Example\nBulk Write Operations\nDatetimes and Timezones\nGeospatial Indexing Example\nGevent\nGridFS Example\nHigh Availability and PyMongo\nPyMongo and mod_wsgi\nServer Selector Example\nTailable Cursors\nTLS/SSL and PyMongo\nClient-Side Field Level Encryption\nHandling UUID Data\n\n","slug":"Pyhon/PythonMongodb","date":"2022-10-20T07:00:00.000Z","categories_index":"Python","tags_index":"Python tips","author_index":"爱慢跑的乌龟"},{"id":"736e2225b7c206e1f84f77a4e032b64a","title":"STM32 I2C 通信","content":"I2C 总线介绍\nI2C 的定义\nInter-intergrated Circuit 的缩写，最初由 PHILIPS 公司推出。用于短距离设备之间的低速串行通信，如处理器和外围器件的通线。只需要 2 根信号线，具有总线时钟同步和仲裁机制，允许多主机通信。传输速率在标准模式下可达 100 kbit/s，快速模式下 400 kbit/s，高速模式下可达 3.4 Mbit/s。设备通过协议层中的地址区分，可选择 7 位或 10 位地址，连接到总线的 IC 数量仅受到最大负载电容 400 pF 的限制。\n\nI2C 总线规约\n起始和停止条件\n\n总线空闲时，总线上的电平都是高电平。\n\n起始信号：SCL 总线为高电平，SDA 总线由高电平变为低电平\n停止信号：SCL 总线为高电平，SDA 总线由低电平变为高电平\n\n数据传输\n\nSCL 为高电平时为数据的有效窗口期，这段时间需要 SDA 线保持其电平状态，达到数据传输的效果。SCL为低电平的时期为数据准备期，这段时间需要 SDA 尽快调整电平至下一位待传数据位。\n所有的串行总线都以 bit为 单位传输数据，I2C 总线按照高位（MSB）在前的方式，每次传输 1 个字节（1Byte = 8bit），然后必须跟一个响应位，当这一位是低电平时，才算有效响应（ACK）。完成这一轮完整的传输后，才能继续传输后续字节数据。\n总线时钟同步\n\nI2C 硬件使用开漏模式，所以总线上的电平以低电平优先。2 个 Master 设备发起通讯，2 号 Master 的时钟 CLK2 比 CLK1 要晚一点。当 2号 Master 发现自己的 CLK 为 “1” 时，总线SCL上已经是“0”了，它就会提前调整自己的时序，马上拉低 CLK，赶上大部队的节奏。当 1 号 Master 发现自己的 CLK 已经为 “1” 时，总线SCL上还是 “0”，它就会放慢自己的脚步，一直等待总线变为 “1”，接着跟大家一起走。\n总线仲裁\n\n2 个 Master 的 CLK 已经完成了时钟同步后，如果在某一时刻同时发出起始信号，准备通信，I2C 总线是通过 SDA 的仲裁机制来实现调解的。1 号和 2 号 Master 都发送了数据 “0”，接着1号 Master 发送了数据 “1”。而此时 2 号 Master 仍然保持数据 “0”。这种情况下，SDA 总线上的数据与发送 “0” 的 2 号 Master 保持一致。1 号 Master 监测到了总线数据与自己的数据冲突，它便自动退出通信过程，将使用权让出。\nSTM32 I2C 总线功能\n\n速率\n\n标准模式：100 kbit/s\n快速模式：400 kbit/s\n\n模式\n\n主机模式\n从机模式：支持 2 个从机地址\n\n中断\n\n通讯过程的各阶段中断\n错误标志\n\n滤波\n\n模拟噪声滤波器\n可编程数字滤波器\n\n\n\n\n数据寄存器 - DR\n地址寄存器 - OAR1\n第二地址寄存器 - OAR2\n校验寄存器 - PEC\n控制寄存器 - CR1/2\n状态寄存器 - SR1/2\n时钟控制寄存器 - CCR\n\nCubeMx 配置\n\nRCC - 选择外部晶振、PLL、主频\n调试口 - 选择调试模式，占用调试 IO 口\nIO 分配 - 打开相应外设开关，默认 IO 或手动选择\n速率、地址、主从、时序\n\n\n\n","slug":"MCU/STM32-I2C","date":"2022-10-18T02:21:00.000Z","categories_index":"单片机","tags_index":"STM32,I2C","author_index":"爱慢跑的乌龟"},{"id":"f421a58a89600265fb1eeb9a03b677f4","title":"STM32 SPI 通信","content":"SPI 通信原理及特点\nSPI，Serial Peripheral interface，串行外围设备接口。是 Motorola 首先在其 MC68HCXX 系列处理器上定义的。SPI 接口主要应用在 EEPROM、FLASH、实时时钟、AD 转换器，还有数字信号处理器和数字信号解码器之间。\nSPI 的优点：\n\n一主多从\n同步通信\n高速全双工，可达几十 Mbps\n\nSPI 通讯协议时序\n\nSCK：时钟信号\nMISO：主收从发\nMOSI：主发从收\nNSS：片选信号\n\nSPI 通讯有 4 种时序模式，由 SPI 控制寄存器 SPI_CR1 中的 CPOL 和 CPHA 位控制。\n\nCPOL(Clock Polority) 时钟极性\nCPHA(Clock Phase) 时钟相位\n\n\n\nCPOL=0：时钟低电平总线空闲\nCPOL=1：时钟高电平总线空闲\nCPHA=0：第一个跳变沿\nCPHA=1：第二个跳变沿\n\nSPI 的 4 种时序模式：\n\n\n\nSPI 时序模式\nCPOL\nCPHA\n空闲时钟电平\n采样时刻\n\n\n\n\n模式 0\n0\n0\n低电平\n第 1 个跳变沿\n\n\n模式 1\n0\n1\n低电平\n第 2 个跳变沿\n\n\n模式 2\n1\n0\n高电平\n第 1 个跳变沿\n\n\n模式 3\n1\n1\n高电平\n第 2 个跳变沿\n\n\n\nSTM32 SPI 总线\n主要功能：\n\n支持 8bit 或 16bit 的数据帧格式，可设置 MSB/LSB 先行\n支持主、从机模式\n片选信号的管理模式可选硬件或软件\n硬件 CRC 校验功能\n支持中断、DMA\n支持 Motorola 模式和 TI 模式\n支持半双工模式（单线单向、单线双向）\n\n中断\n\n\n\nInterrupt event\nEvent flag\nEnable Control bit\n\n\n\n\nTransmit buffer empty flag\nTXE\nTXEIE\n\n\nReceive buffer not empty flag\nRXNE\nRXNEIE\n\n\nMaster Mode fault event\nMODF\nERRIE\n\n\nOverrun error\nOVR\nERRIE\n\n\nCRC error flag\nCRCERR\nERRIE\n\n\nTI frame format error\nFRE\nERRIE\n\n\n\nSTM32CubeMX软件配置\nStep 1：RCC 时钟、SW调试口\nStep 2：SPIx 选择、I/O 管脚选择\nStep 3：SPI 参数、中断、DMA\n\nHAL 库函数分析\n查询模式（阻塞模式）\nHAL_SPI_Transmit(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size, uint32_t Timeout);\n\nHAL_SPI_Receive(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size, uint32_t Timeout);\n\nHAL_SPI_TransmitReceive(SPI_HandleTypeDef *hspi, uint8_t *pTxData, uint8_t *pRxData, uint16_t Size, uint32_t Timeout);\n中断模式\nHAL_SPI_Transmit_IT(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size);\n\nHAL_SPI_Receive_IT(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size);\n\nHAL_SPI_TransmitReceive_IT(SPI_HandleTypeDef *hspi, uint8_t *pTxData, uint8_t *pRxData, uint16_t Size);\nDMA 模式\nHAL_SPI_Transmit_DMA(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size);\n\nHAL_SPI_Receive_DMA(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size);\n\nHAL_SIP_TransmitReceive_DMA(SPI_HandleTypeDef *hspi, uint8_t *pTxData, uint8_t *pRxData, uint16_t Size);\nSTM32 HAL 库 SPI 通讯\n串行 FLash 芯片 W25Q128\n\n\n\n\n\n\n\n\n\n如何看 Datasheet?\n1、主要特点\n2、电气特性\n3、管脚定义\n4、通讯时序\n5、应用说明\nW25Q28 的驱动程序\n\n判断芯片存在\n读数据（查询/DMA）\n写使能、写禁止\n写数据（是否核查）\n扇区擦除、块擦除、芯片擦除\n\n&#x2F;* File: W25Q128.h *&#x2F;\n#ifndef __W25Q128_H\n#define __W25Q128_H\n\n#ifedf __cplusplus\nextern &quot;C&quot; &#123;\n#endif\n#include &quot;main.h&quot;\n\n    \n&#x2F;&#x2F; W25X系列&#x2F;Q系列芯片列表\n&#x2F;&#x2F; W25Q80\tID\t0XEF13\n&#x2F;&#x2F; W25Q16\tID\t0XEF14\n&#x2F;&#x2F; W25Q32\tID\t0XEF15\n&#x2F;&#x2F; W25Q64\tID\t0XEF16\n&#x2F;&#x2F; W25Q128\tID\t0XEF17\n&#x2F;&#x2F; W25Q256\tID\t0XEF18\n\n#define W25Q80 0XEF13\n#define W25Q16 0XEF14\n#define W25Q32 0XEF15\n#define W25Q64 0XEF16\n#define W25Q128 0XEF17\n#define W25Q256 0XEF18\n\n#define NumByteOfPage  \t\t256\n#define\tNumPageOfSector  \t16\n#define NumSectorOfBlock\t16\n#define NumBlockOfChip\t\t256\n\n#define NumByteOfSector\tNumByteOfPage * NumPageOfSector\n#define NumByteOfBlock\tNumByteOfSector * NumSectorOfBlock\n#define FLACH_SZIE \t\tNumByteOfBlock * NumBlockOfChip\n\n#define W25Q128_CS_0\tHAL_GPIO_WritePin(SPI1_CS_GPIO_Port, SPI1_CS_Pin, GPIO_PIN_RESET)\n#define W25Q128_CS_1\tHAL_GPIO_WritePin(SPI1_CS_GPIO_Port, SPI1_CS_Pin, GPIO_PIN_SET)\n\n&#x2F;* 指令表 *&#x2F;\n#define\tW25X_WriteEnable \t\t0x06\n#define\tW25X_WriteDisable\t\t0x04\n#define\tW25X_ReadStatusReg1 \t0x05\n#define\tW25X_ReadStatusReg2\t\t0x35\n#define\tW25X_ReadStatusReg3\t\t0x15\n#define\tW25X_WriteStatusReg1\t0x01\n#define W25X_WriteStatusReg2\t0x31\n#define\tW25X_WriteStatusReg3\t0x11\n#define W25X_ReadData  \t\t    0x03\n#define W25X_FastReadData\t\t0x0B\n#define W25X_FastReadDual\t\t0x3B\n#define\tW25X_PageProgram\t\t0x02\n#define W25X_BlockErase\t\t\t0xD8\n#define W25X_SectorErase\t\t0x20\n#define W25X_ChipErase\t\t\t0xC7\n#define W25X_PowerDown\t\t\t0xB9\n#define W25X_ReleasePowerDown\t 0xAB\n#define W25X_DeviceID\t\t\t0xAC\n#define W25X_ManufactDeviceID\t 0x90\n#define W25X_JedecDeviceID\t\t 0x9F\n#define W25X_Enable4ByteAddr\t 0xB7\n#define W25X_Exit4ByteAddr\t\t 0xE9\n\nuint8_t W25QXX_Init(void);\nuint16_t W25QXX_ReadID(void);\t\t    &#x2F;&#x2F; 读取 FLASH ID\nuint8_t W25QXX_ReadSR(uint8_t regno);\t&#x2F;&#x2F; 读取寄存器器\nvoid W25QXX_4ByteAddr_Enable(void);\t\t&#x2F;&#x2F; 使能 4 字节地址模式\nvoid W25QXX_Write_SR(uint8_t regno, uint_8 sr); &#x2F;&#x2F; 写状态寄存器\nvoid W25QXX_Write_Enable(void);\t\t\t&#x2F;&#x2F; 写使能\nvoid W25QXX_Write_Enable(void);\t\t\t&#x2F;&#x2F; 写保护\nvoid W25QXX_Write_NoChech(uint8_t *pBuffer, uint32_t WriteAdd, uint16_t NumByteToWrite); \nvoid W25QXX_Read(uint8_t *pBuffer, uint32_t ReadAddr, uint16_t NumByteToWrite);&#x2F;&#x2F; 读取 flash\nvoid W25QXX_Read_DMA(uint8_t *pBuffer, uint32_t ReadAddr, uint16_t NumByteToRead);&#x2F;&#x2F; 读取 flsh\nvoid W25QXX_Write(uint8_t *pBuffer, uint32_t WriteAddr, uint16_t NumByteToWrite);&#x2F;&#x2F; 写入 flash\nvoid W25QXX_Erase_Chip(void);\t\t&#x2F;&#x2F; 整片擦除\nvoid W25QXX_Erase_Sector(uint32_t Dst_Addr);\t&#x2F;&#x2F; 扇区擦除\nvoid W25QXX_Erase_Block(uint32_t Dst_Addr);\t&#x2F;&#x2F; \t块擦除\nvoid W25QXX_Wait_Busy(void);\t\t&#x2F;&#x2F; 等待空闲\nvoid W25QXX_PowerDown(void);\t\t&#x2F;&#x2F; 进入掉电模式\nvoid W25QXX_WAKEUP(void);\t\t\t&#x2F;&#x2F; 唤醒\n\n#ifdef __cplusplus\n&#125;\n#endif &#x2F;* __W25Q128_H *&#x2F; \n\n\n\n\n\n\n\n\n\n\nextern \"C\" 的主要作用就是为了能够正确实现 C++ 代码调用其他 C 语言代码。加上 extern \"C\" 后，会指示编译器这部分代码按 C 语言进行编译，而不是 C++的。由于 C++ 支持函数重载，因此编译器编译函数的过程中会将函数的参数类型也加到编译后的代码中，而不仅仅是函数名；而 C 语言并不支持函数重载，因此编译 C 语言代码的函数时不会带上函数的参数类型，一般只包括函数名。\n通过 extern \"C\"，告诉 g++ 编译器，不要对这些函数进行 Name mangling，按照 C 编译器的方式取生成符号表符号。\n\n\n\n\n\n\n\n\n\n__cplusplus 和 c_plusplus 这两个宏有定义，说明使用的c++的编译器。\n&#x2F;* File W25Q128.c *&#x2F;\n#include &quot;W25Q128.h&quot;\n\nextern SPI_HandleTypeDef hspi1;\n\nuint16_t W25QXX_TYPE;\nuint8_t SPI1_RX_BUF[4096];\n\n&#x2F;&#x2F; 初始化 SPI FLASH 的 IO 口\nuint8_t W25QXX_Init(void)&#123;\n    W25Q128_CS_1;\t\t&#x2F;&#x2F; SPI FLASH 不选中\n    W25QXX_TYPE &#x3D; W25QXX_ReadID(); &#x2F;&#x2F; 读取 FLASH ID\n    if(W25QXX_TYPE &#x3D;&#x3D; W25Q128)&#123;\n        return 1;\n    &#125;else&#123;\n        return 0;\n    &#125;\n&#125;\n\n&#x2F;&#x2F; 读取 W25QXX 的状态寄存器\nuint8_t W25QXX_ReadSR(uint8_t regno)&#123;\n    uint8_t cmd[2];\n    uint8_t temp[2];\n    switch(regno)&#123;\n        case 1:\n            cmd[0] &#x3D; W25X_ReadStatusReg1;\n            break;\n        case 2:\n            cmd[0] &#x3D; W25X_ReadStatusReg2;\n        case 3:\n            cmd[0] &#x3D; W25X_ReadStatusReg3;\n        default:\n            cmd[0] &#x3D; W25X_ReadStatusReg1;\n            break;\n    &#125;\n    W25Q128_CS_0;\n    &#x2F;&#x2F; Poll mode\n    &#x2F;&#x2F; 发送指令和接收简单数据推荐使用查询模式\n    HAL_SPI_TransmitReceive(&amp;hspi1, cmd, temp, 2, 10); &#x2F;&#x2F; 发送读转台寄存器命令\n    W25Q128_CS_1;\n    return temp[1];\n&#125;\n\n&#x2F;&#x2F; 写 W25QXX 状态寄存器\nvoid W25QXX_Write_SR(uint8_t regno, uint8_t sr)&#123;\n    uint8_t cmd[2];\n    switch(regno)&#123;\n        case 1: \n            cmd[0] &#x3D; W25X_WriteStatusReg1;\n        case 2:\n            cmd[0] &#x3D; W25X_WriteStatusReg2;\n        case 3:\n            cmd[0] &#x3D; W25X_WriteStatusReg3;\n        default:\n            cmd[0] &#x3D; W25X_WriteStatusReg1;\n    &#125;\n    cmd[1] &#x3D; sr;\n    W25Q128_CS_0;\n    HAL_SPI_Transmit(&amp;hspi1, cmd, 2, 10);\n    W25Q128_CS_1;\n&#125;\n\n&#x2F;&#x2F; W25QXX 写使能\n&#x2F;&#x2F; 将 WEL 置位\nvoid W25QXX_Write_Enable(void)&#123;\n    uint8_t cmd &#x3D; W25X_WriteEnable;\n    W25Q128_CS_0;\n    HAL_SPI_Transmit(&amp;hspi1, &amp;cmd, 1, 10);\n    W25Q128_CS_1;\n&#125;\n\n&#x2F;&#x2F; W25QXX 写禁止\n&#x2F;&#x2F; 将 WEL 清零\nvoid W25QXX_Write_Disable(void)&#123;\n    uint8_t cmd &#x3D; W25X_WriteDisable;\n    W25Q128_CS_0;\n    HAL_SPI_Transmit(&amp;hspi1, &amp;cmd, 1, 10);\n    W25Q128_CS_1;\n&#125;\n\n&#x2F;&#x2F; 等待空闲\nvoid W25QXX_Wait_Busy(void)&#123;\n    while((W25QXX_ReadSR(1)&amp;0x01) &#x3D;&#x3D; 0x01); &#x2F;&#x2F; 等待 BUSY 位清空\n&#125;\n\n&#x2F;&#x2F; 进入掉电模式\nvoid W25QXX_PowerDown(void)&#123;\n    uint8_t cmd &#x3D; W25X_PowerDown;\n    W25Q128_CS_0;\n    HAL_SPI_Transmit(&amp;hspi1, &amp;cmd, 1, 10);\n    W25Q128_CS_1;\n    HAL_Delay(1);\n&#125;\n\n&#x2F;&#x2F; 唤醒\nvoid W25QXX_WAKEUP(void)&#123;\n    uint8_t cmd &#x3D; W25X_ReleasePowerDown;\n    W25Q128_CS_0;\n    HAL_SPI_Transmit(&amp;hspi1, &amp;cmd, 1, 10);\n    W25Q128_CS_1;\n    HAL_Delay(1);\n&#125;\n","slug":"MCU/STM32 SPI","date":"2022-10-16T02:19:00.000Z","categories_index":"单片机","tags_index":"STM32,SPI","author_index":"爱慢跑的乌龟"},{"id":"3d33cea6f7241857ab27348fe640e83f","title":"STM32-通用定时器","content":"通用定时器功能概述\n通用定时器功能\n\n输入捕获(Input Capture)\n输出比较(Output Compare)\n生成 PWM 波\n测量 PWM 周期和占空比\n定时器同步\n定时器串联\n\n结构框图\n\n时序：\n\n\n\n\n\n\n\n\n\n\n预分频系数由 1 修改到 2 时，并不会立即生效，而是要等到下一个 UEV 产生之后才会生效。\n\n\n\n\n\n\n\n\n\n\n当 ARPE = 0 时，修改 TIMx_ARR 寄存器的值会立即生效。计数器的值到达 36 就会产生 UEV 。\n\n\n\n\n\n\n\n\n\n\n当 ARPE = 1 时，修改 TIMx_ARR 寄存器的值不会立即生效。计数器计数到 F5 产生 UEV 后，新的 TIMx_ARR 寄存器值 36 才会生效。\n\n\n\n\n\n\n\n\n\n\nCNT_EN 位使能定时器，计数器经过一个 CK_CNT 周期之后开始计数。UG 位为软件更新位，使定时器复位。\n捕获/比较通道\n捕获/比较通道由 3 个阶段组成。\n\n输入阶段：通道作为输入引脚\n捕获/比较主电路：捕获/比较寄存器 CCR 与计数器进行比较。\n输出阶段：输出阶段就是根据设置的工作模式和控制逻辑，控制输出引脚的电平。\n\n使用捕获/比较通道，通用定时器可以实现如下功能：\n\n输入捕获：可以用于测量一个时钟信号的频率，脉冲宽度等。\n输出比较：将计数器 CNT 的值与 CCR 寄存器比较，控制输出引脚的电平。\nPWM 生成：通过设置 ARR 寄存器和 CCR 寄存器的值，在计数器的值 CNT 变换的过程中，输出 PWM 波。PWM 波的频率由 ARR 寄存器决定，占空比由 CCR 寄存器决定。\n\n典型功能的原理和 HAL 驱动\n生成 PWM 波\n生成 PWM 波相关函数\n&#x2F;* Timer PWM functions ********************************************************&#x2F;\n&#x2F;* PWM 波的配置初始化，需要先执行 HAL_TIM_Base_Init() 进行定时器初始化 *&#x2F;\nHAL_StatusTypeDef HAL_TIM_PWM_Init(TIM_HandleTypeDef *htim);\nHAL_StatusTypeDef HAL_TIM_PWM_DeInit(TIM_HandleTypeDef *htim);\nvoid HAL_TIM_PWM_MspInit(TIM_HandleTypeDef *htim);\nvoid HAL_TIM_PWM_MspDeInit(TIM_HandleTypeDef *htim);\n&#x2F;* 配置 PWM 输出通道 *&#x2F;\nHAL_StatusTypeDef HAL_TIM_PWM_ConfigChannel(TIM_HandleTypeDef *htim, TIM_OC_InitTypeDef *sConfig, uint32_t Channel);\n&#x2F;* Blocking mode: Polling *&#x2F;\n&#x2F;* 启动生成 PWM 波，需要先执行 HAL_TIM_Base_Start() 启动定时器 *&#x2F;\nHAL_StatusTypeDef HAL_TIM_PWM_Start(TIM_HandleTypeDef *htim, uint32_t Channel);\n&#x2F;* 停止生成 PWM 波 *&#x2F;\nHAL_StatusTypeDef HAL_TIM_PWM_Stop(TIM_HandleTypeDef *htim, uint32_t Channel);\n&#x2F;* Non-Blocking mode: Interrupt *&#x2F;\n&#x2F;* 以中断方式生 PWM 波，需要先执行 HAL_TIM_Base_Start_IT() 启动定时器 *&#x2F;\nHAL_StatusTypeDef HAL_TIM_PWM_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel);\n&#x2F;* 停止生成 PWM 波 *&#x2F;\nHAL_StatusTypeDef HAL_TIM_PWM_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel);\n&#x2F;* Non-Blocking mode: DMA *&#x2F;\n&#x2F;* 定时器不常用 DMA 模式 *&#x2F;\nHAL_StatusTypeDef HAL_TIM_PWM_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length);\nHAL_StatusTypeDef HAL_TIM_PWM_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel);\n&#x2F;* 返回定时器状态，与 HAL_TIM_Base_GetState() 函数功能相同 *&#x2F;\nHAL_TIM_StateTypeDef HAL_TIM_PWM_GetState(TIM_HandleTypeDef *htim);\n&#x2F;* 使能 CCR 寄存器的预装载功能，为 CCR 设置的新值在下个 UEV 发生时才更新到 CCR 寄存器 *&#x2F;\n__HAL_TIM_ENABLE_OCxPRELOAD(__HANDLE__, __CHANNEL__);\n&#x2F;* 禁止 CCR 寄存器的预装载功能，为 CCR 设置的新值会立刻更新到 CCR 寄存器 *&#x2F;\n__HAL_TIM_DISABLE_OCxPRELOAD(__HANDLE__, __CHANNEL__);\n&#x2F;* 启用一个通道快速模式 *&#x2F;\n__HAL_TIM_ENABLE_OCxFAST(__HANDLE__, __CHANNEL__);\n&#x2F;* 禁用一个通道快速模式 *&#x2F;\n__HAL_TIM_DISABLE_OCxFAST(__HANDLE__, __CHANNEL__);\n&#x2F;* 当计数器的值等于 CCR 寄存器的值时产生输出比较事件，这是对应和回调函数 *&#x2F;\nvoid HAL_TIM_PWM_PulseFinishedCallback(TIM_HandleTypeDef *htim);\n输出比较\n输出比较(Output Compare) 用于控制输出波形，或指示经过了某一段时间。 工作原理：用寄存器 CCR 的值与计数器值 CNT 比较，当两个寄存器的值匹配时，产生输出比较结果 OCxREF，比较结果可以输出到通道引脚。比较匹配时，输出引脚电平可以是：\n\n冻结(Frozen) - 保持电平\n有效电平(Active level) - 有效电平由设置的通道极性决定\n无效电平(Inactive level) -\n翻转(Toggle)\n\n\n定时器中断事件类型定义：\n#define TIM_IT_UPDATE\tTIM_DIER_UIE                         &#x2F;*!&lt; Update interrupt            *&#x2F;\n#define TIM_IT_CC1      TIM_DIER_CC1IE                       &#x2F;*!&lt; Capture&#x2F;Compare 1 interrupt *&#x2F;\n#define TIM_IT_CC2      TIM_DIER_CC2IE                       &#x2F;*!&lt; Capture&#x2F;Compare 2 interrupt *&#x2F;\n#define TIM_IT_CC3      TIM_DIER_CC3IE                       &#x2F;*!&lt; Capture&#x2F;Compare 3 interrupt *&#x2F;\n#define TIM_IT_CC4      TIM_DIER_CC4IE                       &#x2F;*!&lt; Capture&#x2F;Compare 4 interrupt *&#x2F;\n#define TIM_IT_COM      TIM_DIER_COMIE                       &#x2F;*!&lt; Commutation interrupt       *&#x2F;\n#define TIM_IT_TRIGGER  TIM_DIER_TIE                         &#x2F;*!&lt; Trigger interrupt           *&#x2F;\n#define TIM_IT_BREAK    TIM_DIER_BIE                         &#x2F;*!&lt; Break interrupt             *&#x2F;\n","slug":"MCU/STM32-通用定时器","date":"2022-10-15T02:18:00.000Z","categories_index":"单片机","tags_index":"STM32,通用定时器","author_index":"爱慢跑的乌龟"},{"id":"2ae7b4c0b172c3bdb43c36df10c5338e","title":"STM32-基础定时器","content":"定时器概述\nSTM32F103ZET6 有 2 个高级定时器(Advanced-control timer)、4 个通用定时器(General-purpose timer)和 2 个基本定时器(Basic timer):\n\n\n\n类型\n定时器\n计数器分辨率\n计数类型\n产生 DMA 请求\n捕获/比较通道\n互补输出\n挂载总线\n\n\n\n\n基础\nTIM6，TIM7\n16位\n向上\n有\n0\n无\nAPB 1\n\n\n通用\nTIM2，TIM3，TIM4，TIM5\n16位\n向上、向下、向上/向下\n有\n4\n无\nAPB 1\n\n\n高级\nTIM1，TIM8\n16位\n向上、向下、向上/向下\n有\n4\n有\nAPB 2\n\n\n\n定时器的时钟信号来源：\n\n基础定时器的结构和功能\nTIM 6 和 TIM 7 是基础定时器，它们的功能相同\n\n只能使用内部时钟信号 CK_INT\n16 位自动重装载寄存器(auto-reload register)\n16 位可编程预分频器，分频范围 1-65536\n可以用于出发 DAC 的同步电路\n只有一种事件引起中断——计数器上溢时产生更新事件\n\n\n它有 3 个 16 位的寄存器，这三个寄存器值都可以读写。其中，预分频寄存器和自动重装载寄存器有影子寄存器用于底层工作。\n\n预分频寄存器(TIMx_PSC)\n计数寄存器(TIMx_CNT) - 计数溢出时产生更新事件(Update Event, UEV) 中断\n自动重装载寄存器(TIMx_ARR) - 存储的值用于与计数器的值比较，当计数器的值等于 ARR 的值时产生 UEV 事件，计数的周期个数等于 (1 + ARR)\n\n假设 CK_INT 的频率位 50 MHZ，预分频系数设置位 50000，则计数器时钟频率为  \n若自动重装载寄存器的值为 999，则定时器周期为 1000 ms，计数溢出时产生 UEV 事件。\n基础定时器 HAL 驱动程序\n基础定时器相关函数：\n\n\n\n函数名\n功能描述\n\n\n\n\nHAL_TIM_Base_Init()\n定时器初始化，设置各种参数和连续定时模式\n\n\nHAL_TIM_Base_MspInit()\n弱函数，在 HAL_TIM_Base_Init() 中被调用，需要重新实现\n\n\nHAL_TIM_OnePulse_Init()\n将定时器配置为单次定时模式，需要先执行 HAL_TIM_Base_Init()\n\n\nHAL_TIM_Base_Start()\n以轮询方式启动定时器，不会产生中断\n\n\nHAL_TIM_Base_Stop()\n停止轮询方式的定时器\n\n\nHAL_TIM_Base_Start_IT()\n以中断方式启动定时器，发生 UEV 事件时产生中断\n\n\nHAL_TIM_Base_Stop_IT()\n停止中断方式工作的定时器\n\n\nHAL_TIM_Base_Start_DMA()\n以 DMA 方式启动定时器\n\n\nHAL_TIM_Base_Stop_DMA()\n停止以 DMA 方式工作的定时器\n\n\nHAL_TIM_Base_GetState()\n获取基础定时器的当前状态\n\n\n\n中断处理：\n每个定时器有一个中断，基础定时器只有一个 UEV 中断源，但是通用定时器和高级定时器有多个中断事件源。\n\n\n\n函数名\n功能描述\n\n\n\n\n__HAL_TIM_GET_FLAG()\n获取某个事件是否触发的标志，就是读取状态寄存器 TIMx_SR 中相应的中断事件位是否置 1\n\n\n__HAL_TIM_GET_IT_SOURCE()\n判断是否是某个事件产生的中断，返回值为 SET 或 RESET\n\n\n__HAL_TIM_CLEAR_IT()\n清除某个事件的中断标志，就是将状态寄存器 TIMx_SR 中相应的中断事件位清 0\n\n\n__HAL_TIM_ENABLE_IT()\n启用某个事件的中断，就是将中断使能寄存器 TIMx_DIER 中相应事件位置 1\n\n\n__HAL_TIM_DISABLE_IT()\n禁用某个事件的中断，就是将中断使能寄存器 TIMx_DIER 中相应事件位清 0\n\n\n__HAL_TIM_IRQHandler()\n定时器 ISR 函数里的通用处理函数\n\n\n__HAL_TIM_PeriodElapsedCallback()\n弱函数，UEV 事件中断的回调函数\n\n\n\n","slug":"MCU/STM32-基础定时器","date":"2022-10-15T02:12:00.000Z","categories_index":"单片机","tags_index":"STM32,基础定时器","author_index":"爱慢跑的乌龟"},{"id":"da1a2b22445c6e9d06b74da423642c5e","title":"STM32 DMA","content":"DMA 的介绍\n直接内存访问(Direct memory accesss，DMA)\n用于在外设和内存之间以及内存到内存之间提供高速的数据传输。数据可以通过\nDMA 快速传输，不需要任何 CPU 操作。这样可以节约 CPU 资源。\n两个 DMA 控制器总共有 12 个通道（7 个用于 DMA1，5 个用于 DMA\n2），每个通道专门用于管理来自一个或多个外设的内存访问请求。它有一个仲裁器来处理\nDMA 请求之间的优先级。\nDMA 的主要特性\n\n12 个独立配置的通道：7 个用于 DMA1，5 个用于 DMA2\n每个通道都连接到专门的硬件 DMA\n请求，每个通道上也支持软件触发。该配置有软件完成\nDMA 通道请求的优先级是软件可编程的(very high、high、medium 和 low\n四个优先级别)\n独立的源和目标传输大小(byte, half word,\nword)，模拟打包和拆包。源/目的地址必须在数据大小上对齐\n支持环形缓冲区管理\n3 个事件标志（DMA 半传输、DMA 传输完成和 DMA\n传输错误）在逻辑上“或”在每个通道的单个中断请求中组合在一起\n内存间传输\n外设到内存和内存到外设，以及外设到外设的传输\n访问 Flash、SRAM、APB1、APB2 和 AHB 外设作为源和目标\n可编程传输数据数: 最多 65536 个\n\n\nDMA 功能描述\nDMA 控制器通过与 Cortex-M3® 内核共享系统总线来执行直接内存传输。当\nCPU 和 DMA 访问同一目标（内存或外设）时，DMA\n请求可能会在某些总线周期内停止 CPU\n对系统总线的访问。总线矩阵实现轮询调度，从而确保 CPU\n至少有一半的系统总线带宽（内存和外设）。\nDMA 事务\n事件发生后，外设向 DMA 控制器发送请求信号。DMA\n控制器根据通道优先级为请求提供服务。一旦 DMA 控制器访问外设，DMA\n控制器就会向外设发送确认信号。外设在从 DMA\n控制器获得确认信号后立即释放其请求。外设取消断言请求后，DMA\n控制器将释放确认。如果有更多的请求，外设可以发起下一个事务。\n总之，每次 DMA 传输由三个操作组成：\n\n从外设数据寄存器或通过内部当前外设/内存地址寄存器寻址的内存中的某个位置加载数据。首次传输的起始地址是\nDMA_CPARx 或 DMA_CMARx 寄存器中的外设/内存基地址\n存储加载到外设数据寄存器中的数据，或者通过内部当前外设/内存地址寄存器所寻址的内存中的某个位置的数据首次传输的起始地址是\nDMA_CPARx 或 DMA_CMARx 寄存器中的外设/内存基地址\nDMA_CNDTRx 寄存器递减，其中包含尚未执行的事务数。\n\n仲裁器\n仲裁器根据通道请求的优先级管理通道请求，并启动外设/内存访问序列。\n优先级分两个阶段管理：\n\n软件：每个通道的优先级可以在 DMA_CCRx 寄存器中配置。共有 4 个等级：\n\nVery high priority\nHigh priority\nMedium priority\nLow priority\n\n硬件：如果 2\n个请求具有相同的软件优先级，则编号最小的通道将获得优先级，而不是编号最高的通道。例如，通道\n2 优先于通道 4。\n\nDMA 通道\n每个通道都可以处理位于固定地址的外设寄存器和内存地址之间的 DMA\n传输。要传输的数据量（最多\n65535）是可编程的。包含要传输的数据项数量的寄存器在每次传输后递减。\n数据大小\n外设和内存传输数据大小是可以通过 DMA_CCRx 寄存器的 PSIZE 和 MSIZE\n位设置的。\n指针递增\n根据 DMA_CCRx 寄存器中的 PINC 和 MINC\n位，外设和内存指针可以在每个事务之后自动进行增加。如果使能了增量模式，则下一次传输的地址将根据选择的数据大小在上一次的地址上增加\n1、2 或 4。第一次传输的地址在 DMA_CPARx/DMA_CMARx\n寄存器中。在传输过程中，这些寄存器的值将保持初始值不变。软件不可访问当前传输地址。\n如果通道被配置位非环形模式，在最后一次传输之后，不再为 DMA\n请求提供服务。若要加载新的待传输数据项到 DMA_CNDTRx 寄存器，则需要禁用\nDMA 通道。\n\n\n\n\n\n\n\n\n\n如果 DMA 通道被禁用，DMA 寄存器并不会被重置。在通道配置阶段，DMA\n寄存器(DMA_CCRx, DMA_CPARx and DMA_CMARx) 保持编程的初始值。\n在环形模式下，最后一次传输之后，DMA_CNDTRx\n寄存器会自动加载初始编程值。当前的内部地址寄存器重新加载\nDMA_CPARx/DMA_CMARx 寄存器中的基地址值。\n通道配置步骤\n\n在 DMA_CPARx\n寄存器中设置外设寄存器地址。数据将在外设事件发生后从这个地址移动到内存，或从内存移动到这个地址。\n在 DMA_CMARx\n寄存器中设置内存地址。在外设事件发生之后，将数据写入这个内存，或从中读取数据。\n配置 DMA_CNDTRx\n寄存器中待传输数据的总数。在每个外设事件之后，这个值将递减。\n配置通道优先级，DMA_CCRx 寄存器的 PL[1:0] 位\n在 DMA_CCRx 寄存器中配置数据传输方向、Circular\n模式、外设&amp;内存增量模式、外设&amp;内存数据大小和中断（半传输或完成传输之后）\n使能通道，DMA_CCRx 寄存器的 ENABLE 位\n\n一旦通道使能，它可以为连接到该通道上外设的任何请求提供服务。\n传输一半的字节后，将设置半传输标志(HTIF)，如果设置了半传输中断启用位(HTIE)，则会生成中断。在传输结束时，设置传输完成标志(TCIF)，如果设置了传输完成中断启用位(TCIE)，则会生成中断。\nCircular 模式\nCircular 模式用于处理环形缓冲区和连续数据流。DMA_CCRx 寄存器的 CIRC\n位用于使能该模式。当激活环形模式，待传输数据的数量自动加载为初始值，这个初始值是在通道配置阶段编程写入的，将持续为\nDMA 请求提供服务。\nMemory-to-memory 模式\nDMA通道也可以在没有外设请求触发的情况下工作。这个模式就是 Memory to\nMemory 模式。\n当设置了 DMA_CCRx 寄存器的 MEM2MEM 位，然后设置 DMA_CCRx\n寄存器中的使能位(EN)，则通道在软件启用后立即启动传输。一旦 DMA_CNDTRx\n寄存器达到零，传输就会停止。Memory to Memory 模式不能与 Circular\n模式同时使用。\n可编程的数据宽度，数据对齐或大小端\n当 PSIZE 和 MSIZE 不相等时，DMA执行如下的数据对齐。\n\n寻址不支持字节或半字写操作的\nAHB 外设\n当 DMA 开始 AHB 字节或半字写操作时，数据在 HWDATA[31:0]\n总线的未使用通道上复制。因此，当使用的 AHB\n从外设不支持字节或半字写入操作（当外设不使用 HSIZE\n时）并且不产生任何错误时，DMA 将写入 32 个 HWDATA\n位，如下面的两个示例所示：\n\n为了写半字 0xABCD，DMA 将 HWDATA 总线设置为\n0xABCDABCD，HSIZE = halfword\n为了写入字节 0xAB，DMA 将 HWDATA 总线设置为\n0xABABABAB，HSIZE = Byte\n\n假设 AHB/APB 桥是 AHB 32 位从外设，不考虑 HSIZE\n数据，它将按以下方式将任何 AHB 字节或半字操作转换为 32位 APB 操作：\n\nAHB 字节数据 0xB0 写入到 0x0(0x1/0x2/0x3)的操作将转换为\nAPB 字数据 0xB0B0B0B0 写入到 0x0\nAHB 半字数据 0xB1B0 写入到 0x0(0x1)的操作将转换为 APB\n字数据 0xB1B0B1B0 写入到 0x0\n\n例如，要写入 APB 备份寄存器（与 32 位地址边界对齐的 16\n位寄存器），必须将 MSIZE 配置为 16-bit，将 PSIZE 配置为\n32-bit。\n错误管理\n读取或写入保留的地址空间可能会产生 DMA 传输错误。当 DMA\n读取或写入访问期间发生 DMA\n传输错误时，错误通道通过硬件清除相应通道配置寄存器(DMA_CCRx) 中的 EN\n位自动禁用。设置DMA_IFR 寄存器中的通道传输错误中断标志(TEIF)，如果设置了\nDMA_CCRx 寄存器中的传输错误中断使能位(TEIE)，则生成中断。\n中断\n中断可以在每个 DMA\n通道的半传输、传输完成或传输错误三种情况下产生。\n\n\n\nInterrupt event\nEvent flag\nEnable Control bit\n\n\n\n\nHalf-transfer\nHTIF\nHTIE\n\n\nTransfer complete\nTCIF\nTCIE\n\n\nTransfer error\nTEIF\nTEIE\n\n\n\nDMA 请求映射\nDMA1 控制器\n来自外设(TIMx[1, 2, 3, 4]、ADC1、SPI1、SPI/I2S2、I2Cx[1, 2] 和\nUSARTx[1, 2, 3])的 7 个请求在进入 DMA1 之前只需在逻辑上进行\nOR，这意味着一次只能启用一个请求。\n外设 DMA 请求可以通过在相应外设的寄存器中对 DMA\n控制位进行编程来独立激活/取消激活。\n\n\nDMA2 控制器\n来自外设(TIMx[5, 6, 7, 8]、ADC3、SPI/I2S3、UART4、DAC_Channel[1, 2]\n和 SDIO)的 5 个请求在进入 DMA1 之前只需在逻辑上进行\nOR，这意味着一次只能启用一个请求。\n外设 DMA 请求可以通过在相应外设的寄存器中对 DMA\n控制位进行编程来独立激活/取消激活。\n\n\nDMA 寄存器\nDMA 中断状态寄存器 (DMA_ISR)\nAddress offset: 0x00 Reset value: 0x0000 0000\n\nTEIFx: 通道(x=1..7)传输错误标志\n由硬件设置。通过软件将 1 写入 DMA_IFCR\n寄存器中的相应位来清除它。\n\n0 - 通道 x 没有传输错误(TE)\n1 - 通道 x 上发生传输错误(TE)\n\nHTIFx: 通道(x=1..7)半传输标志\n由硬件设置。通过软件将 1 写入 DMA_IFCR\n寄存器中的相应位来清除它。\n\n0 - 通道 x 上没有半传输(HT)事件\n1 - 通道 x 上发生了半传输(HT)事件\n\nTCIFx: 通道(x=1..7)传输完成标志\n由硬件设置。通过软件将 1 写入 DMA_IFCR\n寄存器中的相应位来清除它。\n\n0 - 通道 x 上没有传输完成(TC)事件\n1 - 通道 x 上发生了传输完成(TC)事件\n\nGIFx: 通道(x=1..7)全局中断标志\n由硬件设置。通过软件将 1 写入 DMA_IFCR\n寄存器中的相应位来清除它。\n\n0 - 通道 x 上没有TE、HT或TC事件\n1 - 通道 x 发生了TE、HT或TC事件\n\nDMA中断标志清除寄存器\n(DMA_IFCR)\nAddress offset: 0x04 Reset value: 0x0000 0000\n\nCTEIFx: 通道(x=1..7)传输错误中断标志清除\n由软件设置和清除。\n\n0 - 无作用\n1 - 清除 DMA_ISR 寄存器中相应的 TEIF 标志\n\nCHTIFx: 通道(x=1..7)半传输中断标志清除\n由软件设置和清除。\n\n0 - 无作用\n1 - 清除 DMA_ISR 寄存器中相应的 HTML 标志\n\nCTCIFx: 通道(x=1..7)传输完成中断标志清除\n由软件设置和清除。\n\n0 - 无作用\n1 - 清除 DMA_ISR 寄存器中相应的 TCIF 标志\n\nCGIFx: 通道(x=1..7)全局中断标志清除\n由软件设置和清除。\n\n0 - 无作用\n1 - 清除 DMA_ISR 寄存器中相应的TCIF 标志\n\nDMA通道 x\n配置寄存器 (DMA_CCRx) (x=channel number)\nAddress offset: 0x08 + 0d20 × (channel number – 1) Reset value:\n0x0000 0000\n\nMEM2MEM: Memory to memory 模式\n由软件设置和清除\n\n0 - Disabled\n1 - Enabled\n\nPL[1:0]: 通道优先级\n由软件设置和清除\n\n00 - Low\n01 - Medium\n10 - High\n11 - Very high\n\nMSIZE[1:0]: Memory size\n由软件设置和清除\n\n00 - 8-bits\n01 - 16-bits\n10 - 32-bits\n11 - Reserved\n\nPSIZE[1:0]: Peripheral size\n由软件设置和清除\n\n00 - 8-bits\n01 - 16-bits\n10 - 32-bits\n11 - Reserved\n\nMINC: Memory increment mode\n由软件设置和清除\n\n0 - Disabled\n1 - Enabled\n\nPINC: Peripheral increment mode\n由软件设置和清除\n\n0 - Disabled\n1 - Enabled\n\nCIRC: Circular mode\n由软件设置和清除\n\n0 - Disabled\n1 - Enabled\n\nDIR: 数据传输方向\n由软件设置和清除\n\n0 - 从外设读取\n1 - 从内存读取\n\nTEIE: 传输错误中断使能\n由软件设置和清除\n\n0 - Disabled\n1 - Enabled\n\nHTIE: 半传输中断使能\n由软件设置和清除\n\n0 - Disabled\n1 - Enabled\n\nTCIE: 传输完成中断使能\n由软件设置和清除\n\n0 - Disabled\n1 - Enabled\n\nEN - 通道使能\n由软件设置和清除\n\n0 - Disabled\n1 - Enabled\n\nDMA 通道 x\n数据数量寄存器 (DMA_CNDTRx) (x=channel number)\nAddress offset: 0x0C + 0d20 × (channel number – 1) Reset value:\n0x0000 0000\n\nNDT[15:0]: 待传输的数据数量\n要传输的数据数量(0 ~\n65535)。此寄存器只能在禁用通道时写入。启用通道后，此寄存器是只读的，指示要传输的剩余字节。此寄存器在每次\nDMA\n传输后递减。传输完成后，如果通道配置为自动重载，则此寄存器可以保持为零，也可以通过先前编程的值自动重新加载模式。\n如果此寄存器为零，则无论通道是否启用，都无法提供任何事务。\nDMA通道 x\n外设地址寄存器(DMA_CPARx) (x=channel number)\nAddress offset: 0x10 + 0d20 × (channel number – 1) Reset value:\n0x0000 0000\n当通道启用时，不能写入此寄存器。\n\nPA[31:0]: 外设地址\n读取/写入数据的外设数据寄存器的基址。\n\n当 PSIZE 为 01 (16位)时，忽略 PA[0]\n位。访问自动对齐到半字地址\n当 PSIZE 为 10 (32位)时，忽略 PA[1:0]\n位。访问将自动与字地址对齐。\n\nDMA通道 x\n内存地址寄存器 (DMA_CMARx) (x=channel number)\nAddress offset: 0x14 + 0d20 × (channel number – 1) Reset value:\n0x0000 0000\n当通道启用时，不能写入此寄存器。\n\nMA[31:0]: 内存地址\n读取/写入数据的内存区域的基址。\n\n当 MSIZE为 01 (16位)时，忽略 MA[0]\n位。访问自动对齐到半字地址\n当 MSIZE为 10 (32位)时，忽略 MA[1:0]\n位。访问将自动与字地址对齐。\n\n","slug":"MCU/STM32-DMA","date":"2022-10-14T16:00:00.000Z","categories_index":"单片机","tags_index":"STM32,DMA","author_index":"爱慢跑的乌龟"},{"id":"123422951594fa2cdc8f869cafbfa775","title":"STM32 中断和事件","content":"嵌套向量中断控制器 (NVIC)\n特点\n\n68条 (不包括 16 条 Cortex®-M3 中断线)\n16 个可编程优先级 (使用 4 位中断优先级)\n低延迟异常和中断处理\n系统控制寄存器的实现\n\nNVIC\n和处理器核心接口紧密耦合，使得低延迟中断处理和高效处理延迟到达的中断成为可能。\n包括核心异常在内的所有中断都由 NVIC 管理。\nSysTick 校准值寄存器\nSysTick 校准值设置为 9000，其中 SysTick 时钟设置为 9 MHz\n(最大HCLK/8)，参考时间基数为 1 ms。\n外部中断/事件控制器 (EXTI)\n外部中断/事件控制器由多达 20\n个连接线设备中的边缘检测器组成，或其他设备中的 19\n个边缘检测器，用于产生事件/中断请求。每个输入线都可以独立配置类型（事件或中断）和相应的触发事（上升或下降或二者都有）。每条线也可以独立屏蔽。挂起寄存器维护中断请求的状态线。\n主要特点\n\n每个中断/事件线可以独立的触发和屏蔽\n每个中断线有专有的状态位\n产生多达 20 个软件事件/中断请求\n检测脉冲宽度低于 APB2 时钟周期的外部信号。\n\n框图\n\n唤醒事件管理\nSTM32F10xxx 能够处理外部或内部事件，以唤醒核心\n(WFE)。唤醒事件可以通过以下方式产生:\n\n在外设控制寄存器中启用中断，但在 NVIC 中不启用中断，并在 Cortex®-M3\n系统控制寄存器中启用 SEVONPEND 位。当 MCU 从 WFE\n恢复时，外设中断挂起位和外设 NVIC IRQ 通道挂起位(在 NVIC\n中断清除挂起寄存器中)必须被清除。\n或者在事件模式下配置外部或内部 EXTI 线路。当 CPU 从 WFE\n恢复时，无需清除外设中断挂起位或 NVIC IRQ\n通道暂挂位作为事件行对应的暂挂位未设置。\n\n在连线设备中，以太网唤醒事件也具有 WFE 唤醒能力。\n功能描述\n若要产生中断，必须配置并使能中断线：\n\nFalling trigger 和 Rising trigger 两个触发寄存器\n置位中断屏蔽寄存器(Interrupt mask register)的相关位，使能中断\n置位中断线对应的挂起位(Pending request register)\n\n若要产生事件，必须配置并使能事件线：\n\nFalling trigger 和 Rising trigger 两个触发寄存器\n置位事件屏蔽寄存器(Event mask register)的相关位，使能事件\n\n中断/事件请求也可以由软件向中断/事件寄存器中写入 1\n来产生。\n硬件中断选择\n配置 20 条线路作为中断源：\n\n配置 20 条中断线的屏蔽位 (EXTI_IMR)\n配置中断线的触发选择位 (EXTI_RTSR, EXTI_FTSR)\n配置控制 NVIC IRQ\n通道映射到外部中断控制器(EXTI)的使能和屏蔽位，以便能够正确识别来自20\n条中断线的中断。\n\n硬件事件选择\n配置 20 条线路作为事件源：\n\n配置 20 条事件线的屏蔽位 (EXTI_EMR)\n配置事件线的触发选择位 (EXTI_RTSR, EXTI_FTSR)\n\n软件中断/事件选择\n这 20 条线路可以配置为软件中断/事件线：\n\n配置 20 条中断/事件线的屏蔽位 (EXTI_IMR, EXTI_EMR)\n设置软件中断寄存器的需求位 (EXTI_SWIER)\n\n外部中断/事件线映射\n\n\n\n\n\n\n\n\n\n\n要配置 AFIO_EXTICRx 来将外部中断/事件线映射到 GPIO 上，首先应该启用\nAFIO 时钟。\n其他四条 EXTI 线路连接如下:\n\nEXTI 16 连接到 PVD 输出\nEXTI 17 连接到 RTC Alarm 事件\nEXTI 18 连接到 USB 唤醒事件\nEXTI 19 连接到以太网唤醒事件(仅在连接线设备中可用)\n\nEXTI 寄存器\n中断屏蔽寄存器 (EXTI_IMR)\nAddress offset: 0x00\nReset value: 0x0000 0000\n\nMRx: Line x 的中断屏蔽\n\n0 - 屏蔽中断\n1 - 使能中断\n\n事件屏蔽寄存器 (EXTI_EMR)\nAddress offset: 0x04\nReset value: 0x0000 0000\n\nMRx: Line x 的事件屏蔽\n\n0 - 屏蔽事件\n1 - 使能事件\n\n上升沿触发选择寄存器\n(EXTI_RTSR)\nAddress offset: 0x08\nReset value: 0x0000 0000\n\nTRx: Line x 的上升沿触发事件配置位\n\n0 - 禁止上升沿触发\n1 - 使能上升沿触发\n\n\n\n\n\n\n\n\n\n\n外部唤醒线路由边沿触发，这些线路上不得产生干扰。如果在写入 EXTI_RTSR\n寄存器期间外部中断线上出现上升沿，不设置挂起位。\n可以为同一中断线设置上升沿和下降沿触发器。这样两者都生成一个触发条件。\n下降沿触发选择寄存器\n(EXTI_FTSR)\nAddress offset: 0x0C\nReset value: 0x0000 0000\n\nTRx: Line x 的下降沿触发事件配置位\n\n0 - 禁止下降沿触发\n1 - 使能下降沿触发\n\n\n\n\n\n\n\n\n\n\n如果在写入 EXTI_FTSR\n寄存器期间外部中断线上出现下降沿，不设置挂起位。\n软件中断事件寄存器\n(EXTI_SWIER)\nAddress offset: 0x10 Reset value: 0x0000 0000\n\nSWIERx: Line x 的软件中断\n如果 Line x 在 EXTI_IMR 中被使能，则当 SWIERx 为 0\n时向它写入 1，EXTI_PR\n寄存器中的相应的挂起位将被设置，从产生一个中断请求。\n通过清除 EXTI_PR 的相应位来清除该位。\n挂起寄存器 (EXTI_PR)\nAddress offset: 0x14 Reset value: undefined\n\nPRx: 挂起位\n\n0 - 没触发器产生请求\n1 - 被选择的触发器产生请求\n\nEXTI 寄存器映射\n\nCubeMX 配置\n配置 GPIO 模式：\n\n\nNVIC 配置：\n\n配置代码\nvoid MX_GPIO_Init(void)\n{\n  GPIO_InitTypeDef GPIO_InitStruct = {0};\n\n  /* GPIO Ports Clock Enable */\n  __HAL_RCC_GPIOA_CLK_ENABLE();\n\n  /*Configure GPIO pin : PA0 */\n  GPIO_InitStruct.Pin = GPIO_PIN_0;\n  GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING;\n  GPIO_InitStruct.Pull = GPIO_NOPULL;\n  HAL_GPIO_Init(GPIOA, &amp;GPIO_InitStruct);\n\n  /* EXTI interrupt init*/\n  HAL_NVIC_SetPriority(EXTI0_IRQn, 1, 0);\n  HAL_NVIC_EnableIRQ(EXTI0_IRQn);\n}\nHAL_GPIO_Init 中的外部中断配置代码：\n/*--------------------- EXTI Mode Configuration ------------------------*/\n/* Configure the External Interrupt or event for the current IO */\nif ((GPIO_Init-&gt;Mode &amp; EXTI_MODE) == EXTI_MODE)\n{\n    /* Enable AFIO Clock */\n    __HAL_RCC_AFIO_CLK_ENABLE();\n    temp = AFIO-&gt;EXTICR[position &gt;&gt; 2u];\n    CLEAR_BIT(temp, (0x0Fu) &lt;&lt; (4u * (position &amp; 0x03u)));\n    SET_BIT(temp, (GPIO_GET_INDEX(GPIOx)) &lt;&lt; (4u * (position &amp; 0x03u)));\n    AFIO-&gt;EXTICR[position &gt;&gt; 2u] = temp;\n    /* Configure the interrupt mask */\n    if ((GPIO_Init-&gt;Mode &amp; GPIO_MODE_IT) == GPIO_MODE_IT)\n    {\n        SET_BIT(EXTI-&gt;IMR, iocurrent);\n    }\n    else\n    {\n        CLEAR_BIT(EXTI-&gt;IMR, iocurrent);\n    }\n    /* Configure the event mask */\n    if ((GPIO_Init-&gt;Mode &amp; GPIO_MODE_EVT) == GPIO_MODE_EVT)\n    {\n        SET_BIT(EXTI-&gt;EMR, iocurrent);\n    }\n    else\n    {\n        CLEAR_BIT(EXTI-&gt;EMR, iocurrent);\n    }\n    /* Enable or disable the rising trigger */\n    if ((GPIO_Init-&gt;Mode &amp; RISING_EDGE) == RISING_EDGE)\n    {\n        SET_BIT(EXTI-&gt;RTSR, iocurrent);\n    }\n    else\n    {\n        CLEAR_BIT(EXTI-&gt;RTSR, iocurrent);\n    }\n    /* Enable or disable the falling trigger */\n    if ((GPIO_Init-&gt;Mode &amp; FALLING_EDGE) == FALLING_EDGE)\n    {\n        SET_BIT(EXTI-&gt;FTSR, iocurrent);\n    }\n    else\n    {\n        CLEAR_BIT(EXTI-&gt;FTSR, iocurrent);\n    }\n}\n","slug":"MCU/STM32-IAE","date":"2022-10-12T09:36:00.000Z","categories_index":"单片机","tags_index":"STM32,中断和事件","author_index":"爱慢跑的乌龟"},{"id":"c3a5445bafc67228b7830b43d89f077b","title":"STM32 GPIO","content":"STM32 GPIO\nGPIO 功能描述\nGPIO 的寄存器包括：\n\n2 个 32-bit 配置寄存器 GPIOx_CRL GPIO_CRH\n2 个 32-bit 数据寄存器 GPIOx_IDR GPIOx_ODR\n1 个 32-bit 置位/复位寄存器 GPIOx_BSRR\n1 个 16-bit 复位寄存器 GPIOx_BRR\n1 个 32-bit 锁定寄存器 GPIOx_LCKR\n\nGPIO 的每个端口可以通过软件配置以下几种模式：\n\nInput floating\nInput pull-up\nInput-pull-down\nAnalog\nOutput open-drain\nOutput push-pull\nAlternate function push-pull\nAlternate function open-drain\n\nI/O 端口位的基本结构：\n\n模式配置：\n\n\n\n\nMODE[1:0]\nMeaning\n\n\n\n\n00\nReserved\n\n\n01\nMaximum output speed 10 MHz\n\n\n10\nMaximum output speed 2 MHz\n\n\n11\nMaximum output speed 50 MHz\n\n\n\n通用 I/O\n在复位期间和复位后，复用功能不激活，I/O\n端口配置位浮动输入模式(CNFx[1:0] = 01b，MODEx[1:0] = 00b)。\n当配置为输出时，写入输出数据寄存器(GPIOx_ODR)的值在 I/O\n引脚上输出。可以在推挽模式或开漏模式(N-MOS 被激活)下使用输出驱动器。\n输入数据寄存器(GPIOx_IDR)在每个 APB2 时钟周期时捕获每个 I/O\n引脚上的数据。\n所有的 GPIO\n引脚都有一个内部弱上拉或弱下拉，当配置为输入模式时，可以选择激活或不激活。\n原子位置位或重置\n在对 GPIOx_ODR 进行按位操作时，软件不需要禁用中断：可以在单原子 APB2\n写访问中只修改一个或几个位。这是通过将置位/复位寄存器(GPIOx_BSRR)的位置\n1，来选择要选择要修改的位来实现。未选择的位不会修改。\n复用功能(AF)\n在使用默认的复用功能之前，有必要对端口位配置寄存器进行编程。\n\n对于复用功能输入，端口必须配置为输入模式（浮动、上拉或下拉），输入引脚必须外部驱动。\n对于复用功能输出，端口必须配置为复用功能输出模式（推挽或开漏）。\n对于双向复用功能，端口必须配置为复用功能输出模式（推挽或开漏）。在这种情况下，输入驱动程序配置浮动输入模式。\n\n如果端口位配置为复用功能输出，则断开输出寄存器并将引脚连接到片上外设的输出信号。\n如果软件将 GPIO\n引脚配置为复用功能输出，但是外设未激活，则不指定其输出。\nI/O 复用功能的软件重映射\n为了优化不同设备包的外设 I/O\n功能数量，可以将一些复用功能映射到其它的引脚上。这是通过软件实现的，通过编程相应的寄存器(AFIO)。\nGPIO 锁定机制\n锁定机制允许 IO 配置被冻结。当 LOCK\n序列被应用于端口时，在下一次重置前，不可能再修改端口位的值。\n输入配置\n当 I/O 口被配置为输入模式时：\n\n输出缓存区被禁用\n施密特触发器输入被激活\n弱上拉电阻和弱下拉电阻激活与否取决于输入模式配置（浮动、上拉或下拉）\n每个 ABP2 时钟周期，I/O 引脚上的数据被采样到输入数据寄存器中\n对输入数据寄存器进行访问以获得 I/O 状态。\n\n\n输出配置\n当 I/O 口被配置为输出模式时：\n\n输出缓冲区被激活\n\n开漏模式: 输出寄存器中的 “0” 激活 N-MOS，而输出寄存器中的 “1” 在\nHi-Z 中离开端口(P-MOS从未激活)\n推挽模式: 输出寄存器中的 “0” 激活 N-MOS，而输出寄存器中的 “1”\n激活P-MOS\n\n施密特输入触发器被激活\n弱上拉和下拉电阻被禁用\n每个 APB2 时钟周期，I/O 引脚上的数据被采样到输入数据寄存器中\n通过读输入寄存器以获得开漏模式下的\nI/O 状态\n通过读输出寄存器以获得推挽模式下最后写入的值\n\n\n复用功能配置\n当 I/O 配置为复用功能时：\n\n输出缓存区在开漏或推挽模式下启用\n输出缓存区由来自外设的信号驱动\n施密特触发输入被激活\n弱上拉和下拉电阻被禁用\n每个 APB2 时钟周期，I/O 引脚上的数据被采样到输入数据寄存器中\n通过读输入寄存器以获得开漏模式下的\nI/O 状态\n通过读输出寄存器以获得推挽模式下最后写入的值\n\n\n模拟量配置\n当 I/O 配置为模拟量时：\n\n输出缓冲区被禁用\n施密特触发输入被停用，为 I/O\n引脚的每个模拟值提供零消耗。施密特触发器的输出被强制为恒定值(0)\n弱上拉和下拉电阻被禁用\n对输入数据寄存器的读访问获得值 “0”\n\n\nGPIO 寄存器\n外设寄存器必须通过 words (32位)来访问。\n端口配置寄存器 低 (GPIOx_CRL)\nAddress offset: 0x00\nReset value: 0x4444 4444\n\n端口配置寄存器 高 (GPIOx_CRH)\nAddress offset: 0x04\nReset value: 0x4444 4444\n\nMODEy[1:0]: Port (A..G) 配置位(y=0..15)\n\n00 - Input mode (reset state)\n01 - Output mode，max speed 10 MHz\n10 - Output mode，max speed 2 MHz\n11 - Output mode，max speed 50 MHz\n\nCNFy[1:0]: Port (A..G) 配置位(y=0..15)\nIn input mode (MODE[1:0]=00):\n\n00 - Analog mode\n01 - Floating inpurt (reset state)\n10 - Input with pull-up / pull-down\n11 - Reserved\n\nIn output mode (MODE[1:0]&gt;00):\n\n00 - General purpose output push-pull\n01 - General purpose output Open-drain\n10 - Alternate function output Push-pull\n11 - Alternate function output Open-drain\n\n端口输入寄存器 (GPIOx_IDR)\nAddress offset: 0x08h\nReset value: 0x0000 XXXX\n\nIDRy: Port (A..G) 输入数据(y=0..15)\n这些位是只读的，只能在 Word 模式下访问。它们包含相应 I/O\n端口的输入值。\n端口输出寄存器 (GPIOx_ODR)\nAddress offset: 0x0C\nReset value: 0x0000 0000\n\nODRy: Port (A..G) 输出数据(y=0..15)\n这些位可以通过软件读写，并且只能在 Word 模式下访问。\n端口位置位/复位寄存器\n(GPIOx_BSRR)\nAddress offset: 0x10\nReset value: 0x0000 0000\n\nBRy: Port (A..G) Reset bit y (y= 0 .. 15)\n这些位是只写的，只能在 Word 模式下访问\n\n0 - 对相应的 ODRx 位没有任何操作\n1 - 重置相应的 ODRx 位\n\nBSy: Port (A..G) Set bit y (y= 0 .. 15)\n这些位是只写的，只能在 Word 模式下访问\n\n0 - 对相应的 ODRx 位没有任何操作\n1 - 设置相应的 ODRx 位\n\n端口位复位寄存器 (GPIOx_BRR)\nAddress offset: 0x14\nReset value: 0x0000 0000\n\nBRy: Port (A..G) Reset bit y (y= 0 .. 15)\n这些位是只写的，只能在Word模式下访问。\n\n0 - 对相应的 ODRx 位没有任何操作\n1 - 重置相应的 ODRx 位\n\n端口配置锁寄存器 (GPIOx_LCKR)\n当一个正确的写序列被应用到第 16\n位(LCKK)时，该寄存器用于锁定端口的配置。Bits[15:0] 用于锁定 GPIO\n的配置。在写序列期间，LCKR[15:0] 的值不能改变。如果 LOCK\n序列已经应用于端口位，则在下一次复位之前，不能再修改端口位的值。\n每个锁位冻结相应的 4 位控制寄存器 (CRL, CRH)。\nAddress offset: 0x18\nReset value: 0x0000 0000\n\nLCKK[16]: Lock key\n这个位可以随时读取。它只能使用 Lock Key Writing Sequence\n进行修改。\n\n0 - 端口配置锁密钥未激活\n1 - 端口配置锁键激活。GPIOx_LCKR\n寄存器被锁定，直到下一次复位。\n\nLCKy: Port (A..G) Lock bit y (y= 0..15)\n这些位是可读写的，但只有当 LCKK 位为 0 时才能写入\n\n0 - 端口配置未锁定\n1 - 端口配置已锁定\n\nAFIO 寄存器\n\n\n\n\n\n\n\n\n\n要读/写 AFIO_EVCR、AFIO_MAPR 和 AFIO_EXTICRX 寄存器，必须首先使能\nAFIO 时钟。\n事件控制寄存器 (AFIO_EVCR)\nAddress offset: 0x00\nReset value: 0x0000 0000\n\nEVOE: 事件输出使能\n由软件设置或清除。置位时，EVENTOUT Cortex® 输出连接到由\nPORT[2:0] 和 PIN[3:0] 位选择的 I/O。\nPORT[2:0]: 端口选择\n通过软件设置和清除。选择用于输出 Cortex® EVENTOUT 信号的端口。\n\n\n\n\n\n\n\n\n\nEVENTOUT信号输出能力不扩展到 PF 和 PG 端口\n\n000 - PA\n001 - PB\n010 - PC\n011 - PD\n100 - PE\n\nPIN[3:0]: 引脚选择 (A..E)\n通过软件设置和清除。选择用于输出 Cortex® EVENTOUT 信号的引脚。\n\n0000 - Px0\n0001 - Px1\n...\n1111 - Px15\n\n复用功能重映射和调试\nI/O 配置寄存器 (AFIO_MAPR)\nAddress offset: 0x04\nReset value: 0x0000 0000\n\n外部中断配置寄存器 1\n(AFIO_EXTICR1)\nAddress offset: 0x08\nReset value: 0x0000\n\nEXTIx[3:0]: EXIT (0..3) 配置\n这些位由软件写入以选择 EXTIx 外部中断的输入引脚。\n\n0000 - PA[x] pin\n0001 - PB[x] pin\n0010 - PC[x] pin\n0011 - PD[x] pin\n0100 - PE[x] pin\n0101 - PF[x] pin\n0110 - PG[x] pin\n\n外部中断配置寄存器 2\n(AFIO_EXTICR2)\nAddress offset: 0x0C\nReset value: 0x0000\n\nEXTIx[3:0]: EXIT (4..7) 配置\n这些位由软件写入以选择 EXTIx 外部中断的输入引脚。\n\n0000 - PA[x] pin\n0001 - PB[x] pin\n0010 - PC[x] pin\n0011 - PD[x] pin\n0100 - PE[x] pin\n0101 - PF[x] pin\n0110 - PG[x] pin\n\n外部中断配置寄存器 3\n(AFIO_EXTICR3)\nAddress offset: 0x10\nReset value: 0x0000\n\nEXTIx[3:0]: EXIT (8..11) 配置\n这些位由软件写入以选择 EXTIx 外部中断的输入引脚。\n\n0000 - PA[x] pin\n0001 - PB[x] pin\n0010 - PC[x] pin\n0011 - PD[x] pin\n0100 - PE[x] pin\n0101 - PF[x] pin\n0110 - PG[x] pin\n\n外部中断配置寄存器 4\n(AFIO_EXTICR4)\nAddress offset: 0x14\nReset value: 0x0000\n\nEXTIx[3:0]: EXIT (12..15) 配置\n这些位由软件写入以选择 EXTIx 外部中断的输入引脚。\n\n0000 - PA[x] pin\n0001 - PB[x] pin\n0010 - PC[x] pin\n0011 - PD[x] pin\n0100 - PE[x] pin\n0101 - PF[x] pin\n0110 - PG[x] pin\n\n复用功能重映射和调试\nI/O 配置寄存器 2 (AFIO_MAPR2)\nAddress offset: 0x1C\nReset value: 0x0000 0000\n\n","slug":"MCU/STM32-GPIO","date":"2022-10-11T07:47:00.000Z","categories_index":"单片机","tags_index":"STM32,GPIO","author_index":"爱慢跑的乌龟"},{"id":"51d61b1e82665e319117cf3815ca2bc7","title":"Amesim 与 Simulink 的联合仿真","content":"Amesim 与 Simulink\n的联合仿真\n环境配置\n软件版本为：Matlab 2020b 和\nAmesim 2021.1，编译器使用 MinGW-w64\n附件安装：\n首先需要在 Matlab 中安装附件\nMATLAB Support for MinGW-w64 C/C++ Compiler\n\n\n点击进入安装即可。\n安装完成后，在命令行输入：\n\nmex -setup\nmex -setup C++\n\n\n环境变量配置（关键）\n路径： 此电脑 - 属性 - 高级系统设置 - 高级 - 环境变量 -\n系统变量\n\n\n\n\n\n\n\n变量名\n变量值\n\n\n\n\nAME\nD:\\tool\\Simcenter\\2021.1\\Amesim\n\n\nGCC_HOME\nD:\\Program Files\\Polyspace\\R2020b\\extern\\lib\\win64\\mingw64\n\n\nMATLAB\nD:\\Program Files\\Polyspace\\R2020b\n\n\nMW_MINGW64_LOC\nC:\\ProgramData\\MATLAB\\SupportPackages\\R2020b\\3P.instrset\\mingw_w64.instrset\n\n\n\nPath：\n\n\nAmesim 编译器选择\n路径： Tools - Preference - Compliation - Active\ncomplier\n\n联合仿真接口使用\n路径：Interfaces - Create interface block...\n\n\n完成 Amesim 草图之后，编译模型，编译细节如下：\n\n点击 Run simulation：\n\n再点击 Simulink，系统将会自动打开 Matlab 并启动\nSimulink。\n在 Simulink Libaray 的 User-Defined Functions 中找到\nS-Function 模块：\n\nS-Function 模块的参数设置：\n\nSimulink interface\n两个接口\nSimcenter Amesim-Simulink 和 Simulink-Simcenter Amesim 接口可以结合\nSimcenter Amesim 和 Simulink 模型执行仿真。\n由于涉及两个软件包，接口提供了两个主要选项：将 Simcenter Amesim 模型导入\nSimulink，或将 Simulink 模型导入 Simcenter Amesim。\n通过 Simcenter Amesim-Simulink 界面，用户可以选择这两种方法。\n除了这两种方法之外，还可以将 Simcenter Amesim 求解器（带有 Simcenter\nAmesim 模型）导出到 Simulink。\n这有时称为协同仿真，因为我们使用两个软件包中的求解器，它们一起执行仿真。\n如何选择我需要的接口？\n这个问题没有单一的答案。答案取决于很多事情。有些 Simcenter Amesim\n系统很难或不可能使用 Simulink\n求解器求解。如果是这种情况，那么用户需要选择协同仿真。这意味着将同时使用\nSimcenter Amesim 和 Simulink 求解器，并且每个人都将负责自己的部分。\n有时 Simulink 系统非常复杂，将其导入 Simcenter Amesim\n可能不是最佳解决方案，因为它会强制使用 Simulink\n固定步长求解器，这有时并不合适。\n除了技术原因之外，还必须考虑模型的用途。如果主要目的是测试/开发\nSimcenter Amesim 模型，则将 Simulink 模型导入 Simcenter Amesim\n可能是最佳策略。如果主要目的是使用在 Simcenter Amesim 中编写的物理模型在\nSimulink 中测试/开发控制器，那么在 Simulink\n中工作显然是一个更好的主意。\n在许多情况下，一个人开发 Simulink 模型，另一个人开发 Simcenter Amesim\n模型。负责整合模型的人显然更喜欢在“他的”环境中工作。\n有一些明显的“规则”：如果 Simulink 模型很小，而 Simcenter Amesim\n模型很大，则可以将 Simulink 模型放入 Simcenter Amesim。如果需要访问\nSimcenter Amesim 中的独特功能，您还可以将 Simulink 模型放入 Simcenter\nAmesim。如果您需要使用 MATLAB® /Simulink 中的特殊功能，您可以将\nSimcenter Amesim 模型放入 Simulink。\nSupported Simulink Interface\nmodes\n\n\n\n\n\n\n\nEnvisaged interface mode\nSupported\n\n\n\n\n1.1 Co-simulation in Simcenter Amesim: Simcenter\nAmesim as Master (Simulink as Slave)\n\n(SL2AMECosim)\n\n\n2.1 Co-simulation in Simulink: Simcenter Amesim as\nSlave (Simulink as Master)\n\n(AME2SLCosim)\n\n\n2.2 Model Exchange: Export of Simcenter Amesim\nmodel into Simulink\n (AME2SL)\n\n\n\n\n对于 SL2AMECosim，请注意，一旦将\nSimulink 模型导入 Simcenter\nAmesim，就不再需要 Simulink\n来运行仿真（也不需要 Simulink 许可证）。\n在 SL2AMECosim 中，嵌入式 Simulink\n求解器始终为固定步长类型。 支持 Simulink\n模型引用。\n对于 Simulink（AME2SL 或\nAME2SLCosim）中的模型交换或联合仿真，Simcenter\nAmesim 模型（带或不带求解器）导出为\nS-Function\n此模式符合黑盒选项。\n\n\n\n\nmultiple Simulink interfaces\n\n如果 Simcenter Amesim 是目标环境，则接口模块是完全独立的（Simcenter\nAmesim 将其视为标准子模型）。 因此，在同一个 Simcenter Amesim\n草图上混合不同块类型或设置的可能性在理论上是不受限制的。\n可以在单个 Simcenter Amesim 系统中使用多个 Simulink\n模型（反之亦然），但不能在单个 Simcenter Amesim 系统中多次使用同一个\nSimulink 模型（反之亦然）。\n目标环境中使用的块与独立系统一样多。\n\n\n\n\n\n\n\n\nCapability\nSupported interface modes for blocks\n\n\n\n\nUse  Simulink\nblocks in Simcenter Amesim\nCo-simulation (SL2AMECosim): Simcenter\nAmesim as Master (Simulink as Slave)\n\n\nUse  Simulink\nblocks with different solver types (variable/fixed-step) or solver\nsettings in Simcenter Amesim\nCo-simulation (SL2AMECosim): Simcenter\nAmesim as Master (Simulink as Slave)\n\n\nUse  Simcenter\nAmesim blocks in Simulink\nCo-simulation (AME2SLCosim): Simcenter\nAmesim as Slave (Simulink as Master)\n\n\n\nModel Exchange (AME2SL): Export of\nSimcenter Amesim model into\nSimulink\n\n\n\nBoth Co-simulation (AME2SLCosim): Simcenter\nAmesim as Slave (Simulink as Master) and Model\nExchange (AME2SL): Export of Simcenter\nAmesim model into Simulink\n\n\nUse  Simcenter\nAmesim blocks with different solver types (variable/fixed-step)\nor solver settings in Simulink\nCo-simulation (AME2SLCosim): Simcenter\nAmesim as Slave (Simulink as Master)\n\n\n\n\n在 SL2AMECosim\n中，求解器类型始终为固定步长，但设置（例如步长）可以不同\n其中一些模型交换块可以是黑盒类型。\n\n依赖\n编译器：\n\nThe Simcenter Amesim to Simulink\ninterface for Simcenter Amesim 2021.1 has been\nextensively tested using MATLAB/Simulink R2015b and\nR2020b. All releases between these two versions should work.\n","slug":"Amesim/Amesim与Simulink联合仿真","date":"2022-09-28T07:12:00.000Z","categories_index":"Amesim","tags_index":"Amesim,Simulink","author_index":"爱慢跑的乌龟"},{"id":"b3283c8479bedbfcba4845761e4e6510","title":"Python 高级应用","content":"语法糖\n语法糖(Syntactic suger)，也译为语法糖衣，是由英国计算机科学家Peter J.Landin发明的一个术语，指计算机语言中添加某种语法，这种语法对语言的功能并没有影响，但是更方便程序员使用。通常来说使用语法糖能够增加程序的可读性，从而减少代码出错的机会。就相当于汉语中的成语。用更简练的语言表达叫复杂的含义。在得到广泛流传的情况下，可以提升交流效率。\n\n1.对一个list排序，先按元素的一个属性排序，再按另一个属性排序。\n如：一个学校的人站成一行，需要年级从小到大，并且每个年级中从矮到高排序。 [P1, P2, P3,...Pn].sort(key&#x3D;lambda x: (x.grade, X.height))\n把需要排序的属性拿出来作为一个tuple，主要的放前面，次要的放后面。因为Python在比较tuple大小的时候正是按字典序进行的。如果需要对更多属性排序，继续添加进tuple即可。\n扩展：\n假设有一个list： list &#x3D; [1, -2, 10, -12, -4, -5, 9, 2]\n依然是排序，目标是将正的放在前面，负的放在后面，并且分别按绝对值从小到大。即输出： [1, 2, 9, 10, -2, -4, -5, -12]\n最简单的方法是： list.sort(key&#x3D;lambda x: (x&lt;0, abs(x))) -------- 2.对于列表形如list_1 = [[1, 2], [3, 4, 5], [6, 7], [8], [9]]转化成列表list_2 = [1, 2, 3, 4, 5, 6, 7, 8, 9]的问题。\n(1) 一般方法\nlist_1 &#x3D; [[1, 2], [3, 4, 5], [6, 7], [8], [9]]\nlist_2 &#x3D; []\nfor _ in list_1:\n\tlist_2 +&#x3D; _\nprint(list_2)\n\n更pythonic的方法，列表推导 list_1 &#x3D; [[1, 2], [3, 4, 5], [6, 7], [8], [9]]\n[i for k in list_1 for i in k]\n抽象用法 list_1 &#x3D; [[1, 2], [3, 4, 5], [6, 7], [8], [9]]\nsum(list_1, [])\n\n装饰器\n1.函数闭包(function closure) + 函数式语言(函数是一等公民，可作为变量使用)中的术语 + 函数闭包：一个函数，其参数和返回值都是函数 + 用于增强函数功能 + 面向切面编程(AOP) # 闭包本质是一个函数\n# 闭包函数的传入参数和返回参数也是函数\n# 闭包函数的返回函数是对传入函数进行增强后的结果\ndef count_time_wrapper(func):\n\t&quot;&quot;&quot;\n\t闭包，用于增强函数func：给函数增强计时功能\n\t&quot;&quot;&quot;\n\tdef improved_func():\n\t\tstart_time &#x3D; time.clock()\n\t\tfunc()\n\t\tend_time &#x3D; time.clock()\n\t\tprint(&quot;it takes &#123;&#125; s to find all the odds&quot;.format(end_time - start_time))\n\treturn improved_func 闭包函数是显式增强\n\n\n\n\n\n\n2.函数语法糖(Syntactic sugar) + 指计算机语言中添加的某种语法，这种语法对语言的功能没有影响 ，但是方便程序员使用。 + 语法糖没有增加新功能 ，只是一种更方便的写法。 + 语法糖可以完全等价地转换为 为原本非语法糖。 + 装饰器在第一次调用被装饰函数时进行增强 + 增强时机-&gt;在第一次调用之前 + 增强次数-&gt;只增强一次，之后为增强后的函数 Python装饰器是函数闭包的语法糖 def count_time_wrapper(func):\n\t&quot;&quot;&quot;\n\t闭包，用于增强函数func：给函数增加计时功能\n\t&quot;&quot;&quot;\n\tdef improved_func():\n\t\tstart_time &#x3D; time.clock()\n\t\tfunc()\n\t\tend_time &#x3D; time.clock()\n\t\tprint(&quot;it takes &#123;&#125; s to find all the odds.&quot;.format(end_time - start_time))\n\treturn improved_func\n\t\n@count_time_wrapper\ndef print_odds():\n\tfor i in range(100):\n\t\tif i % 2 &#x3D;&#x3D; 1:\n\t\t\tprint(i)\n\t\t\t\n&lt;++&gt;&#96;&#96;&#96;\n\n对于有返回值和参数的函数，调用闭包增强：\n\n​&#96;&#96;&#96;python\ndef count_time_wrapper(func):\n\t&quot;&quot;&quot;\n\t闭包，用于增强函数func：给函数增加计时功能\n\t&quot;&quot;&quot;\n\tdef improved_func(*args, **kwargs):\n\t\tstart_time &#x3D; time.clock()\n\t\tret &#x3D; func(*args, **kwargs)\n\t\tend_time &#x3D; time.clock()\n\t\tprint(&quot;it takes &#123;&#125; s to find all the odds.&quot;.format(end_time - start_time))\n\t\treturn ret\n\treturn improved_func\t\n\t\n@count_time_wrapper\ndef print_odds(lim):\n\tcnt &#x3D; 0 \n\tfor i in range(lim):\n\t\tif i % 2 &#x3D;&#x3D; 1:\n\t\t\tcnt +&#x3D; 1\n\treturn cnt\t\t\n\n\n\n\n日志打印器： # 装饰函数\ndef logger(func):\n\tdef wrapper(*args, **kw):\n\t\tprint(&#39;准备计算：&#123;&#125;函数了：&#39;.format(func.__name__))\n\t\tfunc(*args, **kw)\n\t\tprint(&#39;计算结束&#39;)\n\treturn wrapper\n\n@logger\ndef add(x, y):\n\tprint(&#39;&#123;&#125; + &#123;&#125; &#x3D; &#123;&#125;&#39;.format(x, y, x+y))\n\nadd(100, 50)\n\n\n时间计时器： def timer(func):\n\tdef wrapper(*args, **kw):\n\t\tt1 &#x3D; time.time()\n\t\t# 业务函数\n\t\tfunc(*args, **kw)\n\t\tt2 &#x3D; time.time()\n\t\tcost_time &#x3D; t2 - t1\n\t\tprint(&#39;花费时间：&#123;&#125; s.&#39;.format(cost_time))\n\treturn wrapper\n\n@timer\ndef want_sleep(sleep_time):\n\ttime.sleep(sleep_time)\n\nwant_sleep(10)\n\n\n\n进阶用法：带参数的函数装饰器\n例子：\n我们要执行一下两个函数时候，分别根据来说出一段打招呼的话\ndef american():\n\tprint(&quot;I come from America&quot;)\n\ndef chinese():\n\tprint(&quot;我来自中国。&quot;)\n添加装饰器： @say_hello(&quot;china&quot;)\ndef american():\n\tprint(&quot;我来自中国&quot;)\n\n@say_hello(&quot;america&quot;)\ndef chinese():\n\tprint(&quot;I come from America.&quot;)\n\t\ndef say_hello(contry):\n\tdef wrapper(func):\n\t\tdef deco(*args, **kw):\n\t\t\tif contry &#x3D;&#x3D; &quot;china&quot;:\n\t\t\t\tprint(&quot;你好！&quot;)\n\t\t\telif contry &#x3D;&#x3D; &quot;america&quot;:\n\t\t\t\tprint(&quot;hello&quot;)\n\t\t\telif:\n\t\t\t\treturn\n\t\t\tfunc(*args, **kw)\n\t\treturn deco\n\treturn wrapper\n需要一个外层函数来接受装饰器函数的参数\n\n\n\n\n\n\n高阶用法：不带参数的类装饰器 基于类装饰器的实现，必须实现__call__ 和__init__ 两个内置函数。 __init__ :接收被装饰函数 __call__ :实现装饰逻辑。 class logger(object):\n\tdef __inint__(self, func):\n\t\tself.func &#x3D; func\n\t\n\tdef __call__(self, *args, **kw):\n\t\tprint(&quot;[INFO]:the function &#123;func&#125;() is running...&quot;.format(func &#x3D; self.func.__name__))\n\t\treturn self.func(*args, **kw)\n\n@logger\ndef say(something):\n\tprint(&#39;say &#123;&#125;!&#39;.format(something))\n\nsay(&#39;hello&#39;)\n\n\n\n\n带参数的类装饰器 上述例子只能打印INFO 级别的日志，正常情况下，我们还需要打印DEBUG WARNING 等级别的日志。 这就需要给类装饰器传入参数，给这个函数指定级别。 带参数和不带参数的类装饰器有很大的不同。 __init__ ：不再接收被装饰函数，而是接收传入参数。 __call__ ：接收被装饰函数，实现装饰逻辑。 class logger(object):\n\tdef __init__(self, level&#x3D;&#39;INFO&#39;):\n\t\tself.level &#x3D; level\n\t\n\tdef __call__(self, func):\n\t\tdef wrapper(*args, **kw):\n\t\t\tprint(&quot;[&#123;level&#125;]:the function &#123;func&#125;() is running...&quot;.format(level&#x3D;self.level, func&#x3D;func.__name__))\n\t\t\tfunc(*args, **kw)\n\t\treturn wrapper\n\n\n@logger(level&#x3D;&#39;WARNING&#39;)\ndef say(something):\n\tprint(&#39;say &#123;&#125;!&#39;.format(something))\n\nsay(&#39;hello&#39;)\n\n\n\n使用偏函数与类实现装饰器\n绝大多数装饰器都是基于函数和闭包实现的，但这并非制造装饰器的唯一方式。\nPython对某个对象是否通过装饰器(@decorator )形式使用只有一个要求：decorator必须是一个“可被调用(callable)的对象。\n函数是callable对象，类也是callable对象，只要实现了__call__ 函数，还有比较少的人使用的偏函数也是callable对象。\n如下：DelayFunc是一个实现了__call__ 的类，delay返回一个偏函数，在这里delay就可以作为一个装饰器。 import time\nimport functools\n\nclass DelayFunc:\n\tdef __init__(self, duration, func):\n\t\tself.duration &#x3D; duration\n\t\tself.func &#x3D; func\n\t\t\n\tdef __call__(self, *args, **kw):\n\t\tprint(f&#39;Wait for &#123;self.duration&#125; seconds...&#39;)\n\t\ttime.sleep(self.duration)\n\t\treturn self.func(*args, **kw)\n\t\n\tdef eager_call(self, *args, **kw):\n\t\tprint(&#39;Call without delay&#39;)\n\t\treturn self.func(*args, **kw)\n\ndef delay(duration):\n\t&quot;&quot;&quot;\n\t装饰器：推迟某个函数的执行。  \n\t同时提供.eager_call 方法立即执行\n\t&quot;&quot;&quot;\n\t# 此处为了避免定义额外函数\n\t# 直接使用functools.partial 帮助构造 DelayFunc实例\n\treturn functools.partial(DelayFunc, duration)\n\n@delay(duration&#x3D;2)\ndef add(a, b):\n\treturn a+b -------- 装饰类的装饰器\n用Python写单例模式的时候，常用的有三种写法。其中一种，是用装饰器来实现。\ninstances &#x3D; []\n\ndef singleton(cls):\n\tdef get_instance(*args, **kw):\n\t\tcls_mane &#x3D; cls.__name__\n\t\tprint(&#39;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;1&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#39;)\n\t\tif not cls_name in instances:\n\t\t\tprint(&#39;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;2&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#39;)\n\t\t\tinstance &#x3D; cls(*args, **kw)\n\t\t\tinstances[cls_name] &#x3D; instance\n\t\treturn instances[cls_name]\n\treturn get_instance\n\n@singleton\nclass User:\n\t_instance &#x3D; None\n\t\n\tdef __init__(self, name):\n\t\tprint(&#39;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;3&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#39;)\n\t\tself.name &#x3D; name\n\n\n\n\n\n\nwraps装饰器 在functools标准库中提供了一个wraps装饰器 def wrapper(func):\n\tdef innner_function():\n\t\tpass\n\treturn inner_function\n\n@wrapeer\ndef wrapped():\n\tpass\n\nprint(wrapped.__name__)\n# inner_function\n\n\n上边执行func 和下边decorator(func) 是等价的，所以上面func.__name__ 是等价于下面decorator 的，当然名字是inner_function def wrapper(func):\n\tdef inner_function():\n\t\tpass\n\treturn inner_function\n\ndef wrapped():\n\tpass\n\nprint(wrapper(wrapped).__name__)\n# inner_function\n\n\n为了避免这种情况的产生，使用functools.wraps装饰器，它的作用是将被装饰的函数(wrapped) 的一些属性赋值给修饰器函数(wrapper) ，最终让属性显示更符合我们的直觉。 from functools import update_wrapper\nWRAPPER_ASSIGNMENTS &#x3D; (&#39;__moudle__&#39;, &#39;__name__&#39;, &#39;__qualname__&#39;, &#39;__doc__&#39;, &#39;__annotations__&#39;)\n\ndef wrapper(func):\n\tdef inner_function():\n\t\tpass\n\tupdate_wrapper(inner_function, func, assigned&#x3D;WRAPPER_ASSIGNMENTS)\\\n\treturn inner_function\n\n@wrapper\ndef wrapped():\n\tpass\n\nprint(wrapped.__name__)\n\n\n\n内置装饰器：property\n它通常存在于类中，可以将一个函数定义成一个属性，属性的值就是该函数return的内容。\nclass Student(object):\n\tdef __init__(self, name, age&#x3D;None):\n\t\tself.name &#x3D; name\n\t\tself.age - age\n\n# 实例化\nXiaoMing &#x3D; Student(&quot;小明&quot;)\n\n# 添加属性\nXiaoMing.age &#x3D; 25\n\n# 查询属性\nXiaoMing.age\n\n# 删除属性\ndel XiaoMing.age\n这样做会直接将属性暴露出去，不能限制属性值的合法性。\nclass Student(object):\n\tdef __init__(self, name):\n\t\tself.name &#x3D; name\n\t\tself.name &#x3D; None\n\t\n\tdef set_age(self, age):\n\t\tif not isinstance(age, int):\n\t\t\traise ValueError(&quot;输入不合法：年龄必须是数值&quot;)\n\t\tif not 0 &lt; age &lt; 100:\n\t\t\traise ValueError(&quot;输入不合法：年龄范围必须0-100&quot;)\n\t\tself._age &#x3D; age\n\t\n\tdef get_age(self):\n\t\treturn self._age\n\t\n\tdef del_age(self):\n\t\tself._age &#x3D; None\n\nXiaoMing &#x3D; Student(&quot;小明&quot;)\n\n# 添加属性\nXiaoMing.set_age(25)\n\n# 查询属性\nXiaoMing.get_age()\n\n# 删除属性\nXiaoMing.del_age()\n 上面的代码设计虽然可以变量的定义，但是可以发现不管是获取还是赋值（通过函数）都和我们平时见到的不一样。 按照我们思维习惯应该是这样的:\n# 赋值\nXiaoMing.age &#x3D; 24\n\n# 获取\nXiaoMing.age\n这样的设计可以通过下面的代码来实现：\nclass Student(object):\n    def __init__(self, name):\n        self.name &#x3D; name\n        self.name &#x3D; None\n\n    @property\n    def age(self):\n        return self._age\n\n    @age.setter\n    def age(self, value):\n        if not isinstance(value, int):\n            raise ValueError(&#39;输入不合法：年龄必须为数值!&#39;)\n        if not 0 &lt; value &lt; 100:\n            raise ValueError(&#39;输入不合法：年龄范围必须0-100&#39;)\n        self._age&#x3D;value\n\n    @age.deleter\n    def age(self):\n        del self._age\n\nXiaoMing &#x3D; Student(&quot;小明&quot;)\n\n# 设置属性\nXiaoMing.age &#x3D; 25\n\n# 查询属性\nXiaoMing.age\n\n# 删除属性\ndel XiaoMing.age\ntyping\n\n\n\n\n\n\n\n\n\nPython 运行时不强制执行函数和变量类型的注解，但这些注解可用于类型检测器、IDE、静态检查器等第三方工具。\n此模块为类型提示提供运行时支持。最基本的支持包括 Any、Union、Callable、TypeVar 和 Generic 类型。有关完整的规范，请参阅PEP 484。有关类型提示的简化介绍，请参见PEP 483。\n类型注解方式：\ndef greeting(name: str) --&gt; str:\n    return &#39;Hello&#39; + name\ngreeting 函数中，参数 name 的类型是 str, 返回类型也是 str。\n类型别名\n把类型赋给别名，就可以定义类型的别名。本例中 Vector 和 list[float] 相同，可互换：\nVector &#x3D; list[float]\ndef scale(scalar: float, vector: Vector) -&gt; Vector:\n    return [scalar * num for num in vector]\n\nnew_vector &#x3D; scale(2.0, [1.0, -4.2, 5.4])\n类型别名适用于简化类型签名。例如：\nfrom collections.abc import  Sequence\n\nConnectionOptions &#x3D; dict[str, str]\nAddress &#x3D; tuple[str, int]\nServer &#x3D; tuple[Address, ConnectionOptions]\n\ndef broadcast_message(message: str, servers: Sequence[Server]) -&gt; None:\nNewType\n使用 NewType 辅助类来创建不同的类型\nfrom typing import NewType\n\nUserID &#x3D; NewType(&#39;UserId&#39;, int)\nsome_id &#x3D; UserId(524213)\n静态类型检查器把新类型当作原始类型的子类，这种方式适用于捕捉逻辑错误。\n\n\n\n\n\n\n\n\n\n注意，这些检查只由静态类型检查器强制执行。在运行时，语句 Derived = NewType('Derived', Base) 将产生一个 Derived 类，该类立即返回你传递给它的任何参数。 这意味着语句 Derived(some_value) 不会创建一个新的类，也不会引入超出常规函数调用的很多开销。\n可调对象(Callable)\n预期特定签名回调函数的框架可以用Callable[[Arg1Type, Arg2Type], ReturnType] 实现类型提示。\nfrom collections.abc import Callable\n\ndef feeder(get_next_item: Callable[[], str]) -&gt; None:\n    # Body\ndef async_query(on_success: Callable[[int, Exception], None]，\n               on_error:Callable[[int, Exception], None]) -&gt; None:\n    # Body\n无需指定调用签名，用省略号字面量替换类型提示里的参数列表：Callable[..., ReturnType]，就可以声明可调对象的返回类型。\n以其他可调用对象为参数的可调用对象可以使用 ParamSpec 来表明其参数类型是相互依赖的。此外，如果该可调用对象增加或删除了其他可调用对象的参数，可以使用 Concatenate 操作符。它们分别采取Callable[ParamSpecVariable, ReturnType] 和 Callable[Concatenate[Arg1Type, Arg2Type, ..., ParamSpecVariable], ReturnType] 的形式\n","slug":"Pyhon/Python高级","date":"2022-09-28T07:00:00.000Z","categories_index":"Python","tags_index":"Python tips","author_index":"爱慢跑的乌龟"},{"id":"5badb916fa8f30fce64229fc7b4b0982","title":"Python 的深拷贝和浅拷贝","content":"Python 的深拷贝和浅拷贝\na &#x3D; [1, 2, 3, [1, 2, 3, [4, 5]]]\nb &#x3D; a\n当使用赋值运算符 =，a 和 b\n两个变量指向的同一个地址：\n\na &#x3D; [1, 2, 3, [1, 2, 3, [4, 5]]]\nc &#x3D; a.cope()\n当列表具有多层时，copy()\n仅拷贝一层(浅拷贝)，而深层的列表依然指向原列表的地址：\n\n修改第一层列表的值并不会影响原有列表，但是修改深层列表的原有列表：\nc[3][0] &#x3D; 10\n\n若要完全拷贝(深拷贝)多层列表 a，则需要使用\ncopy 库中的 deepcopy() 函数实现：\nimport copy\nd &#x3D; copy.deepcopy(a)\n\n此时，对于 列表 d 的修改不会对原有列表 a 产生任何影响。\n\n\n\n\n\n\n\n\n\nPython\n中的拷贝仅对于可变量如列表、字典等，而不可变的量如常量、元组等，则没有拷贝的属性。\n","slug":"Pyhon/深拷贝与浅拷贝","date":"2022-09-27T11:01:00.000Z","categories_index":"Python","tags_index":"Python tips","author_index":"爱慢跑的乌龟"},{"id":"c1235f99efb341252757b2cde16e8265","title":"AD20 使用笔记","content":"AD20 使用笔记\n网格设置\nAltium Designer 20 一共有 3 种栅格：Grids、Gudies 和 Axes。\nGrids 是最常用的普通栅格。\nGrids 栅格的设置有：\n\nG 键设置栅格大小\n\n\n\nCtrl + G 设置栅格属性\n\n\n\n自定义区域栅格\n\n\n\n栅格捕捉开关：\n\nGuides\n栅格用于捕捉我们放置的向导线(参考线)或点，如果没有放置是不起作用的。\n矩阵区域内排列\nAlt + A\n\n交叉选择模式\nShift + Ctrl + X\n\nPCB 设计规则管理器\n\n规则约束共 10 大类：\n电气规则：包含间距、短路、开路等。\n信号线规则：线宽、过孔、差分线、扇孔等。\n贴片规则、阻焊规则、铺铜规则、测试点规则、生产部分规则、高速部分规则、放置器件的规则\n和 信号完整性分析的规则\n常用规则\n\n安全间距（最小线间距）（6 mil)\n\n一般最小间距为 3.5-6mil\n\n\n线宽（6 mil)\n\n电流与线宽之间的关系： \n\n -\n修正系数,一般覆铜线在内层时取 0.024，在外层时取 0.048;\n - 最大温升 [℃]\n - 铜线的截面积 []\n\n\n印制导线最大允许工作电流（导线厚 50um，允许温升 10 ℃）\n\n\n\n\n导线宽度（Mil）\n导线电流（A）\n\n\n\n\n10\n1\n\n\n15\n1.2\n\n\n20\n1.3\n\n\n25\n1.7\n\n\n30\n1.9\n\n\n50\n2.6\n\n\n75\n3.5\n\n\n100\n4.2\n\n\n200\n7.0\n\n\n250\n8.3\n\n\n\n\n添加 Net Classes：\n\n\n\n为网络分类添加独立的线宽规则：\n\n\n\n过孔（12 24 mil)\n\n\n显示网络飞线\n\n原理图库分部分绘制\n\n导出 Gerber 文件\n\nGerber 设置界面：\n\n\n\n\n\n生成NC钻孔文件:\n\n\n\n\n","slug":"Altium-Designer/AD20使用笔记","date":"2022-09-19T06:48:00.000Z","categories_index":"电子技术","tags_index":"Altium Designer","author_index":"爱慢跑的乌龟"},{"id":"0eaae2e7a8b8a57479711ca2360e5962","title":"立创 EAD 导出 AD 封装","content":"立创 EDA 导出 AD 封装\n\n导出 AD 库\n\n\n\n确认导出\n\n\n\n得到 AD 的 pcb 文件\n\n\n\n\n\n\n\n\n\n\n\n生成的是 pcb 文件，需要再 AD 中生成元件封装库\n\n生成元件封装库\n\n\n\n得到元件封装库\n\n\n导出 3D 模型文件\n\n导出 3D 模型\n\n\n\n选择导出\n\n\n\n使用 FreeCAD 打开文件，并删除 PCB 底板\n\n\n\n导出 STEP 文件\n\n\n\n选中模型\n\n\n\n选择导出\n\n\n\n保存\n\n","slug":"Altium-Designer/立创EAD导出AD封装","date":"2022-09-08T08:43:00.000Z","categories_index":"电子技术","tags_index":"Altium Designer,立创EDA","author_index":"爱慢跑的乌龟"},{"id":"042597e1033e319d05b0a52bf84695b9","title":"Python 字典操作","content":"1. 字典介绍\n字典是一种可变容器模型，且可存储任意类型对象。\n字典的每个键值对 key : value 用冒号 : 分割，每个对之间用逗号 \",\" 分割，整个字典包括在花括号{}中，格式如下：\nd &#x3D; &#123;key1 : value1, key2 : value2, key3 : value3&#125;\n2. 字典的增、删、改、查\n添加：\ninfo_dict &#x3D; &#123;&#39;姓名&#39;:&#39;张三&#39;, &#39;性别&#39;:&#39;男&#39;, &#39;年龄&#39;:22&#125;\nprint(&#39;原始字典： &#39;, info_dict)\n# 原始字典： &#123;&#39;姓名&#39;:&#39;张三&#39;, &#39;性别&#39;:&#39;男&#39;, &#39;年龄&#39;:22&#125;\n\n# 添加1，key不相同则添加\ninfo_dict[&#39;住址&#39;] &#x3D; &#39;北京&#39;\nprint(&#39;添加1: &#39;, info_dict)\n# 添加1: &#123;&#39;姓名&#39;:&#39;张三&#39;, &#39;性别&#39;:&#39;男&#39;, &#39;年龄&#39;:22, &#39;住址&#39;:&#39;北京&#39;&#125;\n\n# 添加2， key相同则替换\ninfo_dict[&#39;姓名&#39;:&#39;张三丰&#39;]\nprint(&#39;添加2: &#39;, info_dict)\n# 添加2: &#123;&#39;姓名&#39;:&#39;张三丰&#39;, &#39;性别&#39;:&#39;男&#39;, &#39;年龄&#39;:22&#125;\n删除:\ninfo_dict &#x3D; &#123;&#39;姓名&#39;:&#39;张三&#39;, &#39;性别&#39;:&#39;男&#39;, &#39;年龄&#39;:22&#125;\nprint(&#39;原始字典： &#39;, info_dict)\n# 原始字典： &#123;&#39;姓名&#39;:&#39;张三&#39;, &#39;性别&#39;:&#39;男&#39;, &#39;年龄&#39;:22&#125;\n\n# 删除1， 根据key删除\ninfo_dict.pop(&#39;性别&#39;)\nprint(&#39;删除1: &#39;， info_dict)\n# 删除1: &#123;&#39;姓名&#39;:&#39;张三&#39;, &#39;年龄&#39;:22&#125;\n\n# 删除2，随机删除\ninfo_dict.popitem()\nprint(&#39;删除2&#39;, info_dict)\n# &#123;&#39;姓名&#39;:&#39;张三&#39;&#125;\n\n# 删除3：清空字典\ninfo_dict.clear()\nprint(&#39;清空: &#39;, info_dict())\n# 清空：&#123;&#125;\n\n# 删除字典\ndel info_dict\n修改：\ninfo_dict &#x3D; &#123;&#39;姓名&#39;:&#39;张三&#39;, &#39;性别&#39;:&#39;男&#39;, &#39;年龄&#39;:22&#125;\nprint(&#39;原始字典： &#39;, info_dict)\n# 原始字典： &#123;&#39;姓名&#39;:&#39;张三&#39;, &#39;性别&#39;:&#39;男&#39;, &#39;年龄&#39;:22&#125;\n\n# 修改\ninfo_dict[&#39;姓名&#39;] &#x3D; &#39;张三丰&#39;\nprint(info_dict)\n# &#123;&#39;姓名&#39;:&#39;张三丰&#39;, &#39;性别&#39;:&#39;男&#39;, &#39;年龄&#39;:22&#125;\n查询：\ninfo_dict &#x3D; &#123;&#39;姓名&#39;:&#39;张三&#39;, &#39;性别&#39;:&#39;男&#39;, &#39;年龄&#39;:22&#125;\nprint(&#39;原始字典： &#39;, info_dict)\n# 原始字典： &#123;&#39;姓名&#39;:&#39;张三&#39;, &#39;性别&#39;:&#39;男&#39;, &#39;年龄&#39;:22&#125;\n\n# 咨询\n# 咨询1，使用key\nname &#x3D; info_dict[&#39;姓名&#39;]\nprint(&#39;key查询: &#39;, name)\n# 张三\n\n# 咨询2，使用get()\nage &#x3D; info_dict.get(&#39;年龄&#39;)\nprint(&#39;get查询: &#39;, age)\n# 22\n3. keys()、values()、item()\ninfo_dict &#x3D; &#123;&#39;姓名&#39;:&#39;张三&#39;, &#39;性别&#39;:&#39;男&#39;, &#39;年龄&#39;:22&#125;\nprint(&#39;原始字典：&#39;,info_dict)\n# 原始字典： &#123;&#39;姓名&#39;: &#39;张三&#39;, &#39;性别&#39;: &#39;男&#39;, &#39;年龄&#39;: 22&#125;\n\nprint(&#39;key:&#39;, info_dict.keys())\nprint(&#39;value:&#39;, info_dict.values())\nprint(&#39;item:&#39;, info_dict.items())\n&#39;&#39;&#39;\nkey: dict_keys([&#39;姓名&#39;, &#39;性别&#39;, &#39;年龄&#39;])\nvalue: dict_values([&#39;张三&#39;, &#39;男&#39;, 22])\nitem: dict_items([(&#39;姓名&#39;, &#39;张三&#39;), (&#39;性别&#39;, &#39;男&#39;), (&#39;年龄&#39;, 22)])\n&#39;&#39;&#39;\n通过key获取所有的键：\ninfo_dict &#x3D; &#123;&#39;姓名&#39;:&#39;张三&#39;, &#39;性别&#39;:&#39;男&#39;, &#39;年龄&#39;:22&#125;\nprint(&#39;原始字典：&#39;,info_dict)\n# 原始字典： &#123;&#39;姓名&#39;: &#39;张三&#39;, &#39;性别&#39;: &#39;男&#39;, &#39;年龄&#39;: 22&#125;\n\nfor key in info_dict:\n    print(&#39;key值为：&#39;, key)\n\n&#39;&#39;&#39;\nkey值为： 姓名\nvalue值为： 张三\nkey值为： 性别\n&#39;&#39;&#39;\n通过values获取所有的值：\ninfo_dict &#x3D; &#123;&#39;姓名&#39;:&#39;张三&#39;, &#39;性别&#39;:&#39;男&#39;, &#39;年龄&#39;:22&#125;\nprint(&#39;原始字典：&#39;,info_dict)\n# 原始字典： &#123;&#39;姓名&#39;: &#39;张三&#39;, &#39;性别&#39;: &#39;男&#39;, &#39;年龄&#39;: 22&#125;\n\nfor value in info_dict.values():\n    print(value)\n    \n&#39;&#39;&#39;\n张三\n男\n22\n&#39;&#39;&#39;\n4. 合并字典\n使用update()方法合并：\ndict1 &#x3D; &#123;&#39;姓名&#39;: &#39;张三&#39;, &#39;性别&#39;: &#39;男&#39;, &#39;年龄&#39;: 22&#125;\ndict2 &#x3D; &#123;&#39;刘备&#39;: &#39;玄德&#39;, &#39;张飞&#39;: &#39;翼德&#39;, &#39;曹操&#39;: &#39;孟德&#39;&#125;\n# print(&#39;字典1：&#39;, dict1)\n# print(&#39;字典2：&#39;, dict2)\n&#39;&#39;&#39;\n字典1： &#123;&#39;姓名&#39;: &#39;张三&#39;, &#39;性别&#39;: &#39;男&#39;, &#39;年龄&#39;: 22&#125;\n字典2： &#123;&#39;刘备&#39;: &#39;玄德&#39;, &#39;张飞&#39;: &#39;翼德&#39;, &#39;曹操&#39;: &#39;孟德&#39;&#125;\n&#39;&#39;&#39;\n\n# 使用update()合并\ndict1.update(dict2)\nprint(dict1)\n# &#123;&#39;姓名&#39;: &#39;张三&#39;, &#39;性别&#39;: &#39;男&#39;, &#39;年龄&#39;: 22, &#39;刘备&#39;: &#39;玄德&#39;, &#39;张飞&#39;: &#39;翼德&#39;, &#39;曹操&#39;: &#39;孟德&#39;&#125;\n\ndict2.update(dict1)\nprint(dict2)\n# &#123;&#39;刘备&#39;: &#39;玄德&#39;, &#39;张飞&#39;: &#39;翼德&#39;, &#39;曹操&#39;: &#39;孟德&#39;, &#39;姓名&#39;: &#39;张三&#39;, &#39;性别&#39;: &#39;男&#39;, &#39;年龄&#39;: 22&#125;\n**使用**合并：**\ndict1 &#x3D; &#123;&#39;姓名&#39;: &#39;张三&#39;, &#39;性别&#39;: &#39;男&#39;, &#39;年龄&#39;: 22&#125;\ndict2 &#x3D; &#123;&#39;刘备&#39;: &#39;玄德&#39;, &#39;张飞&#39;: &#39;翼德&#39;, &#39;曹操&#39;: &#39;孟德&#39;&#125;\n# print(&#39;字典1：&#39;, dict1)\n# print(&#39;字典2：&#39;, dict2)\n&#39;&#39;&#39;\n字典1： &#123;&#39;姓名&#39;: &#39;张三&#39;, &#39;性别&#39;: &#39;男&#39;, &#39;年龄&#39;: 22&#125;\n字典2： &#123;&#39;刘备&#39;: &#39;玄德&#39;, &#39;张飞&#39;: &#39;翼德&#39;, &#39;曹操&#39;: &#39;孟德&#39;&#125;\n&#39;&#39;&#39;\n\n# 使用**合并\ndict3 &#x3D; dict(dict1, **dict2)\nprint(dict3)\n# &#123;&#39;姓名&#39;: &#39;张三&#39;, &#39;性别&#39;: &#39;男&#39;, &#39;年龄&#39;: 22, &#39;刘备&#39;: &#39;玄德&#39;, &#39;张飞&#39;: &#39;翼德&#39;, &#39;曹操&#39;: &#39;孟德&#39;&#125;\n使用|合并：\ndict1 &#x3D; &#123;&#39;姓名&#39;: &#39;张三&#39;, &#39;性别&#39;: &#39;男&#39;, &#39;年龄&#39;: 22&#125;\ndict2 &#x3D; &#123;&#39;刘备&#39;: &#39;玄德&#39;, &#39;张飞&#39;: &#39;翼德&#39;, &#39;曹操&#39;: &#39;孟德&#39;&#125;\n\ndict3 &#x3D; dict1|dict2\nprint(dict3)\n&#39;&#39;&#39;\n&#123;&#39;姓名&#39;: &#39;张三&#39;, &#39;性别&#39;: &#39;男&#39;, &#39;年龄&#39;: 22, &#39;刘备&#39;: &#39;玄德&#39;, &#39;张飞&#39;: &#39;翼德&#39;, &#39;曹操&#39;: &#39;孟德&#39;&#125;\n&#39;&#39;&#39;\n5. 检查键是否在于字典中\ndict &#x3D; &#123;&#39;刘备&#39;: &#39;玄德&#39;, &#39;张飞&#39;: &#39;翼德&#39;, &#39;曹操&#39;: &#39;孟德&#39;&#125;\n\ndef key_in_dict(dict, key):\n    return key in dict\n\nif __name__ &#x3D;&#x3D; &#39;__main__&#39;:\n    print(key_in_dict(dict, &#39;刘备&#39;))\n    print(key_in_dict(dict, &#39;关羽&#39;))\n\n&#39;&#39;&#39;\nTrue\nFalse\n&#39;&#39;&#39;\n6. 获取字典中所有键组成的列表\ndict &#x3D; &#123;&#39;刘备&#39;: &#39;玄德&#39;, &#39;张飞&#39;: &#39;翼德&#39;, &#39;曹操&#39;: &#39;孟德&#39;&#125;\n\ndef get_keys(dict):\n    return list(dict.keys())\n\nif __name__ &#x3D;&#x3D; &#39;__main__&#39;:\n    print(get_keys(dict))\n\n&#39;&#39;&#39;\n[&#39;刘备&#39;, &#39;张飞&#39;, &#39;曹操&#39;]\n&#39;&#39;&#39;\n7. 获取字典中所有值组成的列表\ndict &#x3D; &#123;&#39;刘备&#39;: &#39;玄德&#39;, &#39;张飞&#39;: &#39;翼德&#39;, &#39;曹操&#39;: &#39;孟德&#39;&#125;\n\ndef get_keys(dict):\n    return list(dict.values())\n\nif __name__ &#x3D;&#x3D; &#39;__main__&#39;:\n    print(get_keys(dict))\n\n&#39;&#39;&#39;\n[&#39;玄德&#39;, &#39;翼德&#39;, &#39;孟德&#39;]\n&#39;&#39;&#39;\n8. 将字典所有键值对转换为元组列表\ndict &#x3D; &#123;&#39;刘备&#39;: &#39;玄德&#39;, &#39;张飞&#39;: &#39;翼德&#39;, &#39;曹操&#39;: &#39;孟德&#39;&#125;\n\ndef dict_to_list(dict):\n    return list(dict.items())\n\nif __name__ &#x3D;&#x3D; &#39;__main__&#39;:\n    print(dict_to_list(dict))\n&#39;&#39;&#39;\n[(&#39;刘备&#39;, &#39;玄德&#39;), (&#39;张飞&#39;, &#39;翼德&#39;), (&#39;曹操&#39;, &#39;孟德&#39;)]\n&#39;&#39;&#39;\n9. 将两个列表组合为一个字典\nlist1 &#x3D; [&#39;姓名&#39;, &#39;性别&#39;, &#39;年龄&#39;]\nlist2 &#x3D; [&#39;张三&#39;, &#39;男&#39;, 22]\n\ndef list_to_dict(keys, values):\n    return dict(zip(keys, values))\nif __name__ &#x3D;&#x3D; &#39;__main__&#39;:\n    print(list_to_dict(list1, list2))\n    \n&#39;&#39;&#39;\n&#123;&#39;姓名&#39;: &#39;张三&#39;, &#39;性别&#39;: &#39;男&#39;, &#39;年龄&#39;: 22&#125;\n&#39;&#39;&#39;\n10. 计算字典长度\ndict &#x3D; &#123;&#39;刘备&#39;: &#39;玄德&#39;, &#39;张飞&#39;: &#39;翼德&#39;, &#39;曹操&#39;: &#39;孟德&#39;&#125;\n\nprint(len(dict))\n&#39;&#39;&#39;\n3\n&#39;&#39;&#39;\n","slug":"Pyhon/Python 字典操作","date":"2022-08-25T07:00:00.000Z","categories_index":"Python","tags_index":"Python tips","author_index":"爱慢跑的乌龟"},{"id":"a6cc85e12f76b1f87c9f343cdd3617c3","title":"Python 字符串操作","content":"1. 字符串的创建\nvar1 &#x3D; &#39;hello&#39;\nvar2 &#x3D; &#39;world&#39;\n2. Python 访问字符串中的值\npython中使用切片来截取字符串其中一段内容，切片截取的内容不包含结束下标对应的数据\n[起始下标 : 结束下标 : 步长]\nvar &#x3D; &#39;helloworld&#39;\nstr &#x3D; var[0:2]\nprint(str)\n&#39;&#39;&#39;\nhe\n&#39;&#39;&#39;\n从后向前索引\nvar &#x3D; &#39;helloworld&#39;\nstr &#x3D; var[-4:-2]\nprint(str)\n&#39;&#39;&#39;\nor\n&#39;&#39;&#39;\n3. 循环输出\nstr &#x3D; &#39;ab def&#39;\nfor i in str:\n    print(i)\n&#39;&#39;&#39;\na\nb\n\nd\ne\nf\n&#39;&#39;&#39;\n4. 统计出现的次数\nstr &#x3D; &#39;ab def&#39;\nprint(str.count(&#39;a&#39;))\n&#39;&#39;&#39;\n1\n&#39;&#39;&#39;\n5. 元素以指定的字符连接生成一个新的字符串\nstr &#x3D; &#39;ab def&#39;\nprint(&#39;-&#39;.join(str))\n&#39;&#39;&#39;\na-b- -d-e-f-\n&#39;&#39;&#39;\n6. 去除左空格\nstr &#x3D; &#39;ab def&#39;\nprint(str.lstrip())\n&#39;&#39;&#39;\nab def\n&#39;&#39;&#39;\n7. 去除右空格\nstr &#x3D; &#39; ab def &#39;\nprint(str.rstrip())\n&#39;&#39;&#39;\n ab def\n &#39;&#39;&#39;\n8. 去除两边空格\nstr &#x3D; &#39; ab def &#39;\nprint(str.strip())\n&#39;&#39;&#39;\nab def\n&#39;&#39;&#39;\n9. 判断目标字符是否存在\nstr &#x3D; &#39; ab def &#39;\nprint(str.find(&#39;c&#39;))\nprint(str.find(&#39;d&#39;))\n&#39;&#39;&#39;\n-1\n4\n&#39;&#39;&#39;\n10. 检查目标字符索引\nstr &#x3D; &#39; ab def&#39;\nprint(str.index(&#39;b&#39;))\n&#39;&#39;&#39;\n2\n&#39;&#39;&#39;\n11. 判断字符串是否以固定字符开始\nstr &#x3D; &#39;Hello World&#39;\nprint(str.startswith(&#39;h&#39;))\nprint(str.startswith(&#39;H&#39;))\n&#39;&#39;&#39;\nFalse\nTrue\n&#39;&#39;&#39;\n12. 判断字符串是否以固定字符结尾\nstr &#x3D; &#39;Hello World&#39;\nprint(str.endswith(&#39;D&#39;))\nprint(str.endswith(&#39;d&#39;))\n&#39;&#39;&#39;\nFalse\nTrue\n&#39;&#39;&#39;\n13. 首字母转换为大写\nstr &#x3D; &#39;helloworld&#39;\nprint(str.capitalize())\n&#39;&#39;&#39;\nHelloworld\n&#39;&#39;&#39;\n14. 转大写\nstr &#x3D; &#39;Hello World&#39;\nprint(str.upper())\n&#39;&#39;&#39;\nHELLO WORLD\n&#39;&#39;&#39;\n15. 转小写\nstr &#x3D; &#39;Hello World&#39;\nprint(str.lower())\n&#39;&#39;&#39;\nhello world\n&#39;&#39;&#39;\n16. 首字母转大写\nstr &#x3D; &#39;hello world&#39;\nprint(str.title())\n&#39;&#39;&#39;\nHello World\n&#39;&#39;&#39;\n17. 大写变小写，小写变大写\nstr &#x3D; &#39;Hello World&#39;\nprint(str.swapcase())\n&#39;&#39;&#39;\nhELLO wORLD\n&#39;&#39;&#39;\n18. 分割字符串\nstr &#x3D; &#39;Hello World&#39;\nprint(str.split(&#39; &#39;))\n# [&#39;Hello&#39;, &#39;World&#39;]\n","slug":"Pyhon/Python 字符串操作","date":"2022-08-15T07:00:00.000Z","categories_index":"Python","tags_index":"Python tips","author_index":"爱慢跑的乌龟"},{"id":"89d442f48e0b4ccbd2aa5cc42a297c7d","title":"侧风引起的车辆运动","content":"\n\n\n\n\n\n\n\n\n高速行驶的车辆在受到侧向风力作用时，将会产生侧向运动。\n侧风干扰力\n设以速度  直线行驶的车辆，受到速度为  的侧向风的作用，则作用于车辆的侧向力  和横摆力矩  表达为 \n\n\n\n侧风引起的干扰力和横摆力矩\n\n\n - 侧向力系数\n - 横摆力矩系数\n - 空气密度\n - 表示车辆尺寸，通常取为轴距\n\n 和  均为气流相对侧偏角  的函数。 和  均随  的增加而增加，并受车辆形状的影响较为明显。\n侧向力  的作用点称为空气力学中心（AC）。 设 AC 与车辆质心的距离为 吗，并定义 AC 在车辆质心之后时  为正。作用于车辆的横摆力矩  可写为： \n由恒定速度侧风引起的车辆运动\n\n\n速度恒定的侧向风\n\n车辆受一个速度的恒定的侧向风作用。此时，假定侧向力  为阶跃力并作用于车辆的空气力学中心 。\n用固定于车辆的坐标系来方便地表达车辆的运动。车辆的运动方程如下： \n\n对上式进行拉普拉斯变换，得： \n\n其中， Misplaced & b_{\\beta}&amp;=\\frac{2(l_f^2K_f+l_r^2K_r)+2l_{\\text{w}}(l_fK_f-l_rK_r)}{IV}+\\frac{ml_{\\text{w}}V}{I}\\\\ &amp;=\\frac{2}{IV}[l_f^2K_f+l_r^2K_r-l_{\\text{w}}l_{\\text{N}}(K_f+K_r)]+\\frac{ml_{\\text{w}}V}{I} \n\n\n - 阶跃侧向力的幅值\n\n根据上述方程，得到  和  的稳态值如下： \n\n\n - NSP 至车辆质心的距离\n\n\n如果空气力学中心 AC 位于 NSP 前方，车辆将最终沿逆时针方向作圆周运动；如果 AC 与 NSP 恰巧重合，则车辆将不作圆周运动（瞬态期间除外）；若 AC 位于 NSP 后方，则车辆沿顺时针方向作圆周运动。而车辆质心与 AC 和 NSP 的相对位置则对车辆运动无直接影响。（当  时，假定 ）\n设侧向加速度的稳态值为 ，单位侧向风引起的稳态侧向加速度值为：  该值被称为侧风敏感系数，可以用作表征车辆对侧风干扰的敏感程度指标。\n\n\n\n\n\n\n\n\n\n例题 4.2\n试求车辆在恒定速度的侧风作用下，为保持其直线行驶所需的前轮转向角，并计算在该直线行驶过程中车辆的姿态角。\n解： 根据车辆对侧风作用的稳态横摆角速度响应和对转向输入的稳态横摆角速度响应。若两者之和为零，即可认为侧风引起的车辆运动被前轮转向输入引起的横摆运动所抵消，即由一下方程描述车辆在侧风作用下直线行驶：  根据上述方程，可求得转向角为：  要使车辆在侧风作用下维持直线行驶的路径，当  大于  时，需要给车辆施加抵抗侧风的反向转向角；相反，当  小于  时，则需施加顺风的、与侧风方向相同的转向角。\n对直线路径而言，车辆的姿态角与侧偏角  时一致的。由于侧向风力全部由前、后轮胎力来平衡，即：  求得车辆的姿态角为： \n\n\n\n由侧向阵风引起的车辆运动\n车辆在受到短促的侧向阵风作用下的情况。其中车辆转向角固定为零，侧向风力 ，作用于车辆的空气动力学中心 AC。\n\n\n短促的侧向阵风引起的侧向力\n\n用固定于地面的绝对坐标系来描述车辆的运动。运动方程如下： \n\n对上式进行拉普拉斯变换： \n\n其中， \n\n\n由上述方程，可得到稳态值如下： 其中其中\n\n如果其 AC 在 NSP 之前，将转向背风面并顺风行驶；若 AC 与 NSP 重合，车辆将短时间逆风行驶，然后又回到其原有方向行驶；如果 AC 在 NSP 之后，车辆将短时间内飘移到逆风状态，然后转向迎风面并逆风行驶。\n\n\n\n\n\n\n\n\n\n例题 4.3\n使用 Matlab-Simulink 软件进行侧向阵风作用下的车辆运动仿真，其中风速为 25 m/s，作用时间为 0.4 s，车辆的行驶速度为 40 m/s.\n解： 计算得到 \n车辆在侧向阵风作用下的运动方程： \n\n\n\n\n\n积分框图\n\n\n\n参数设置\n\n\n\n仿真结果\n\n\n\n轨迹\n\n","slug":"Vehicle Dynamics/侧风引起的车辆运动","date":"2022-08-10T14:16:00.000Z","categories_index":"车辆动力学","tags_index":"《车辆操纵动力学理论与应用》","author_index":"爱慢跑的乌龟"},{"id":"7c9364c1fe52fd3e1a8da24093d3f563","title":"质心侧向力所引起的车辆运动","content":"\n\n\n\n\n\n\n\n\n当车辆行驶在侧向倾斜的路面上时，其重力的侧向分量即为作用于车辆质心的侧向力。\n\n\n施加于车辆质心 CG 的侧向力\n\n阶跃侧向力作用下车辆的运动\n设前轮转角为零，持续作用于质心的侧向力为 ，根据车辆的运动方程(车辆运动方程 - 固定于车辆坐标系下的运动方程)： \n\n假设车辆运动的过程中  的幅值不大，且侧偏角条件  总成立。\n对上式进行拉普拉斯变换，得到车辆侧偏角和横摆角速度对侧向力  的响应  和 ： \n\n\n\n\n - 固有频率\n - 阻尼系数\n\n稳态条件\n\n\n阶跃侧向力\n\n通过拉普拉斯变换，分别得到  和  的稳态值： \n\n  总为正； 则是在  （即不足转向）情况下为正，而在  （即过多转向）且  时为负。\n\n\n具有不足转向特性车辆的稳态情况\n\n在侧向力  的作用下，车辆产生一个侧偏角 。因此，在前、后轮胎将会产生大小为  和  的作用力，其合力为 ，作用在中性转向点  上，方向与  相反。如果车辆表现为不足转向特性，则  位于质心的后方，并且会产生一个绕  点逆时针方向的横摆力矩。\n绕  点的逆时针的横摆运动所产生的前、后轮侧偏角分别为  和 ，则前、后轮所产生的侧偏力大小分别为  和 ，两者方向相反，以平衡外部侧向力所产生的横摆力矩。\n车辆受到的离心力  也作用在质心上，且与  方向相反。因为这些力处于平衡状态，所以车辆作稳态转向，且朝外偏离圆周向外运动。\n\n\n具有中性转向特性车辆的稳态情况\n\n由于具有中性转向特性的车辆的  与质心  重合，所以合力  不会产生横摆力矩，车辆也不会作横摆运动。当产生侧偏角时，车辆仍继续它的平移运动。\n\n\n具有过多转向特性车辆的稳态情况\n\n当车辆呈过多转向特性时， 位于  点的前方，合力  将产生一个顺时针方向绕质心的横摆力矩。为了平衡这个横摆力矩，前、后轮产生侧向力  和 ，使得车辆作顺时针的横摆运动。作用于质心的离心力  与  方向相同。当车辆具有过多转向特性时的情况相反，车头会朝着圆周内侧运动。\n\n\n侧偏角(a)和横摆角速度(b)随车速的变化关系\n\n对于过多转向特性的车辆而言，其对外部扰动的敏感程度随这车速的增加而增加。\n瞬态响应\n车辆运动的瞬态响应为：\n当  时，  \n当  时，有 \n\n当  时，瞬态响应表现为振荡，具体为  其中， \n\n其中，  结论：\n当受到侧向力干扰  的作用时，不足转向车辆的瞬态响应减弱了侧向干扰力的影响。正是由于侧向力  引起的车辆运动，使得侧向力  的影响变小了。最后，车辆运动达到稳态条件。\n中性转向车辆对作用于其质心的侧向力  的响应，仅由其侧偏运动来体现。\n当呈过多转向特性时，车辆并不总是像不足转向情况那样，会减弱外部侧向力  的影响。相反，车辆的运动可能会激发  对车辆的影响。特别是离心力会随车速的增加而增加。当超过某一极限车速时，由车辆横摆运动引起的离心力会变得过大，而且会增大作用于车辆的横摆力矩。最终车辆陷入旋转运动。\n\n\n质心受阶跃侧向力作用下车辆的运动\n\n\n\n\n\n\n\n\n\n\n例题 4.1\n采用 Matlab-Simulink 软件，仿真在车辆质心处受到 4kN 的侧向力时车辆的响应。设行驶车速为 80km/h，转向角始终固定为 0。\n令 ，得到车辆的运动方程为： \n\n计算车辆轨迹： \n\n\n\n车辆运动积分形式框图\n\n\n\n车辆参数\n\n\n\n车辆行驶轨迹\n\n\n\n仿真结果\n\n脉冲侧向力作用下车辆的运动\n如果转向角为零，当  时，在侧向力  作用下的车辆运动方程可表述为： \n\n\n\n作用于质心的脉冲侧向力\n\n当  相比车辆的运动变化周期足够小时，侧向力  的近似拉普拉斯变换  可记为  。对上述运动方程进行拉普拉斯变换，得： \n\n其中， \n\n\n根据以上方程，当车辆达到稳态时，有： （其中）（其中）\n\n在  时间段内，车辆对侧向力  得瞬态响应与阶跃侧向力作用下的瞬态响应相同。在  时刻，侧向力  变为 0， 车辆质心处的侧偏角立刻减小，有横摆运动引起的轮胎侧向力变得更具主导作用，以抑制车辆的横摆运动，并使车辆维持一个相对原有行驶方向恒定的横摆角。这个横摆角对不足转向车辆为正，而对过多转向车辆为负。对车辆在绝对坐标系中的侧向位移  而言，对不足转向车辆沿正向增大，而对过多转向车辆则沿负向增大。当车辆呈中性转向特性时，车辆不会产生侧偏角，因而在原有运动方向作一恒定的侧向位移后，仍继续沿原有方向直线行驶。\n\n\n质心受脉冲侧向力作用下车辆的运动\n\n","slug":"Vehicle Dynamics/质心侧向力所引起的车辆运动","date":"2022-08-07T07:20:00.000Z","categories_index":"车辆动力学","tags_index":"《车辆操纵动力学理论与应用》","author_index":"爱慢跑的乌龟"},{"id":"1f8b736ff94c1eb5090dfe6a571c51cd","title":"车辆的动态特性","content":"车辆对转向输入的瞬态响应\n瞬态响应和方向稳定性\n描述车辆运动的基本方程为：  其特性方程为：  或  其中， \n\n且车辆的横摆转动惯量可写为： \n\n - 横摆力矩半径\n\n代入上式得： \n由特征方程所表示的系统，其响应可由  表示，其中  和  为方程的根：  车辆瞬态响应特性及其稳定性可按  和  的情况作如下分类：\n\n当 、 时， 和  为负数，瞬态响应作无振荡衰减（系统稳定）;\n当  时， 和  为复数，若其实部为负，瞬态响应作振荡衰减（系统稳定）;\n当  时， 和  一个为负实数，一个为正实数，瞬态响应为非振荡发散（系统不稳定）。\n\n线性系统稳定性的充分必要条件是：系统特征方程的根全部为负实数或具有负实部的共轭复数。\n考虑第  种情况。若 ，则必须 。设  时得车速为 ，则  对于所有大于  的车速，均有  成立。\n\n车辆的稳定性条件可表示如下：  要使车辆处于稳定状态，前、后轮的侧偏刚度应分别具有上限值和下限值。\n将不等式改写如下：  得到前轮侧偏刚度的上限值如下：  得到后轮侧偏刚度的下限如下：  \n\n前、后轮侧偏刚度的上、下限值与车速的关系\n\n\n若  且车辆呈不足转向特性，或虽然车辆表现过多转向特性但 ，那么  总是大于 0，即车辆运动是稳定的。与其相对应的就是第  和  种情况。   的系数总是为正。第一项中  为正或者 0 时，那么  也为正或 0。也就是说，若车辆的稳态转向特性为过多转向或中性转向时，则无论车辆对于转向输入的瞬态响应是否稳定，都总是非振荡的。\n当  为负时， 的值取决于 ，当超出某一特定车速后， 由正变负。也就是说，当车辆呈不足转向特性时，在车速低于该特定车速的情况下，车辆对转向输入的瞬态响应表现为非振荡的形式；一旦高于该特定车速，则其响应表现为振荡。\n当车辆的横摆转动惯量大于或小于某一定值时，车辆对转向输入的响应由非振荡向振荡变化的速度总是会增加。\n车辆对转向输入的瞬态响应特性与车辆行驶速度和转向特性尤为相关。\n\n车辆的转向特性和瞬态响应\n\n\n\n\n对车辆瞬态响应的定性理解\n\n固有频率和阻尼比\n设固有频率为 ，阻尼比为 ，则由特征方程的系数可得： \n\n\n\n\n\nSM 和车速对固有频率的影响\n\n固有频率  随着车辆行驶速度的增大而减小，但它仅随 SM 的增大略有增加。\n\n\nSM 和车速对阻尼比的影响\n\n随着 SM 的增大，阻尼比减小，从而导致车辆对于转向输入的响应也愈加振荡。\n当车辆呈不足转向特性时， 随车速的增加而减小，车辆运动则变为小阻尼运动，从而会引发更多的振荡。\n当车辆呈过多转向特性时， 随车速的增大而增大，从而使车辆对转向输入的响应恶化。\n当车辆呈中性转向特性时，或不论车辆的转向特性如何而  接近于 0 时，都有 ，这时我们可以认为车辆处于临界阻尼状态。\n响应性\n对稳定的线性系统而言，设其特征方程的特征根实部为 ，则响应时间就是表示其系统响应速度的一个参数，即  当  时， 为：  当  时，有：  车辆动态特性的基本性质（如固有频率 、阻尼比  以及响应时间 ）取决于车辆的行驶速度和以静态裕度 SM 衡量的转向特性。\n转向输入响应的传递函数和响应时间历程\n车辆基本运动方程的拉普拉斯变换： \n\n对  和  求解其代数方程，可得： \n\n使用  和  来表示：  其中， \n\n并且有 \n\n\n\n - 质心侧偏角增益常数，是车辆作稳态转向时其侧偏角  相对于其转角  的稳态值\n - 横摆角速度增益常数，是稳态转向中横摆角速度  相对于转向角  的稳态值\n\n通过拉氏反变换得到时域响应： \n\n设  和  的初始值为 0.\n当车辆表现为非振荡响应(即 )时， 和  如下： \n\n当车辆响应为无振荡的临界状态(即 )时，有： \n\n当车辆响应为由振荡(即 ) 时，有：  其中， \n\n其中，  关于车辆对转向输入的响应性，可由当横摆角速度达到稳态的时间  以及达到第一个振荡峰值的时间  来表示：\n\n\n横摆角速度的响应性\n\n关于  和  的计算公式如下： \n\n通过 Matlab/Simulink 来数值仿真车俩的运动方程。将车辆的运动方程改写为： \n\n\n\n车辆对转向输入的运动响应\n\n\n\n\n\n\n\n\n\n\n\n例：试用 Matlab-Simulink 对车辆在阶跃转向输入下的响应进行仿真，其中 ，车速分别为 、 和 ，车辆参数：，，，，，。\n\n\n仿真中车车辆参数的设置\n\n\n\n仿真程序框\n\n\n\n仿真结果\n\n\n使用地面固定坐标系对车辆的运动进行描述：\n\n\n分别求解关于  和  的代数方程，得： \n\n使用  和  来表示，得：  其中， \n\n\n\n - 侧向加速度增益常数，表示车辆稳态转向运动时，其侧向加速度对  的响应\n\n\n车辆对于周期性转向输入的响应\n对于周期性输入 ，车辆质心处的侧向加速度响应为： \n\n - 周期性转向输入的频率\n\n\n由上式可得相对于转向角的侧行加速度增益  和相位角 ，分别为： \n\n其中， \n\n对周期性转向输入  的车辆横摆角速度  的响应为：  对转向输入的横摆角速度增益  和相位角  分别为： \n\n其中， \n\n\n\n横摆角速度频率响应示意图\n\n当转向输入的频率较小时，横摆角速度对转向输入的增益几乎为恒定值。随着转向输入频率的增大，对于具有不足转向特性的车辆而言，其增益在某一频率处达到峰值，然后下降。而对于具有过多转向和中性转向特性而言，其增益不存在峰值，而是随转向输入频率的增大而减小。\n对相频特性而言，在低频率时，相位迟滞接近零；但随频率的增加，相位迟滞会急剧增加。三种转向特性下均表现如此，只是这种趋势对具有过多转向特性的车辆而言更明显。对具有不足转向特性的车辆而言，其横摆角速度增益的峰值发生在车辆瞬态响应相对某一固定转向发生振荡的时刻。该峰值会随着阻尼比  的较小而增大。当车辆呈不足转向特性时，行驶速度  越大，此峰值就会越大。出现此峰值的频率接近于车辆的固有频率 。\n","slug":"Vehicle Dynamics/车辆的动态特性","date":"2022-07-25T08:58:00.000Z","categories_index":"车辆动力学","tags_index":"《车辆操纵动力学理论与应用》","author_index":"爱慢跑的乌龟"},{"id":"9ab12d58e32b064120d052ffccea039c","title":"车辆的稳态转向","content":"\n\n\n\n\n\n\n\n\n现有可用的几种方法，可以不通过直接求解运动方程来理解其基本运动特性。\n\n通过分析这个力学系统的稳态条件来了解其静态特性\n通过考虑该力学系统的特征方程的特征根以及对周期性外界干扰的响应，以研究其力学特性\n\n稳态转向运动的描述\n车辆在作稳态转向运动时，其质心侧偏角和横摆角速度不变。因此，将稳态条件\n 和 \n代入运动方程（固定于车辆坐标系下的运动方程）： \n\n求解上述方程（克莱姆法则）： \n\n其中，  整理上式可得： \n\n若车辆以恒定速度 、横摆角速度\n 作稳态转向运动，则其稳态转向半径\n 为：  假设车辆以 \n的低速作稳态转向运动，则上式中的  可以忽略不计，那么 、 和  可表示如下：  稳态转向式：  上述方程是以车辆作 \n的低速稳态转向运动状态作为基准，表明了车辆稳态转向运动的条件随车速的变化规律。\n稳态转向及转向特性\n不足转向(US)和过多转向(OS)特性\n设前轮转向角为 ，则转向半径  为：  当车辆以固定转向角  作稳态转向运动时，其转向半径\n 会随着行驶速度  的变化而变化。 的符号将直接影响  和  之间的关系。\n\n\n在固定转向角情况下转向半径与车速的关系\n\n\n当 \n时，车辆的转向半径随着速度的增大而增大。\n当 \n时，车辆的转向半径随着速度的增大而减小。\n\n\n\n随着车速的增加回转半径的变化情况。\n\n当 \n时，若保持转向角不变而增加车速，要想维持原来的圆周路径半径，转向角就显得不足。这样一种相对于车速增加转向角显得不足的特性，我们称之为不足转向特性(US)。\n当 \n时，若保持转向角不变而增加车速，要想继续维持原来的圆周路径半径，转向角将会显得过大。这样一种相对于车速的增加转向角呈过大的特性被称为过多转向特性(OS)。\n当 \n时，转向半径与行驶速度的变化无关，这种特性被称为中性转向特性(NS)。\n要想车辆维持等半径稳态转向运动，转向角需要随着随着车速的变化而变化，应满足如下条件：\n\n\n\n固定转向半径下的前轮转向角与车速关系\n\nUS、NS 和 OS 被统称为车辆的转向特性。\n当车辆以恒定转向角作稳态转向运动时，横摆角速度  和 车速  的关系可表示为： \n\n\n相对于车速的稳态横摆角速度\n\n\n具有 NS 特性的车辆，其横摆角速度随速度呈线性增长。\n具有 US\n特性的车辆，其横摆角速度也随车速的增大而增大，但增大到某一值后会发生饱和而不再增大。\n具有 OS 特性的车辆，其横摆角速度随车速的增加而迅速增大，直至到  出处于无穷大。\n\n对以恒定转向角作稳态转向的车辆而言，其质心侧偏角\n 和速度的关系为： \n\n\n相对于车速的稳态质心侧偏角\n\n不管车辆的转向特性如何，\n都随车速的增加而减小。超过某一速度后， 值变负，而其绝对值增大。\n\n如果车辆呈 OS 特性，则  在\n 处变为负无穷。\n如果车辆呈 US 特性，则 \n会在较高车速处达到饱和值。\n如果车辆呈 NS\n特性，不管车速如何，其转向角与转向半径或横摆角速度保持准静态的关系。\n\n车辆的质心侧偏角表明车辆在稳态转向运动中相对回转路径的姿态。随着车速的增加，侧偏角\n\n变为负值，且其绝对值增大。表明当车速增大时，车头会指向圆周运动轨迹的内侧。\n\n\n相对于圆周路径的车辆姿态\n\n稳定性临界车速和稳定性因数\n当车辆呈 OS 特性时，对于恒定的转向角，当车辆的行驶速度达到  时，车辆的横摆角速度  和侧偏角  将趋于无穷大。 可由下式求得：  解得：  由于是 OS 特性，所以 。\n注：\n当车辆呈 OS 特性时，特别值得注意的是，在  的情况下，车辆运动的不稳定性是在前轮转向角固定的前提下推导出的，但这并不表示车辆在超出\n 时就无法驾驶，还得取决于驾驶人的操纵能力。只是由于理论上存在一个稳定性临界车速，车辆设计者通常倾向于避免设计出呈\nOS 特性的车辆。\n定义稳定性因子  为：  如果 ，则  为：  稳定性因子 \n的符号决定着车辆的转向特性，它是相对于车速的一个表示稳态转向变化程度的重要指标。 也被称为 US/OS 梯度。\n静态裕度和中性转向点\n轮胎的侧偏力将产生绕车辆质心旋转的横摆力矩。当 \n为正时，则轮胎侧偏力的合力作用于车辆质心的前方；若  为\n0，合力作用点位于质心；若 \n为负，合力的作用点位于车辆质心的后方。将合力的作用点称为中性转向点(NSP)。\n\n\n由于车辆侧偏角引起的轮胎侧偏力的合力\n\n设 NSP 与车辆质心的距离为 ， 计算为：  用  除以 \n来定义静态裕度(SM)这个无量纲的量： \n\n当 ，则为 US；\n当 ，则为 NS；\n当 ，则为 OS。\n\n也可以通过前、后轮的侧偏角( 和 )来定义车辆的转向特性：\n\n当 \n时，则为 US；\n当  时，则为\nNS；\n当 \n时，则为 OS；\n\n\n\n稳态转向车辆的前、后轮侧偏角\n\n稳态转向与侧向加速度\n若车辆以如下的侧向加速度作稳态转向运动，即  则作用在其质心的离心力为 ，其中 \n为重力加速度。上式必须与作用于前、后车轮的侧向力相平衡，同时绕车辆质心的力矩应为\n0。于是，有：  因此，得：  如果轮胎得特性是线性的，即  联立上式，可得：  将其代入  得：  若车辆的转向半径恒定()，则侧向加速度与转向角之间的关系为：\n 若车辆的行驶速度恒定()，则：  此时侧向加速与转向角之间的关系为：  将 \n的系数定义为不足/过多转向（US/OS）梯度，即：  其中稳定性因子 \n表征了稳态转向对车速的依赖程度，不足/过多转向梯度则表征了其对侧向加速度的依赖程度。\n前、后轮胎转向变形：稳态转向时侧偏角除以侧向加速：\n\n\n稳态转向和轮胎的非线性特性\n设前、后轮胎的侧向力与其垂直载荷之比分别为  和 ： \n\n - 前轴载荷\n - 后轴载荷\n\n如果前、后轮的侧偏特性（ 和 ）给定，且车辆质心的侧向加速度\n\n已知，则可求出前、后轮的侧偏角  和  的大小。\n若已知侧向加速度 ，即可确定前、后轮的侧偏角（ 和 ），从而求得 。\n车辆作稳态转向时，无轮侧偏力和侧偏角是否满足线性关系，其几何关系始终成立。若圆周运动的转向半径为\n，则有： \n\n\n前后轮胎的非线性特性\n\n根据上图的  与 \n之间的关系，可以得到车辆以恒定转向半径作稳态转向时，其侧向加速度与转向角之间的关系。\n\n\n在恒定转向半径情况下车辆侧向加速度与转向角的关系\n\n对具有过多转向特性的车辆而言，随着  的增大， 迅速减小。当  时，则有 。该点定义了这样一个界限：作半径为\n\n定圆运动的车辆，想通过提高车速的办法来增加其侧向加速度是不可能的。\n当车辆以恒定车速 \n作圆周运动时，其转向半径为 ，侧向加速度与所需转向角之间的关系为：\n\n\n\n恒定车速下相对于侧向加速度的前轮转向角\n\n","slug":"Vehicle Dynamics/车辆的稳态转向","date":"2022-07-22T03:55:00.000Z","categories_index":"车辆动力学","tags_index":"《车辆操纵动力学理论与应用》","author_index":"爱慢跑的乌龟"},{"id":"f9c4292fa4fe978142ad10f6e4c2b397","title":"车辆运动方程","content":"\n\n\n\n\n\n\n\n\n考虑的只是车辆的侧向运动和横摆运动\n固定于车辆坐标系下的运动方程\n车辆坐标系：  表示车辆的纵向， 表示车辆的侧向，其中坐标系的原点位于车辆的质心  点。\n\n\n描述车辆平面运动的坐标轴\n\n对于  坐标系，质心  的位置矢量记为 ，则其速度矢量  可表示为： \n\n - 表示  方向\n - 表示  方向\n\n对速度求导，可得  点的加速度：  \n\n单位矢量的时间导数\n\n 和  在  时间内的变化量为：  于是，有： \n\n最终得出  点的加速度矢量 ，即  质心侧偏角 - 车辆行驶方向与其纵向的夹角  ()\n由于 ，所以可以认为  很小。若车辆的行驶速度时恒定的，则意味着  也是一个常数。\n通常用质心侧偏角  来描述车辆运动要更加方便。如果  小的情况下： \n\n由此可得： \n\n车辆的侧向运动和横摆运动会使轮胎产生侧偏角。侧偏角产生的侧向力反过来又成为控制车辆运动的力。\n\n\n车辆平面运动\n\n\n\n每个轮胎的侧偏力\n\n定义左、右前轮相对于  方向的夹角为实际的转向角 。车轮的侧偏角记为： 、、、，作用于车轮的侧偏力记为：、、、。\n车辆的侧向运动描述为： \n\n - 车辆的惯性质量\n\n车辆的横摆运动为： \n\n - 车辆的横摆转动惯量\n - 车辆质心到前后轴的距离\n\n轮胎的侧偏角定义为轮胎行进方向与轮胎航向(或车轮旋转平面)的 夹角。\n各轮的侧偏角分别表示如下： \n\n\n - 车辆的前后轮距\n\n将四轮车辆模型简化为两轮的自行车模型：\n\n\n等效的自行车模型\n\n设前后轮的侧向力分别为  和 ：  车辆的侧向运动方程可变为： \n\n用侧偏角和侧偏刚度来计算侧偏力： \n\n\n - 前、后轮侧偏刚度\n\n将  和  代入运动方程：  整理上式得：  对上式进行拉普拉斯变换：  得到车辆运动的特征方程：  展开整理得： \n\n\n\n导出的运动方程式是关于  和  的一阶联立微分方程。通过观察上式可以发现，系数  对于车辆运动有很大的影响。当  时，了，则表示车辆的侧向运动和横摆运动完全解耦，此时  与  根本不再相关。当 ，它的符号(即正或负)将显著影响着侧向运动和横摆运动的耦合形式，即  和  的大小直接影响这车辆运动的基本特征。\n地面固定坐标系下的运动方程\n\n\n以地面固定坐标系表示的车辆运动\n\n车辆的横摆角 ： 轴与车辆纵向的夹角。\n车辆的航向角 ： 轴与车辆航向的夹角。\n车辆质心  点偏离  轴的侧向位移为 。\n假设：\n，且 。若前轮转角 ，则可认为作用与前、后轮胎的侧偏力  和  的方向几乎与  方向相同。因此，车辆的运动可如下描述。首先，车辆质心在  方向的运动为：  车辆的横摆运动为：  当  很小时，可以认为车辆质心在  方向速度分量 ，在  方向的速度分量 。同时，车辆会以  的角速度绕质心转动。假设车辆的前、后的左右车轮分别集中于其前、后车轴中心，若  很小，则前、后轮沿  方向附加的速度分量分别等于  和 。对于前、后轮而言，其行进方向分别存在着一个相对于  轴的夹角，记为  和 ： \n\n前、后轮的航向与  轴的夹角分别为  和 。于是，前、后轮胎侧偏角（即  和 ）可分别表示为： \n\n作用于前、后轮的侧偏力（即  和 ）可表示为： \n\n将其代入运动方程得： \n\n整理上式可得： \n\n其拉普拉斯变换形式的方程如下：  得到其特征方程如下：  展开上式，并重新整理，得： \n","slug":"Vehicle Dynamics/车辆运动方程","date":"2022-07-21T05:50:00.000Z","categories_index":"车辆动力学","tags_index":"《车辆操纵动力学理论与应用》","author_index":"爱慢跑的乌龟"},{"id":"d9cd67d7ebad7fb89d409e84b17a6add","title":"轮胎力学","content":"侧向力\n当侧偏角较小时，它与侧向力几乎呈线性关系。当侧偏角超过某一值后，侧向力的增加变得缓慢，并最终在\n 出达到饱和。\n\n\n不同垂直载荷下轮胎侧向力与侧偏角的关系\n\n对于一辆普通的轿车而言，其侧向运动通常是在线性区域范围内发生的。上图中线性部分的斜率就是轮胎的侧偏刚度，它表示单位侧偏角产生的轮胎侧偏力，是评价轮胎侧偏特性的一个重要参数。\n垂直载荷和路面条件的影响\n\n\n侧向力与侧偏角和垂直载荷之间的关系\n\n当轮胎的垂直载荷较小时，，侧偏刚度会随着载荷的增加而增加，但当载荷超出某一极限时，侧偏刚度可能会减小。\n将侧偏刚度与当前载荷之间的比值，称为侧偏刚度系数。\n\n\n垂直载荷对侧偏刚度系数的影响\n\n侧偏刚度系数随着轮胎载荷的增大而几乎呈线性地减小。侧偏刚度与轮胎载荷的关系可写为：\n\n\n - 载荷在 0\n附近的侧偏刚度系数\n - 载荷相关系数\n\n侧偏刚度先随着轮胎载荷的增大而增大至一个峰值，之后随着轮胎载荷的增大而减小。轮胎通常在侧偏刚度随载荷增加的范围内工作。\n\n\n垂直载荷对侧偏刚度的影响\n\n轮胎侧偏刚度和载荷二者之间的关系可近似为一条抛物线。\n轮胎胎面基底与路面之间的摩擦系数 \n的影响和垂直载荷相同。如下图所示：\n\n\n路面条件对侧向力的影响\n\n胎压的影响\n如果弹性基础的弹簧常数 \n以及轮胎胎面基底的弯曲刚度 \n越大，则轮胎胎面基底的变形就越小。弹簧常数  取决于轮胎充气压力。一方面，\n随着轮胎充气压力的增大而增大，侧向力应该增大；而另一方面，轮胎充气压力增大导致接地区域长度\n\n减小，会使侧向力减小。两方面因素相互作用，使得轮胎在充气压力变化范围内，侧向力几乎恒定不变。\n\n\n轮胎充气压力对侧向力的影响\n\n\n当垂直载荷相对较小时，接地区域长度对侧向力的影响比弹簧常数 \n大，即此时的侧偏刚度随着胎压的增大而减小。\n当垂直载荷相对较大时，弹簧常数 \n对侧向力的影响比接地区域长度大，即此时的侧偏刚度随着轮胎充气压力的增大而增大。\n对于更大的垂直载荷，轮胎充气压力增大对接地区域长度的影响更大，因而侧偏刚度会随着轮胎充气压力的增大而减小。\n\n\n\n轮胎充气压力对侧偏刚度的影响\n\n轮胎形状的影响\n轮胎胎面基底的弯曲刚度 \n有轮胎的形状决定。通常，轮胎尺寸越大，\n值越大。对于半径相同的轮胎，宽度大的扁平轮胎 \n值较大。因此，为了获得大的侧向力，我们希望将轮胎制成扁平形状。\n驱动力和制动的影响\n作用于轮胎上的侧向力 \n和驱动力（或者制动力）\n总是满足以下不等式： \n作用于轮胎与地面接触面内的水平合力不会超过其垂直载荷与摩擦系数的乘积。合力的矢量只能位于半径为\n\n的圆内。称此圆为摩擦圆。\n\n\n摩擦圆\n\n假设不论侧偏角如何，在任何值时有驱动力（或者制动力）引起的侧向力的下降率是相同的，则有下式成立：\n 即：  对于给定的侧偏角而言，侧向力  与驱动力（或制动力） 的关系曲线为一椭圆。\n\n\n驱动力/制动力与侧向力的关系\n\n回正力矩\n当侧偏角较小时，回正力矩随着侧偏角线性增加；而随着侧偏角继续增大，回正力矩趋于饱和并达到某一特定峰值，随后开始随着侧偏角的增大而减小。\n\n\n回正力矩与侧偏角的关系\n\n不论侧偏角如何，轮胎垂直载荷对回正力矩的影响都很大。\n对于一个真实的轮胎而言，其回正力矩会随着轮胎充气压力的增大而减小。原因是，虽然侧向力随着轮胎充气压力的增大而增大，但与此同时，接地区域长度也减小了，这会对回正力矩的大小产生很大影响。\n外倾侧向力\n当侧偏角为零时，轮胎的外倾侧向力与外倾角成正比。\n\n\n外倾侧向力与外倾角的关系\n\n外倾侧向力系数（即单位外倾角对应的外倾侧向力）几乎随着轮胎垂直载荷呈线性增大。\n外倾侧向力系数等于侧偏刚度与  的乘积。\n\n -\n轮胎胎面基底的有效半径\n\n\n\n外倾角对轮胎侧向力的影响\n\n驱动和制动工况下轮胎的侧向力\n制动工况\n \n\n无量纲量  为：   为轮胎纵向滑移率：\n\n\n\n轮胎接地面力的分布\n\n当  时，则  假设滑移力的方向 \n近似为滑动起始点出的移动方向，即：  可得：  由于 、，可以针对当前的轮胎垂直载荷、由实验测量来确定\n 和 。\n由于摩擦系数  是轮胎垂直载荷\n 和 滑移速度  的函数，因此期望一个能反映 \n对轮胎载荷和滑移速度的经验公式。这里定义  为：  作为滑移率 、侧偏角\n、轮胎载荷  和轮胎行驶速度 \n的函数，轮胎的纵向力和侧向力可以通过数值求解获得，即： \n驱动工况\n\n\n\n其中若 ，则 ，于是有：  当  时，则：  其中， \n\n\n滑动速度  为：  驱动过程中的滑移率  为：\n\n\n\n\n侧向力与纵向力及其相互作用\n\n","slug":"Vehicle Dynamics/轮胎力学","date":"2022-07-19T05:50:00.000Z","categories_index":"车辆动力学","tags_index":"《车辆操纵动力学理论与应用》","author_index":"爱慢跑的乌龟"},{"id":"7d5686ce3c9c17768b418785872c4c2b","title":"Docker实战案例","content":"操作系统\nBusyBox\nBusyBox 是一个集成了一百多个最常用 Linux\n命令和工具（如cat、echo、grep、mount、telnet等）的精简工具箱，它只有几MB的大小，很方便进行各种快速验证，被誉为“Linux系统的瑞士军刀”。BusyBox\n可运行于多款 POSIX\n环境的操作系统中，如Linux（包括Android）、Hurd、FreeBSD等。\n下载 busybox：latest 镜像：\n$ docker pull busybox:latest\nAlpine\nAlpine操作系统是一个面向安全的轻型 Linux 发行版。它不同于通常的 Linux\n发行版，Alpine 采用了musl libc 和 BusyBox\n以减小系统的体积和运行时资源消耗，但功能上比BusyBox又完善得多，因此得到开源社区越来越多的青睐。\nDebian/Ubuntu\nDebian 和 Ubuntu 都是目前较为流行的 Debian\n系的服务器操作系统，十分适合研发场景。Docker Hub\n上提供了官方镜像，国内各大容器云服务也基本都提供了相应的支持。\ndebian镜像很适合作为基础镜像，用于构建自定义镜像。\n当试图直接使用 apt-get 安装一个软件的时候，会提示\nE：Unable to locate package.\n这并非系统不支持 apt-get 命令。Docker镜像在制作时为了精简清除了 apt\n仓库信息，因此需要先执行 apt-get update\n命令来更新仓库信息。更新信息后即可成功通过 apt-get 命令来安装软件.\nCentOS/Fedora\nCentOS 和 Fedora 都是基于 Redhat 的常见 Linux 分支。CentOS\n是目前企业级服务器的常用操作系统；Fedora 则主要面向个人桌面用户。\nFedora 是由 Fedora Project 社区开发，红帽公司赞助的 Linux\n发行版。它的目标是创建一套新颖、多功能并且自由和开源的操作系统。\n为镜像添加SSH服务\n基于docker\ncommit命令创建容器\n\n准备工作\n\n使用 ubuntu: 14.04 镜像来创建一个容器：\n$ docker run -it ubuntu:14.04 &#x2F;bin&#x2F;bash\n更新 apt 缓存，并安装 openssh-server:\n# apt-get updata\n# apt-get install openshh-server -y\n\n配置 SSH 服务\n\n如果需要正常启动 SSH 服务，则目录 /var/run/sshd\n必须存在。手动创建它，并启动 SSH 服务：\nmkdir -p &#x2F;var&#x2F;run&#x2F;sshd\n&#x2F;usr&#x2F;sbin&#x2F;sshd -D &amp;\n查看容器的 22 端口，可见此端口已经处于监听状态：\nnetstat -tunlp\n修改 SSH 服务的安全登录配置，取消 pam 登录限制：\nsed -ri &#39;s&#x2F;session required pam_loginuid.so&#x2F;#session required pam_loginuid.so&#x2F;g&#39; &#x2F;etc&#x2F;pam.d&#x2F;sshd\n在 root 用户目录下创建 .ssh\n目录，并复制需要登录的公钥信息（一般为本地主机用户目录下的\n.ssh/id_rsa.pub 文件，可由 ssh-keygen-t rsa 命令生成）到 authorized_keys\n文件中：\nmkdir root&#x2F;.ssh\nvim &#x2F;root&#x2F;.ssh&#x2F;authorized_keys\n创建自动启动 SSH 服务的可执行文件 run.sh，并添加可执行权限：\nvim &#x2F;run.sh\nchmod +x run.sh\n其中，run.sh 脚本内容如下：\n#!&#x2F;bin&#x2F;bash\n&#x2F;usr&#x2F;sbin&#x2F;sshd -D\n退出容器：\nexit\n\n保存镜像\n\n将所退出的容器用 docker commit 命令保存为一个新的 sshd:\nubuntu镜像：\ndocker commit fc1 sshd:ubuntu\n\n使用镜像\n\n启动容器，并添加端口映射 10022 -&gt; 22：\ndocker run -p 10022:22 -d sshd:ubuntu &#x2F;run.sh\n使用 Dockerfile 创建\n\n创建工作目录\n\n创建一个 sshd_ubuntu 工作目录：\nmkdir sshd_ubuntu\n创建 Dockerfile 和 run.sh 文件：\ncd sshd_ubuntu&#x2F;\ntouch Dockerfile run.sh\n\n编写 run.sh 脚本和 authorized_keys 文件\n\nrun.sh 脚本：\n#!&#x2F;bin&#x2F;bash\n&#x2F;usr&#x2F;sbin&#x2F;sshd -D\n在宿主机上生成 SSH 密钥对，并创建 authorized_keys 文件：\nssh-keygen -t rsa\ncat ~&#x2F;.shh&#x2F;id_rsa.pub &gt; authorized_keys\n\n编写 Dockerfile\n\n# 设置继承镜像\nFROM ubuntu:14.04\n\n# 作者\nMAINTAINER docker_user (user@docker.com)\n\n# 开始运行更新命令\nRUN apt-get updata\n\n# 安装 ssh 服务\nRUN apt-get install -y openssh-server\nRUN mkdir -p &#x2F;var&#x2F;run&#x2F;sshd\nRUN mkdir -p &#x2F;root&#x2F;.ssh\n\n# 取消 pam 限制\nRUN sed -ri &#39;s&#x2F;session required pam_loginuid.so&#x2F;#session required pam_loginuid.so&#x2F;g&#39; &#x2F;etc&#x2F;pam.d&#x2F;sshd\n\n# 复制配置文件到相应位置，并赋予脚本可执行权限\nADD authorized_keys &#x2F;root&#x2F;.ssh&#x2F;authorized_key\nADD run.sh &#x2F;run.sh\nRUN chmod 755 &#x2F;run.sh\n\n# 开放端口\nEXPOSE 22\n\n# 设置自启动命令\nCMD [&quot;&#x2F;run.sh&quot;]\n\n创建镜像\n\n在 sshd_ubuntu 目录下， 使用 docker build\n命令来创建镜像。这里需要注意最后还有一个\n.，表示使用当前目录中的 Dockerfile：\ncd sshd_ubuntu\ndocker build -t sshd:Dockerfile .\n如果读者使用 Dockerfile 创建自定义镜像，那么需要注意的是 Docker\n会自动删除中间临时创建的层，还需要注意每一步的操作和编写的 Dockerfile\n中命令的对应关系。\nWeb 服务与应用\nApache\nApache 是一个高稳定性的、商业级别的开源 Web 服务器。目前 Apache\n已经是世界使用排名第一的 Web\n服务器软件。由于其良好的跨平台和安全性，Apache\n被广泛应用在多种平台和操作系统上。作为 Apache\n软件基金会支持的项目，它的开发者社区完善而高效。自1995年发布至今，一直以高标准进行维护与开发。Apache\n名称源自美国的西南部一个印第安人部落：阿帕奇族，它支持类 UNIX 和 Windows\n系统。\n\n使用官方镜像\n\n官方提供了名为 httpd 的 Apache 镜像，可以作为基础 Web 服务镜像。\nDockerfile文件：\nFROM httpd:2.4\nCOPY .&#x2F;public-html &#x2F;usr&#x2F;local&#x2F;apache2&#x2F;htdocs&#x2F;&lt;i\n创建项目目录 public-html，并在此目录下创建 index.html文件：\n&lt;!DOCTYPE html&gt;\n\t&lt;html&gt;\n        &lt;body&gt;\n            &lt;p&gt;\n                Hello, Docker!\n            &lt;&#x2F;p&gt;\n        &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n构建自定义镜像：\ndocker build -t apache2-image .\n运行镜像：\ndocker run -it --rm --name apache-container -p 80:80 apache2-image\n也可以不创建自定义镜像，直接通过映射目录方式运行 Apache 容器：\ndocker run -it --rm --name my-apache-app -p 80:80 -v &quot;$PWD&quot;:&#x2F;usr&#x2F;local&#x2F;apache2&#x2F;htdocs&#x2F; httpd:2.4\n\n使用自定义镜像\n\n创建一个 apache_ubuutu 工作目录，在其中创建 Dockerfile 文件、run.sh\n文件 和 sample 目录：\nmkdir apache_ubuntu &amp;&amp; cd apache_ubuntu\ntouch Dockerfile run.sh\nmkdir sample\nDockerfile 文件：\n# 设置 自己创建的 sshd 镜像\nFROM sshd:Dockerfile\n# 作者信息\nMAINTAINER docker_user (user@docker.com)\n# 设置环境变量，所有操作都是非交互式的\nENV DEBIAN_FRONTEND noninteractive\n# 安装\nRUN apt-get -yq install apache2 &amp;&amp; \\\n\trm -rf &#x2F;var&#x2F;lib&#x2F;apt&#x2F;lists&#x2F;*\nRUN echo &quot;Asia&#x2F;Shanghai&quot; &gt; &#x2F;etc&#x2F;timezone &amp;&amp;\\\n\tdpkg-reconfigure -f noninteractive tzdata\n# 添加用户的脚本，并设置权限，这会覆盖之前放在这个位置的脚本\nADD run.sh &#x2F;run.sh\nRUN chmod 755 &#x2F;*.sh\n# 添加一个示例的web站点，删掉默认安装在 apache 文件夹下面的文件，并将用户添加的示例用软链接链到&#x2F;var&#x2F;www&#x2F;html目录下面\nRUN mkdir -p &#x2F;var&#x2F;lock&#x2F;apache2 &amp;&amp; mkdir -p &#x2F;app &amp;&amp; rm -fr &#x2F;var&#x2F;www&#x2F;html &amp;&amp; ln -s &#x2F;app &#x2F;var&#x2F;www&#x2F;html\nCOPY sample&#x2F; &#x2F;app\n#设置 apache 相关的一些变量，在容器启动的时候可以使用 -e 参数替代\nENV APACHE_RUN_USER www-data\nENV APACHE_RUN_GROUP www-data\nENV APACHE_LOG_DIR &#x2F;var&#x2F;log&#x2F;apache2\nENV APACHE_PID_FILE &#x2F;var&#x2F;run&#x2F;apache2.pid\nENV APACHE_RUN_DIR &#x2F;var&#x2F;run&#x2F;apache2\nENV APACHE_LOCK_DIR &#x2F;var&#x2F;lock&#x2F;apache2\nENV APACHE_SERVERADMIN admin@localhost\nENV APACHE_SERVERNAME localhost\nENV APACHE_SERVERALIAS docker.localhost\nENV APACHE_DOCUMENTROOT &#x2F;var&#x2F;www\nEXPOSE 80\nWORKDIR &#x2F;app\nCMD [&quot;&#x2F;run.sh&quot;]\n此 sample 站点的内容为输出 Hello Docker！。然后在 sample 目录下创建\nindex.html 文件，内容如下：\n&lt;!DOCTYPE html&gt;\n    &lt;html&gt;\n        &lt;body&gt;\n            &lt;p&gt;Hello, Docker!&lt;&#x2F;p&gt;\n        &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\nrun.sh 脚本：\n$ cat run.sh\n#!&#x2F;bin&#x2F;bash\n&#x2F;usr&#x2F;sbin&#x2F;sshd &amp;\nexec apache2 -D FOREGROUND\n使用 docker build 命令创建 apache:ubuntu 镜像：\ndocker build -t apache:ubuntu\n\n\n\n\n\n\n\n\n\n在使用 Dockerfile\n创建镜像时，会继承父镜像的开放端口，但却不会继承启动命令。\nNginx\nNginx 是一款功能强大的开源反向代理服务器，支持\nHTTP、HTTPS、SMTP、POP3、IMAP 等协议。它也可以作为负载均衡器、HTTP\n缓存或 Web 服务器。Nginx\n一开始就专注于高并发和高性能的应用场景。它使用类 BSD 开源协议，支持\nLinux、BSD、Mac、Solaris、AIX 等类Unix系统，同时也有 Windows\n上的移植版本。\n\n使用官方镜像\n\n只用 docker run 直接运行官方 Nginx 镜像：\ndocker run -d -p 80:80 --name webserver nginx\n\n自定义 Web 页面\n\n创建 index.html 文件，并将 index.html 文件挂载至容器中：\ndocker run --name nginx-container -p 80:80 -v index.html:&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html:ro -d nignx\nTomcat\nTomcat 是由 Apache 软件基金会下属的 Jakarta 项目开发的一个 Servlet\n容器，按照 Sun Microsystems 提供的技术规范，实现了对 Servlet 和 Java\nServer Page（JSP）的支持。同时，它提供了作为 Web\n服务器的一些特有功能，如 Tomcat 管理和控制平台、安全域管理和 Tomcat\n阀等。由于 Tomcat 本身也内含了一个 HTTP 服务器，也可以当作一个单独的Web\n服务器来使用。\n搜索 Tomcat 相关镜像的个数：\ndocker search tomcat |wc -l\n\n准备工作\n\n创建 tomcat7.0_jdk1.6 文件夹，从 www.oracle.com 网站上下载 sun_jdk\n1.6 压缩包，解压为 jdk 目录。\n创建 Dockerfile 和 run.sh 文件：\nmkdir tomcat7.0_jdk1.6\ncd tomcat7.0_jdk1.6\ntouch Dockerfile run.sh\n下载Tomcat，可以到官方网站下载最新的版本，也可以直接使用下面链接中给出的版本：\nwget http:&#x2F;&#x2F;mirror.bit.edu.cn&#x2F;apache&#x2F;tomcat&#x2F;tomcat-7&#x2F;v7.0.56&#x2F;bin&#x2F;apache-tomcat-7.0.56.zip\n解压后，tomcat7.0_jdk1.6目录结构应如下所示（多余的压缩包文件已经被删除）：\nls\nDockerfile  apache-tomcat-7.0.56   jdk  run.sh\n\nDockerfile 文件和其他脚本文件\n\nDockerfile 文件：\nFROM sshd:Dockerfile\n#设置继承自用户创建的 sshd 镜像\n\n\nMAINTAINER docker_user (user@docker.com)\n#创建者的基本信息\n\n\n#设置环境变量，所有操作都是非交互式的\nENV DEBIAN_FRONTEND noninteractive\n\n#注意这里要更改系统的时区设置\nRUN echo &quot;Asia&#x2F;Shanghai&quot; &gt; &#x2F;etc&#x2F;timezone &amp;&amp; \\\n        dpkg-reconfigure -f noninteractive tzdata\n        \n#安装跟 tomcat 用户认证相关的软件\nRUN apt-get install -yq --no-install-recommends wget pwgen ca-certificates &amp;&amp; \\\n    apt-get clean &amp;&amp; \\\n    rm -rf &#x2F;var&#x2F;lib&#x2F;apt&#x2F;lists&#x2F;*\n    \n#设置 tomcat 的环境变量，若读者有其他的环境变量需要设置，也可以在这里添加。\nENV CATALINA_HOME &#x2F;tomcat\nENV JAVA_HOME &#x2F;jdk\n\n#复制 tomcat 和 jdk 文件到镜像中\nADD apache-tomcat-7.0.56 &#x2F;tomcat\nADD jdk &#x2F;jdk\nADD create_tomcat_admin_user.sh &#x2F;create_tomcat_admin_user.sh\nADD run.sh &#x2F;run.sh\nRUN chmod +x &#x2F;*.sh\nRUN chmod +x &#x2F;tomcat&#x2F;bin&#x2F;*.sh\nEXPOSE 8080\nCMD [&quot;&#x2F;run.sh&quot;]\n创建 tomcat 用户和密码脚本文件 create_tomcat_admin_user.sh\n文件，内容为：\n#!&#x2F;bin&#x2F;bash\nif [ -f &#x2F;.tomcat_admin_created ]; then\n    echo &quot;Tomcat &#39;admin&#39; user already created&quot;\n    exit 0\nfi\n#generate password\nPASS&#x3D;$&#123;TOMCAT_PASS:-$(pwgen -s 12 1)&#125;\n_word&#x3D;$( [ $&#123;TOMCAT_PASS&#125; ] &amp;&amp; echo &quot;preset&quot; || echo &quot;random&quot; )\necho &quot;&#x3D;&gt; Creating and admin user with a $&#123;_word&#125; password in Tomcat&quot;\nsed -i -r &#39;s&#x2F;&lt;\\&#x2F;tomcat-users&gt;&#x2F;&#x2F;&#39; $&#123;CATALINA_HOME&#125;&#x2F;conf&#x2F;tomcat-users.xml\necho &#39;&lt;role rolename&#x3D;&quot;manager-gui&quot;&#x2F;&gt;&#39; &gt;&gt; $&#123;CATALINA_HOME&#125;&#x2F;conf&#x2F;tomcat-users.xml\necho &#39;&lt;role rolename&#x3D;&quot;manager-script&quot;&#x2F;&gt;&#39; &gt;&gt; $&#123;CATALINA_HOME&#125;&#x2F;conf&#x2F;tomcat-users.xml\necho &#39;&lt;role rolename&#x3D;&quot;manager-jmx&quot;&#x2F;&gt;&#39; &gt;&gt; $&#123;CATALINA_HOME&#125;&#x2F;conf&#x2F;tomcat-users.xml\necho &#39;&lt;role rolename&#x3D;&quot;admin-gui&quot;&#x2F;&gt;&#39; &gt;&gt; $&#123;CATALINA_HOME&#125;&#x2F;conf&#x2F;tomcat-users.xml\necho &#39;&lt;role rolename&#x3D;&quot;admin-script&quot;&#x2F;&gt;&#39; &gt;&gt; $&#123;CATALINA_HOME&#125;&#x2F;conf&#x2F;tomcat-users.xml\necho &quot;&lt;user username&#x3D;\\&quot;admin\\&quot; password&#x3D;\\&quot;$&#123;PASS&#125;\\&quot; roles&#x3D;\\&quot;manager-gui,manager-\n    script,manager-jmx,admin-gui, admin-script\\&quot;&#x2F;&gt;&quot; &gt;&gt; $&#123;CATALINA_HOME&#125;&#x2F;conf&#x2F;\n    tomcat-users.xml\necho &#39;&lt;&#x2F;tomcat-users&gt;&#39; &gt;&gt; $&#123;CATALINA_HOME&#125;&#x2F;conf&#x2F;tomcat-users.xml\necho &quot;&#x3D;&gt; Done!&quot;\ntouch &#x2F;.tomcat_admin_created\necho &quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;\necho &quot;You can now configure to this Tomcat server using:&quot;\necho &quot;&quot;\necho &quot;    admin:$&#123;PASS&#125;&quot;\necho &quot;&quot;\necho &quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;\n编写 run.sh 脚本文件，内容为：\n#!&#x2F;bin&#x2F;bash\nif [ ! -f &#x2F;.tomcat_admin_created ]; then\n    &#x2F;create_tomcat_admin_user.sh\nfi\n&#x2F;usr&#x2F;sbin&#x2F;sshd -D &amp;\nexec $&#123;CATALINA_HOME&#125;&#x2F;bin&#x2F;catalina.sh run\n\n创建和测试镜像\n\n创建镜像 tomcat7.0：jdk1.6：\ndocker build -t tomcat7.0:jdk1.6 .\n启动一个 tomcat 容器进行测试：\ndocker run -d -P tomcat7.0:jdk1.6\n通过 docker logs 得到 tomcat 的密码：\ndocker logs 3cd\n&#x3D;&gt; Creating and admin user with a random password in Tomcat\n&#x3D;&gt; Done!\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\nYou can now configure to this Tomcat server using:\n    admin:aBwN0CNCPckw\nJetty\nJetty 是一个优秀的开源 Servlet\n容器，以其高效、小巧、可嵌入式等优点深得人心，它为基于 Java 的 Web\n内容（如 JSP 和 Servlet）提供运行环境。Jetty 基于 Java 语言编写，它的\nAPI 以一组 JAR 包的形式发布。开发人员可以将 Jetty\n容器实例化成一个对象，可以迅速为一些独立运行的 Java 应用提供 Web\n服务。\nDockerHub 官方提供了 Jetty 镜像，直接运行 docker run\n指令即可：\ndocker run -d jetty\nLAMP\nLAMP（Linux-Apache-MySQL-PHP）是目前流行的 Web\n工具栈，其中包括：Linux 操作系统，Apache 网络服务器，MySQL\n数据库，Perl、PHP 或者 Python\n编程语言。其组成工具均是成熟的开源软件，被大量网站所采用。和 Java/J2EE\n架构相比，LAMP 具有 Web\n资源丰富、轻量、快速开发等特点；和微软的.NET架构相比，LAMP更具有通用、跨平台、高性能、低价格的优势。因此\nLAMP 无论是在性能、质量还是价格方面都是企业搭建网站的首选平台。\n\n使用 linode/lamp 镜像\n\n直接运行镜像：\ndocker run -p 80:80 -t -i linode&#x2F;lamp &#x2F;bin&#x2F;bash\n在容器内部 shell 启动 apache 以及 mysql 服务：\nservice apache2 start\nservice mysql start\n\n使用 tutum/lamp 镜像\n\n直接运行镜像：\ndocker run -d -p 80:80 -p 3306:3306 tutum&#x2F;lamp\nCMS\n内容管理系统（Content Management\nSystem，CMS）指的是提供内容编辑服务的平台程序。CMS\n可以让不懂编程的用户方便又轻松地发布、更改和管理各类数字内容（主要以文本和图像为主）。\nWordPress\nWordPress 基于 PHP 和\nMySQL，架构设计简单明了，支持主题，插件和各种功能模块。更重要的是，WordPress\n拥有庞大的社区，在线资源非常丰富，并且在各大网络空间商和云平台中受到广泛的支持。根据2013年8月的统计数据，流量排名前一千万的网站中其使用率高达22%。\n\n使用官方镜像\n\n下载官方镜像：\ndocker pull wordpress\n创建并运行一个 wordpress 容器，并连接到 mysql 容器：\ndocker run --name some-wordpress --link some-mysql:mysql -d wordpress\n\n使用 Compose 搭建 WordPress 应用\n\n新建一个 docker-compose.yml 文件：\nwordpress:\n\timage: wordpress\n\tlinks: \n\t\t- db:mysql\n\tports:\n\t\t- 8080:80\ndb:\n\timage: mariadb\n\tenvironment:\n\t\tMYSQL_ROOT_PASSWORD: example\n然后执行：\ndocker-compose up\n\n\n\n\n\n\n\n\n\n如果提示没有 docker-compose 命令，可以通过 pip install docker-compose\n来在线安装。\nGhost\nGhost 是一个广受欢迎的开源博客平台，使用 JavaScript 编写，以 MIT\n协议发布。它的设计非常简约，使用起来体验优异，非常适合做内容发布，故而受到很多极客或技术工作者的喜爱。\n直接运行官方镜像：\ndocker run --name ghost-container -d ghost\n数据库应用\n主流的数据库类型主要包括关系型(SQL)和非关系型(NoSQL)两种。\n关系数据库是建立在关系模型基础上的数据库，借助于集合代数等数学概念和方法来处理数据库中的数据，支持复杂的事物处理和结构化查询。代表实现有\nMySQL、Oracle、PostGreSQL、MariaDB、SQLServer 等。\n非关系数据库是新兴的数据库技术，它放弃了传统关系型数据库的部分强一致性限制，带来性能上的提升，使其更适用于需要大规模并行处理的场景。非关系型数据库是关系型数据库的良好补充，代表产品有\nMongoDB、Redis、CouchDB 等。\nMySQL\nMySQL\n是全球最流行的开源的开源关系数据库软件之一，因为其高性能、成熟可靠和适应性而得到广泛应用。\n使用官方镜像启动一个 MySQL Server 实例：\ndocker run --name mysql1 -e MYSQL_ROOT_PASSWORD&#x3D;123 -d mysql:latest\nMySQL 服务的标准端口是 3306，用户可以通过 CLI\n工具对配置进行修改：\ndocker run -it --link some-mysql:mysql --rm mysql sh -c &#39;exec mysql -h&quot;$MYSQL_ PORT_3306_TCP_ADDR&quot; -P&quot;$MYSQL_PORT_3306_TCP_PORT&quot; -uroot -p&quot;$MYSQL_ENV_MYSQL_ROOT_PASSWORD&quot;&#39;\n\n系统与日志访问\n\n用户可以使用 docker exec 指令调用内部系统中的 bash\nshell，以访问容器内部系统：\ndocker exec -it some-mysql bash\nMySQL Server 日志可以使用 docker logs 指令查看：\ndocker logs some-mysql\n\n使用自定义配置文件\n\n如果用户希望使用自定义 MySQL 配置，则可以创建一个目录，内置 cnf\n配置文件，然后将其挂载至容器的 /etc/mysql/conf.d\n目录。比如，自定义配置文件为\n/my/custom/config-file.cnf，则可以使用以下指令：\ndocker run --name some-mysql -v &#x2F;my&#x2F;custom:&#x2F;etc&#x2F;mysql&#x2F;conf.d -e MYSQL_ROOT_PASSWORD&#x3D;my-secret-pw -d mysql:tag\n\n脱离cnf文件进行配置\n\n很多的配置选项可以通过标签（flags）传递至 mysqld\n进程。这样用户就可以脱离cnf配置文件，对容器进行弹性的定制。\ndocker run --name some-mysql -e MYSQL_ROOT_PASSWORD&#x3D;my-secret-pw -d mysql:tag --character-set-server&#x3D;utf8mb4 --collatioo-server&#x3D;utf8mb4_unicode_ci\nMongoDB\nMongoDB 是一款可扩展、高性能的开源文档数据库，是当今最流行的 NoSQL\n数据库软件之一。它采用 C++\n开发，支持复杂的数据类型和强大的查询语言，提供了关系数据库的绝大部分功能。\n使用官方镜像\n用户可以使用 docker run 指令直接运行官方 mongodb\n镜像：\ndocker run --name mongo-container -d mongo\n\n连接 mongodb 容器\n\n使用 --link 参数，连接新建的\nmongo-container 容器：\ndocker run -it --link mongo-container:db alpine sh\n\n直接使用 mongo cli 指令\n\n如果想直接在宿主机器上使用 mongodb 镜像，可以在\ndocker run 指令后面加入entrypoint\n指令，这样就可以非常方便的直接进入 mongo cli 了：\ndocker run -it --link mongo-container:db --entrypoint mongo mongo --host db\n使用自定义 Dockerfile\nDockerfile 文件：\n# 设置从用户之前创建的 sshd 镜像继承。\nFROM sshd\nMAINTAINER docker_user (user@docker.com)\nRUN apt-get update &amp;&amp; \\\n    apt-get install -y mongodb pwgen &amp;&amp; \\\n    apt-get clean &amp;&amp; \\\n    rm -rf &#x2F;var&#x2F;lib&#x2F;apt&#x2F;lists&#x2F;*\n    \n# 创建 mongodb 存放数据文件的文件夹\nRUN mkdir -p &#x2F;data&#x2F;db\nVOLUME &#x2F;data&#x2F;db\nENV AUTH yes\n\n# 添加脚本\nADD run.sh &#x2F;run.sh\nADD set_mongodb_password.sh &#x2F;set_mongodb_password.sh\nRUN chmod 755 .&#x2F;*.sh\nEXPOSE 27017\nEXPOSE 28017\nCMD [&quot;&#x2F;run.sh&quot;]\n新建 set_mongodb_password.sh\n脚本。此脚本主要负责配置数据库的用户名和密码：\n#!&#x2F;bin&#x2F;bash\n# 这个脚本主要是用来设置数据库的用户名和密码。\n# 判断是否已经设置过密码。\nif [ -f &#x2F;.mongodb_password_set ]; then\n        echo &quot;MongoDB password already set!&quot;\n        exit 0\nfi\n&#x2F;usr&#x2F;bin&#x2F;mongod --smallfiles --nojournal &amp;\nPASS&#x3D;$&#123;MONGODB_PASS:-$(pwgen -s 12 1)&#125;\n_word&#x3D;$( [ $&#123;MONGODB_PASS&#125; ] &amp;&amp; echo &quot;preset&quot; || echo &quot;random&quot; )\nRET&#x3D;1\nwhile [[ RET -ne 0 ]]; do\n    echo &quot;&#x3D;&gt; Waiting for confirmation of MongoDB service startup&quot;\n    sleep 5\n    mongo admin --eval &quot;help&quot; &gt;&#x2F;dev&#x2F;null 2&gt;&amp;1\n    RET&#x3D;$?\ndone\n\n# 通过 docker logs + id 可以看到下面的输出。\necho &quot;&#x3D;&gt; Creating an admin user with a $&#123;_word&#125; password in MongoDB&quot;\nmongo admin --eval &quot;db.addUser(&#123;user: &#39;admin&#39;, pwd: &#39;$PASS&#39;, roles: \n    [ &#39;userAdminAnyDatabase&#39;, &#39;dbAdminAnyDatabase&#39; ]&#125;);&quot;\nmongo admin --eval &quot;db.shutdownServer();&quot;\necho &quot;&#x3D;&gt; Done!&quot;\ntouch &#x2F;.mongodb_password_set\necho &quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;\necho &quot;You can now connect to this MongoDB server using:&quot;\necho &quot;&quot;\necho &quot;    mongo admin -u admin -p $PASS --host &lt;host&gt; --port &lt;port&gt;&quot;\necho &quot;&quot;\necho &quot;Please remember to change the above password as soon as possible!&quot;\necho &quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;\n\n新建 run.sh，此脚本是主要的 mongodb 启动脚本：\n#!&#x2F;bin&#x2F;bash\nif [ ! -f &#x2F;.mongodb_password_set ]; then\n        &#x2F;set_mongodb_password.sh\nfi\nif [ &quot;$AUTH&quot; &#x3D;&#x3D; &quot;yes&quot; ]; then\n\n# 这里读者可以自己设定 Mongodb 的启动参数。\n\texport mongodb&#x3D;&#39;&#x2F;usr&#x2F;bin&#x2F;mongod --nojournal --auth --httpinterface --rest&#39;\nelse\n\texport mongodb&#x3D;&#39;&#x2F;usr&#x2F;bin&#x2F;mongod --nojournal --httpinterface --rest&#39;\nfi\nif [ ! -f &#x2F;data&#x2F;db&#x2F;mongod.lock ]; then\n    eval $mongodb\nelse\n    export mongodb&#x3D;$mongodb&#39; --dbpath &#x2F;data&#x2F;db&#39;\n    rm &#x2F;data&#x2F;db&#x2F;mongod.lock\n    mongod --dbpath &#x2F;data&#x2F;db --repair &amp;&amp; eval $mongodb\nfi\n第二步，使用 docker build 指令构建镜像：\ndocker build -t mongodb-imaga .\n第三步，启动后台容器，并分别映射 27017 和 28017 端口到本地：\ndocker run -d -p 27017:27017 -p 28017:28017 mongodb\n通过 docker logs 来查看默认的 admin 帐户密码：\ndocker logs sa9\n    &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n        You can now connect to this MongoDB server using:\n            mongo admin -u admin -p 5elsT6KtjrqV --host &lt;host&gt; --port &lt;port&gt;\n        Please remember to change the above password as soon as possible!\n        &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\nRedis\nRedis\n是一个开源（BSD许可）的基于内存的数据结构存储系统，可以用作数据库、缓存和消息中间件。\n通过 docker run 指令可以直接启动一个 redis-container\n容器：\ndocker run --name redis-container -d redis\n\n连接redis容器\n\n用户可以使用 --link 参数，连接创建的 redis-container\n容器：\ndocker run -it --link redis-container:db alpine sh\n还可以使用 n c指令（即NetCat）检测 redis 服务的可用性：\nnc db 6379\n\n使用自定义配置\n\n可以通过数据卷实现自定义 redis 配置，如下所示：\ndocker run -v &#x2F;myredis&#x2F;conf&#x2F;redis.conf:&#x2F;usr&#x2F;local&#x2F;etc&#x2F;redis&#x2F;redis.conf --name \n    myredis redis redis-server &#x2F;usr&#x2F;local&#x2F;etc&#x2F;redis&#x2F;redis.conf\n","slug":"Linux/Docker实战案例","date":"2022-06-30T07:13:00.000Z","categories_index":"Docker","tags_index":"《Docker技术入门与实践》","author_index":"爱慢跑的乌龟"},{"id":"1eaff4e22fb5fa029043d1942e6ee81c","title":"棋盘格角点检测","content":"A\nNew Sub-Pixel Detector for X-Corners in Camera Calibration Targets\n\n\n\n\n\n\n\n\n\n基于海塞矩阵的方法\n一个标准的 X-Corners 如下图所示：\n\n其表达式为： \n由于实际的图像中存在噪点，所以需要对图像进行低通滤波，这里使用高斯算子：\n 高斯算子平滑的 X-Corner 的强度分布模型：  其中，.\n对于 X-Corner，我们可以使用由图像函数的 Hessian\n矩阵的特征值推导出的新形状算子。\nHessian\n矩阵的特征值对应曲面的最小和最大二阶导数，它们的相关特征向量是二阶导数极值的方向，并且相互正交.\n将图像函数中一个像素的邻域视为一个表面块，Hessian 矩阵表示为  \n是图像函数  的二阶偏导数.\nHessian 矩阵的两个特征值为:  对应的归一化特征向量是： \n其中，.\n对于方程（2）中的 X-Corner，对应的 Hessian 矩阵的最大特征值  是正的，最小特征值 \n是负的，因此我们可以得到一个新的简单算子来检测x角点的像素位置：  待检测角是 \n的局部负极值点. 基于这个约束，我们可以确定 X-Corner 的像素位置 .\n亚像素检测：\n很明显，X-Corner 真正的亚像素位置必须位于  附近。我们假设它的实际位置是\n. .\n对于每个\nX-Corner，我们可以使用第二个泰勒多项式来描述它周围的局部强度分布：   是图像函数  在点  的值.  是  在点  的一阶偏导， 是  在点  的二阶偏导.\n如上所述，X-Corner 就是强度剖面的鞍点. 我们可以将 式（3）沿  和  的一阶导数设为0：  然后我们就可以得到亚像素的位置 ：  Detection of X-corners in Discrete\nSpace：\n对于离散图像，只需要做一个修改，即在离散空间中实现卷积。这里我们选择标准高斯核作为卷积掩码：\n 掩码的维度为 ，其中  为 .\n然后将离散图像与相应的微分核进行卷积，得到离散图像的偏导数。\n图像求导问题\n一阶导数\n导数的的定义：  由于图像的像素是离散的，所以通常采用差分的形式，取 ，在图像中  处的方向导数为：\n\n关于差分： 向前差分：向后差分：中心差分：\nSobel 算子计算梯度的方式略有不同.\n\n根据式（2）计算 \n点处的方向导数为：  \n对于 sobel 算子为：  \n使用 sobel 算子计算 \n点的梯度有：  对角线方向导数有：  \n二阶导数\n数学定义为：  向前差分：  由 ， 得：\n 向后差分：  同理：  对于  ，向后差分:  向后差分： \n\nHessian 矩阵\n\n二元函数泰勒公式的近似表达式：  其极值情况可由  矩阵来判定，令 ，.\n当 \n时，如果对于任意向量 ，都有 \n为正，那么 \n为正定矩阵，函数具有局部极小值. 如果对于任意向量 ，都有 \n为负，那么 \n为负定矩阵，函数具有局部极大值.\n当 Hessian\n矩阵同时具有正负特征值时，该点为鞍点.\n","slug":"Digital-Image/X-Corner","date":"2022-06-29T07:11:00.000Z","categories_index":"图像处理","tags_index":"相机标定,角点检测","author_index":"爱慢跑的乌龟"},{"id":"e8df40174e1c8fdb0eda4ca741803291","title":"Docker 基础入门","content":"核心概念与安装配置\nDocker 的三大核心概念：\n\n镜像(Image)\n容器(Container)\n仓库(Repository)\n\n核心概念\nDocker 镜像\nDocker 镜像可以将其理解为一个只读的模板。它是 docker\n容器的基础。用户可以从网络上下载已经配置好的镜像，并直接使用。\nDocker 容器\nDocker\n容器类似于一个轻量级的沙箱，用于运行和隔离应用。容器是从镜像创建的应用运行实例。可以将其启动、开始、停止和删除。\n\n镜像自身是只读的。容器从镜像启动的时候，会在镜像的最上层创建一个可写层\n\nDocker 仓库\nDocker 仓库是 Docker 集中存放镜像文件的场所。\nDocker 仓库的类型：\n\n公开仓库(Public)\n私有仓库(Private)\n\nDocker 的安装\nUbuntu 环境下安装 Docker\n推荐至少使用 14.04 LTS 版本。\n为了让 Docker 使用 aufs 存储，推荐安装 linux-image-extra\n软件包：\n$ sudo apt-get install -y linux-image-extra-$(uname -r)\n添加镜像源：\n安装 apt-transport-https 包支持 HTTP 协议的源：\n$ sudo apt-get install -y apt-transport-https\n添加源的 gpg 密钥：\n$ sudo apt-key adv --keyserver hkp:&#x2F;&#x2F;p80.pool.sks-keyservers.net:80 --recv-keys \n    58118E89F3A912897C070ADBF76221572C52609D\n获取当前操作系统的代号：\n$ lsb_release -c\nCodename:       trusty\n接下来就可以添加Docker的官方apt软件源了。通过下面的命令创建\n/etc/apt/sources.list.d/docker.list\n文件，并写入源的地址内容。非 trusty\n版本的系统注意修改为自己对应的代号：\n$ sudo cat &lt;&lt;EOF &gt; &#x2F;etc&#x2F;apt&#x2F;sources.list.d&#x2F;docker.list\ndeb https:&#x2F;&#x2F;apt.dockerproject.org&#x2F;repo ubuntu-trusty main\nEOF\n更新 apt 软件包缓存：\n$ sudo apt-get update\n安装 Docker：\n$ sudo apt-get install -y docker-engine\n通过脚本自动化安装 Docker：\n$ sudo curl -sSL https:&#x2F;&#x2F;get.docker.com&#x2F; | sh\n启动 docker 服务：\n$ sudo systemctl start docker\nCentOS 环境下安装 Docker\n添加 yum 软件源：\n$ sudo tee &#x2F;etc&#x2F;yum.repos.d&#x2F;docker.repo &lt;&lt;-&#39;EOF&#39;\n[dockerrepo]\nname&#x3D;Docker Repository\nbaseurl&#x3D;https:&#x2F;&#x2F;yum.dockerproject.org&#x2F;repo&#x2F;main&#x2F;centos&#x2F;$releasever&#x2F;\nenabled&#x3D;1\ngpgcheck&#x3D;1\ngpgkey&#x3D;https:&#x2F;&#x2F;yum.dockerproject.org&#x2F;gpg\nEOF\n安装 docker：\n$ sudo yum update\n$ sudo yum install -y docker-engine\n使用脚本安装\n$ curl -fsSL https:&#x2F;&#x2F;get.docker.com&#x2F; | sh\n或者：\n$ wget -qO- https:&#x2F;&#x2F;get.docker.com&#x2F; | sh\n配置 Docker 服务\n将当前用户加入 docker 用户组：\n$ sudo usermod -aG docker USER_NAME\nDocker 服务的默认配置文件：/etc/default/docker\n可以通过修改 DOCKER_OPTS 来修改服务启动的参数。\nDocker 服务的管理脚本：/etc/init.d/docker\n查看版本信息：\n$ docker verison\nClient: Docker Engine - Community\n Version:           20.10.17\n API version:       1.41\n Go version:        go1.17.11\n Git commit:        100c701\n Built:             Mon Jun  6 23:02:56 2022\n OS&#x2F;Arch:           linux&#x2F;amd64\n Context:           default\n Experimental:      true\n\nServer: Docker Engine - Community\n Engine:\n  Version:          20.10.17\n  API version:      1.41 (minimum version 1.12)\n  Go version:       go1.17.11\n  Git commit:       a89b842\n  Built:            Mon Jun  6 23:01:02 2022\n  OS&#x2F;Arch:          linux&#x2F;amd64\n  Experimental:     false\n containerd:\n  Version:          1.6.6\n  GitCommit:        10c12954828e7c7c9b6e0ea9b0c02b01407d3ae1\n runc:\n  Version:          1.1.2\n  GitCommit:        v1.1.2-0-ga916309\n docker-init:\n  Version:          0.19.0\n  GitCommit:        de40ad0\n\nDocker 镜像\nDocker 运行容器前需要本地存在对应的镜像，若本地无镜像，Docker\n将从默认的镜像仓库下载，用户可以通过配置，使用自定义的镜像仓库。\n镜像获取\n使用 docker pull 命令从 Docker Hub\n镜像仓库下载镜像。\n命令格式：docker pull Image-Name[: TAG] (TAG\n通常是版本信息)\n没有指定 TAG，默认为 latest\n$ docker pull ubuntu\nUsing default tag: latest\nlatest: Pulling from library&#x2F;ubuntu\n405f018f9d1d: Pull complete\nDigest:sha256:b6b83d3c331794420340093eb706a6f152d9c1fa51b262d9bf34594887c2c7ac\nStatus: Downloaded newer image for ubuntu:latest\ndocker.io&#x2F;library&#x2F;ubuntu:latest\n镜像文件一般由若干层(layer)组成，每个层都有一个唯一的 ID\n(如：405f018f9d1d)。使用 docker pull\n命令下载时会获取并输出镜像的各层信息。当不同的镜像包括相同的层时，本地仅存储层的一份内容，减小了需要的存储空间。\n镜像名称之前应该加上仓库地址前缀，使用官方仓库时默认省略，即：docker pull ubuntu：14.04\n相当于\ndocker pull registry.hub.docker.com/ubuntu：14.04。\n若从非官方仓库下载镜像，则必须指定仓库地址前缀。\npull 子命令支持的选项：\n-a,--all-tags=true|false -\n是由获取仓库中所有镜像，默认为 否。\n查看镜像信息\n列出所有镜像\n命令：docker images\n$ docker images\nREPOSITORY   TAG       IMAGE ID       CREATED       SIZE\nubuntu       latest    27941809078c   2 weeks ago   77.8MB\n\nREPOSITORY - 来自于那个仓库\nTAG - 版本信息\nIMAGE ID - 唯一标识镜像\nCREATED - 镜像的最后更新时间\nSIZE - 镜像大小\n\nimages 子命令主要支持的选项：\n-a, --all&#x3D;true|false: 列出所有镜像（包含临时文件），默认为 否；\n--digests&#x3D;true|false: 列出镜像的数字摘要值，默认为 否；\n-f, --filter&#x3D;[]: 过滤列出镜像；\n--format&#x3D;&quot;TEMPLATE&quot;: 控制输出格式，.ID代表ID信息，.Repository代币哦仓库信息；\n--no-trunc&#x3D;true|false: 对输出结果中太长的部分是否进行截断，默认为 是；\n-q, --quiet&#x3D;true|false: 仅输出ID信息，默认为　否\n使用 man docker-images 查看更多命令选项。\n添加镜像标签\n使用 tag\n命令来为一个本地镜像添加新的标签，以方便使用：\n$ docker tag ubuntu:latest myubuntu:latest\n查看详细信息\n使用 inspect 命令获取镜像的详细信息：\n$ docker inspect ubuntu:14.04\n返回的消息为 JSON 格式的消息，如果只想获取其中一项，使用\n-f 参数来指定：\n$ docker inspect -f &#123;&#123;&quot;.Architecture&quot;&#125;&#125;\n查看镜像的历史\n使用 history 命令来查看镜像的历史：\n$ docker history ubuntu:14.04\n可以查看各个层的内容具体的创建信息。\n搜索镜像\n使用 docker search\n命令来搜索远程仓库中的镜像，默认使用官方仓库。\n支持的参数有 ：\n--no-trunc&#x3D;true|false: 输出信息不截断显示，默认为 否；\n-f, --filter&#x3D;[]: 基于条件过滤输出\n--limit&#x3D;25: 搜索结果的最大数量\n搜索所有自动创建的评价为1+的带nginx关键字的镜像：\n$ docker search --limit&#x3D;10 nginx\n删除镜像\n使用 docker rmi 命令来删除镜像：\n使用标签删除\n$ docker rmi ubuntu:latest\n\n\n\n\n\n\n\n\n\n当一个镜像拥有多个标签时，删除某一个标签并不会影响原来的镜像\n使用镜像 ID 删除\n当使用 ID 进行删除时，所有的镜像标签包括原始镜像本身都会被删除。\n\n\n\n\n\n\n\n\n\n若镜像创建的容器存在时，则该镜像文件将无法被删除\n如果需要强制删除，可以使用 -f 参数。\n创建镜像\n有三种方式创建镜像：\n\n基于已有镜像的容器创建\n基于本地模板导入\n基于 Dockerfile 创建\n\n基于已有镜像的容器创建\n使用 docker commit 命令来创建。\n主要选项包括：\n-a, --author&#x3D;&quot;&quot;: 作者信息\n-c, --change&#x3D;[]: 提交的执行 Dockerfile 指令\n-m, --message&#x3D;&quot;&quot;: 提交信息\n-p, --pause&#x3D;true: 提交时暂停容器的运行\n提交时使用容器的 ID 或名称来指定容器：\n$ docker commit -m &quot;Added a new file&quot; -a &quot;Anson&quot; a925cb40b3f0 test:0.1\n基于本地模板导入\n使用 docker inport 命令来创建。\n$ cat ubuntu-14.04-x86_64-minimal.tar.gz | docker import - ubuntu:14.04\n存出和载入镜像\n存出镜像\n使用 docker save 来存出镜像：\n$ docker save -o ubuntu_14.04.tar ubuntu:14.04\n载入镜像\n使用 docker load 来载入镜像：\n$ docker load --input ubuntu_14.04.tar\n或者：\n$ docker load &lt; ubuntu_14.04.tar\n上传镜像\n使用 docker push 命令来上传镜像到仓库，默认为官方 Docker\nHub仓库：\ndocker push NAME[:TAG] | [REGISTRY_HOST[:REGISTRY_PORT]/]NAME[:TAG]\n$ docker tag test:latest user&#x2F;test:latest\n$ docker push user&#x2F;test:latest\nDocker 容器\n容器是镜像运行的实例。镜像是静态的只读文件，而容器带有运行时需要的可写文件层。\n创建容器\n新建容器\n使用 docker create 命令来创建一个容器：\n$ docker create -it ubuntu:latest\n此时容器处于停止状态，可以使用 docker start\n命令来启动它。\n启动容器\n使用 docker start 命令来启动一个已经创建的容器：\n$ docker start af\naf\n新建并启动容器\n使用 docker run 命令来创建并执行。\n$ docker run ubuntu &#x2F;bin&#x2F;echo &#39;Hello world&#39;\nHello world\n启动一个 bash 终端：\n$ docker run -it ubuntu:14.04 &#x2F;bin&#x2F;bash\n\n-t - 让 Docker\n分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上\n-i - 让容器的标准输入保持打开\n\nCtrl + d 或 输入 exit 退出容器。\n守护态运行\n通过添加 -d 参数实现：\ndocker run -d ubuntu  &#x2F;bin&#x2F;sh -c &quot;while true; do echo hello world; sleep 1; done&quot;\n终止容器\n使用 docker stop 命令来终止一个运行中的容器。\ndocker stop[-t|--time[=10]][CONTAINER...]\n首先向容器发送 SIGTERM 信号，等待一段超时时间（默认为10秒）后，再发送\nSIGKILL信号来终止容器：\n$ docker stop ce5\nce5\ndocker kill 命令会直接发送 SIGKILL\n信号来强行终止容器。\n重新启动一个容器使用 docker restart 命令。\n进入容器\n进入容器的方法：\n\nattach\nexec\nnsenter\n...\n\nattach 命令\ndocker attach [--detach-keys[=[]]] [--no-stdin] [--sig-proxy[=true]] CONTAINER\n主要选项：\n--detach-keys&#x3D;&quot;&quot;: 重写用于退出容器的键序列\n--no-stdin[&#x3D;false]: 是否关闭标准输入\n--sig-proxy[&#x3D;true]: 代理进程接收到的所有信号\n\n\n\n\n\n\n\n\n\n\n当多个窗口同时使用 attach\n命令连接到同一个容器时，所有的窗口都会同步显示。当某个窗口阻塞时，其他窗口也无法执行操作了。\nexec 命令\n主要参数：\n-i, --interactive[&#x3D;false]: 使用标准输入接受用户命令\n--privileged[&#x3D;false]: 赋予命令拓展权限\n-t, --tty[&#x3D;false]: 分配 pseudo-TTY\n-u, --user&#x3D;&quot;&quot;: 用户名或 UID (format:[:])\n$ docker exec -it 55c0389b9d7c &#x2F;bin&#x2F;bash\nnsenter 工具\n\n找到容器进程的 PID，命令如下：\nPID&#x3D;$(docker inspect --format &quot;&#123;&#123;.State.Pid&#125;&#125;&quot; &lt;container&gt;)\n通过 PID 连接到容器\n$ nsenter --target $PID --mount --uts --ipc --net --pid\n\n例子：\n$ docker run -idt ubuntu\n243c32535da7d142fb0e6df616a3c3ada0b8ab417937c853a9e1c251f499f550\n$ docker ps\nCONTAINER ID   IMAGE   COMMAND   CREATED  STATUS   PORTS  NAMES\n243c32535da7  ubuntu:latest   &quot;&#x2F;bin&#x2F;bash&quot;  18 seconds ago  Up 17 seconds \n    nostalgic_hypatia\n$ PID&#x3D;$(docker-pid 243c32535da7)\n10981\n$ nsenter --target 10981 --mount --uts --ipc --net --pid\nroot@243c32535da7:&#x2F;#\n删除容器\n使用 docker rm 命令来删除容器。\n主要参数：\n-f, --force[&#x3D;false]: 强制删除正在运行的容器\n-l,\t--link[&#x3D;false]: 删除指定的链接，但保留容器\n-v, --volumes[&#x3D;false]: 删除容器挂载的数据卷\n导入和导出容器\n在需要将容器从一个系统迁移到另一个系统的情况下，可以使用 Docker\n的导入和导出功能。\n导出容器\n使用 docker export 命令来导出容器：\n$ docker export -o test_for_run.tar ce5\n$ docker export e81 &gt; test_for_stop.tar\n导入容器\n使用 docker import 命令来导入容器：\n$ docker import test_for_run.tar - test&#x2F;ubuntu:v1.0\n访问 Docker 仓库\n仓库（Repository）是集中存放镜像的地方，分公共仓库和私有仓库。\nDocker Hub公共镜像市场\nDocker官方维护了一个公共镜像仓库 https://hub.docker.com\n时速云镜像市场\n访问地址 https://hub.tenxcloud.com\n搭建本地私有仓库\n使用 registry\n镜像创建私有仓库\n使用 registry 镜像来简单搭建一套本地私有仓库环境：\n$ docker run -d -p 5000:5000 registry\n默认情况下，会将仓库创建在容器的 /tmp/registry\n目录下。使用参数 -v 将镜像文件存放在本地的指定路径。\n$ docker run -d -p 5000:5000 -v &#x2F;opt&#x2F;data&#x2F;registry:&#x2F;tmp&#x2F;registry registry\n\n管理私有仓库\n使用 docker tag 命令将这个镜像标记为\n10.0.2.2：5000/test\n$ docker tag ubuntu:14.04 10.0.2.2:5000&#x2F;test\n使用 docker push 上传标记的镜像：\n$ docker push 10.0.2.2:5000&#x2F;test\nDocker 数据管理\n生产环境中使用 Docker\n的过程中，往往需要对数据进行持久化，或者需要在多个容器之间进行数据共享，这必然涉及容器的数据管理操作。\n容器中管理数据主要有两种方式：\n\n数据卷(Data Volumes)：容器内数据直接映射到本地主机环境；\n数据卷容器(Data Volume Containers)：使用特定容器维护数据卷。\n\n数据卷\n数据卷的特性：\n\n数据卷可以在容器之间共享和重用，容器间传递数据将变得高效方便；\n对数据卷内数据的修改会立马生效，无论是容器内操作还是本地操作；\n对数据卷的更新不会影响镜像，解耦了应用和数据；\n卷会一直存在，直到没有容器使用，可以安全地卸载它。\n\n在容器内创建一个数据卷\n在 docker run 命令下，使用参数 -v\n在容器内创建一个数据卷。重复使用可创建多个。\n例：\n$ docker run -d -P --name web -v &#x2F;webapp training&#x2F;webapp python app.py\n挂载一个主机目录作为数据卷\n$ docker run -d -P --name web -v &#x2F;src&#x2F;webapp:&#x2F;opt&#x2F;webapp training&#x2F;webapp python app.py\n加载主机的 /src/webapp 目录到容器的\n/opt/webapp 目录\n注：本地目录的路径必须是绝对路径，如果目录不存在，Docker会自动创建。\nDocker 挂载数据卷的默认权限是读写（rw），用户也可以通过 ro\n指定为只读：\n$ docker run -d -P --name web -v &#x2F;src&#x2F;webapp:&#x2F;opt&#x2F;webapp:ro\ntraining&#x2F;webapp python app.py\n挂载一个本地主机文件作为数据卷\n-v\n也可以从主机挂载单个文件到容器中作为数据卷（不推荐）。\n$ docker run --rm -it -v ~&#x2F;.bash_history:&#x2F;.bash_history ubuntu &#x2F;bin&#x2F;bash\n数据卷容器\n如果用户需要在多个容器之间共享一些持续更新的数据，最简单的方式是使用数据卷容器。数据卷容器也是一个容器，但是它的目的是专门用来提供数据卷供其他容器挂载。\n\n创建一个数据卷容器 dbdata，并在其中创建一个数据卷挂载到\n/dbdata:\n$ docker run -it -v &#x2F;dbdata --name dbdata ubuntu\nroot@3ed94f279b6f:&#x2F;#\n然后，可以在其他容器中使用 --volumes-from 来挂载\ndbdata 容器中的数据卷，例如创建 db1 和 db2\n两个容器，并从dbdata容器挂载数据卷：\n$ docker run -it --volumes-from dbdata --name db1 ubuntu\n$ docker run -it --volumes-from dbdata --name db2 ubuntu\n\n\n\n\n\n\n\n\n\n\n使用 --volumes-from\n参数所挂载数据卷的容器自身并不需要保持在运行状态。\n如果删除了挂载的容器（包括dbdata、db1和db2），数据卷并不会被自动删除。如果要删除一个数据卷，必须在删除最后一个还挂载着它的容器时显式使用\ndocker rm-v 命令来指定同时删除关联的容器。\n利用数据卷容器来迁移数据\n\n备份\n\n备份 dbdata 数据卷容器内的数据卷：\n$ docker run --volumes-from dbdata -v $(pwd):&#x2F;backup --name worker ubuntu tar cvf &#x2F;backup&#x2F;backup.tar &#x2F;dbdata\n\n镜像：ubuntu\n容器：worker\n-v $(pwd):/backup：挂载本地的当前目录到 worker 容器的\n/backup 目录\n--volumes-from dbdata：让 worker 容器挂载 dbdata\n容器的数据卷\ntar cvf/backup/backup.tar /dbdata：将\n/dbdata 下内容备份为容器内的\n/backup/backup.tar\n\n\n恢复\n\n将数据恢复到一个容器：\n首先创建一个带有数据卷的容器 dbdata2：\n$ docker run -v &#x2F;dbdata --name dbdata2 ubuntu &#x2F;bin&#x2F;bash\n然后创建另一个新的容器，挂载dbdata2的容器，并使用untar解压备份文件到所挂载的容器卷中：\n$ docker run --volumes-from dbdata2 -v $(pwd):&#x2F;backup busybox tar xvf &#x2F;backup&#x2F;backup.tar\n端口映射与容器互联\n端口映射实现访问容器\n\n从外部访问容器应用\n\n在启动容器的时候，如果不指定对应的参数，在容器外部是无法通过网络来访问容器内的网络应用和服务的。\n当容器中运行一些网络应用，要让外部访问这些应用时，可以通过\n-P 或 -p 参数来指定端口映射。当使用\n-P 参数时，Docker会随机映射一个 49000~49900\n的端口到内部容器开放的网络端口：\ndocker run -d -P training&#x2F;webapp python app.py\n可以使用 docker logs 命令来查看应用的信息：\n$ docker logs -f nostalgic_morse\n-p可以指定要映射的端口，并且，在一个指定端口上只可以绑定一个容器。支持的格式有\nIP：HostPort：ContainerPort、\nIP：：ContainerPort、\nHostPort：ContainerPort。\n\n映射所有接口地址\n\n使用 HostPort：ContainerPort 格式将本地的 5000\n端口映射到容器的 5000 端口，可以执行：\n$ docker run -d -p 5000:5000 training&#x2F;webapp python app.py\n多次使用 -p 参数可以绑定多个端口。\n\n映射到指定地址的指定端口\n\n可以使用 IP：HostPort：ContainerPort\n格式指定映射使用一个特定地址，比如localhost 地址 127.0.0.1：\n$ docker run -d -p 127.0.0.1:5000:5000 training&#x2F;webapp python app.py\n\n映射到指定地址的任意端口\n\n使用 IP：：ContainerPort 绑定 localhost\n的任意端口到容器的 5000端 口，本地主机会自动分配一个端口：\n$ docker run -d -p 127.0.0.1::5000 training&#x2F;webapp python app.py\n还可以使用 upd 标记来指定 UDP 端口：\n$ docker run -d -p 127.0.0.1:5000:5000&#x2F;udp training&#x2F;webapp python app.py\n\n查看映射端口配置\n\n使用 docker port\n命令来查看当前映射的端口配置，也可以查看绑定的地址：\n$ docker port nostalgic_morse 5000\n127.0.0.1:49155\n互联机制实现便捷互访\n容器的互联（linking）是一种让多个容器中应用进行快速交互的方式。它会在源和接收容器之间创建连接关系，接收容器可以通过容器名快速访问到源容器，而不用指定具体的\nIP 地址。\n\n自定义容器命名\n\n使用 --name 参数可以为容器自定义命名：\n$ docker run -d -P --name web training&#x2F;webapp python app.py\n\n\n\n\n\n\n\n\n\n容器的名称是唯一的。\n\n容器互联\n\n使用 --link 参数可以让容器之间安全地进行交互。\n创建一个新的数据库容器：\n$ docker run -d --name db training&#x2F;postgres\n创建一个新的 web 容器，并将它连接到 db 容器：\n$ docker run -d -P --name web --link db:db training&#x2F;webapp python app.py\n--link 参数的格式为\n--link name: alias，其中 name 是要连接的容器名称，alias\n是这个连接的别名。\nweb 容器连接到 db 容器，这允许web容器访问db容器的信息。\nDocker通过两种方式为容器公开连接信息：\n\n更新环境变量\n更新 /etc/hosts 文件\n\n使用 Dockerfile 创建镜像\nDockerfile 是一个文本格式的配置文件，用户可以使用 Dockerfile\n来快速创建自定义的镜像。\n基本结构\nDockerfile 由一行行命令语句组成，并且支持以 #\n开头的注释行。\n一般而言，Dockerfile分为四部分：\n\n基础镜像信息\n维护者信息\n镜像操作指令\n容器启动时执行指令\n\n指令说明\n指令的一般格式为 INSTRUCTION arguments\n\n\n\n\n\n\n\n指令\n说明\n\n\n\n\nFROM\n指定所创建镜像的基础镜像\n\n\nMAINTAINER\n指定维护者信息\n\n\nRUN\n运行命令\n\n\nCMD\n指定启动容器时默认执行的命令\n\n\nLABEL\n指定生成镜像的元数据标签信息\n\n\nEXPOSE\n声明镜像内服务所监听的端口\n\n\nENV\n指定环境变量\n\n\nADD\n复制指定的  路径下的内容到容器的  路径下， 可以为\nURL；如果为 tar 文件，会自动解压到  路径下\n\n\nCPOY\n复制本地主机的  路径下的内容到镜像中的 \n路径下；一般情况下推荐使用 COPY，而不是 ADD\n\n\nENTERPOINT\n指定镜像的默认入口\n\n\nVOLUME\n创建数据卷挂载点\n\n\nUSER\n指定运行容器时的用户名或 UID\n\n\nWORKDIR\n配置工作目录\n\n\nARG\n指定镜像使用的参数\n\n\nONBUILD\n配置当所创建的镜像为其他镜像的基础镜像时，所执行的创建操作指令\n\n\nSTOPSIGNAL\n容器退出的信号值\n\n\nHEALTHCHECK\n如何进行健康检查\n\n\nSHELL\n指定使用 shell 时的默认 shell 类型\n\n\n\nFROM\n指定所创建镜像的基础镜像，如果本地不存在，则默认会去 Docker Hub\n下载指定镜像。\n格式：FROM &lt;image&gt; or\nFROM &lt;imgae&gt;: &lt;tag&gt; or\nFROM &lt;image&gt;@&lt;digest&gt;\n 任何 Dockerfile 中的第一条指令必须为 FROM\n指令。并且，如果在同一个Dockerfile中创建多个镜像，可以使用多个FROM指令（每个镜像一次）。\nMAINTAINER\n指定维护者信息。\n格式：MAINTAINER &lt;name&gt;\nRUN\n运行指定命令。\n格式：RUN &lt;command&gt; or\nRUN [\"executable\", \"param1\", \"param2\"]\n注：必须使用双引号\n前者默认将在 shell 终端中运行命令，即/bin/sh-c；后者则使用 exec\n执行，不会启动shell环境。\nCMD\n指定启动容器时默认执行的命令。\n格式：\n\nCMD [\"executable\", \"param1\", \"param2\"] 使用 exec\n执行\nCMD command param1 param2 在 /bin/sh\n中执行\nCMD [\"param1\", \"param2\"] 提供给 ENTERPOINT\n的默认参数\n\n每个Dockerfile只能有一条 CMD\n命令。如果指定了多条命令，只有最后一条会被执行。\nLABEL\n用来指定生成镜像的元数据标签信息。\n格式：LABEL &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; ...\nEXPOSE\n声明镜像内服务所监听的端口。\n格式：EXPOSE &lt;port&gt; [&lt;port&gt; ...]\nEXPOSE 22 80 8443\n注意，该指令只是起到声明作用，并不会自动完成端口映射。\nENV\n指定环境变量，在镜像生成过程中会被后续 RUN\n指令使用，在镜像启动的容器中也会存在。\n格式：ENV &lt;key&gt;&lt;value&gt; or\nENV &lt;key&gt;=value\nENV PG_MAJOR 9.3\nENV PG_VERSION 9.3.4\nRUN curl -SL http:&#x2F;&#x2F;example.com&#x2F;postgres-$PG_VERSION.tar.xz | tar -xJC &#x2F;usr&#x2F;src&#x2F;\n    postgress &amp;&amp; …\n\n\nENV PATH &#x2F;usr&#x2F;local&#x2F;postgres-$PG_MAJOR&#x2F;bin:$PATH\nADD\n该命令将复制指定的路径下的内容到容器中的路径下。\n格式：ADD &lt;src&gt; &lt;dest&gt;\n路径支持正则格式。\nCOPY\n格式：COPY &lt;src&gt; &lt;dest&gt;\nENTRYPOINT\n指定镜像的默认入口命令，该入口命令会在启动容器时作为根命令执行，所有传入值作为该命令的参数。\n格式：\n\nENTRYPOINT [\"executable\", \"param1\", \"param2\"] exec\n调用执行\nENTRYPOINT command param1, param2 shell 中执行\n\n每个Dockerfile中只能有一个ENTRYPOINT，当指定多个时，只有最后一个有效。\nVOLUME\n创建一个数据卷挂载点。\n格式：VOLUME [\"/data\"]\nUSER\n指定运行容器时的用户名或UID，后续的RUN等指令也会使用指定的用户身份。\n格式：USER daemon\nWORKDIR\n为后续的 RUN、CMD 和 ENTRYPOINT 指令配置工作目录。\n格式：WORKDIR /path/to/workdir\n可以使用多个 WORKDIR\n指令，后续命令如果参数是相对路径，则会基于之前命令指定的路径。\nARG\n指定一些镜像内使用的参数，这些参数在执行 docker build\n命令时才以 --build-arg&lt;varname&gt;=&lt;value&gt;\n格式传入。\n格式：ARG &lt;name&gt;[=&lt;default value&gt;]\nONBUILD\n配置当所创建的镜像作为其他镜像的基础镜像时，所执行的创建操作指令。\n格式：ONBUILD[INSTRUCTION]\nSTOPSIGNAL\n指定所创建镜像启动的容器接收退出的信号值。例如：\nSTOPSIGNAL signal\nHEALTHCHECK\n配置所启动容器如何进行健康检查（如何判断健康与否），自Docker\n1.12开始支持。\n格式：\n\nHEALTHCHECK [OPTIONS] CMD command：根据所执行命令返回值是否为0来判断；\nHEALTHCHECK NONE：禁止基础镜像中的健康检查。\n\nOPTIONS：\n\n--interval=DURATION（默认为：30s）：过多久检查一次；\n--timeout=DURATION（默认为：30s）：每次检查等待结果的超时；\n--retries=N（默认为：3）：如果失败了，重试几次才最终确定失败。\n\nSHELL\n指定其他命令使用 shell 时的默认 shell 类型。\n创建镜像\n编写完成 Dockerfile 之后，可以通过 docker build\n命令来创建镜像。\n\n如果使用非内容路径下的 Dockerfile，可以通过 -f\n选项来指定其路径。\n要指定生成镜像的标签信息，可以使用 -t 选项。\n\n格式：docker build [OPTION] Path 读取指定路径下的\nDockerfile，并将该路径下的所有内容发送到 Docker\n服务端，由服务端创建镜像。\n例如，指定 Dockerfile 所在路径为\n/tmp/docker_builder/，并且希望生成镜像标签为build_repo/first_image，可以使用下面的命令：\n$ docker build -t build_repo&#x2F;first_image &#x2F;tmp&#x2F;docker_builder&#x2F;\n使用 .dockerignore 文件\n可以通过 .dockerignore 文件（每一行添加一条匹配模式）来让 Docker\n忽略匹配模式路径下的目录和文件。\n","slug":"Linux/Docker基础入门","date":"2022-06-24T06:44:00.000Z","categories_index":"Docker","tags_index":"《Docker技术入门与实践》","author_index":"爱慢跑的乌龟"},{"id":"f7bc0ebd3befb631a0f9a8db60b72936","title":"拉普拉斯变换","content":"拉普拉斯变换\n拉普拉斯变换简表\n\n\n\n\n\n\n\n\n序号\n原函数\n象函数\n\n\n\n\n1\n单位阶跃函数\n\n\n\n2\n单位脉冲函数\n\n\n\n3\n常数\n\n\n\n4\n单位斜坡函数\n\n\n\n5\n\n\n\n\n6\n\n\n\n\n7\n\n\n\n\n8\n\n\n\n\n9\n\n\n\n\n10\n\n\n\n\n11\n\n\n\n\n12\n\n\n\n\n13\n\n\n\n\n14\n\n\n\n\n15\n\n\n\n\n16\n\n\n\n\n17\n\n\n\n\n18\n\n\n\n\n19\n\n\n\n\n\n拉普拉斯变换的定义\n设有时间函数,当时，；在时定义函数的拉普拉斯变换为：\n​ \n拉普拉斯变换：在一定条件下，把实数域中的实变函数变换到复数域内与之等价的复变函数\n\n\n\n\n\n\n\n\n\n判断拉氏变换是否存在\n拉氏变换是否存在取决于定义的积分是否收敛。拉氏变换存在的条件：\n\n当时，分段连续，只有有限个间断点；\n当时，的增长速度不超过某个指数函数，即\n\n\n在复平面上，对于的所有复数\n(Res表示s的实部)都使积分式绝对收敛，故是拉普拉斯变换的定义域，称为收敛坐标。\n拉普拉斯变换的基本性质\n线性定理\n若、是任意两个复常数，且：\n，\n则：\n平移定理\n若：\n则：\n微分定理\n若：\n则：\n同理 ，对于二阶导数的拉普拉斯变换：\n\n推广到 n 阶导数： \n积分定理\n若：\n则：\n对于 n 重积分：\n\n终值定理\n若：\n则：\n初值定理\n若：\n则：\n","slug":"Math/Laplace Transform","date":"2022-06-23T03:18:00.000Z","categories_index":"数学","tags_index":"拉普拉斯变换","author_index":"爱慢跑的乌龟"},{"id":"409671003844af96bee509bb7a2097ee","title":"Latex数学公式","content":"数学公式的插入\n\n\n\n类型\n环境名称\n\n\n\n\n行内公式\n$...$\n\n\n独行公式\n$$...$$\n\n\n\n希腊字母\n\n\n\n命令\n大写\n小写\n\n\n\n\nalpha\n\n\n\n\ngamma\n\n\n\n\nepsilon\n\n\n\n\neta\n\n\n\n\niota\n\n\n\n\nlambda\n\n\n\n\nnu\n\n\n\n\nxi\n\n\n\n\nrho\n\n\n\n\ntau\n\n\n\n\nphi\n\n\n\n\npsi\n\n\n\n\nbeta\n\n\n\n\ndelta\n\n\n\n\nzeta\n\n\n\n\ntheta\n\n\n\n\nkappa\n\n\n\n\nmu\n\n\n\n\nomicron\n\n\n\n\npi\n\n\n\n\nsigma\n\n\n\n\nupsilon\n\n\n\n\nchi\n\n\n\n\nomega\n\n\n\n\n\n声调/变音符号\n\n\n\n公式\n符号\n公式\n符号\n\n\n\n\n\\dot{a}\n\n\\ddot{a}\n\n\n\n\\acute{a}\n\n\\grave{a}\n\n\n\n\\check{a}\n\n\\breve{a}\n\n\n\n\\tilde{a}\n\n\\bar{a}\n\n\n\n\\hat{a}\n\n\\widehat{a}\n\n\n\n\\vec{a}\n\n\n\n\n\n\n标准函数\n\n\n\n\n\n\n\n\n\n公式\n符号\n公式\n符号\n\n\n\n\n\\exp_a b=a^b\n\n\\sin a\n\n\n\n\\exp b=e^b\n\n\\cos b\n\n\n\n10^m\n\n\\tan c\n\n\n\n\\arcsin a\n\n\\sec d\n\n\n\n\\arccos b\n\n\\csc e\n\n\n\n\\arctan c\n\n\\cot f\n\n\n\n\\sinh a\n\n\\operatorname{argsh} a\n\n\n\n\\cosh b\n\n\\operatorname{argch} b\n\n\n\n\\tanh c\n\n\\operatorname{argth} c\n\n\n\n\\coth d\n\n\\operatorname{}\n将任何字符转换成标准函数的形式\n\n\n\n界限\n\n\n\n公式\n符号\n公式\n符号\n\n\n\n\n\\min x\n\n\\lim u\n\n\n\n\\max y\n\n\\liminf v\n\n\n\n\\inf s\n\n\\limsup w\n\n\n\n\\sup t\n\n\\dim p\n\n\n\n\\deg q\n\n\\det m\n\n\n\n\\ker\\phi\n\n\n\n\n\n\n映射\n\n\n\n公式\n符号\n公式\n符号\n\n\n\n\n\\Pr j\n\n\\hom l\n\n\n\n\\lVert z\\rVert\n\n\\arg z\n\n\n\n\n微分和导数\n\n\n\n\n\n\n\n\n\n公式\n符号\n公式\n符号\n\n\n\n\ndt\n\n\\prime\n\n\n\n\\mathrm{d}t\n\n\\backprime\n\n\n\n\\partial t\n\nf^\\prime\n\n\n\n\\nabla\\psi\n\nf' f''\n\n\n\nf^{(3)}\n\n\\dot{y} \\ddot{y}\n\n\n\n\n类字母符号和常数\n\n\n\n公式\n符号\n公式\n符号\n\n\n\n\n\\infty\n\n\\aleph\n\n\n\n\\complement\n\n\\backepsilon\n\n\n\n\\eth\n\n\\Finv\n\n\n\n\\hbar\n\n\\Im\n\n\n\n\\imath\n\n\\jmath\n\n\n\n\\Bbbk\n𝕜\n\\ell\n\n\n\n\\mho\n\n\\wp\n\n\n\n\\Re\n\n\\circledS\n\n\n\n\n模算数\n\n\n\n\n\n\n\n\n\n公式\n符号\n公式\n符号\n\n\n\n\na\\equiv1\\pmod{m}\n**\na\\bmod b\n\n\n\n\\gcd(m,n)\n\n\\operatorname{lcm}(m,n)\n\n\n\n\\mid\n\n\\nmid\n\n\n\n\\shortmid\n\n\\nshortmid\n\n\n\n\n根号\n\n\n\n公式\n符号\n公式\n符号\n\n\n\n\n\\surd\n\n\\sqrt{2}\n\n\n\n\\sqrt[n]{}\n\n\\sqrt[n]{x}\n\n\n\n\n运算符\n\n\n\n\n\n\n\n\n\n公式\n符号\n公式\n符号\n\n\n\n\n+\n\n-\n\n\n\n\\pm\n\n\\mp\n\n\n\n\\dotplus\n\n\\times\n\n\n\n\\div\n\n\\divideontimes\n\n\n\n/\n\n\\backslash\n\n\n\n\\cdot\n\n*\n\n\n\n\\star\n\n\\circ\n\n\n\n\\bullet\n\n\\boxplus\n\n\n\n\\boxminus\n\n\\boxtimes\n\n\n\n\\boxdot\n\n\\oplus\n\n\n\n\\ominus\n\n\\otimes\n\n\n\n\\oslash\n\n\\odot\n\n\n\n\\circleddash\n\n\\circledcirc\n\n\n\n\\circledast\n\n\\bigoplus\n\n\n\n\\bigotimes\n\n\\bigodot\n\n\n\n\n集合\n\n\n\n\n\n\n\n\n\n公式\n符号\n公式\n符号\n\n\n\n\n\\{ \\}\n\n\\emptyset\n\n\n\n\\varnothing\n\n\\in\n\n\n\n\\notin\n\n\\not\\in\n\n\n\n\\ni\n\n\\not\\ni\n\n\n\n\\cap\n\n\\Cap\n\n\n\n\\sqcap\n\n\\bigcap\n\n\n\n\\cup\n\n\\Cup\n\n\n\n\\sqcup\n\n\\bigcup\n\n\n\n\\bigsqcup\n\n\\uplus\n\n\n\n\\biguplus\n\n\\setminus\n\n\n\n\\smallsetminus\n\n\\times\n\n\n\n\\subset\n\n\\Subset\n\n\n\n\\sqsubset\n\n\\supset\n\n\n\n\\Supset\n\n\\sqsupset\n\n\n\n\\subseteq\n\n\\nsubseteq\n\n\n\n\\subsetneq\n\n\\varsubsetneq\n\n\n\n\\sqsubseteq\n\n\\supseteq\n\n\n\n\\nsupseteq\n\n\\supsetneq\n\n\n\n\\varsupsetneq\n\n\\sqsupseteq\n\n\n\n\\subseteqq\n\n\\nsubseteqq\n\n\n\n\\subsetneqq\n\n\\varsubsetneqq\n\n\n\n\\supseteqq\n\n\\nsupseteqq\n\n\n\n\\supsetneqq\n\n\\varsupsetneqq\n\n\n\n\n关系符号\n\n\n\n\n\n\n\n\n\n公式\n符号\n公式\n符号\n\n\n\n\n\\ne\n\n\\neq\n\n\n\n\\equiv\n\n\\not\\equiv\n\n\n\n\\doteq\n\n\\doteqdot\n\n\n\n\\overset{\\underset{def}{}}{=}\n\n:=\n\n\n\n\\sim\n\n\\nsim\n\n\n\n\\backsim\n\n\\thicksim\n\n\n\n\\simeq\n\n\\backsimeq\n\n\n\n\\eqsim\n\n\\cong\n\n\n\n\\ncong\n\n\\approx\n\n\n\n\\thickapprox\n\n\\approxeq\n\n\n\n\\asymp\n\n\\propto\n\n\n\n\\varpropto\n\n&lt;\n\n\n\n\\nless\n\n\\ll\n\n\n\n\\not\\ll\n\n\\lll\n\n\n\n\\not\\lll\n\n\\lessdot\n\n\n\n&gt;\n\n\\ngtr\n\n\n\n\\gg\n\n\\not\\gg\n\n\n\n\\ggg\n\n\\not\\ggg\n\n\n\n\\gtrdot\n\n\\le\n\n\n\n\\leq\n\n\\lneq\n\n\n\n\\leqq\n\n\\nleq\n\n\n\n\\nleqq\n\n\\lneqq\n\n\n\n\\lvertneqq\n\n\\ge\n\n\n\n\\geq\n\n\\gneq\n\n\n\n\\geqq\n\n\\ngeq\n\n\n\n\\ngeqq\n\n\\gneqq\n\n\n\n\\gvertneqq\n\n\\lessgtr\n\n\n\n\\lesseqgtr\n\n\\lesseqqgtr\n\n\n\n\\gtrless\n\n\\gtreqless\n\n\n\n\\gtreqqless\n\n\\leqslant\n\n\n\n\\nleqslant\n\n\\eqslantless\n\n\n\n\\geqslant\n\n\\ngeqslant\n\n\n\n\\eqslantgtr\n\n\\lesssim\n\n\n\n\\lnsim\n\n\\lessapprox\n\n\n\n\\lnapprox\n\n\\gtrsim\n\n\n\n\\gnsim\n\n\\gtrapprox\n\n\n\n\\gnapprox\n\n\\prec\n\n\n\n\\nprec\n\n\\preceq\n\n\n\n\\npreceq\n\n\\precneqq\n\n\n\n\\succ\n\n\\nsucc\n\n\n\n\\succeq\n\n\\nsucceq\n\n\n\n\\succneqq\n\n\\preccurlyeq\n\n\n\n\\curlyeqprec\n\n\\succcurlyeq\n\n\n\n\\curlyeqsucc\n\n\\precsim\n\n\n\n\\precnsim\n\n\\precapprox\n\n\n\n\\precnapprox\n\n\\succsim\n\n\n\n\\succnsim\n\n\\succapprox\n\n\n\n\\succnapprox\n\n\n\n\n\n\n几何符号\n\n\n\n\n\n\n\n\n\n公式\n符号\n公式\n符号\n\n\n\n\n\\parallel\n\n\\nparallel\n\n\n\n\\shortparallel\n\n\\nshortparallel\n\n\n\n\\perp\n\n\\angle\n\n\n\n\\sphericalangle\n\n\\measuredangle\n\n\n\n45^\\circ\n\n\\Box\n\n\n\n\\blacksquare\n\n\\diamond\n\n\n\n\\Diamond\n\n\\lozenge\n\n\n\n\\blacklozenge\n\n\\bigstar\n\n\n\n\\bigcirc\n\n\\triangle\n\n\n\n\\bigtriangleup\n\n\\bigtriangledown\n\n\n\n\\vartriangle\n\n\\triangledown\n\n\n\n\\triangleright\n\n\\blacktriangle\n\n\n\n\\blacktriangledown\n\n\\blacktriangleleft\n\n\n\n\\blacktriangleright\n\n\n\n\n\n\n逻辑符号\n\n\n\n\n\n\n\n\n\n公式\n符号\n公式\n符号\n\n\n\n\n\\forall\n\n\\exists\n\n\n\n\\nexists\n\n\\therefore\n\n\n\n\\because\n\n\\And\n\n\n\n\\lor\n\n\\vee\n\n\n\n\\curlyvee\n\n\\bigvee\n\n\n\n\\land\n\n\\wedge\n\n\n\n\\curlywedge\n\n\\bigwedge\n\n\n\n\\bar{q}\n\n\\bar{abc}\n\n\n\n\\overline{q}\n\n\\overline{abc}\n\n\n\n\\lnot\n\n\\neg\n\n\n\n\\bot\n\n\\top\n\n\n\n\\vdash\n\n\\dashv\n\n\n\n\\vDash\n\n\\Vdash\n\n\n\n\\models\n\n\\Vvdash\n\n\n\n\\nvdash\n\n\\nVdash\n\n\n\n\\nvDash\n\n\\nVDash\n\n\n\n\\ulcorner\n\n\\urcorner\n\n\n\n\\llcorner\n\n\\lrcorner\n\n\n\n\n箭头\n\n\n\n\n\n\n\n\n\n公式\n符号\n公式\n符号\n\n\n\n\n\\Rrightarrow\n\n\\Lleftarrow\n\n\n\n\\Rightarrow\n\n\\nRightarrow\n\n\n\n\\Longrightarrow\n\n\\implies\n\n\n\n\\Leftarrow\n\n\\nLeftarrow\n\n\n\n\\Longleftarrow\n\n\\Leftrightarrow\n\n\n\n\\nLeftrightarrow\n\n\\Longleftrightarrow\n\n\n\n\\iff\n\n\\Uparrow\n\n\n\n\\Downarrow\n\n\\Updownarrow\n\n\n\n\\leftarrow\n\n\\rightarrow\n\n\n\n\\nleftarrow\n\n\\nrightarrow\n\n\n\n\\leftrightarrow\n\n\\nleftrightarrow\n\n\n\n\\longleftarrow\n\n\\longrightarrow\n\n\n\n\\longleftrightarrow\n\n\\uparrow\n\n\n\n\\downarrow\n\n\\updownarrow\n\n\n\n\\nearrow\n\n\\searrow\n\n\n\n\\nwarrow\n\n\\swarrow\n\n\n\n\\mapsto\n\n\\longmapsto\n\n\n\n\\rightharpoonup\n\n\\rightharpoondown\n\n\n\n\\leftharpoonup\n\n\\leftharpoondown\n\n\n\n\\upharpoonleft\n\n\\upharpoonright\n\n\n\n\\downharpoonleft\n\n\\downharpoonright\n\n\n\n\\leftrightharpoons\n\n\\rightleftharpoons\n\n\n\n\\curvearrowleft\n\n\\circlearrowleft\n\n\n\n\\Lsh\n\n\\upuparrows\n\n\n\n\\rightrightarrows\n\n\\rightleftarrows\n\n\n\n\\rightarrowtail\n\n\\rightarrowtail\n\n\n\n\\curvearrowright\n\n\\circlearrowright\n\n\n\n\\Rsh\n\n\\downdownarrows\n\n\n\n\\leftleftarrows\n\n\\leftrightarrows\n\n\n\n\\leftarrowtail\n\n\\looparrowleft\n\n\n\n\\hookrightarrow\n\n\\hookleftarrow\n\n\n\n\\multimap\n\n\\leftrightsquigarrow\n\n\n\n\\rightsquigarrow\n\n\\twoheadrightarrow\n\n\n\n\\twoheadleftarrow\n\n\\xleftarrow{left}\n\n\n\n\\xrightarrow{right}\n\n\n\n\n\n\n特殊符号\n\n\n\n\n\n\n\n\n\n公式\n符号\n公式\n符号\n\n\n\n\n\\amalg\n\n\\%\n\n\n\n\\dagger\n\n\\ddagger\n\n\n\n\\ldots\n\n\\cdots\n\n\n\n\\smile\n\n\\frown\n\n\n\n\\wr\n\n\\diamondsuit\n\n\n\n\\heartsuit\n\n\\clubsuit\n\n\n\n\\spadesuit\n\n\\Game\n\n\n\n\\flat\n\n\\natural\n\n\n\n\\sharp\n\n\\diagup\n\n\n\n\\diagdown\n\n\\centerdot\n\n\n\n\\ltimes\n\n\\rtimes\n\n\n\n\\leftthreetimes\n\n\\rightthreetimes\n\n\n\n\\eqcirc\n\n\\circeq\n\n\n\n\\triangleq\n\n\\bumpeq\n\n\n\n\\Bumpeq\n\n\\doteqdot\n\n\n\n\\risingdotseq\n\n\\fallingdotseq\n\n\n\n\\intercal\n\n\\barwedge\n\n\n\n\\veebar\n\n\\doublebarwedge\n\n\n\n\\between\n\n\\pitchfork\n\n\n\n\\vartriangleleft\n\n\\ntriangleleft\n\n\n\n\\vartriangleright\n\n\\ntriangleright\n\n\n\n\\trianglelefteq\n\n\\ntrianglelefteq\n\n\n\n\\trianglerighteq\n\n\\ntrianglerighteq\n\n\n\n\n\n上下标和积分\n\n\n\n\n\n\n\n\n\n公式\n符号\n公式\n符号\n\n\n\n\na^2\n\na_2\n\n\n\na^{2+2}\n\na_{i,j}\n\n\n\na^2_2\n\n{}^2_1\\!X^3_4\n\n\n\nx'\n\nx^\\prime\n\n\n\n\\dot{x}\n\n\\ddot{x}\n\n\n\n\\vec{x}\n\n\\overleftarrow{AB}\n\n\n\n\\overrightarrow{AB}\n\n\\widehat{AB}\n\n\n\n\\overset{\\frown}{AB}\n\n\\overline{ABC}\n\n\n\n\\underline{ABC}\n\n\n\n\n\n\n上括号\n\\overbrace{1+2+\\cdots+100}：\n\\begin{matrix}5050\\\\\\overbrace{1+2+\\cdots+100}\\end{matrix}：\n下括号\n\\underbrace{1+2+\\cdots+100}：\n\\begin{matrix}\\underbrace{1+2+\\cdots+100}\\\\5050\\end{matrix}：\n求和\n\\sum_{i=1}^na_i \\sum\\limits_{i=1}^na_i：\n求积\n$\\prod_{i=1}^na_i \\prod\\limits_{i=1}^na_i$：\n上积\n\\coprod_{i=1}^na_i \\coprod\\limits_{i=1}^na_i：\n极限\n\\lim_{n\\to\\infty}x_n \\lim\\limits_{n\\to\\infty}x_n：\n积分\n\\int_{-N}^{N}e^x\\,dx：\n二重积分\n\\iint_M^Ndx\\,dy：\n三重积分\n\\iiint_M^Ndx\\,dy\\,dz：\n闭合曲线、曲面积分\n\\oint_Cx^3\\,dx+4y^2\\,dy：\n交集\n\\bigcap_1^np \\bigcap\\limits_1^np：\n并集\n\\bigcup_1^np \\bigcup\\limits_1^np：\n","slug":"Math/Latex_formula","date":"2022-06-20T02:24:00.000Z","categories_index":"数学","tags_index":"Latex 公式","author_index":"爱慢跑的乌龟"},{"id":"a903464ea5b37de55ddd5756ddfafbfa","title":"MQTT V3.1","content":"消息格式\n每个 MQTT 消息可能包含三个部分：\n\nFixed header(全部消息类型)\nVariable header(部分消息类型)\nPayload(部分消息类型)\n\nFixed header\n每个 MQTT 消息类型都必须包含 fixed header. fixed header\n的格式如下表所示：\n\nMessage Type(消息类型)\nPosition：byte1，bits 7-4\n\nReserved\nCONNECT\nCONNACK\nPUBLISH\nPUBACK\nPUBREC\nPUBREL\nPUBCOMP\nSUBSCRIBE\nSUBACK\nUNSUBSCRIBE\nUNSUBACK\nPINGREQ\nPINGRESP\nDISCONNECT\nReserved\n\nenum msgTypes&#123;\n    CONNECT &#x3D; 1, CONNACK, PUBLISH, PUBACK, PUBREC, PUBREL, PUBCOMP, SUBSCRIBE, UNSUBSCRIBE, UNSUBACK, PINGREQ, PINGRESP, DISCONNECT\n&#125;\nFlags(标志位)\nDUP\nPosition: byte1， bit 3.\n当客户端或服务器试图重新发送时，设置次标志。\n注：只能用于 QoS 值大于 0\n的消息，并且需要一个确认(acknowledgment)。当 DUP 位被设置时，variable\nheader 需要包含 Message ID。\nQoS\nPosition：byte1，bits 2-1.\n该标志用于指示所发送的消息的保证级别。QoS 级别如下表：\n\nRETAIN\nPosition：byte1，bit 0.\n该标志只能用于 PUBLISH\n消息类型。当客户端向服务器发送一个 PUBLISH 消息时，如果\nRETAIN 标志设置为\n1，则服务器应该在将消息传递给订阅方之后，依然保存该消息。\n当一个 Topic 上建立了新的订阅时，且订阅方设置了 RETAIN\n标志位，服务器应该将最后保留的消息发送给该订阅方。若没有保留任何消息，则不发送消息。\n为了让客户端区分所接收到的消失是服务器保留的消息，还是服务器实时发布的消息。当原始\nPUBLISH 到达时已存在的订阅导致服务器向客户端发送\nPUBLISH时，不应使用 RETAIN 标志设置，不管原始\nPUBLISH 的保留标志。\n如果服务器接收到零长度 payload 的消息，并且在同一主题上设置了\nRETAIN 标志，则可以删除保留消息。\nRemaining Length\n表示当前消息中剩余的字节数，包括 variable header 和 payload\n中的数据。\nVariable header\n某些类型的 MQTT 命令消息还包含一个 variable header。它位于 fixed\nheader 和 payload 之间。\nRemaining Length 字段的字节不影响 Remaining\n的字节计数长度值。该值只考虑 variable header 和 payload。\nvariable header 字段的格式如下，它们必须按照顺序出现在报头中：\nProtocol name\n消息类型：CONNECT\n该字段是一个 UTF-encoded 的字符串，表示协议名称 MQIsdp。\nProtocol version\n消息类型：CONNECT\n该字段是一个8位无符号值，表示客户端使用的协议的修订级别。V3.1\n版本的协议表示如下：\n\nConnect flags\n消息类型：CONNECT\n标志位：Clean session flag、Will、Will QoS、Retain flags\n\nClean session flag\nPosition：bit 1\n如果没有设置(0)，那么服务器在断开连接后必须存储客户端的订阅。这包括继续存储订阅主题的\nQoS 1 和 QoS 2\n消息，以便在客户端重新连接时交付它们。服务器还必须维护在连接丢失时传递的动态消息的状态。这个信息必须保存到客户端重新连接。\n如果设置为(1)，那么服务器必须丢弃之前维护的关于客户端的任何信息，并将连接视为“干净的”。当客户端断开连接时，服务器也必须丢弃任何状态。\nWill flag\nPosition：bit 2\nWill message 是当服务器与客户端的连接意外发生中断(I/O错误，客户端在\nKeep Alive\n规定的时间内未能完成通信)时，由服务器代替客户端所发布的消息。\n如果设置了 Will 标志，那么 Will QoS 和\nWill Retain 标志必须出现在 Connect flags\n字段中。同时， Will Topic 和 Will Message\n字段也必须包含在 payload 中。\nWill QoS\nPosition：bit 4，3\n设置 Will Message 的 QoS level，QoS level 同上，分为 3 级。\nWill Retain\nPosition：bit 5\nWill Retain\n标志表示在客户端意外断开连接的情况下，服务器是否应该保留由服务器代表客户端发布的Will消息。\nUser name and password flags\nPosition：bits 6，7\n连接的客户端可以指定用户名和密码，设置标志位表示用户名和密码(可选)包含在\nCONNECT 消息的 payload。\n如果设置了 User Name 标志位，则 User Name\n字段为必填字段，否则其值将被忽略。 如果设置了 Password\n标志，则 Password 字段是必须的，否则其值将被忽略。\n不提供用户名而提供密码是无效的。\nKeep Alive timer\n消息类型：CONNECT\nKeep\nAlive计时器(以秒为单位)定义了从客户端接收到的消息之间的最大时间间隔。它使用服务器能够检测到客户端断开连接，并且不必等待\nTCP/IP 连接超时。客户端必须在每个 Keep Alive\n时间段内发送消息。如果在该时间段内没有与数据相关的消息，则客户端发送一个\nPINGREQ 消息，服务器用 PINGRESP\n消息表示确认。\nKeep Alive\n定时器是一个16位的值，表示该时间周期的秒数。实际值与应用程序相关，但典型值是几分钟。最长约18小时。值为0(0)表示客户机没有断开连接。\nKeep Alive计时器的格式如下表所示。Keep Alive Timer 的 2 字节顺序是\nMSB，然后是 LSB (big-endian)。\n\nConnect return code\n消息类型：CONNACK\n该字段定义一个 1 字节无符号返回码。返回码如下表所示：\n\n\nTopic name\n消息类型：PUBLISH\n主题名称是标识将有效负载数据发布到的信息通道的键。订阅方使用密钥来标识希望在其上接收发布信息的信息通道。\n主题名称是UTF-encoded 的字符串。主题名称的长度不超过32767个字符。\nPayload\nCONNECT\nPayload 包含一个或多个 UTF-8 encoded\n的字符串。它们为客户端指定一个唯一的标识符、一个Will主题和消息以及要使用的用户名和密码。除了第一个变量外，其他的都是可选的，它们的存在取决于变量头中的标志。\nSUBSCRIBE\nPayload 包含客户端可以订阅的主题名称列表和QoS级别。这些字符串是\nUTF-encoded。\nSUBACK\nPayload 包含授予的 QoS level 的列表。\n这些是服务端的管理员允许客户端订阅特定 Topic Name 的 QoS level。 授予的\nQoS 级别的列出顺序与对应的\nSUBSCRIBE消息中的主题名称相同。\n\nPUBLISH 消息的 Payload\n部分只包含特定于应用程序的数据。没有对数据的性质或内容做任何假设，消息的这一部分被视为\nBLOB。\nMessage identifiers\n消息类型：PUBLISH,PUBACK,PUBREC,PUBREL,PUBCOMP,SUBSCRIBE,SUBACK,UNSUBSCRIBE,UNSUBACK\n只有 QoS level 为 1 或 2 的消息才会有 Message ID。\nMessage ID 是一个 16\n位无符号整数，在特定通信方向的“正在传输”消息集合中必须是唯一的。\n注：客户端将维护它自己的 Message IDs 列表，与它所连接的服务器使用的\nMessage IDs 分开。客户端可以发送一个 Message ID 为 1 的\nPUBLISH，同时接收 Message ID 为 1\n的PUBLISH。\nMessage Identifier 的两个字节顺序是 MSB，然后是 LSB(大端序)。\n\nMQTT and UTF-8\n在MQTT中，字符串的前缀是两个字节，以表示长度，如下表所示。\n\n字符串长度是编码字符串的字节数，而不是字符数。例如，字符串OTWP使用UTF-8编码，如下表所示。\n\n命令报文\nCONNECT -\n客户端向服务器提交连接请求\n当建立从客户机到服务器的 TCP/IP 套接字连接时，必须使用\nCONNECT 流创建一个协议级别的会话。\nFixed header\n\nRemaining Length 是可变报头的长度(12字节) 和 Payload\n的长度。这可以是一个多字节字段。\nVariable header\n\n\nPayload\nCONNECT 消息的 payload\n包含一个或多个UTF-8编码的字符串，基于 variable header\n中的标志。如果存在字符串，则必须按以下顺序出现:\nClient Identifier\nUTF-encoded 字符串，长度在 1 - 23\n个字符之间，在所有连接到服务器的客户端中，ID 必须是唯一的。如果 ID\n字符超过 23 个，服务器将返回错误代码 2：Identifier Rejected.\nWill Topic\n(如果 Will Flag 设置)第 2 个 UTF-8 encoding 字符串为 Will Topic。Will\nMessage 将被发布到 Will Topic。\nWill Message\n(如果 Will Flag 设置)第 3 个 UTF-8 encoding 字符串为 Will\nMessage。Will Message 定义了在客户端意外断开连接时发布到 Will Topic\n的消息的内容。这可能是一个零长度的消息。\nUser Name\n(如果 User Name Flag 设置)第 4 个 UTF-8 encoding 字符串为 User\nName。User Name 用于标识正在连接的用户的名称，用于认证。User Name\n的长度建议不超过12个字符。\nPassword\n(如果 Password Flag 设置)第 5 个 UTF-8 encoding 字符串为\nPassword。连接用户对应的密码，可用于认证。建议密码长度不超过12个字符。\nResponse\n服务器发送 CONNACK 消息来响应来自客户端的\nCONNECT 消息。\n如果在 TCP/IP\n连接建立后，服务器在合理的时间内没有收到CONNECT消息，服务器应该关闭连接。\n如果客户端在合理的时间内没有收到来自服务器的 CONNACK\n消息，客户端应该关闭TCP/IP\n套接字连接，并通过打开一个新的套接字到服务器并发出 CONNECT\n消息来重新启动会话。\n如果具有相同客户端 ID 的客户端已经连接到服务器，在完成新客户端的\nCONNECT 流之前，服务器必须断开“旧的”客户端。\nCONNACK - 确认连接请求\nCONNACK 消息是服务器响应客户端 CONNECT\n请求而发送的消息。\nFiexed header\n\nVariable header\n\n\nPayload\n无\nPUBLISH - 发布消息\nPUBLISH\n消息由客户机发送到服务器，分发给感兴趣的订阅者。每个\nPUBLISH\n消息都与一个主题名称(也称为主题或通道)相对应。发布到特定主题名称的消息将传递给该主题的连接订阅者。\nFixed header\n\nVariable header\nTopic name\n一个 UTF-encoding 字符串。不能包含 Topic\n通配符。当使用通配符订阅的客户端接收到此字符串时，此字符串将是原始发布者指定的绝对主题，而不是客户端使用的订阅字符串。\nMessage ID\n用于具有 QoS level 1 和 QoS level 2\n的消息。\n下表显示了 PUBLISH 消息的一个示例 Variable header。\n\n\n\nField\nValue\n\n\n\n\nTopic Name:\n\"a/b\"\n\n\nQoS level\n1\n\n\nMessage ID:\n10\n\n\n\n本例中 Variable header 的格式如下表所示。\n\nPayload\n包含要发布的数据。数据的内容和格式是应用程序特有的。\nResponse\n对 PUBLISH 消息的响应取决于 QoS\nlevel。下表显示了预期的响应。\n\n\n\nQoS Level\nExpected response\n\n\n\n\nQoS 0\nNone\n\n\nQoS 1\nPUBACK\n\n\nQoS 2\nPUBREC\n\n\n\nPUBACK - 发布确认\nPUBACK 消息是对 QoS level 1 的 PUBLISH\n消息的响应。服务器发送 PUBACK 消息以响应来自发布客户机的\nPUBLISH 消息，订阅者发送 PUBACK\n消息以响应来自服务器的PUBLISH 消息。\nFixed header\n\nVariable header\n包含正在被确认的 PUBLISH 消息的消息标识符(Message\nID)。下表显示了变量头文件的格式。\n\nPayload\n无\nActions\n当客户端接收到 PUBACK\n消息时，它会丢弃原始消息，因为它也被服务器接收(并记录)。\nPUBREC - 确认发布被接受\nPUBREC 消息是对具有 QoS level 2 的 PUBLISH\n消息的响应。它是 QoS level 2 协议流的第二条消息。PUBREC\n消息由服务器发送，以响应来自发布客户机的 PUBLISH\n消息，或者由订阅方发送，以响应来自服务器的 PUBLISH\n消息。\nFixed header\n\nVariable header\nVariable header 包含已确认的 PUBLISH 的 Message\nID。下表显示了变量头文件的格式。\n\nPayload\n无\nActions\n当接收到 PUBREC 消息时，接收方向发送方发送\nPUBREL 消息， Message ID 与 PUBREC\n消息相同。\nPUBREL - 确认发布\nPUBREL 消息是发布方对来自服务器的 PUBREC\n消息的响应，或服务器对来自订阅方的PUBREC 消息的响应。它是\nQoS 2 协议流中的第三条消息。\nFixed header\n\nVariable header\nVariable header 包含与被确认的 PUBREC 消息相同的 Message\nID。下表显示了变量头文件的格式。\n\nPayload\n无\nActions\n当服务器接收到来自发布方的 PUBREL\n消息时，服务器使原始消息对感兴趣的订阅者可用，并向发布者发送具有相同\nMessage ID 的PUBCOMP\n消息。当订阅者从服务器接收到PUBREL\n消息时，订阅者使该消息对订阅应用程序可用，并向服务器发送\nPUBCOMP 消息。\nPUBCOMP - 确认发布完成\n此消息要么是服务器对发布者的 PUBREL\n消息的响应，要么是订阅者对服务器的 PUBREL 消息的响应。它是\nQoS 2 协议流中的第四个也是最后一个消息。\nFixed header\n\n\nVariable header\nVariable header 包含与确认的 PUBREL 消息相同的 Message\nID。\n\nPayload\n无\nActions\n当客户端接收到 PUBCOMP\n消息时，它会丢弃原始消息，因为它已经被传递给服务器(仅一次)。\nSUBSCRIBE - 订阅命名主题\nSUBSCRIBE\n消息允许客户端向服务器注册对一个或多个主题名称。发布到这些主题的消息作为\nPUBLISH\n消息从服务器传递到客户端。订阅消息还指定订阅者希望在其上接收发布消息的\nQoS level。\nFixed header\n\nVariable header\n\nPayload\nSUBSCRIBE\n消息的有效负载包含客户端希望订阅的主题名称列表，以及客户端希望接收消息的\nQoS级别。\n字符串是 UTF-encoded\n编码的，QoS级别占用单个字节的2位。主题字符串可以包含特殊的topic\n通配符来表示一组主题。 这些 topic/QoS 对是连续打包的，如下表中的示例\npayload 所示。\n\n\n\nTopic name\n\"a/b\"\n\n\n\n\nRequested QoS\n1\n\n\nTopic name\n\"c/d\"\n\n\nRequested QoS\n2\n\n\n\nSUBSCRIBE 消息中的主题名称没有被压缩。示例 payload\n的格式如下表所示。\n\n假设请求的 QoS 级别被授权，客户端接收到的 PUBLISH\n消息小于或等于这个级别，这取决于来自发布者的原始消息的 QoS 级别。\n例如，如果客户端对特定主题有 QoS leve 1\n的订阅，那么将以 QoS level 0 向客户端发送到该主题的 QoS level 0\nPUBLISH 消息。发送到同一主题的 QoS level 2\nPUBLISH 消息被降级为 QoS level 1\n以交付给客户端。\n这意味着发布者负责确定消息可以传递的最大QoS，但订阅者可以将QoS降级为更适合其使用的QoS。消息的QoS从不升级。\n一个同时设置了两个 QoS\n级别位的请求应该被认为是一个无效的数据包，并且连接被关闭。\nResponse\n当它从客户端接收到一个 SUBSCRIBE 消息时，服务器用一个\nSUBACK 消息响应。\n服务器可以在客户端接收到 SUBACK\n消息之前开始发送由于订阅而产生的 PUBLISH 消息。\nSUBACK - 订阅确认\n服务器向客户端发送 SUBACK 消息以确认接收到\nSUBSCRIBE 消息。\nSUBACK 消息包含授权的 QoS\n级别的列表。SUBACK 消息中授予的 QoS 级别的顺序与相应的\nSUBSCRIBE 消息中的主题名称的顺序匹配。\nFixed header\n\nVariable header\nVariable header 包含被确认的订阅消息的 Message\nID。下表显示了变量头文件的格式。\n\nPayload\nPayload 包含一个已授权的 QoS 级别向量。每个级别对应于相应的\nSUBSCRIBE 消息中的主题名称。SUBACK 消息中的\nQoS 级别的顺序与 SUBSCRIBE 消息中主题名称和请求的QoS\n对的顺序匹配。Variable header 中的 Message ID 使能够进行匹配\nSUBACK 消息与相应的 SUBSCRIBE 消息。\nUNSUBSCRIBE - 取消订阅主题\n客户端向服务器发送 UNSUBSCRIBE\n消息以取消对指定主题的订阅。\nFixed header\n\nVariable header\nVariable header 包含一个 Message ID，因为 UNSUBSCRIBE\n消息的 QoS级别为 1。\n\nPayload\n客户端的 payload 中是取消订阅的主题列表。字符串是\nUTF-encoded，并且连续打包。UNSUBSCRIBE\n消息中的主题名称没有被压缩。下表显示了一个示例 payload。\n\n\n\nTopic Name\n\"a/b\"\n\n\n\n\nTopic Name\n\"c/d\"\n\n\n\n\nResponse\n服务器发送 UNSUBACK 到客户端响应\nUNSUBSCRIBE 消息。\nUNSUBACK - 取消订阅确认\nUNSUBACK 消息由服务器发送给客户端，以确认接收到\nUNSUBSCRIBE 消息。\nFixed header\n\nVariable header\n\nPayload\n无\nPINGREQ\nPINGREQ\n消息是从已连接的客户端发送到服务器的“心跳”消息。\nFixed header\n\nVariable header\n无\nPayload\n无\nResponse\n对 PINGREQ 消息的响应是 PINGRESP 消息。\nPINGRESP - PING 响应\nFixed header\n\n\nVariable header\n无\nPayload\n无\nDISCONNECT\n客户端向服务器发送 DISCONNECT 消息，表示它即将关闭\nTCP/IP 连接。这允许干净的断开连接，而不是仅仅删除线路。\n如果客户端连接了 clean\n会话标志集，那么之前维护的关于客户端的所有信息将被丢弃。\nFixed header\n\nVariable header\n无\nPayload\n无\n\nQoS level 1：\n\nQoS level 2：\n\n","slug":"IOT/Mqtt","date":"2022-06-18T12:30:03.000Z","categories_index":"通信协议","tags_index":"MQTT","author_index":"爱慢跑的乌龟"},{"id":"d8ed3ff70bac5529479cf8a31499ebd5","title":"Linux 服务","content":"Linux 服务\ndaemon与服务\n系统为了某些功能必须要提供一些服务（系统本身或者网络方面），这个服务就称为service。service 的提供需要程序来运行，完成这个 service 的程序就称之为 daemon。\n\n\n\n\n\n\n\n\n\n服务的名称被建立之后，在 Linux 中使用时，通常在服务的名称之后会加上一个d。\nsystemd\nsystemd 全部就是仅有一个 systemd 服务搭配 systemctl 命令来处理，无须其他额外的命令来支持。\nsystemd 将所有的服务定义为一个服务单元(unit)，并将每个 unit 归类到不同的服务类型中(type)中。\nsystemd 将服务单元(unit)以下几个类型(type):\n\nservice\nsocket\ntarget\npath\nsnapshot\ntimer\n...\n\nsystemd 将许多的功能集合成为一个所谓的 target 项目，这个项目这要在设计操作环境的创建，所以是集合了许多的 daemon，执行某个 target 就是执行很多的 daemon。\nsystemd 配置文件放置的目录\n服务的基本类型包括：系统服务、数据监听与交换的 socket 文件服务(socket)、存储系统状态的快照类型、提供不同类似运行级别分类的操作环境(target)。\n文件目录：\n\n/usr/lib/systemd/system/：每个服务最主要的启动脚本设置。\n/run/systemd/system/：系统执行过程中所产生的服务脚本。\n/etc/systemd/system/：管理员根据主机系统的需求所建立的执行脚本。\n\n操作系统所执行的服务均设置在/etc/systemd/system/ 中设置，仅是一些链接文件。而实际的启动脚本文件在 /usr/lib/systemd/system/ 中，必须在该目录下才能修改相应服务的启动设置。\nsystemd 的 unit 类型\n扩展名就是服务的类型。例如：multipathd.service 、multi-user.target。\n几种常见的 systemd 的服务类型：\n\n\n\n\n\n\n\n扩展名\n主要服务功能\n\n\n\n\n.service\n一般服务类型(service unit)：主要是系统服务，包括服务器本身需要的本地服务以及网络服务等，经常被使用到的服务大多是这种类型。所以，这也是最常见的类型了。\n\n\n.socket\n内部程序数据交换的 socket 服务(socket unit)：主要是 IPC(Inter-process communication) 的传输信息 socket 文件 (socket file) 功能。这种类型的服务通常在监控信息传递的 socket文件中，当通过此 socket 文件传递信息要链接服务时，就根据当时的状态将该用户的要求传送到对应的 daemon，若 daemon 尚未启动，则启动该 daemon 后在传送用户的要求。 使用 socket 类型的服务一般较少用到，因此在开机启动时通常会稍微延迟启动的时间。一般用于本地服务较多。\n\n\n.target\n执行环境类型(target unit)：其实是一群 unit 的集合。\n\n\n.mount.automount\n文件系统挂载相关的服务(automount unit/mount unit)：例如来自网络的自动挂载、NFS 文件系统挂载等与文件系统相关性较高的进程管理。\n\n\n.path\n检测特定文件或目录类型(path unit)：某些服务需要检测某些特定的目录来提供队列服务，例如最常见的打印服务，就是通过检测打印队列目录来启动打印功能。\n\n\ntimer\n循环执行的服务(timer unit)：这个服务有点类似 anacrontab，不过是由 systemd 主动提供。\n\n\n\nsystemctl 管理服务\nsystemd 这个启动服务的机制，主要是通过一个名为 systemctl 的命令来完成的。\nsystemctl 管理单一服务(service unit) 的启动/开机启动与查看状态\nsystemctl [command] [unit]\ncommand:\nstart:\t\t立刻开启[unit]\nstop:\t\t立刻关闭[unit]\nrestart:\t立刻重新启动[unit]\nreload: \t不关闭[unit]的情况下，重新加载配置文件，让设置生效\nenable:\t\t设置开机时，[unit]自动启动\ndisable:\t关闭开机时自动启动\nstatus:\t\t当前[unit]的状态\nis-active:\t当前是否正在运行中\nis-enable:\t是否设置开机自动启动\nsystemctl status docker.service:\n\n\nLoaded：开机是服务是否自动启动 [enabled，disabled]\nActive：是否正在执行[running，dead]\n\n几种常见的服务状态：\n\nactive (running)：正在运行\nactive (exited)：仅执行一次就正常结束的服务，目前没有进程执行\nactive (waiting)：正在运行中，还需要等待其他事件发生才能继续执行\ninactive：服务当前没有运行\n\ndaemon 的默认状态：\n\nenabled：开机自动运行\ndisabled：开机不运行\nstatic：不可以自行启动，但是可能会其他 enabled 的服务唤醒\nmask：daemon 无论如何都不会被启动，因为已经被强制注销\n\nsystemctl 查看系统上的所有服务\nsystemctl [command] [--type&#x3D;TPYE] [--all]\ncommand:\nlist-units:\t\t\t依据 unit 显示目前所有启动 unit，若加上 --all 会列出没有启动的\nlist-units-files:\t依据 &#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F; 内的文件，将所有文件列表说明\n--type&#x3D;TPYE: 服务类型: service、socket、target等\nsystemctl 管理不同的操作环境(target unit)\nsystemctl list-units --type=target --all：\n\n与操作界面相关性较高的 tatget 有以下几个：\n\ngraphical.target：命令加上图形界面，包含有 multi-user.target\nmulti-user.target：纯命令行模式\nrescue.target：在无法使用 root 登录的情况下，systemd 在启动时会多加一个额外的临时系统，与原本的操作系统无关，此时可以获得 root 权限来维护系统。\nemergency.target：紧急处理系统的错误，还是需要使用 root 登录的情况，在无法使用 rescue.target 时，可以尝试这种模式\nshutdown.target：关机模式\ngetty.target：可设置需要几个 tty 的操作\n\nsystemctl [command] [unit.target]\ncommand:\nget-default:\t获取当前的 target\nset-default:\t设置 [unit.target] 为默认的操作模式\nisolate:\t\t切换到 [unit.target] 操作模式\n\n在不重新启动的情况下，将目前操作环境改为纯命令模式，关闭图形界面\nsystemctl isolate multi-user.target\n在 target 项目中必须使用 isolate 才能切换操作环境，而不是 start \nsystemd 还提供可一些简单的命令来切换操作模式：\nsystemctl poweroff\t\t系统关机\nsystemctl reboot \t\t重新启动\nsystemctl suspend\t\t进入挂起模式\nsystemctl hibernate\t\t进入休眠模式\nsystemctl rescue\t\t强制进入休眠模式\nsystemctl emergency \t强制进入紧急恢复模式\n\nsuspend：挂起模式会将系统的状态数据保存到内存中，然后关闭大部分的系统硬件。当用户按下唤醒机器的按钮时，系统数据会在内存中恢复，然后启动大部分被关闭的硬件\nhibernate：休眠模式则是将系统状态保存到硬盘当中，保存完毕后，将计算机关机。\n\nsystemctl 分析各种服务之间的依赖关系\nsystemctl list-dependencies [unit] [--reverse]\n--reverse: 反向追踪谁使用该 [unit].\nsystemctl list-dependencies：\n\n与 systemd 的 daemon 运行过程相关的目录\nsystemd 启动脚本配置文件在 /usr/lib/systemd/system/ 与 /etc/systemd/system/ 目录下。\n\n/usr/lib/systemd/system/\n官方提供的软件安装后，默认的启动脚本配置文件放在该目录下，这里的数据尽量不要修改，如需要修改，应该修改 /etc/systemd/system/ 下的文件\n/run/systemd/system/\n系统执行过程中所产生的服务脚本，其优先级高于 /usr/lib/systemd/system/\n/etc/systemd/system/\n管理员依据主机系统的需要所建立的执行脚本，执行优先级高于 /run/systemd/system/\n/etc/sysconfig/*\n服务将初始化的一些选项设置写入到这个目录\n/var/lib/\n一些会产生数据的服务都会将它的数据写入到 /var/lib/ 目录中。\n/run/\n放置 daemon 的缓存\n\n\n获取 socket 文件的位置：\nsystemctl list-sockets:\n\n\n查询服务所对应的端口，位于 /etc/services\n执行 cat /etc/services 查看端口：\n\n\n关闭网络服务\n\n\n\n\n\n\n\n\n\n会产生一个网络监听端口(port)的进程，就可以称它是网络服务\n查看网络端口的方式：\nnetstat -tlunp\n\n关闭一个网络服务：\nsystemctl stop avahi-daemon.service\nsystemctl stop avahi-daemon.socket\nsystemctl disable avahi-daemon.service avahi-daemon.socket\nsystemctl 对于 service 类型的配置文件\n\n/usr/lib/systemd/system/vsftpd.service ：官方发布默认配置文件\n/etc/systemd/system/vsftpd.service.d/custom.conf：在 /etc/systemd/system 下建立与配置文件相同文件名的目录，但是要加上 .d 扩展名，然后在该目录下建立配置文件即可。配置文件的扩展名最好用 .conf。\n/etc/systemd/system/vsftpd.service.wants/*：此目录内的文件为链接文件，设置依赖服务的链接。启动 vsftpd.service 之后，最好加上该目录下建议的服务。\n/etc/systemd/system/vsftpd.service.requires/*：此目录内的文件为链接文件，设置依赖服务的链接。在启动 vsftpd.service 之前，需要事先启动的服务。\n\n\n配置文件中，能够将整个设置分为三个部分：\n\n[Unit]：unit 本身的说明，以及其他依赖 deamon 的设置，包括在什么服务之后才启动此 unit 之类的设置值。\n[Service]、[Socket]、[Timer]、[Mount]、[Path]：不同的 unit 类型就要使用相应的设置项目。这个项目主要用来规范服务启动的脚本、环境配置文件名、重新启动的方式等。、\n[Install] ：将此 unit 安装到哪个 target 里去\n\n配置文件内的设置规则：\n\n设置项目通常是可以重复的，例如可以重复设置两个 After 在配置文件中，但是会替换前面的。\n如果设置参数需要有 【是/否】的项目(布尔值，Boolean)，可以使用1、yes、true、on代表启动，用0、no、false、off代表关闭\n空白行、开头为 # 或 ；的那一行，代表注释\n\n两个 vsftpd 运行的实例\n# 1. 建立所需要的配置文件\ncd &#x2F;etc&#x2F;vsftpd\ncp vsftpd.conf vsftpd2.conf\n# 修改端口\nvim vsftpd2.conf\nlisten_port&#x3D;555\n# 2. 处理启动脚本设置\ncd &#x2F;etc&#x2F;systemd&#x2F;system\ncp &#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;vsftpd.service vsftpfd2.service\nvim vsftpd.service\n# 3. 重新加载 systemd 的脚本配置文件内容\nsystemctl daemon-reload\n自定义服务\n脚本：\n# vim &#x2F;backups&#x2F;backup.sh\n----\n#! &#x2F;bin&#x2F;bash\nsource &#x3D; &quot;&#x2F;etc &#x2F;home &#x2F;root &#x2F;var&#x2F;lib &#x2F;var&#x2F;spool&#x2F;&#123;cron, at, mail&#125;&quot;\ntarget &#x3D; &quot;&#x2F;backups&#x2F;backup-system-$(data +%Y-%m-%d).tar.gz&quot;\n[ ! -d &#x2F;backups ] &amp;&amp; mkdir &#x2F;backups\ntar -zcvf $&#123;target&#125; $&#123;source&#125; $&gt; &#x2F;backups&#x2F;backup.log\n# chmod a+x &#x2F;backups&#x2F;backup.sh\n设计一个名为 bachup.service 的启动脚本设置：\n# vim &#x2F;etc&#x2F;systemd&#x2F;system&#x2F;backup.service\n[Unit] \nDescription&#x3D;backup my server\nRequires&#x3D;atd.service\n[Service]\nType&#x3D;simple\nExecStart&#x3D;&#x2F;bin&#x2F;bash -c &quot; echo &#x2F;backups&#x2F;bachup.sh | at now&quot;\n[Install]\nWantedBy&#x3D;multi-user.target\nsystemctl 针对 timer 的配置文件\n任务需求：\n想要使用 systemd 的 timer 功能，必须要有几个要件：\n\n操作系统的 timer.target 一定要启动。\n要有个 sname.service 的服务存在(sname 是你自己指定的名称)\n要有个 sname.timer 的时间启动服务存在\n\n sname.timer  的设置值\n可以到 /etc/systemd/system 下面去建立一个 *.timer 文件\n基本设置如下：\n\n\n\n\n\n\n\n设置参数\n参数说明\n\n\n\n\nOnActiveSec\n当 timer.target 启动多久后才执行这个 unit\n\n\nOnBootSec\n当启动完成后多久之后才执行\n\n\nOnStartupSec\n当 systemd 第一次启动之后过多久才执行\n\n\nOnUnitActiveSec\n这个 timer 配置文件所管理的那个 unit 服务在最后一次启动后，隔多久再执行一次的意思\n\n\nOnUnitlnactiveSec\n这个 timer 配置文件所管理的那个 unit 服务在最后一次停止后，隔多久再执行一次的意思\n\n\nOnCalendar\n使用实际时间（非循环时间）的方式来启动服务的意思\n\n\nUnit\n一般来说不太需要设置，因此如同上面提到的，基本上我们设置都是 sname.server + sname.timer，那如果你的 sname 并不相同时，那在 .timer 的文件中，就得要指定是哪个 service unit\n\n\nPersistent\n当使用 OnCalendar 的设置时，指定该功能要不要持续进行的意思，通常是设置为 yes，比较能够满足类似 anacron 的功能\n\n\n\n使用于 OnCalendar 的时间 \n\n\n\n\n\n\n\n\n\n语法：英文周名 YYYY-MM-DD HH:MM:SS\n范例：Thu 2015-08-13 13:40:00\n也可以直接使用间隔时间来处理。常用的间隔时间单位有：\n\nus 或 usec：微妙\nms 或 msec：毫秒\ns、sec、second、seconds\nm、min、minute、minutes\nh、hr、hour、hours\nd、day、days\nw、week、weeks\nmonth、months\ny、year、years\n\n常见的使用范例：\n\n\n\n\n\n\n\n\n\n隔 3 小时： 3h 或 3hr 或 3hours\n隔 300 分钟过 10 秒： 10s 300m\n隔 5 天又 100 分钟： 100m 5 day\n一个循环时间运行的案例：\n\n启动后 2 小时开始执行一次 backup.service\n自从第一次执行后，未来每两天执行一次 backup.service\n\n# vim &#x2F;etc&#x2F;systemd&#x2F;system&#x2F;backup.timer\n[Unit]\nDescription&#x3D;backup my server timer\n[Timer]\nOnBootSec&#x3D;2hrs\nOnUnitActiveSec&#x3D;2days\n[Install]\nWantedBy&#x3D;multi-user.target\n固定日期运行案例：\n\n星期天凌晨2点运行\n\n# vim &#x2F;etc&#x2F;systemd&#x2F;system&#x2F;backup2.timer\n[Unit]\nDescription&#x3D;backup my server timer2\n[Timer]\nOnCalendar&#x3D;Sun *-*-* 02:00:00\nPersistent&#x3D;true\nUnit&#x3D;backup.service\n[Install]\nWantedBy&#x3D;multi-user.target\n","slug":"Linux/service","date":"2022-05-04T04:05:00.000Z","categories_index":"Linux","tags_index":"Linux 服务","author_index":"爱慢跑的乌龟"},{"id":"2b59eb5778e5da9b12f5210e8d61016e","title":"路径规划算法","content":"1.\n自动驾驶汽车定位-感知-规划-决策-控制概述\n定位\n\n定位，即通过GPS、惯导、激光雷达等传感器，获取车辆的位置和航向信息。\n绝对定位是指通过GPS实现，采用双天线，通过卫星获得车辆在地球上的绝对位置和航向信息。\n相对定位是指根据车辆的初始位姿，通过惯导、里程计等传感器获得加速度信息，将其对时间进行积分，即可得到相对初始位姿的当前位姿信息。\n\n感知\n\n环境感知，即通过摄像头、激光雷达、毫米波雷达、超声波雷达等队中传感器，感知周围环境信息和车辆状态信息。\n环境信息包括：道路、方向、曲率、坡度、交通标志，信号灯；车辆状态信息包括：车辆前进的速度、加速度、转向角度、车身位置及姿态。\n多种传感器虽然可以获得丰富、细致的环境信息，但如何对多种传感器的信息进行融合统一处理\n\n规划\n\n规划是对未来时域、空域的车辆一系列动作的计划。从涉及的时空大小全局（宏观）路径规划和局部（微观）路径规划。\n全局路径规划指在已知全局地图的情况下，从车辆当前位置规划出一条到目的地的全局路径。\n局部路径规划指根据环境感知的信息在环道、转弯、躲避障碍物等情况下，实时规划出一条安全、平顺、舒适的行驶路径。\n\n决策控制\n\n决策控制，包括决策和控制两部分\n决策，在整个无人驾驶系统中，扮演驾驶员大脑的角色，根据定位、感知、路径规划的信息，决定无人车的形式策略。包括：选取哪条车道、是否换道、是否跟车行驶、是否绕道、是否停车等。\n控制，主要包括转向、驱动、制动三方面的控制，执行规划决策模块下发的期望速度和期望转向角度，也包括转向灯、喇叭、门窗等的控制。\n\n2.全局路径规划算法——Dijkstra算法\n算法简介\n迪杰斯特拉算法(Dijkstra)是由荷兰计算机科学家狄克斯特拉于1959年提出的，因此又叫狄克斯特拉算法。是从一个节点遍历其余各节点的最短路径算法，解决的是有权图中最短路径问题\n算法思想\n\n设是一个带权有向图，把图中节点集合V分成两组，第一组为已求出最短路径的集合,(用S表示，初始时S中只有一个源点，以后每求得一条最短路径，就将该节点加入到集合S中，直到全部节点都加入到S中，算法结束)\n第二组为区域未确定最短路径的节点集合（用U表示），按最短路径长度的递增次序依次把第二组的节点加入S中。在加入的过程中，总保持从源点v到S中各节点的最短路径长度不大于从源点v到U中任何节点的最短路径长度。\n此外，每个节点对应一个距离，S中的节点的距离就是从v到此节点的最短距离路径长度，U中的节点的距离，是从v到此节点只包括S中的节点为中间节点的当前最短路径长度。\n\n\n算法精讲\n\n初始时，S只包含起点s；U包含除s外的其他节点，且U中节点的距离为”起点s到该节点的距离“[例如，U中节点v的距离为(s,v)的长度，然后s和v不相邻，则v的距离为].\n从U中选出”距离最短的节点k“，并将节点k加入到S中；同时，从U中移除节点k。\n更新U中各节点到起点s的距离。之所以更新U中节点的距离，是因为上一步确定了k是求出最短路径的节点，从而可以利用k来更新其他节点的距离；例如，的距离可能大于的距离。\n重复步骤(2)和(3)，直到遍历完所有节点。\n\n\n选取节点， \n\n选取节点，，.\n\n选取节点，，.\n\n选取节点，，.\n\n，.\n\n，.\n\n，.\n\n的最优路径为\n最短距离为22\nMatlab实现\nclc\nclear\nclose all\n%% 图定义\n% 根据节点的邻近节点表及字母点-数字节点对应表，构造节点元胞数组\nnodes_dist = cell(0);\nnodes_dist(1,:) = {1, [2, 6, 7], [12, 16, 14]};\nnodes_dist(2,:) = {2, [1, 3, 6], [12, 10, 7]};\nnodes_dist(3,:) = {3, [2, 4, 5, 6], [10, 3, 5, 6]};\nnodes_dist(4,:) = {4, [3, 5], [3, 4]};\nnodes_dist(5,:) = {5, [3, 4, 6, 7], [5, 4, 2, 8]};\nnodes_dist(6,:) = {6, [1, 2, 3, 5, 7], [16, 7, 6, 2, 9]};\nnodes_dist(7,:) = {7, [1, 5, 6], [14, 8, 9]};\n\n%% 算法初始化\n% S/U的第一列表示节点编号\n% 对于S,第二列表示从源节点到本节点已求得的最小距离，不再变更；\n% 对于U,第二列表示从源节点到本节点暂时求得的最小距离，可能会变更\nS = [4, 0];\nU(:,1) = [1, 2, 3, 5, 6, 7];\nU(:,2) = [inf, inf, 3, 4, inf, inf]};\n\n% 最优路径及暂时的最优路径的初始化\npath_opt = cell(7, 2);\npath_opt(4,:) = {4, 4};\n\npath_temp = cell(7, 2);\npath_temp(3,:) = {3, [4, 3]};\npath_temp(4,:) = {4, 4};\npath_temp(5,:) = {5, [4, 5]};\n\n%% 循环遍历所有节点\nwhile ~isempty(U)\n[dist_min, idx] = min(U(:,2));\nnode_min = U(idx, 1);\nS(end+1,:) = [node_min, dist_min];\nU(idx,:) = [];\n\n% 将最小的距离值的节点添加到到最优路径集合\npath_opt(node_min,:) = path_temp(node_min,:);\n\n%% 依次遍历最小距离节点的邻节点，判断是否在U集合中更新邻节点的距离值\nfor i = 1:length(nodes_dist{node_min, 2})\n\ti = 1;\n\t% 需要判断的节点\n\tnode_temp = nodes_dist{node_min, 2}(i);\n\t\n\t% 找出U集合中节点node_temp的索引值\n\tidx_temp = find(node_temp == U(:,1));\n\t\n\t% 判断是否更新\n\tif ~isempty(idx_temp)\n\t\tif dist_min + node_dist{node_min, 3}(i) &lt; U(idx_temp, 2)\n\t\t\tU(idx_temp, 2) = dist_min + nodes_dist{node_min, 3}(i)\n\t\t\t\n\t\t\t% 更新暂时最优路径\n\t\t\tpath_temp{node_temp, 1} = node_temp;\n            path_temp{node_temp, 2} = [path_opt{node_min, 2}, node_temp];\n            end        \nPython实现\n# 图定义\n# 根据节点的邻近节点表-数字对应表，构造图\nnodes_dist = dict()\nnodes_dist[1] = {2: 12, 6: 16, 7: 14}\nnodes_dist[2] = {1: 12, 3: 10, 6: 7}\nnodes_dist[3] = {2: 10, 4: 3, 5: 5, 6: 6}\nnodes_dist[4] = {3: 3, 5: 4}\nnodes_dist[5] = {3: 5, 4: 4, 6: 2, 7: 8}\nnodes_dist[6] = {1: 16, 2: 7, 3: 6, 5: 2, 7: 9}\nnodes_dist[7] = {1: 14, 5: 8, 6: 9}\n\n# S 集合\nS = dict()\n\n# U 集合\nU = dict()\nU[1] = float('inf')\nU[2] = float('inf')\nU[3] = float('inf')\nU[4] = 0\nU[5] = float('inf')\nU[6] = float('inf')\nU[7] = float('inf')\n\n# 当前最优路径\nkeys = [i for i in range(1, 8)]\npath_temp = dict([(k, []) for k in keys])\n\n\n# 最终最优路径\npath_opt = dict([(k, []) for k in keys])\n\n# 循环遍历U集合，直到所有节点被确定，并移出集合\nwhile U:\n    # 寻找U集合中的最小值，及其对应的节点\n    dist_min = min(U.values())\n    node_min = min(U, key=U.get)\n    # 将最小值节点移出U集合，移入S集合\n    S[node_min] = dist_min\n    del U[node_min]\n\n    # 确定该最小值节点的最终最优路径\n    path_opt[node_min] += path_temp[node_min]\n    path_opt[node_min].append(node_min)\n\n    # 围绕该最小值节点，循环遍历其相邻节点\n    for node_temp in nodes_dist[node_min].keys():\n        # 判断该相邻节点是否在集合U中，即该节点是否已经被确定。若已确定，则不做考虑\n        if node_temp in list(U.keys()):\n            # 判断该路径是否比原有路径短\n            if (dist_min + nodes_dist[node_min][node_temp]) &lt; U[node_temp]:\n                # 更新最短距离\n                U[node_temp] = dist_min + nodes_dist[node_min][node_temp]\n                # 该最短距离所对应的新路径\n                path_temp[node_temp] = path_opt[node_min]\n\nprint(S, U)\nprint(path_opt)\n3.全局路径规划算法——蚁群算法\n算法简介\n蚁群算法是一种智能算法，它是由一群无智能或有微智能的个体(Agent)通过相互协作表现出智能行为，从而为求解复杂问题提供了一个新的可能性。\n\n蚁群算法(Ant Colony Algorithm, ACA)\n于1992年首次提出，该算法模拟了自然界中蚂蚁的觅食行为.\n蚂蚁在寻找食物源时，会在其经过的路径上释放一种信息素，并能够感知其他蚂蚁释放的信息素，信息素浓度的大小表征路径的远近，信息素浓度越高，表示对应的路径距离越短。\n通常，蚂蚁会以较大的概率优先选择信息素浓度较大路径，并释放一定量的信息素，以增强该条路径上的信息素浓度，这样，会形成正反馈。最终，蚂蚁能够找到一条从巢穴到食物源的最佳路径，即距离最短。\n\nTSP问题描述\n蚁群算法最早用来解决TSP问题，并且表现出很大的优越性，因为它有分布式特性、鲁棒性强并且容易与其他算法结合，但是同时也存在收敛速度慢，容易陷入局部最优等缺点。\nTSP问题(Travel Salesperson\nProblem，即旅行商问题或者称为中国邮递员问题)，是一种NP-hard问题，此类问题用一般的算法很难得到最优解的，所以一般需要借助一些启发式算法求解，例如遗传算法(GA)，蚁群算法(ACO)，微粒群算法(PSO)等。\n\n\n\n\n\n\n\n\n\nTSP问题（旅行商问题）是指旅行家旅行n个城市，要求各个城市经历且仅经历一次然后回到出发城市，并要求所走路程最短。\n一个TSP问题可以表达为：求解遍历图，所有的节点一次并且回到起始节点，使得连接这些节点的路径成本最低。\n算法思想\n\n用蚂蚁的行走路径并表示待优化问题的可行解，整个蚂蚁群的所有路径构成待优化问题的解空间。\n路径较短的，蚂蚁会释放较多的信息素，随着时间的推进，较短的路径上积累的信息素浓度逐渐增高，选择该路径的蚂蚁个数也愈来愈多。\n最终，整个蚂蚁会在正反馈的作用下集中到最佳的路径上，此时对应的便是待优化问题的最优解。\n\n\n算法精讲\n原理\n假如蚁群中所有蚂蚁的数量为，所有城市之间的信息素用矩阵表示，最短路径为\n，最佳路径为。每只蚂蚁都有自己的内存，内存中用一个禁忌表(Tabu)来存储蚂蚁已经访问过的城市，表示以后的搜索将不能访问这些城市；还有用另外一个允许访问的城市表(Allowed)来存储它还可以访问的城市；另外还用矩阵(Delta)来储存它在一个循环（或者迭代）中经过的路径释放的信息素；还有另外一些数据，例如一些控制参数，该蚂蚁行走完全程的总成本或距离(tourLength)，等等。假定算法总共运行MAX_GEN次，运行时间为t.\n蚁群算法计算过程如下：\n\n初始化\n为每只蚂蚁选择下一个节点。\n更新信息素矩阵\n检查终止条件\n\n\n\n\n\n\n\n\n\n\n如果达到最大迭代数MAX_GEN，算法终止，转到第(5)步；否则，重新初始化所有蚂蚁的Delta矩阵所有元素初始化为0，Tabu表清空，Allowed表加入所有城市节点。随机选择它们的起始位置（也可以人为指定）。在Tabu表中加入起始节点，Allowed表中删除该起始节点，重复执行(2),(3),(4)步。\n\n输出最优值\n\n\n不失一般性，设整个蚂蚁群体中蚂蚁的数量为，城市的数量为，城市与城市之间的相互距离为，时刻城市与城市连接路径上的信息素浓度为。初始时刻，各个城市间连接路径上的信息素浓度相同，不妨设为。\n蚂蚁根据各个城市间连接路径上的信息素浓度决定其下一个访问的城市，设表示时刻蚂蚁从城市转移到城市的概率，其计算公式如下：\n​ \n其中，为启发函数，，表示蚂蚁从城市转移到城市的期望程度，蚂蚁待访问城市的集合。开始时，中有个元素，即包括除了蚂蚁出发城市的其他所有城市，随着时间的推进，中的元素不断减少，直至为空，即表示所有的城市均访问完毕。为信息素重要程度因子，其值越大，表示信息素的浓度在转移中起的作用越大；为启发函数重要程度因子，其值越大，表示启发函数转移中的作用越大，即蚂蚁会以较大的概率转移到距离短的城市。\n在蚂蚁释放信息素的同时，各个城市间连接路径上的信息素逐渐消失，设参数表示信息挥发程度。因此，当所有蚂蚁完成一次循环后，各个城市间连接路径上的信息素浓度需要进行实时更新，具体公式如下：\n​ \n其中，表示第只蚂蚁在城市与城市连接路径上释放的信息素浓度，表示所有蚂蚁在城市与城市连接路径上释放的信息素浓度之和。\nant cycle system 模型中，的计算公式如下：\n​ 第只蚂蚁从城市访问城市其它\n\n\n\n\n\n\n\n\n\n定义\n参数影响分析\n\n\n\n\n\n信息启发式因子\n值越大，蚂蚁选择之前走过的路径可能性就越大，搜索路径的随机性减弱，越小，蚁群搜索范围就会减少，容易陷入局部最优\n\n\n\n期望启发式因子\n值越大，蚁群越容易选择局部较短路径，这时算法的收敛速度是加快了，但是随机性却不高，容易得到局部最优解\n\n\n\n蚁群数量\n数目越多，得到的最优解就越精确，但是会产生不少重复解，随着算法接近最优解的收敛，信息正反馈作用降低，大量的重复工作，消耗了资源，增加了时间复杂度\n\n\n\n信息挥发因子，表示残留因子\n过小时，在各路径上残留的信息素过多，导致无效的路径继续被搜索，影响到算法的收敛速率；过大，无效的路径虽然可以被排除搜索，但是不能保证有效的路径也会被搜索，影响到最优值的搜索。\n\n\n\n蚁群算法中主要参数的理想选择如下：\n\n\n\n参数\n取值范围\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n流程图：\n\n文献\n1.蚁群算法中参数\nα、β 、ρ设置的研究 ———以 TSP 问题为例\n蚁群算法在TSP问题应用中取得了良好的效果，但也存在一些不足：\n\n如果参数、、设置不当，导致求解速度很慢且所得的解质量特别差；\n基本蚁群算法计算量大，求解所需要的时间较长；\n基本蚁群算法中理论上要求所有的蚂蚁选择同一路线，该线路即为所求的最优线路；但在实际计算中，在给定一定循环次数的条件下很难实现这种情况。\n另一方面，在其他实际应用中，如图像处理中寻求最优模板问题，并不要求所有的蚂蚁都能找到最优的模板，而只需要一只找到即可。\n\n时刻在路径上的信息素浓度为：\n​ \n表示蚂蚁在时间段到的过程中，在到的路径上留下的残留信息浓度。根据信息素更新策略的不同，有3种不同的蚁群算法模型：\n\nant-quantity模型\n，如果蚂蚁经过，如果蚂蚁不经过\n式中，是常量，信息素的增量与之间的距离有关。\nant-density模型\n，如果蚂蚁经过，如果蚂蚁不经过\n式中，是常量，则信息素增加一个固定值，与之间的距离无关\nant-cycle模型\n，如果蚂蚁在巡回中经过，如果蚂蚁在巡回中不经过\n式中，是常量；表示第只蚂蚁的循环路线，即如果蚂蚁经过，则信息素增量为一个常量除以蚂蚁的巡回路线长。这里，信息素增量只与蚂蚁的巡回路线和有关系，而和具体的无关。\n\n代码实现\nimport random\nimport copy\nimport time\nimport sys\nimport math\nimport tkinter\nimport threading\nfrom functools import reduce\n\n# 参数\n'''\nAlpha:信息启发因子，值越大，则蚂蚁选择之前走过的路径可能性就越大，值越小，则蚁群搜索范围就会减少，容易陷入局部最优\nBeta:值越大，蚁群就越容易选择局部最短路径，这时算法收敛速度加快，但是随机性不高，容易得到局部的相对最优\n'''\n(Alpha, Beta, Rho, Q) = (1.0, 2.0, 0.5, 100.0)\n# 城市数，蚁群\n(city_num, ant_num) = (50, 50)\ndistance_x = [\n    178,272,176,171,650,499,267,703,408,437,491,74,532,\n    416,626,42,271,359,163,508,229,576,147,560,35,714,\n    757,517,64,314,675,690,391,628,87,240,705,699,258,\n    428,614,36,360,482,666,597,209,201,492,294]\ndistance_y = [\n    170,395,198,151,242,556,57,401,305,421,267,105,525,\n    381,244,330,395,169,141,380,153,442,528,329,232,48,\n    498,265,343,120,165,50,433,63,491,275,348,222,288,\n    490,213,524,244,114,104,552,70,425,227,331]\n\n# 城市距离和信息素\ndistance_graph = [[0.0 for col in range(city_num)] for raw in range(city_num)]\npheromone_graph = [[1.0 for col in range(city_num)] for raw in range(city_num)]\n\n\n#----------蚂蚁-----------\nclass Ant(object):\n    def  __init__(self, ID):\n        self.ID = ID                    # ID\n        self.__clean_data()             # 随机初始化出生点\n4.全局路径规划算法——动态规划算法\n算法简介\n\n动态规划是运筹学的一个分支，是求解多阶段决策过程最优化问题的数学方法。\n各个阶段决策的选取不是任意确定的，它依赖于当前面临的状态，又影响以后的发展。当各个阶段的决策确定以后，就组成一个决策序列，因而也就决定了整个过程的一条活动路线，这样的一个前后关联具有链状结构的多阶段过程就称为多阶段决策问题。\n动态规划在车辆工程技术领域有着广泛的应用，如“两档变速器的最优换挡规律”、“混合动力汽车最优能量管理策略”、“栅格地图最优路径搜索”等。\n\n动态规划算法是通过拆分问题，定义问题状态和状态之间的关系，使得问题能够以递推（或者说分治）的方式去解决。动态规划算法的基本思想与分治法类似，也是将待求解问题分解为若干子问题（阶段），按顺序求解子阶段，前一子问题的解，为后一子问题的求解提供了有用的信息。在求解任一子问题时，列出各种可能的局部解，最后一个子问题就是初始问题的解。\n算法思想\n\n美国数学家Bellman等人在20世纪50年代初提出了著名的最优化原理，把多阶段决策问题转化为一系列单阶段最优化问题。\n对最佳路径（最佳决策过程）所经过的各个阶段，其中每各阶段起始点到全过程终点的路径，必定是该阶段起始点到全过程终点的一切可能路径中的最佳路径（最优决策），这就是Bellman提出的著名的最优化原理。\n简言之，一个最优决策的子决策必然是最优的。\n\n\n算法精讲\n\n逆向寻优，正向求解\nDP算法本质由三层循环构成\n第一层遍历每一个阶段；\n第二层遍历第i个阶段的每个状态；\n第三层循环遍历第i+1个阶段的每一个状态。\n\n\n\n第四阶段 (D-&gt;E): D有两条路线到终点E。\n\n\n第三阶段(C-&gt;D): C到D有6条路线\n第3阶段的C有3个状态值，分别讨论经过该状态值的最优路线\n经过C1\n\n最短路线为\n经过C2\n\n最短路线为\n经过C3\n\n最短路线为\n\n第二阶段(B-&gt;C): B到C有9条路线。\n第2阶段的B有3个状态值，分别讨论经过该状态值的最优路线\n经过B1\n\n最短路线为\n经过B2\n\n最短路线为\n经过C3\n\n最短路线为\n\n第一阶段(A-&gt;B)：A到B有3条路线\n\n最短路线为\n5.全局路径规划算法——A*算法\n算法简介\n\nA*(A-Star)算法是一种静态路网求解最短路径最有效的直接搜索方法，也是解决许多搜索问题的有效算法，\n广泛应用于室内机器人路径搜索、游戏动画路径搜索等。\n\n算法思想\n\nA*算法结合了贪心算法（深度优先）和Dijkstra算法（广度优先），是一种启发是搜索算法。\n路径优劣的评价公式为：\n是从初始状态经由状态到目标状态的代价估计，\n是在状态空间中从初始状态到状态的实际代价\n是从状态到目标状态的最佳路径的估计代价\n使用了两个状态表，分别称为openList表和closeList表。openList表由待考察的节点组成，closeList表由已经考察过节点组成。\n\n算法精讲——预处理\n\n将地图栅格化，把每一个正方形格子的中央称为节点；\n确定栅格属性，即每一个格子有两种状态：可走和不可走（体现障碍物）。\n定义两个列表集合：openList和closeList。openList表由待考察的节点组成，closeList由已经考察的节点组成。类似Dijkstra算法的U集合和S集合。\n确定起始节点和目标节点。\n\n\n\n初始时，定义A为父节点，节点A离自身的距离为0，路径完全确定，移入closeList中；\n父节点周围共有8个节点，定义为子节点。将子节点放入openList中，成为待考察对象。\n若某个节点既未在openList，也没在closeList中，则表明还有未搜索到该节点。\n路径优劣的判断依据是移动代价，单步移动代价采取Manhattan\n计算方式，即把横向和纵向移动一个节点的定义为10。斜向移动代价参考等腰三角形计算斜边的方式，距离为14。\n算法精讲——开始搜索\n\n移动代价评价函数为：。是初始状态经由状态到目标状态的代价估计，是在状态空间中从初始状态到状态的实际代价，是从状态到目标状态的最佳路径的估计代价。以节点为例。\n首先考察，由于从A到该格子是斜向移动，单步移动距离为14，故\n在考察估计代价。估计的含义是忽略剩下的路径是否包含有障碍物（不可走），完全按照Manhattan计算方式，计算只做横向或纵向移动的累计代价：横向向右移动3步，纵向向上移动1步，总共4步，故为.\n因此从A节点移动I节点的总移动代价为：\n以此类推，分别计算当前openList中余下的7个子节点的移动代价，挑选最小代价节点F，移动到closeList中。\n现在\n\n\n","slug":"Self-Driving/PathPlan","date":"2022-05-03T16:00:00.000Z","categories_index":"自动驾驶","tags_index":"路径规划","author_index":"爱慢跑的乌龟"},{"id":"b64cd93b72faed23ef520531eb71c1e8","title":"pacman 文档","content":"pacman - Arch Linux\n软件管理器\nSYNOPSIS\npacman &lt;operation&gt; [options] [targets]\nDESCRIPTION\nPacman 是一个包管理的使用程序，用于跟踪 Linux\n系统上以安装的包。它具有依赖性支持、软件包组、安装和卸载脚本，以及将本地机器与远程存储库同步以自动升级包的功能。Pacman\n包是 tar 压缩格式。\n调用 pacman\n涉及到指定一个带有任何潜在选项(options)和目标(targets)的操作(operation)。目标通常是包名(package\nname)、文件名(file name)、URL或搜索字符串(search\nstring)。目标可以作为命令行参数提供。\nOPERATIONS\n\n-D， --database\n对包数据库进行操作。通过该操作，可以修改 pacman\n数据库中已安装软件包的某些属性。检查数据库内部一致性。\n-Q，--query\n查询包数据库。该操作可以查看已安装的包及其文件，以及关于单个包的元信息。这可以针对本地包数据库运行，可以用于单个包文件。\n-R，--remove\n从系统中移除包。还可以指定要删除的组，在这种情况下，该组中的每个包都会被删除。属于指定包的文件将会被删除，数据库将会更新。\n-S，--sync\n同步包。包直接从远程仓库中安装，包括所需的所有依赖项。如果一个包名存在于多个仓库中，可以显示的指定仓库来确定需要安装的包。对于版本要求：pacman -S \"bash&gt;=3.2\"(需要使用双引号)。\n除了包之外，还可以指定组(group)。例：如果 gnome\n是一个已定义的包组，那么 pacman -S gnome\n将提供一个提示，允许从编号列表中选择要安装的包。包的选择是使用空格和\"/\"或逗号的包号(package\nnumbers)列表来指定的。可以用连字符(-)分隔第一个和最后一个包号来选择连续的包。排除包可以在数字或数字范围前加上插入符号(^)来实现。\n提供其他包的包(Packages that provide other\npackages)也被处理。例：pacman -S foo 将首先查找一个 foo\n包。如果没有找到 foo，将搜索提供与 foo 相同功能的包。\n可以使用 pacman -Su 来升级所有过时的软件包。\n-T --deptest\n检查依赖关系；这在 makepkg\n等脚本中用于检查已安装的包。该操作检查指定的每个依赖项，并返回系统当前不满足的依赖项列表。例：pacman -T qt \"bash&gt;=3.2\"\n-U，--upgrade\n向系统升级或添加包，并从同步仓库中安装所需的依赖项。可以指定\nURL或文件路径。这是一个“删除尔后添加”的过程。\n-F，--files\n查询 files\n数据库。查找或显示属于某个包的文件。只有作为同步数据库一部分的包才会被搜索。\n-V，--version\n版本信息\n-h，--help\n显示给定操作的语法。如果没有提供操作，则显示一般语法。\n\nOPTIONS\n\n-b，--dbpath \n指定数据库的位置(默认：/var/lib/pacman)。注意：这必须是一个绝对路径。\n-r，--root \n指定安装跟目录(默认：/)。这不能作为将软件安装到/usr/local而不是/usr的一种方式。\n-v，--verbose\n输出路径，如根目录(Root)，配置文件(Conf File)，DB路径(DB\nPath)，缓存目录(Cache Dirs)等。\n--arch \n指定架构(architecture)\n--cachedir\n\n指定包的缓存目录(默认：/var/cache/pacman/pkg)。可以指定多个缓存目录，并按照传递给\npacman\n的顺序依次尝试它们。注意：这必须是一个绝对路径。\n--color \n指定何时启动着色。选项有 [always, never, auto]。\n--config \n指定配置文件\n--debug\n显示调试消息。当报告错误时，建议使用此选项。\n--gpgdir\n\n指定 GnuPG\n校验包签名的文件目录(默认：/etc/pacman.d/gnupg)。这个目录应该包含两个文件：pubring.gpg\n和 trustdb.gpg。注意：这必须是一个绝对路径。\n--hookdir\n\n指定一个有钩子文件(hook\nfiles)的目录(默认：/etc/pacman.d/hooks)。可以指定多个钩子目录，使后面目录中的钩子优先于前面目录中的钩子。注意:这是一个绝对路径。\n--logfile \n指定一个备用日志文件。这是一个绝对路径，与安装根目录设置无关。\n--noconfirm\n绕过任何“你确定吗?””消息。这样做不是一个好主意，除非你想从脚本运行pacman。\n--confirm\n取消先前的—noconfirm的影响。\n--disable-download-timeout\n在下载时禁用默认的低速限制和超时。如果你用代理和/或安全网关下载文件有问题，请使用这个。\n--sysroot\n\n指定一个替代系统根(system\nroot)。在运行Pacman之前，将chroot和chdir放入系统根目录。这允许正确地操作挂载的客户系统。给出的任何其他路径都将被解释为相对于系统根。需要root特权。\n\nSYNC OPTIONS (APPLY TO -S)\n\n-c，--clean\n从缓存和当前未使用的同步数据库中删除不再安装的包，以释放磁盘空间。当\npacman 下载软件包时，它会把它们保存在一个缓存目录中。-c\n仅删除那些不再被安装的包，-cc\n会删除缓存中的所有文件。\n-g，--groups\n显示每个指定包组的所有成员。如果没有提供组名，将列出所有组；传递标志两次(-gg)以查看所有组及其成员。\n-i，--info\n显示给定同步数据库包的信息。-ii\n将显示所有依赖于此包的存储库中的那些包。\n-l，--list\n列出指定仓库中的所有包。可以在命令行上指定多个仓库。\n-q，--quiet\n为某些同步操作显示较少的信息。当在脚本中处理 pacman\n的输出时，这很有用。搜索将只显示包名，而不显示仓库、版本、组和描述信息；List将只显示包名，而忽略数据库和版本;组将只显示包名而忽略组名。\n-s，--search \n这将搜索同步数据库中的每个包，以查找匹配regexp的名称或描述。当您包含多个搜索条件时，只有描述匹配所有这些条件的包将被返回。\n-u，--sysupgrade\n升级所有过期的软件包。如果有新的包存在，将检查和升级当前安装的每个包。所有要升级的包将会显示一个报告，没有用户的确认操作将不会进行。依赖关系将在此级别自动解决，并将在必要时进行安装/升级。\n-y，--refresh\n从 pacman.conf(/etc/pacman.conf)\n中定义的服务器下载一个新的主包数据库副本。这通常应该在每次使用\n-u 时使用。-yy\n将强制刷新所有包数据库，即使它们看起来是最新的。\n\nREMOVE OPTIONS (APPLY TO -R)\n\n-c，--cascade\n删除所有目标包，以及依赖于一个或多个目标包的所有包。这个操作是递归的，必须小心使用，因为它可能会删除许多可能需要的包。\n-n，--nosave\n指示 pacman\n忽略文件备份指定。通常，当从系统中删除一个文件时，数据库会检查该文件是否应该以\n.pacsave 扩展名重命名。\n-s，--recursive\n删除指定的每个目标，包括它们的所有依赖项，前提是(A)其他包不需要它们;(B)它们不是由用户明确安装的。如果要忽略条件(B)，则传递此选项两次(-ss)。\n-u，--unneeded\n删除任何其他包不需要的目标。这在不使用 -c\n选项删除组时非常有用，以避免破坏任何依赖关系。\n\n\nEXAMPLES\npacman -Ss ne.hack\n# 搜索仓库中符合正则表达式&quot;ne.hack&quot;的包\npacman -S gpm\n# 下载并安装gpm，包括依赖项。\npacman -U &#x2F;home&#x2F;user&#x2F;ceofhack-0.6-1-x86_64.pkg.tar.gz\n# 从本地文件安装&quot;ceofhack-0.6-1&quot;软件包。\npacman -Syu\n# 更新包列表并升级所有包。\npacman -Syu gpm\n# 更新包列表，升级所有的包，然后安装gpm(如果还没有安装的话)。\n\n官方帮助文档：pacman\n","slug":"Linux/pacman","date":"2022-04-28T07:42:04.000Z","categories_index":"Linux","tags_index":"Pacman 命令","author_index":"爱慢跑的乌龟"},{"id":"a48e6dda0c21e40880cba7e763278b04","title":"Docker","content":"Docker\n\n官方文档地址\n中文参考手册\n\n\n1.什么是Docker\n1.1 官方定义\n\n\n\n\n\n\n\n\n\n\n官方介绍\n\nWe have a vomplete container solution for you - no matter who you\nare where you are on your containeriztion jouery.\n翻译：我们为你提供一个完整的容器解决方案，不管你是谁，无论你在哪，你都可以可是容器的旅程。\n官方定义：docker 是一个容器技术\n\n\n1.2 Docker 的起源\n\n\n\n\n\n\n\n\n\nDocker 最初是 dotCloud 公司创始人 Solomon Hykes\n在法国期间发起的一个公司内部项目，它是基于dotCloud\n公司多年云服务技术的一次革新，并于 2013年 3月以Apache 2.0\n授权协议开源，主要项目代码在 Github 上进行维护。Docker 项目后来还加入\nLinux 基金会，并成功推动 开放容器联盟(OCI)。\nDocker 自开源后受到了广泛的关注和讨论，至今其 Github 项目已经超过 5万\n7千个星标和一万多个 fork。甚至由于Docker 项目火爆，在 2013\n年底，dotCloud 公司决定改名为 Docker。 Docker 最初是在 Ubuntu 12.04\n上开发实现的；Red Hat 则从 RHEL.6.5 开始对 Docker 进行支持；Google\n也在其 PaaS 产品中广泛应用 Docker。\nDocer 使用 Google 公司推出的 Go 语言进行开发实现，基于 Linux 内核的\ncgroup， namespace，以及 OverlayFS\n类等技术，对进程进行封装隔离，属于操作系统层面的虚拟化技术。由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。\n2. 为什么是Docker\n\n在开发的时候，在本机测试环境可以跑，生成环境跑不起来\n这里我们拿 java Web 应用程序举例，我们一个 java Web\n应用程序涉及的东西很多，比如\njdk、tomcat、mysql等软件环境。当这些其中某一项版本不一致的时候，可能就会导致应用程序跑不起来这种情况。Docker\n则将程序以及使用的软件环境直接打包在一起，无论在哪个机器上都保证了环境一致。\n优势1：一致的运行环境，更轻松的迁移\n服务器自己的程序挂了，结果发现是别人程序出了问题把内存吃完了，自己的程序因为内存不够就挂了\n这种也是一种比较常见的情况，如果你的程序重要性不是特别高的话，公司基本上不可能让你的程序独享一台服务器，这时候你的服务器就会跟公司其他人的程序共享一台服务器，所以不可避免地就会受到其他程序的干扰，导致自己的程序出现问题。Docker\n就很好解决了环境隔离的问题，别人的程序不会影响到自己的程序。\n优势2：对进程进行封装隔离，容器与容器之间互不影响，更高效的利用系统资源\n公司要弄一个活动，可能会有大量的流量进来，公司需要部署几十台服务器\n在没有 Docker\n的情况下，要在几天内部署几十台服务器，这对运维来说是一件非常折磨人的事，而且每台服务器的环境还不一定一样，就会出现各种问题。用\nDocker\n的话，只需要将程序打包到镜像，需要多少台服务器，就跑多少容器，极大地提高了部署效率。\n优势3：通过镜像复制N多个环境一致的容器\n\n3. Docker 和虚拟机的区别\n\n\nDocker\n\n虚拟机是携带操作系统的，本身很小的应用却因为携带了操作系统而变得非常大，很笨重。Docker\n是不携带操作系统的，所以 Docker\n的应用就非常的轻巧。另外，在调用宿主机的CPU、磁盘等等资源的时候，拿内存举例，虚拟机时利用\nHypervisor 去虚拟化内存，整个调用过程时虚拟内存 -&gt; 虚拟物理内存 -&gt;\n真正物理内存，但是 Docker 是利用Docker Engine\n去调用宿主机的资源，这个过程是 虚拟内存 -&gt; 真正物理内存。\n\n\n\n\n\n\n\n\n\n传统虚拟机\nDocker 容器\n\n\n\n\n磁盘占用\n几个GB到几十个GB\n几十MB到几百MB\n\n\nCPU　内存占用\n虚拟操作系统非常占用CPU和内存\nDocker 引擎占用极低\n\n\n启动速度\n几分钟\n几秒\n\n\n安装管理\n需要专门的运维技术\n安装、管理方便\n\n\n应用部署\n每次部署都费时费力\n从第二次部署开始轻松简洁\n\n\n耦合性\n多个应用服务安装到一起，容易相互影响\n每个应用服务一个容器，达到隔离\n\n\n系统依赖\n无\n需求相同或相似的内核，目前推荐Linux\n\n\n\n4. Docker 的安装\n4.1 安装 docker(centos 7.x)\n\n卸载原始 Docker\n$ sudo yum remove docker \\\n\t\t\t\t  docker-client \\\n\t\t\t\t  docker-client-latest \\\n\t\t\t\t  docker-common \\\n\t\t\t\t  docker-latest \\\n\t\t\t\t  docker-latest-logrotate \\\n\t\t\t\t  docker-logrotate \\\n\t\t\t\t  docker-engine\n安装 docker 依赖\n$ sudo yum install -y yum-utils \\\n  device-mapper-persistent-data \\\n  lvm2\n设置 docker 的 yum 源\n$ sudo yum-config-manager \\\n\t--add-repo \\\n\thttps:&#x2F;&#x2F;download.docker.com&#x2F;linux&#x2F;centos&#x2F;docker-ce.repo\n安装最新版的 docker\n$ sudo yum install docker-ce docker-cecli containerd.io\n指定版本安装 docker\n$ yum install docker-ce --showduplicates | sort -r\n$ yum install docker-ce-&lt;VERSION_STRING&gt; docker-ce-cli-&lt;VERSION_STRING&gt; containerd.io\n$ yum install docker-ce-18.09.5-3.e17 docker-ce-cli-18.09.5-3.e17 containerd.io\n启动 docker\n$ sudo systemctl enable docker\n$ sudo systemctl start docker\n关闭 docker\n$ sudo systemctl stop docker\n测试 docker 安装\n$ sudo docker run hello-world\n\n4.2 bash 安装(通用所有平台)\n$ curl -fsSL get.docker.com -o get-docker.sh\n$ sudo sh get-docker.sh --mirror Aliyun\n\n启动 docker\n$ sudo systemctl enable docker\n$ sudo systemctl start doecker\n创建 docker 用户组\n$ sudo groupadd docker\n当前的用户加入 docker 组\n$ sudo usermod -aG docker $USER\n测试 docker 安装是否正确\n$ docker run hello-world\n\n5. Docker 的核心架构\n\n镜像 image 复数 images\n定义：一个镜像代表着一个软件 如：MySQL镜像 redis镜像\nnginx镜像····\n容器 container\n定义：基于某个镜像运行一次就会生成一个程序实例，一个实例称之为一个容器\n特点：可读、可写\n仓库 repository\n定义：用来存储 docker 中的所有镜像\n远程仓库：docker 官方维护的一个唯一的远程仓库\n本地仓库：当前机器的镜像存储位置\n\n\n\ndockerKernel\n\n6. 镜像的相关操作\n6.1 辅助命令\n# 1. 安装完成辅助命令\n\tdocker version\t---------------------\t查看 docker 的信息\n\tdocker info\t\t---------------------\t查看更详细的信息\n\tdocker --help \t---------------------\t帮助命令\n6.2 Images 镜像命令\n# 1. 查看本机中所有镜像\n\tdocker images\t------------------------\t列出本地所有镜像\n\t\t-a\t列出所有镜像\n\t\t-q\t只显示镜像 id\n# 2. 搜素镜像\n\tdocker search [options] 镜像名 -----------\t去 dockerhub 上查询当前镜像\n\t\t-s\t指定值\t\t列出收藏数不少于指定值的镜像\n\t\t--no-trunc\t  显示完整的镜像信息\n# 3. 从仓库下载镜像\n\tdocker pull 镜像名[:TAG|@DIGEST] ----------\t下载镜像\n# 4. 删除镜像\n\tdocker rmi 镜像名  -----------------------\t 删除镜像\n\t\t-f\t强制删除\n# 5. 载入镜像\n\tdocker load -i xxx.tar\n6.3 Contrainer 容器命令\n# 1. 运行容器\n\tdocker run 镜像名\t---------------\t镜像名新建并启动容器\n\t--name\t\t为容器起一个名字\n\t-d\t\t\t启动守护容器（在后台启动容器）\n\t-p\t\t\t映射端口号：原始端口号\t\t指定端口号启动\n# 2. 查看运行的容器\n\tdocker ps\t---------------------\t列出所有正在运行的容器\n\t-a\t\t\t正在运行的和历史运行的容器\n\t-q\t\t\t静默模式，只显示容器编号\n# 3. 停止|关闭|重启容器\n\tdocker start 容器名称或容器ID\t---------- 开启容器\n\tdocker restart 容器名或容器ID\t----------- 重启容器\n\tdocker stop 容器名或容器ID\t----------- 正常停止容器\n\tdocker kill 容器名或容器ID\t----------- 立即停止容器运行\n# 4. 删除容器\n\tdocker rm 容器名称|容器ID\t\t----------- 删除停止的容器\n\t-f\t\t删除正在运行的容器\n# 5. 查看容器内进程\n\tdocker top\t容器名称|容器ID\t----------- 查看容器内进程\n# 6. 查看容器内部细节\n\tdocker inspect\t容器名称|容器ID\t----------- 查看容器内部细节\n# 7. 查看运行日志\n\tdocker logs [OPTIONS] 容器名称|容器ID\t----------- 查看容器内进程\n\t-t\t\t加入时间戳\n\t-f\t\t跟随最新的日志打印\n\t--tail\t数字\t显示最后多少条\n# 8. 进入容器\n\tdocker exec -it\t容器名称|容器ID bash\t--------- 进入容器bash，与容器交互\n\t退出容器\texit\n# 9. 操作系统与容器的文件传输\n\t从容器到操作系统：\tdocker cp 容器ID:容器内资源路径 \t操作系统路径\n\t从操作系统到容器：\tdocker cp 文件|目录\t容器ID：容器路径\n# 10. 数据卷(volum)实现与宿主机共享目录\n\tdocker run -v 宿主机的路径|任意别名:&#x2F;容器内的路径\t\t镜像名\n\tdocker run -v 宿主机的路径|任意别名:&#x2F;容器内的路径:ro\t镜像名\n\tro：镜像只读\n\t\t注意：\n\t\t\t1. 如果是宿主机类路径必须是绝对路径，宿主机目录会覆盖容器内目录内容\n\t\t\t2. 如果是别名则会在docker运行容器时自动在宿主机中创建一个目录，并将容器目录文件复制到宿主机中\n# 11. 打包镜像\n\tdocker save 镜像名\t-o 名称.tar\n# 12. 载入镜像\n\tdocker load -i 名称.tar\n# 13. 容器打包成新的镜像\n\tdocker commit -m &quot;描述信息&quot; -a &quot;作者信息&quot;\t（容器ID或名称） 打包的镜像的名称：标签\n7. Dokcer 中容器之间的网络配置\n\n\n\n\n\n\n\n\n\nDocker 允许通过外部访问容器或容器互联的方式来提供网络服务\n7.1 docker\n容器与操作系统通信机制\n当 Docker 启动时，会自动在主机上创建一个 docker0\n虚拟网桥，实际上是 Linux 的一个\nbridge，可以理解为一个软件交换机。它会在挂载到它的网口之间进行转发。\n同时，Docker 随机分配一个本地未占用的私有网段（在 RFC1918中定义）中的一个地址给\ndocker0 接口。比如典型的 172.17.0.1，掩码为\n255.255.0.0。此后启动的容器内的网口也会自动分配一个同一网段（172.17.0.0/16）的地址。\n\n\nnetDocker0\n\n当创建一个 Docker 容器的时候，同时会创建了一对 veth pair\n接口（当数据包发送到一个接口时，另外一个接口也可以收到相同的数据包）。这对接口一端在容器内，即\neth0；另一端在本地并被挂载到 docker0\n网桥，名称以 veth 开头（例如\nvethAQI2QT）。通过这种方式，主机可以跟容器通信，容器之间也可以相互通信。Docker\n就创建了在主机和所有容器之间一个虚拟共享网络。\n\n\ndocker0\n\n7.2 Docker 网络使用\n注意：一般在使用 docker 网桥(bridge)\n实现容器与容器通信时，都是站在一个应用的角度进行容器通信。\n# 1. 查看 docker 网桥配置\n\tdocker network ls\n# 2. 自定义网桥\n\tdocker network create -d bridge 网桥名称\n# 3. 指定容器网桥\n\tdocker run --network 网桥名称 \n&gt; docker network [OPTION]\n     connect     Connect a container to a network\n     create      Create a network\n     disconnect  Disconnect a container from a network\n     inspect     Display detailed information on one or more networks\n     ls          List networks\n     prune       Remove all unused networks\n     rm          Remove one or more networks\n​\n8. 数据卷\n数据卷\n是一个可供一个或多个容器使用的特殊目录，它绕过\nUFS，可以提供很多有用的特性\n\n数据卷 可以在容器之间共享和重用\n对 数据卷 的修改会立马生效\n对 数据卷 的更新，不会影响镜像\n数据卷 默认会一直存在，即使容器被删除\n\n\n\n\n\n\n\n\n\n\n注意：数据卷 的使用，类似于 Linux 下对目录或文件进行\nmount，镜像中的被指定为挂载点的目录中的文件会复制到数据卷中（仅数据卷为空时会复制）。\n# 1. 自定义数据卷目录\n\tdocker run -v 绝对路径:容器内路径\n# 2. 自动创建数据卷\n\tdocker run -v 卷名：容器内路径\ndocker 操作数据卷命令\n# 1. 查看数据卷\n\tdocker volume ls\n# 2. 查看数据卷细节\n\tdocker volume inspect 卷名\n&gt; docker volume [OPTION]\n     create      Create a volume\n     inspect     Display detailed information on one or more volumes\n     ls          List volumes\n     prune       Remove all unused local volumes\n     rm          Remove one or more volumes\n9. Dockerfile\n什么是 Dockerfile\n定义：用来帮助我们自己构建一个自定义镜像 Dockerfile 成为镜像构建文件\n描述文件\nDockerfile 的保留命令\n官方说明(https://docs.docker.com/engine/reference/builder/)\n\n\n\n\n\n\n\n保留字\n作用\n\n\n\n\nFROM\n当前镜像是基于哪个镜像的\n\n\nMAINTAINER\n镜像维护者的姓名和邮箱地址\n\n\nRUN\n构建镜像时需要运行的指令\n\n\nEXPOSE\n当前容器对外暴露的端口号\n\n\nWORKDIR\n指定再创建容器后，终端默认登录进来的工作目录，一个落脚点\n\n\nENV\n用来再构建镜像的过程中设置环境变量\n\n\nADD\n将宿主机目录下的文件拷贝进镜像且ADD命令会自动处理URL和解压tar包\n\n\nCOPY\n类似于 ADD\n，拷贝文件和目录到镜像中将从构建上下文目录中的文件/目录复制到新的一层的镜像内的位置\n\n\nVOLUME\n容器数据卷，用于数据保存和持久化工作\n\n\nCMD\n指定一个容器启动时要运行的命令\nDockerfile 中可以有多个CMD 指令，但只有最后一个生效， CMD\n会被 docker run 之后的参数替换\n\n\nENTRYPOINT\n指定一个容器启动时要运行的命令\nENTRYPOINT 的目的和 CMD\n一样，都是在指定容器启动程序及其参数\n\n\n\nFROM 命令\n\n基于哪个镜像进行构建新的镜像，在构建时会自动从 docker hub 拉取\nbase 镜像 必须作为 Dockerfile 的一个指令出现\n语法\nFROM &lt;image&gt;\nFROM &lt;image&gt;[:&lt;tag&gt;]\t使用版本\nFROM &lt;image&gt;[@&lt;digest&gt;]\t使用摘要\n\nRUN 命令\n\nRUN\n指令将在当前映像之上的新层中执行任何命令并提交结果。生成的提交映像将用于\nDockerfile 中下一步\n语法：\nRUN &lt;command&gt;\nRUN echo hello\nRUN [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;](exec form)\nRUN [&quot;&#x2F;bin&#x2F;bash&quot;, &quot;-c&quot;, &quot;echo hello&quot;]\n\nEXPOSE 命令\n\n用来指定构建的镜像在运行为容器时对外暴露的端口\n语法：\nEXPOSE 80&#x2F;tcp\t如果没有显示指定则默认暴露都是 tcp\nEXPOSE 80&#x2F;udp \n\nCMD 命令\n\n用来为启动的容器指定执行的命令，在 Dockerfile 中只能有一条 CMD\n指令。如果列出多个命令，则只有最后一个命令才会生效。\n注意：Dockerfile 中只能有一条 CMD\n指令。如果列出多个命令，则只有最后一个命令才会生效。\n语法：\nCMD [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]\nCMD [&quot;param1&quot;, &quot;param2&quot;]\nCMD command param1 param2 (shell form)\n\nWORKDIR 命令\n\n用来为 Dockerfile 中的任何 RUN、CMD、ENTRYPOINT、COPY 和 ADD\n指令设置工作目录。如果 WORKDIR 不存在，即使它没有在任何后续 Dockerfile\n指令中使用，它也将被创建。\n语法：\nWORKDIR &#x2F;path&#x2F;to&#x2F;workdir\n\nWORKDIR &#x2F;a\nWORKDIR b\nWORKDIR c\n\nADD 命令\n\n用来从 context 上下文复制新文件、目录或远程文件\nurl，并将它们添加到位于指定路径的映像文件系统中\n语法：\nADD hom* &#x2F;mydir&#x2F; \t通配符添加多个文件\nADD hom?.txt &#x2F;mydir 通配符添加\nADD test.txt relativeDir&#x2F; 可以指定相对路径\nADD test.txt &#x2F;absoluteDir&#x2F; 绝对路径\nADD url\n\nCOPY 命令\n\n用来将 context 目录中指定文件复制到镜像的指定目录中\n语法：\nCOPY src dest\nCOPY [&quot;&lt;src&gt;&quot;,... &quot;&lt;dest&gt;&quot;]\n\nVOLUME 命令\n\n用来定义容器运行时可以挂载到宿主机的目录\n语法：\nVOLUME [&quot;&#x2F;data&quot;]\n\nENV 命令\n\n用来为构建镜像设置环境变量。这个值将会出现在构建阶段中所有的后续指令的环境中。\n语法：\nENV &lt;key&gt; &lt;value&gt; \nENV &lt;key&gt; &lt;value&gt; ...\n\nENTRYPOINT 命令\n\n用来指定容器启动时执行命令和 CMD 类似\n语法：\n[&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]\nENTRYPOINT command param1 param2\n\n","slug":"Linux/Docker","date":"2022-04-24T16:00:00.000Z","categories_index":"Docker","tags_index":"Docker 入门","author_index":"爱慢跑的乌龟"},{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick Start\nCreate a new post\n$ hexo new &quot;My New Post&quot;\nMore info: Writing\nRun server\n$ hexo server\nMore info: Server\nGenerate static files\n$ hexo generate\nMore info: Generating\nDeploy to remote sites\n$ hexo deploy\nMore info: Deployment\n---\ntitle: \ndata:\ncategories:\ntag: [tag1, tag2]\nindex_img:\nbanner_img:\nexcerpt:\nmathjax: true\n---\n","slug":"hello-world","date":"2022-03-29T16:00:00.000Z","categories_index":"","tags_index":"","author_index":"爱慢跑的乌龟"}]